

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="排序算法是《数据结构与算法》中最基本的算法之一，常见的共有十种：  冒泡排序（Bubble Sort） 选择排序（Selection Sort） 插入排序（Insertion Sort） 希尔排序（Shell Sort） 归并排序（Merge Sort） 快速排序（Quick Sort） 堆排序（Heap Sort） 计数排序（Counting Sort） 桶排序（Bucket">
<meta property="og:type" content="article">
<meta property="og:title" content="十大排序算法">
<meta property="og:url" content="http://example.com/2023/08/26/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="排序算法是《数据结构与算法》中最基本的算法之一，常见的共有十种：  冒泡排序（Bubble Sort） 选择排序（Selection Sort） 插入排序（Insertion Sort） 希尔排序（Shell Sort） 归并排序（Merge Sort） 快速排序（Quick Sort） 堆排序（Heap Sort） 计数排序（Counting Sort） 桶排序（Bucket">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230827112203238.png">
<meta property="og:image" content="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9a152a7e13500cf688efd8e5297f9f6e.gif">
<meta property="og:image" content="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/c7322fccb46e3cc0ea3c107781d1e880.gif">
<meta property="og:image" content="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6d867acd56e40fb32975f9e91d041fa9.gif">
<meta property="og:image" content="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/e250b339f4595451ca75ba3b83c83704.gif">
<meta property="og:image" content="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2f9f62d486be19b87a3f37f13eb75786.gif">
<meta property="og:image" content="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/eaca66d26efe27519e8c462d3a7d4593.gif">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-8223537/2c40662fc38e7e7ba7882786f1ee19e2.gif">
<meta property="og:image" content="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/25fdb31acd81f931cd443cb932140ab9.gif">
<meta property="og:image" content="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9095a2947d144f4b960369dbc1d259d7.gif">
<meta property="og:image" content="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/88cb17eb223c8838182dcaff3dfcde17.gif">
<meta property="article:published_time" content="2023-08-26T14:31:43.000Z">
<meta property="article:modified_time" content="2023-08-28T03:37:53.355Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="排序">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230827112203238.png">
  
  
  
  

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"✍","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":false,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<meta name="referrer" content="no-referrer" />

<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>My Tech Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/article.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.1)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="十大排序算法"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-26 22:31" pubdate>
          2023年8月26日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          31 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-12 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">十大排序算法</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年8月28日 中午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>排序算法是《数据结构与算法》中最基本的算法之一，常见的共有十种：</p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="http://www.codebaoku.com/algorithm-sort/bubble-sort.html">冒泡排序（Bubble Sort）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.codebaoku.com/algorithm-sort/selection-sort.html">选择排序（Selection Sort）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.codebaoku.com/algorithm-sort/insertion-sort.html">插入排序（Insertion Sort）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.codebaoku.com/algorithm-sort/shell-sort.html">希尔排序（Shell Sort）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.codebaoku.com/algorithm-sort/merge-sort.html">归并排序（Merge Sort）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.codebaoku.com/algorithm-sort/quick-sort.html">快速排序（Quick Sort）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.codebaoku.com/algorithm-sort/heap-sort.html">堆排序（Heap Sort）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.codebaoku.com/algorithm-sort/counting-sort.html">计数排序（Counting Sort）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.codebaoku.com/algorithm-sort/bucket-sort.html">桶排序（Bucket Sort）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.codebaoku.com/algorithm-sort/radix-sort.html">基数排序（Radix Sort）</a></li>
</ol>
<p>其中，前面七种属于比较排序，即通过比较来决定元素的相对次序。后面三种则属于非比较排序。</p>
<p>这十种排序方式的复杂度如下：</p>
<figure>
<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230827112203238.png" srcset="/img/loading.gif" lazyload alt="" /><figcaption>image-20230827112203238</figcaption>
</figure>
<p>下面分别来看看这十种排序方式：</p>
<h2 id="冒泡排序bubble-sort">冒泡排序（Bubble Sort）</h2>
<p>冒泡排序的基本思想是，从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻元素大小比较进行交换，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端。</p>
<figure>
<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9a152a7e13500cf688efd8e5297f9f6e.gif" srcset="/img/loading.gif" lazyload alt="" /><figcaption>冒泡排序的动图演示</figcaption>
</figure>
<p>在数据完全有序的时候展现出最优时间复杂度，为O(n)。其他情况下，几乎总是O( n2 )。因此，算法在数据基本有序的情况下，性能最好。 要使算法在最佳情况下有O(n)复杂度，需要做一些改进，增加一个<code>swap</code>的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">void</span> <span class="hljs-title function_">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> 
&#123;
    <span class="hljs-type">int</span> i, j, temp;
    <span class="hljs-type">bool</span> swap;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)
    &#123;
        swap = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)
        &#123;
            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) 
            &#123;
                temp = arr[j];
                arr[j] = arr[j + <span class="hljs-number">1</span>];
                arr[j + <span class="hljs-number">1</span>] = temp;
                swap = <span class="hljs-literal">true</span>;
            &#125;            
        &#125; 
        <span class="hljs-keyword">if</span>(swap == <span class="hljs-literal">false</span>) <span class="hljs-comment">//有序</span>
            <span class="hljs-keyword">break</span>;
    &#125;
&#125;
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> 
&#123;
    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">22</span>, <span class="hljs-number">34</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">82</span>, <span class="hljs-number">55</span>, <span class="hljs-number">89</span>, <span class="hljs-number">50</span>, <span class="hljs-number">37</span>, <span class="hljs-number">5</span>, <span class="hljs-number">64</span>, <span class="hljs-number">35</span>, <span class="hljs-number">9</span>, <span class="hljs-number">70</span> &#125;;
    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);
    bubble_sort(arr, len);
    <span class="hljs-type">int</span> i;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>
<p>冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高,基本为O(n2)，在数据量大的时候不适合使用。</p>
<h2 id="选择排序selection-sort">选择排序（Selection Sort）</h2>
<p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p>
<p>它的排序思想是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<figure>
<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/c7322fccb46e3cc0ea3c107781d1e880.gif" srcset="/img/loading.gif" lazyload alt="" /><figcaption>选择排序的动图演示</figcaption>
</figure>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span> <span class="hljs-comment">//交互两个变量</span>
&#123;
    <span class="hljs-type">int</span> temp = *a;
    *a = *b;
    *b = temp;
&#125;
<span class="hljs-type">void</span> <span class="hljs-title function_">selection_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>
&#123;
    <span class="hljs-type">int</span> i,j;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; len - <span class="hljs-number">1</span> ; i++)
    &#123;
		<span class="hljs-type">int</span> min = i;
		<span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; len; j++) <span class="hljs-comment">//遍历未排序的元素</span>
        &#123;
		    <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min])    <span class="hljs-comment">//找到目前最小值</span>
		        min = j;    		  <span class="hljs-comment">//记录最小值序号            </span>
        &#125;
		swap(&amp;arr[min], &amp;arr[i]);     <span class="hljs-comment">//做交換</span>
     &#125;
&#125;</code></pre></div>
<p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。</p>
<h2 id="插入排序insertion-sort">插入排序（Insertion Sort）</h2>
<p>插入排序的基本方法是：从待排序的n个元素中的第二个元素开始，依次与前面的元素比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。</p>
<figure>
<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6d867acd56e40fb32975f9e91d041fa9.gif" srcset="/img/loading.gif" lazyload alt="" /><figcaption>插入排序的动图演示</figcaption>
</figure>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertion_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>
&#123;
    <span class="hljs-type">int</span> i,j,key;
    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;len;i++)
    &#123;
        key = arr[i];
        j=i<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">while</span>((j&gt;=<span class="hljs-number">0</span>) &amp;&amp; (arr[j]&gt;key)) 
        &#123;
            arr[j+<span class="hljs-number">1</span>] = arr[j];
            j--;
        &#125;
        arr[j+<span class="hljs-number">1</span>] = key;
    &#125;
&#125;</code></pre></div>
<p>插入排序由于O( n2 )的复杂度，在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。</p>
<h2 id="希尔排序shell-sort">希尔排序（Shell Sort）</h2>
<p>希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>
<p>希尔排序基本思想是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。</p>
<figure>
<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/e250b339f4595451ca75ba3b83c83704.gif" srcset="/img/loading.gif" lazyload alt="" /><figcaption>十大经典排序算法动画与解析，看我就够了！（配代码完全版）</figcaption>
</figure>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> 
&#123;
    <span class="hljs-type">int</span> gap, i, j;
    <span class="hljs-type">int</span> temp;
    
    <span class="hljs-keyword">for</span> (gap = len &gt;&gt; <span class="hljs-number">1</span>; gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>)
    &#123;
	    <span class="hljs-keyword">for</span> (i = gap; i &lt; len; i++) 
        &#123;
            temp = arr[i];
            <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)
            &#123;
                arr[j + gap] = arr[j];
            &#125;
            arr[j + gap] = temp;
	    &#125;        
    &#125;
&#125;</code></pre></div>
<p>Shell排序虽然快，但是毕竟是插入排序，其数量级并没有后起之秀--快速排序O(n㏒n)快。在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。</p>
<h2 id="归并排序merge-sort">归并排序（Merge Sort）</h2>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<p>它的基本思路是：</p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<figure>
<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2f9f62d486be19b87a3f37f13eb75786.gif" srcset="/img/loading.gif" lazyload alt="" /><figcaption>归并排序的动图演示</figcaption>
</figure>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> 
&#123;
    <span class="hljs-keyword">return</span> x &lt; y ? x : y;
&#125;
<span class="hljs-type">void</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> 
&#123;
    <span class="hljs-type">int</span> *a = arr;
    <span class="hljs-type">int</span> *b = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
    <span class="hljs-type">int</span> seg, start;
    
    <span class="hljs-keyword">for</span> (seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg) 
    &#123;
        <span class="hljs-keyword">for</span> (start = <span class="hljs-number">0</span>; start &lt; len; start += seg * <span class="hljs-number">2</span>) 
        &#123;
            <span class="hljs-type">int</span> low = start, mid = min(start + seg, len), high = min(start + seg * <span class="hljs-number">2</span>, len);
            <span class="hljs-type">int</span> k = low;
            <span class="hljs-type">int</span> start1 = low, end1 = mid;
            <span class="hljs-type">int</span> start2 = mid, end2 = high;
            
            <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)
                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];
            <span class="hljs-keyword">while</span> (start1 &lt; end1)
                b[k++] = a[start1++];
            <span class="hljs-keyword">while</span> (start2 &lt; end2)
                b[k++] = a[start2++];
        &#125;
        <span class="hljs-type">int</span> *temp = a;
        a = b;
        b = temp;
    &#125;
    <span class="hljs-keyword">if</span> (a != arr) 
    &#123;
        <span class="hljs-type">int</span> i;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)
        &#123;
            b[i] = a[i];            
        &#125;
        b = a;
    &#125;
    <span class="hljs-built_in">free</span>(b);
&#125;</code></pre></div>
<p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。</p>
<h2 id="快速排序quick-sort">快速排序（Quick Sort）</h2>
<p>冒泡排序总的比较与移动次数较多，快速排序又称分区交换排序，是对冒泡排序的改进，快速排序采用的思想是分治思想。</p>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<figure>
<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/eaca66d26efe27519e8c462d3a7d4593.gif" srcset="/img/loading.gif" lazyload alt="" /><figcaption>快速排序的动图演示</figcaption>
</figure>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//a：待排序数组，low：最低位的下标，high：最高位的下标</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span>
&#123;
    <span class="hljs-keyword">if</span>(low&gt;=high)
    &#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-type">int</span> left=low;
    <span class="hljs-type">int</span> right=high;
    <span class="hljs-type">int</span> key=a[left];    <span class="hljs-comment">/*用数组的第一个记录作为分区元素*/</span>
    <span class="hljs-keyword">while</span>(left!=right)
    &#123;
        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[right]&gt;=key)    <span class="hljs-comment">/*从右向左扫描，找第一个码值小于key的记录，并交换到key*/</span>
            --right;
        a[left]=a[right];
        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[left]&lt;=key)
            ++left;
        a[right]=a[left];    <span class="hljs-comment">/*从左向右扫描，找第一个码值大于key的记录，并交换到右边*/</span>
    &#125;
    a[left]=key;    <span class="hljs-comment">/*分区元素放到正确位置*/</span>
    quickSort(a,low,left<span class="hljs-number">-1</span>);
    quickSort(a,left+<span class="hljs-number">1</span>,high);
&#125;</code></pre></div>
<p>快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。</p>
<h2 id="堆排序heap-sort">堆排序（Heap Sort）</h2>
<p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序原理就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</p>
<figure>
<img src="https://ask.qcloudimg.com/http-save/yehe-8223537/2c40662fc38e7e7ba7882786f1ee19e2.gif" srcset="/img/loading.gif" lazyload alt="" /><figcaption>十大经典排序算法动画与解析，看我就够了！（配代码完全版）</figcaption>
</figure>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> 
&#123;
    <span class="hljs-type">int</span> temp = *b;
    *b = *a;
    *a = temp;
&#125;

<span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> 
&#123;
    <span class="hljs-comment">// 建立父節點指標和子節點指標</span>
    <span class="hljs-type">int</span> dad = start;
    <span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (son &lt;= end) 
    &#123; <span class="hljs-comment">// 若子節點指標在範圍內才做比較</span>
        <span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 先比較兩個子節點大小，選擇最大的</span>
            son++;
        <span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">//如果父節點大於子節點代表調整完畢，直接跳出函數</span>
            <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">else</span> 
        &#123; <span class="hljs-comment">// 否則交換父子內容再繼續子節點和孫節點比較</span>
            swap(&amp;arr[dad], &amp;arr[son]);
            dad = son;
            son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        &#125;
    &#125;
&#125;

<span class="hljs-type">void</span> <span class="hljs-title function_">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> 
&#123;
    <span class="hljs-type">int</span> i;
    <span class="hljs-comment">// 初始化，i從最後一個父節點開始調整</span>
    <span class="hljs-keyword">for</span> (i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
        max_heapify(arr, i, len - <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢</span>
    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;
        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);
        max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);
    &#125;
&#125;

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> 
&#123;
    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, \
                 <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;
    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);
    heap_sort(arr, len);
    <span class="hljs-type">int</span> i;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>
<p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p>
<hr />
<h2 id="计数排序counting-sort">计数排序（Counting Sort）</h2>
<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>它的基本方法是：</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<figure>
<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/25fdb31acd81f931cd443cb932140ab9.gif" srcset="/img/loading.gif" lazyload alt="" /><figcaption>冒泡排序的动图演示</figcaption>
</figure>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">print_arr</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span> 
&#123;
    <span class="hljs-type">int</span> i;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, arr[i]);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
&#125;

<span class="hljs-type">void</span> <span class="hljs-title function_">counting_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *ini_arr, <span class="hljs-type">int</span> *sorted_arr, <span class="hljs-type">int</span> n)</span> 
&#123;
    <span class="hljs-type">int</span> *count_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100</span>);
    <span class="hljs-type">int</span> i, j, k;
    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">100</span>; k++)
        count_arr[k] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)
        count_arr[ini_arr[i]]++;
    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">100</span>; k++)
        count_arr[k] += count_arr[k - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span> (j = n; j &gt; <span class="hljs-number">0</span>; j--)
        sorted_arr[--count_arr[ini_arr[j - <span class="hljs-number">1</span>]]] = ini_arr[j - <span class="hljs-number">1</span>];
    <span class="hljs-built_in">free</span>(count_arr);
&#125;

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> 
&#123;
    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span> i;
    <span class="hljs-type">int</span> *arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * n);
    <span class="hljs-type">int</span> *sorted_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * n);
    srand(time(<span class="hljs-number">0</span>));
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)
        arr[i] = rand() % <span class="hljs-number">100</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ini_array: &quot;</span>);
    print_arr(arr, n);
    counting_sort(arr, sorted_arr, n);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sorted_array: &quot;</span>);
    print_arr(sorted_arr, n);
    <span class="hljs-built_in">free</span>(arr);
    <span class="hljs-built_in">free</span>(sorted_arr);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>
<p>排序目标要能够映射到整数域，其最大值最小值应当容易辨别。例如高中生考试的总分数，显然用0-750就OK啦；又比如一群人的年龄，用个0-150应该就可以了，再不济就用0-200喽。另外，计数排序需要占用大量空间，它比较适用于数据比较集中的情况。</p>
<h2 id="桶排序bucket-sort">桶排序（Bucket Sort）</h2>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<figure>
<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9095a2947d144f4b960369dbc1d259d7.gif" srcset="/img/loading.gif" lazyload alt="" /><figcaption>img</figcaption>
</figure>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 使用桶排序法对数列 [5，2，30，98，20，1，45，80] 从小到大排序 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>
&#123;
    <span class="hljs-type">int</span> m[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">30</span>,<span class="hljs-number">98</span>,<span class="hljs-number">20</span>,<span class="hljs-number">1</span>,<span class="hljs-number">45</span>,<span class="hljs-number">80</span>&#125;;
    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组a存放[1,10]的数,将数组a赋值为零*/</span>
    <span class="hljs-type">int</span> b[<span class="hljs-number">40</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组b存放[11,50]的数,将数组b赋值为零*/</span>
    <span class="hljs-type">int</span> c[<span class="hljs-number">50</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组c存放[51,100]的数,将数组c赋值为零*/</span>
    <span class="hljs-type">int</span> i;
    
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)
    &#123;
        <span class="hljs-comment">/* 定义三个桶 */</span>
        <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">0</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">11</span>)) 
            a[m[i]<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;               <span class="hljs-comment">/*假如i=0,那么m[i]=5;将5放在数组a的第5个位置，即a[4]中,所以是a[m[i]-1] */</span>
        <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">10</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">51</span>)) 
            b[m[i]<span class="hljs-number">-10</span><span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;   
        <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">51</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">101</span>)) 
            c[m[i]<span class="hljs-number">-50</span><span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;    
    &#125;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)                         <span class="hljs-comment">/*输出数组a的结果*/</span>
      <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)                         <span class="hljs-comment">/*输出数组b的结果*/</span>
      <span class="hljs-keyword">if</span>(b[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">11</span>);
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">50</span>;i++)                         <span class="hljs-comment">/*输出数组c的结果*/</span>
      <span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">51</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
&#125;</code></pre></div>
<p>桶排序可用于最大最小值相差较大的数据情况，但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。</p>
<h2 id="基数排序radix-sort">基数排序（Radix Sort）</h2>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<figure>
<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/88cb17eb223c8838182dcaff3dfcde17.gif" srcset="/img/loading.gif" lazyload alt="" /><figcaption>基数排序的动图演示</figcaption>
</figure>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 20</span>
<span class="hljs-comment">//#define SHOWPASS</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> BASE 10</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span> 
&#123;
  <span class="hljs-type">int</span> i;
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) 
  &#123;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, a[i]);
  &#125;
&#125;

<span class="hljs-type">void</span> <span class="hljs-title function_">radixsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span> 
&#123;
  <span class="hljs-type">int</span> i, b[MAX], m = a[<span class="hljs-number">0</span>], <span class="hljs-built_in">exp</span> = <span class="hljs-number">1</span>;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++) 
  &#123;
    <span class="hljs-keyword">if</span> (a[i] &gt; m) 
      m = a[i];
  &#125;

  <span class="hljs-keyword">while</span> (m / <span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">0</span>) 
  &#123;
    <span class="hljs-type">int</span> bucket[BASE] = &#123; <span class="hljs-number">0</span> &#125;;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) 
    &#123;
      bucket[(a[i] / <span class="hljs-built_in">exp</span>) % BASE]++;
    &#125;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; BASE; i++) 
    &#123;
      bucket[i] += bucket[i - <span class="hljs-number">1</span>];
    &#125;

    <span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) 
    &#123;
      b[--bucket[(a[i] / <span class="hljs-built_in">exp</span>) % BASE]] = a[i];
    &#125;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) 
    &#123;
      a[i] = b[i];
    &#125;

    <span class="hljs-built_in">exp</span> *= BASE;

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SHOWPASS</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nPASS   : &quot;</span>);
    print(a, n);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
  &#125;
&#125;

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> 
&#123;
  <span class="hljs-type">int</span> arr[MAX];
  <span class="hljs-type">int</span> i, n;

  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter total elements (n &lt;= %d) : &quot;</span>, MAX);
  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);
  n = n &lt; MAX ? n : MAX;

  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter %d Elements : &quot;</span>, n);
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) 
  &#123;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);
  &#125;

  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nARRAY  : &quot;</span>);
  print(&amp;arr[<span class="hljs-number">0</span>], n);

  radixsort(&amp;arr[<span class="hljs-number">0</span>], n);

  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nSORTED : &quot;</span>);
  print(&amp;arr[<span class="hljs-number">0</span>], n);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>
<p>基数排序要求较高，元素必须是整数，整数时长度10W以上，最大值100W以下效率较好，但是基数排序比其他排序好在可以适用字符串，或者其他需要根据多个条件进行排序的场景，例如日期，先排序日，再排序月，最后排序年 ，其它排序算法可是做不了的。</p>
<p>参考链接：</p>
<p>https://zhuanlan.zhihu.com/p/42586566</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="category-chain-item">数据结构与算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%8E%92%E5%BA%8F/">#排序</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/28/%E5%85%B1%E7%94%A8%E4%BD%93union%E8%AF%A6%E8%A7%A3/" title="共用体union详解">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">共用体union详解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E5%8F%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BC%80%E6%BA%90%E8%B5%84%E6%BA%90/" title="常见的开发概念及开源资源">
                        <span class="hidden-mobile">常见的开发概念及开源资源</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"vknpQgHbpd1oLUPUwwPbdY3B-gzGzoHsz","appKey":"1DCiNflrxTVqUxWR5T00HypH","path":"window.location.pathname","placeholder":"欢迎留言交流","avatar":"robohash","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <p <i class="iconfont icon-copyright"></i> <span>2023 | KayougZhang</span> </p> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
