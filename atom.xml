<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-25T05:48:10.424Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于算术平均算法的滤波器</title>
    <link href="http://example.com/2023/09/22/%E5%9F%BA%E4%BA%8E%E7%AE%97%E6%9C%AF%E5%B9%B3%E5%9D%87%E7%AE%97%E6%B3%95%E7%9A%84%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <id>http://example.com/2023/09/22/%E5%9F%BA%E4%BA%8E%E7%AE%97%E6%9C%AF%E5%B9%B3%E5%9D%87%E7%AE%97%E6%B3%95%E7%9A%84%E6%BB%A4%E6%B3%A2%E5%99%A8/</id>
    <published>2023-09-22T05:58:53.000Z</published>
    <updated>2023-09-25T05:48:10.424Z</updated>
    
    <content type="html"><![CDATA[<p>在AD采集获取数据时，为避免干扰信号的影响，一般我们都会对获取的原始数据进行滤波处理，比较常见的做法是算术平均，即对N个数据进行平均求值，为了进一步优化这种简易的平均算法，我们可以采用以下方法：</p><ul><li><strong>算术平均的递推平滑滤波</strong></li><li><strong>算术平均的带阻平滑滤波</strong></li><li><strong>算术平均的阶梯平滑滤波</strong></li><li><strong>算术平均的中值滤波</strong></li><li><strong>算术平均的限幅滤波</strong></li></ul><p>下面分别来看看这几种算术平均滤波算法：</p><h2 id="算术平均的递推平滑滤波">算术平均的递推平滑滤波</h2><p>在简易的平均算法中，取N个数计算后就会丢弃，如果N值较大，耗时就会较长，这样数据看起来可能就并不那么平滑，而递推平均算法则不存在这些问题。同样一个长度为N的数据队列，每新采样一次数据，就用此数据替换掉最老的数据，并输出算术平均值。实现如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 定义平滑滤波对象类型 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">FilterObject</span>&#123;</span>  <span class="hljs-type">float</span> newValue;       <span class="hljs-comment">//最新测量值</span>  <span class="hljs-type">float</span> lastValue;      <span class="hljs-comment">//上一个输出值</span>  <span class="hljs-type">float</span> *buffer;        <span class="hljs-comment">//数据缓存区</span>  <span class="hljs-type">int16_t</span> position;     <span class="hljs-comment">//写操作位置</span>  <span class="hljs-type">uint16_t</span> bufCount;    <span class="hljs-comment">//滤波的数量</span>&#125;<span class="hljs-type">filter_t</span>;<span class="hljs-comment">/* 平滑滤波处理函数，返回滤波后的值 */</span><span class="hljs-type">float</span> <span class="hljs-title function_">SmoothingFilter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> _FilterObject *filter)</span>&#123;  <span class="hljs-type">float</span> result=lastValue;   <span class="hljs-comment">/* 填充缓冲区 */</span>  <span class="hljs-keyword">if</span>(filter-&gt;position&gt;=filter-&gt;bufCount)  &#123;<span class="hljs-comment">/* 超出范围 */</span>    filter-&gt;position=<span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span>  &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;filter-&gt;bufCount;i++)    &#123;      filter-&gt;buffer[i]=filter-&gt;newValue;    &#125;    filter-&gt;position=<span class="hljs-number">0</span>;    filter-&gt;lastValue=filter-&gt;newValue;  &#125; <span class="hljs-comment">/* 算法的关键处-&gt;类同变化率 */</span>  result = filter-&gt;lastValue - filter-&gt;buffer[filter-&gt;position]/filter-&gt;bufCount;  result += filter-&gt;newValue/filter-&gt;bufCount;    filter-&gt;buffer[filter-&gt;position++] = filter-&gt;newValue;<span class="hljs-comment">//替换之后，位置后移</span>  filter-&gt;lastValue = result;  filter-&gt;newValue = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>特点：第一，对周期性干扰和高频的干扰都有一定的效果。第二，数据变化不明显，响应较慢，而且N越大越明显。第三，对偶然出现的脉冲性干扰的抑制作用较差。所以这种滤波器并不适用于脉冲干扰比较严重的场合。</p><h2 id="算术平均的带阻平滑滤波">算术平均的带阻平滑滤波</h2><p>这种方式是对比本次采集与上次采集数据的偏差值，如果偏差值大于设定的做大值则认为数据变化远超干扰的影响，忽略干扰，直接对数据进行更新。如果偏差值小于设定的最小值则认为数据稳定，不需要滤波。如果偏差值处于设定的最大最小值之间，则需要进行滤波处理。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*定义平滑滤波对象类型*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FilterObject</span>&#123;</span>  <span class="hljs-type">float</span> newValue;       <span class="hljs-comment">//最新测量值</span>  <span class="hljs-type">float</span> lastValue;      <span class="hljs-comment">//上一个输出值</span>  <span class="hljs-type">float</span> *buffer;        <span class="hljs-comment">//数据缓存区</span>  <span class="hljs-type">int16_t</span> position;    <span class="hljs-comment">//写操作位置指针</span>  <span class="hljs-type">uint16_t</span> bufCount;    <span class="hljs-comment">//滤波的数量</span>  <span class="hljs-type">uint16_t</span> delayCount;  <span class="hljs-comment">//延迟计数</span>  <span class="hljs-type">uint16_t</span> delayLimit;  <span class="hljs-comment">//延迟限值</span>  <span class="hljs-type">float</span> rangeLimit;     <span class="hljs-comment">//量程范围</span>  <span class="hljs-type">float</span> upperRario;     <span class="hljs-comment">//比例下限</span>  <span class="hljs-type">float</span> lowerRatio;     <span class="hljs-comment">//比例下限</span>&#125;FilterObjectType;<span class="hljs-comment">/* 带阻平滑滤波器，对指定区间滤波，返回滤波后的值*/</span><span class="hljs-type">float</span> <span class="hljs-title function_">BandSmoothingFilter</span><span class="hljs-params">(FilterObjectType *filter)</span>&#123;  <span class="hljs-type">float</span> result=filter-&gt;lastValue;   <span class="hljs-comment">/* 填充缓冲区 */</span>  <span class="hljs-keyword">if</span>(filter-&gt;position&gt;=filter-&gt;bufCount)  &#123;    filter-&gt;position=<span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span>  &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;filter-&gt;bufCount;i++)    &#123;      filter-&gt;buffer[i]=filter-&gt;newValue;    &#125;    filter-&gt;position=<span class="hljs-number">0</span>;    filter-&gt;lastValue=filter-&gt;newValue;  &#125;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(filter-&gt;newValue-filter-&gt;lastValue)&gt;=(filter-&gt;rangeLimit*filter-&gt;lowerRatio/<span class="hljs-number">100</span>))  &#123;<span class="hljs-comment">/* 范围之间 滤波 */</span>    result=filter-&gt;lastValue-filter-&gt;buffer[filter-&gt;position]/filter-&gt;bufCount;    result+=filter-&gt;newValue/filter-&gt;bufCount;      filter-&gt;buffer[filter-&gt;position++]=filter-&gt;newValue;  &#125;  <span class="hljs-keyword">else</span>  &#123;<span class="hljs-comment">/* 不滤波 消抖 */</span>    filter-&gt;delayCount+=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(filter-&gt;delayCount&gt;=filter-&gt;delayLimit)    &#123;      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;filter-&gt;bufCount;i++)      &#123;        filter-&gt;buffer[i]=filter-&gt;newValue;      &#125;      filter-&gt;position++;      result=filter-&gt;newValue;      filter-&gt;delayCount=<span class="hljs-number">0</span>;    &#125;  &#125;  filter-&gt;lastValue=result;  filter-&gt;newValue=<span class="hljs-number">0.0</span>;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>特点：通过区间滤波，对周期性干扰和小幅的噪声干扰均有较好的效果。如果出现持续性的高频大幅脉冲干扰，这一滤波器将变得无能为力。</p><h2 id="算术平均的阶梯平滑滤波">算术平均的阶梯平滑滤波</h2><p>对于一些情况，如小幅值干扰信号持续存在而被测信号也基本处于一个稳定的区间内。对比本次采集与上次采集数据的偏差值，如果偏差值大于设定的做大值则认为数据变化远超干扰的影响，忽略干扰，直接对数据进行更新。如果偏差值小于设定的最小值则认为数据稳定，这时的干扰于数据的变化不能忽略，我们需要采用完全滤波。如果偏差值处于设定的最大最小值之间，则干扰信号相比于数据的变化较小，但不可忽略，进行半滤波处理。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*定义平滑滤波对象类型*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FilterObject</span>&#123;</span>  <span class="hljs-type">float</span> newValue;       <span class="hljs-comment">//最新测量值</span>  <span class="hljs-type">float</span> lastValue;      <span class="hljs-comment">//上一个输出值</span>  <span class="hljs-type">float</span> *buffer;        <span class="hljs-comment">//数据缓存区</span>  <span class="hljs-type">int16_t</span> position;    <span class="hljs-comment">//写操作位置指针</span>  <span class="hljs-type">uint16_t</span> bufCount;    <span class="hljs-comment">//滤波的数量</span>  <span class="hljs-type">uint16_t</span> delayCount;  <span class="hljs-comment">//延迟计数</span>  <span class="hljs-type">uint16_t</span> delayLimit;  <span class="hljs-comment">//延迟限值</span>  <span class="hljs-type">float</span> rangeLimit;     <span class="hljs-comment">//量程范围</span>  <span class="hljs-type">float</span> upperRario;     <span class="hljs-comment">//比例下限</span>  <span class="hljs-type">float</span> lowerRatio;     <span class="hljs-comment">//比例下限</span>&#125;FilterObjectType;<span class="hljs-comment">/* 阶梯平滑滤波处理函数，返回滤波后的值*/</span><span class="hljs-type">float</span> <span class="hljs-title function_">StepSmoothingFilter</span><span class="hljs-params">(FilterObjectType *filter)</span>&#123;  <span class="hljs-type">float</span> result=filter-&gt;lastValue;  <span class="hljs-comment">/* 填充缓冲区 */</span>  <span class="hljs-keyword">if</span>(filter-&gt;position&gt;=filter-&gt;bufCount)  &#123;    filter-&gt;position=<span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span>  &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;filter-&gt;bufCount;i++)    &#123;      filter-&gt;buffer[i]=filter-&gt;newValue;    &#125;    filter-&gt;position=<span class="hljs-number">0</span>;    filter-&gt;lastValue=filter-&gt;newValue;  &#125;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(filter-&gt;newValue-filter-&gt;lastValue)&gt;(filter-&gt;rangeLimit*filter-&gt;upperRario/<span class="hljs-number">100</span>))  &#123;<span class="hljs-comment">/* 超过最大值直接更新值 消抖 */</span>    filter-&gt;delayCount+=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(filter-&gt;delayCount&gt;=filter-&gt;delayLimit)    &#123;      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;filter-&gt;bufCount;i++)      &#123;        filter-&gt;buffer[i]=filter-&gt;newValue;      &#125;      filter-&gt;position++;      result=filter-&gt;newValue;      filter-&gt;delayCount=<span class="hljs-number">0</span>;    &#125;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(filter-&gt;newValue-filter-&gt;lastValue)&gt;=(filter-&gt;rangeLimit*filter-&gt;lowerRatio/<span class="hljs-number">100</span>))  &#123;<span class="hljs-comment">/* 小于最小值 完全滤波 */</span>    result=filter-&gt;lastValue-filter-&gt;buffer[filter-&gt;position]/filter-&gt;bufCount;       result+=filter-&gt;newValue/filter-&gt;bufCount;       filter-&gt;buffer[filter-&gt;position++]=filter-&gt;newValue;    <span class="hljs-keyword">if</span>(filter-&gt;position&gt;=filter-&gt;bufCount)    &#123;      filter-&gt;position=<span class="hljs-number">0</span>;    &#125;       result=result-filter-&gt;buffer[filter-&gt;position]/filter-&gt;bufCount;    result=result+filter-&gt;newValue/filter-&gt;bufCount;    filter-&gt;buffer[filter-&gt;position++]=filter-&gt;newValue;    filter-&gt;delayCount=<span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span>  &#123;<span class="hljs-comment">/* 范围之内 半滤波 */</span>    result=filter-&gt;lastValue-filter-&gt;buffer[filter-&gt;position]/filter-&gt;bufCount;     result=result+filter-&gt;newValue/filter-&gt;bufCount;    filter-&gt;buffer[filter-&gt;position++]=filter-&gt;newValue;    filter-&gt;delayCount=<span class="hljs-number">0</span>;  &#125;   filter-&gt;lastValue=result;  filter-&gt;newValue=<span class="hljs-number">0.0</span>;  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><h2 id="算术平均的中值滤波"><strong>算术平均的中值滤波</strong></h2><p>中值滤波主要是去除相对频率较低的周期干扰和相对频率较高的非周期干扰。去掉最高和最低的数，中间的数更为接近真实值。这一滤波算法适用于高速采集，必须采集到一定数量的数据，一般一次采集几十个数然后再做此滤波是比较有效果的。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 中值平均滤波算法 */</span><span class="hljs-comment">/* pData:采集的数据指针 */</span><span class="hljs-comment">/* aSize:采集的数据长度 */</span><span class="hljs-comment">/* eSize:各需要丢弃的极大值和极小值的数量 */</span><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">MedianMeanFilter</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *pData,<span class="hljs-type">uint16_t</span> aSize,<span class="hljs-type">uint16_t</span> eSize)</span>&#123;    <span class="hljs-type">uint32_t</span> tData;    <span class="hljs-type">uint32_t</span> result=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(aSize&lt;=<span class="hljs-number">2</span>*eSize)    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/* 冒泡排序 */</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;aSize<span class="hljs-number">-1</span>; i++)  <span class="hljs-comment">//比较n-1轮</span>    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;aSize<span class="hljs-number">-1</span>-i; j++)  <span class="hljs-comment">//每轮比较n-1-i次,</span>        &#123;            <span class="hljs-keyword">if</span> (pData[j] &lt; pData[j+<span class="hljs-number">1</span>])            &#123;                tData = pData[j];                pData[j] = pData[j+<span class="hljs-number">1</span>];                pData[j+<span class="hljs-number">1</span>] = tData;            &#125;        &#125;    &#125;    <span class="hljs-comment">/* 去掉首末端eSize数据，取平均值 */</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=eSize;j&lt;(aSize-eSize);j++)    &#123;        result+=pData[j];    &#125;        result /= (aSize<span class="hljs-number">-2</span>*eSize);        <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><h2 id="算术平均的限幅滤波"><strong>算术平均的限幅滤波</strong></h2><p>此种算法就是在中值滤波的基础上剔除超出限幅的数据。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*限幅平均滤波算法*/</span><span class="hljs-comment">/* pData:采集的数据指针 */</span><span class="hljs-comment">/* aSize:采集的数据长度 */</span><span class="hljs-comment">/* eSize:各需要丢弃的极大值和极小值的数量 */</span><span class="hljs-comment">/* rData:参考值 */</span><span class="hljs-comment">/* lValue:偏离参考值的限幅 */</span><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">LimitedMeanFilter</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *pData,<span class="hljs-type">uint16_t</span> aSize,<span class="hljs-type">uint16_t</span> eSize,<span class="hljs-type">uint32_t</span> rData,<span class="hljs-type">uint32_t</span> lValue)</span>&#123;  <span class="hljs-type">uint32_t</span> uResult=<span class="hljs-number">0</span>, mResult=<span class="hljs-number">0</span>, lResult=<span class="hljs-number">0</span>; <span class="hljs-comment">//求和值</span>  <span class="hljs-type">uint16_t</span> uNumber=<span class="hljs-number">0</span>, mNumber=<span class="hljs-number">0</span>, lNumber=<span class="hljs-number">0</span>; <span class="hljs-comment">//数量</span>  <span class="hljs-comment">/* 判断采集的数据量 */</span>  <span class="hljs-keyword">if</span>(aSize&lt;=<span class="hljs-number">2</span>*eSize)  &#123;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">/* 冒泡排序 */</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;aSize<span class="hljs-number">-1</span>; i++) <span class="hljs-comment">//比较n-1轮</span>  &#123;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;aSize<span class="hljs-number">-1</span>-i; j++) <span class="hljs-comment">//每轮比较n-1-i次,</span>     &#123;       <span class="hljs-keyword">if</span> (pData[j] &lt; pData[j+<span class="hljs-number">1</span>])       &#123;         pData[j]^=pData[j+<span class="hljs-number">1</span>];         pData[j+<span class="hljs-number">1</span>]^= pData[j];         pData[j]^=pData[j+<span class="hljs-number">1</span>];       &#125;     &#125;  &#125;  <span class="hljs-comment">/* 剔除极值后根据限幅值求和 */</span>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=eSize;j&lt;(aSize-eSize);j++)  &#123;     <span class="hljs-keyword">if</span>(pData[j]&gt;(rData+lValue))     &#123;<span class="hljs-comment">/* 大于上限 */</span>       uResult+=pData[j];       uNumber++;     &#125;     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pData[j]&lt;(rData-lValue))     &#123;<span class="hljs-comment">/* 小于下限 */</span>       lResult+=pData[j];       lNumber++;     &#125;     <span class="hljs-keyword">else</span>     &#123;<span class="hljs-comment">/* 上下限之间 */</span>       mResult+=pData[j];       mNumber++;     &#125;  &#125;  <span class="hljs-comment">/* 求平均值 */</span>  <span class="hljs-keyword">if</span>((mNumber&gt;uNumber)&amp;&amp;(mNumber&gt;lNumber))  &#123;<span class="hljs-comment">/* 处于上下限之间的数据量较大时 */</span>     mResult = mResult/mNumber;  &#125;  <span class="hljs-keyword">else</span>  &#123;     mResult = (uResult+mResult+lResult)/(uNumber+mNumber+lNumber);  &#125;    <span class="hljs-keyword">return</span> mResult;&#125;</code></pre></div><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/foxclever/article/details/106038732">滤波器开发之一：基于算数平均的平滑滤波器_算术平均掩模_foxclever的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/foxclever/article/details/106296222">滤波器开发之二：基于算数平均的带阻平滑滤波器_用均值滤波实现带阻滤波-CSDN博客</a></p><p><a href="https://blog.csdn.net/foxclever/article/details/106448052">滤波器开发之三：基于算数平均的阶进平滑滤波器_阶梯平滑_foxclever的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/foxclever/article/details/120925665">滤波器开发之四：基于算术平均的中值滤波器_算术中值滤波_foxclever的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/foxclever/article/details/121191411">滤波器开发之五：基于算术平均的限幅滤波器-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在AD采集获取数据时，为避免干扰信号的影响，一般我们都会对获取的原始数据进行滤波处理，比较常见的做法是算术平均，即对N个数据进行平均求值，为了进一步优化这种简易的平均算法，我们可以采用以下方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;算术平均的递推平滑滤波&lt;/str</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算术平均" scheme="http://example.com/tags/%E7%AE%97%E6%9C%AF%E5%B9%B3%E5%9D%87/"/>
    
  </entry>
  
  <entry>
    <title>C语言中的回调函数及使用</title>
    <link href="http://example.com/2023/09/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/09/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2023-09-07T02:13:19.000Z</published>
    <updated>2023-09-19T00:36:00.844Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中，我们会经常碰到回调函数的问题，那什么是回调函数？怎么使用回调函数呢？下面具体来看看。</p><h1 id="什么是回调函数">什么是回调函数</h1><p><strong>回调函数</strong>就是一个通过<strong>函数指针</strong>调用的函数。</p><p>假如你把 <strong>函数A的指针</strong> 当作参数传给 <strong>函数B</strong>，然后在 <strong>函数B</strong> 中通过传进来的这个指针调用 <strong>函数A</strong> ，那么这就是回调机制，<strong>函数A</strong> 就是<strong>回调函数</strong>。</p><p>知乎上有个比较形象的比喻：你到商店买东西，刚好没货，于是留下了你的电话，有货后店员就打了你的电话，去店里取货。在这个例子里，你的电话号码就叫<strong>回调函数</strong>，你把电话留给店员就叫<strong>注册回调函数</strong>，店里后来有货了叫做<strong>触发了回调关联的事件</strong>，店员给你打电话叫做<strong>调用回调函数</strong>，你到店里去取货叫做<strong>响应回调事件</strong>。</p><h1 id="为何要使用回调函数">为何要使用回调函数</h1><p>回调函数最大的优势是解耦，降低了程序的耦合度，使上层的应用更完整，而不需要考虑底层的实现细节，方便协作与移植。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2ecc00017db499f2620d.jpeg" alt="" /><figcaption>img</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;softwareLib.h&gt;</span> <span class="hljs-comment">//Library 函数所在库的头文件</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">Callback</span><span class="hljs-params">()</span> <span class="hljs-comment">// Callback Function</span>&#123;    <span class="hljs-comment">// TODO</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <span class="hljs-comment">// Main program</span>&#123;    <span class="hljs-comment">// TODO</span>    Library(Callback);    <span class="hljs-comment">// TODO</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>乍一看，回调似乎只是函数间的调用，和普通函数调用没啥区别，但仔细一看，可以发现：</p><p>主函数和回调函数是在同一层，而库函数在另外一层，主程序中把回调函数当参数传入库函数中。只要我们改变传进库函数的参数（函数指针），就可以实现不同的功能，丝毫不需要修改库函数的实现，这就是解耦。</p><h1 id="如何使用回调函数">如何使用回调函数</h1><h3 id="以简单的函数指针参数形式使用">1.以简单的函数指针参数形式使用</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">Callback_1</span><span class="hljs-params">()</span> <span class="hljs-comment">// Callback Function 1</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, this is Callback_1\n&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">Callback_2</span><span class="hljs-params">()</span> <span class="hljs-comment">// Callback Function 2</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, this is Callback_2\n&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Handle</span><span class="hljs-params">(<span class="hljs-type">int</span> (*Callback)())</span>&#123;Callback();&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;Handle(Callback_1);  Handle(Callback_2);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230918221802882.png" alt="" /><figcaption>image-20230918221802882</figcaption></figure><h3 id="以typedef定义的函数指针类型方式使用">2.以typedef定义的函数指针类型方式使用</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*cb)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">Callback_1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-comment">// Callback Function 1</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, this is Callback_1, %d\n&quot;</span>, a);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">Callback_2</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span> <span class="hljs-comment">// Callback Function 2</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, this is Callback_2, %d\n&quot;</span>, b);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Handle</span><span class="hljs-params">(cb callback, <span class="hljs-type">int</span> x)</span>&#123;callback(x);&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;  Handle(Callback_1, <span class="hljs-number">1</span>);  Handle(Callback_2, <span class="hljs-number">2</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230918225732968.png" alt="" /><figcaption>image-20230918225732968</figcaption></figure><h3 id="以弱函数的方式使用">3.以弱函数的方式使用</h3><p>在回调函数前面添加标识： <code>__weak</code> ，该函数允许定义与其名称和形式完全一样的函数，若使用者重新定义了该函数则会调用新函数，否则使用此默认函数。在STM32的HAL库中使用了很多这样的函数。如：</p><div class="code-wrapper"><pre><code class="hljs c">__weak <span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span>&#123;  <span class="hljs-comment">/* Prevent unused argument(s) compilation warning */</span>  UNUSED(GPIO_Pin);  <span class="hljs-comment">/* <span class="hljs-doctag">NOTE:</span> This function Should not be modified, when the callback is needed,</span><span class="hljs-comment">           the HAL_GPIO_EXTI_Callback could be implemented in the user file</span><span class="hljs-comment">   */</span>&#125;</code></pre></div><h3 id="以函数封装注册的方式使用">4.以函数封装注册的方式使用</h3><p>对于一些复杂的对象进行属性和方法的封装，如STM32中DMA外设中的回调函数被一起封装在一个结构体中：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">DMA_HandleTypeDef</span></span><span class="hljs-class">&#123;</span>  DMA_Channel_TypeDef        *Instance;                                               DMA_InitTypeDef            Init;                                                    HAL_LockTypeDef            Lock;                                                    __IO HAL_DMA_StateTypeDef  State;                                                    <span class="hljs-type">void</span>                       *Parent;                                                   <span class="hljs-type">void</span>  (* XferCpltCallback)( <span class="hljs-keyword">struct</span> __DMA_HandleTypeDef * hdma);   <span class="hljs-type">void</span>  (* XferHalfCpltCallback)( <span class="hljs-keyword">struct</span> __DMA_HandleTypeDef * hdma);  <span class="hljs-type">void</span>  (* XferErrorCallback)( <span class="hljs-keyword">struct</span> __DMA_HandleTypeDef * hdma);    <span class="hljs-type">void</span>  (* XferAbortCallback)( <span class="hljs-keyword">struct</span> __DMA_HandleTypeDef * hdma);      __IO <span class="hljs-type">uint32_t</span>              ErrorCode;                                                 DMA_TypeDef                *DmaBaseAddress;                                           <span class="hljs-type">uint32_t</span>                   ChannelIndex;                                           &#125; DMA_HandleTypeDef;</code></pre></div><p>在使用时我们只需声明一个DMA对象，编写对应的回调函数，然后通过注册函数进行注册(<code>HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)( DMA_HandleTypeDef * _hdma))</code>),这样就可以使用了。可参考：<a href="https://zhuanlan.zhihu.com/p/390460838">c语言回调函数的使用及实际作用详解</a></p><p><strong>链接：</strong></p><p><a href="https://www.runoob.com/w3cnote/c-callback-function.html">C 语言回调函数详解 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://blog.csdn.net/miao19920101/article/details/75648491">回调指针回调函数的使用（C语言）_森林之猫猫狗狗的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在开发过程中，我们会经常碰到回调函数的问题，那什么是回调函数？怎么使用回调函数呢？下面具体来看看。&lt;/p&gt;
&lt;h1 id=&quot;什么是回调函数&quot;&gt;什么是回调函数&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;回调函数&lt;/strong&gt;就是一个通过&lt;strong&gt;函数指针&lt;/strong&gt;</summary>
      
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="回调函数" scheme="http://example.com/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C语言中几个重要的关键字</title>
    <link href="http://example.com/2023/09/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2023/09/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2023-09-07T02:12:24.000Z</published>
    <updated>2023-09-07T09:45:59.835Z</updated>
    
    <content type="html"><![CDATA[<p>在了解关键字之前，先来了解变量或函数的“声明”与“定义”之间的区别：</p><p><strong>声明</strong>：告诉编译器，声明的变量或函数在程序中的某个位置，数据类型，参数顺序及返回类型，但未为它们分配内存。</p><p><strong>定义</strong>：编译器创建一个对象并分配一块内存并给取一个名字，这个名字就是变量名或对象名。</p><p>因此，我们可以将声明作为定义的子集。变量或函数可以声明多次，但只能定义一次。</p><p>由ANSI标准定义的C语言关键字共32个:</p><ul><li><strong>数据类型关键字（14个）：char double float short unsigned signed int long void struct enum union typedef sizeof</strong></li><li><strong>存储类型关键字（6个）：extern const static auto register volatile</strong><br /></li><li><strong>流程控制关键字（12个）：do if while break else switch case continue for default goto return</strong></li></ul><p>这里主要来看看存储类型的几个关键字。</p><h1 id="extern">extern</h1><p>通过使用 <strong>extern</strong> 关键字来声明变量或函数，不会为变量或函数分配存储空间，而只是指示编译器该变量或函数在其他文件中定义，提供一个全局变量的引用，可以在当前文件引用此变量或函数。</p><p>一般在模块化编程中，我们都会在头文件中声明的函数名前添加 extern 关键字，以供外部文件使用，当我们不添加此关键字，使用也是正常的，那是因为编译器会默认给该函数增加外部使用的属性，但我们在编写程序时，为养成好习惯，最好添加 extern 关键字，不同的平台，不同的编译器，所产生的结果会不一样。</p><h1 id="const">const</h1><p>const 关键字用来告诉编译器，<strong>被修饰的这些变量或函数，具有“只读”的特点</strong>。在编译的过程中，一旦我们的代码试图去改变这些变量或函数，编译器就会给出错误提示。关于 const 的用法有以下几种：</p><h4 id="修饰局部变量">1.修饰局部变量</h4><p><strong>const 变量必须被初始化</strong>！！</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 这两种方式都是表示变量n的值不能被改变了 */</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<span class="hljs-type">int</span> <span class="hljs-type">const</span> n = <span class="hljs-number">5</span>;<span class="hljs-comment">/* 修饰字符串常量 */</span><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;abcdef&quot;</span>; <span class="hljs-comment">//防止无意错误的修改，如：str[4] = &#x27;y&#x27;;</span><span class="hljs-comment">/* 以下编译错误 */</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> n;n = <span class="hljs-number">5</span>;</code></pre></div><h4 id="修饰指针变量">2.修饰指针变量</h4><p><strong>常量指针</strong>：说明此指针指向常量。<strong>指针指向的值不能改变，但指针的指向可以改变。</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<span class="hljs-type">int</span> b = <span class="hljs-number">6</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p = &amp;a;<span class="hljs-comment">//常量指针p，指向const的变量，这里指向int型变量a</span>p = &amp;b;<span class="hljs-comment">//编译正常，指针的指向可以改变</span>*p = <span class="hljs-number">10</span>; <span class="hljs-comment">//编译报错，指针指向的值是只读的</span></code></pre></div><p><strong>指针常量</strong>：说明此指针是个常量。<strong>指针指向不可改变，但指针指向的值可以改变。</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<span class="hljs-type">int</span> b = <span class="hljs-number">6</span>;<span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a; <span class="hljs-comment">//只读变量指针p，指向变量a</span>*p = <span class="hljs-number">8</span>;<span class="hljs-comment">//编译正常，指针指向的值可以改变</span>p = &amp;b;<span class="hljs-comment">//编译报错，const指针自身内容(指向)不能改变</span></code></pre></div><p>区分常量指针和指针常量的一般规则是：<strong>从右向左，const就近依次结合</strong>。如：</p><p><code>int * const p</code> : p先与<code>const</code>结合，说明p为只读变量，然后与<code>*</code>结合，说明p是一个只读变量指针，最后与<code>int</code> 结合，说明只读变量指针p指向一个int型的变量。所以这就是一个指向int型的只读指针。</p><p><code>const int * p</code> : p先与<code>*</code>结合，说明p为一个指针，然后与<code>int</code>结合，说明p指向一个int型的变量，最后与<code>const</code> 结合，说明p指向的是一个只读的int型变量。所以这是一个指向只读int型变量的指针。</p><p>当然也可以根据const关键字的位置来区别：当const关键字的右边是类型时，则表示值是常量。当const关键字的右边是指针变量时，则表示指针本身是常量。</p><h4 id="修饰函数的参数">3.修饰函数的参数</h4><p>关键字const修饰函数形参时，通常用于参数为指针或引用的情况，且只能修饰输入参数。若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。将函数参数声明为 const 类型，表示函数内部是不能改变这个参数的值。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 防止修改指针指向的内容，即改变了源字符串的值 */</span><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span>  <span class="hljs-comment">/* 防止修改指针指向的地址 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span> <span class="hljs-params">( <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p1 , <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p2 )</span></code></pre></div><h4 id="修饰函数的返回值">4.修饰函数的返回值</h4><p>const 型的返回值，指的是函数的返回值为一个 const 变量，函数返回值（即指针）的内容不能被修改，且该返回值只能被赋给加const 修饰的同类型指针。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title function_">GetString</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">char</span> *str = GetString(); <span class="hljs-comment">//编译错误</span><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = GetString();<span class="hljs-comment">//编译正确</span></code></pre></div><h4 id="修饰全局变量">5.修饰全局变量</h4><p>全局变量的作用域是整个文件，我们应该尽量避免使用全局变量，因为一旦有一个函数改变了全局变量的值，它也会影响到其他引用这个变量的函数，导致除了bug后很难发现，如果一定要用全局变量，我们应该尽量的使用const修饰符进行修饰，这样防止不必要的人为修改，使用的方法与局部变量是相同的。</p><h1 id="static">static</h1><p>static关键字常见用法有三种：</p><h4 id="修饰局部变量-1">1.修饰局部变量</h4><p>使用static修饰局部变量，称为静态局部变量，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于全局（静态）存储区，在函数返回时，<strong>它的值会保持不变</strong>。其作用域为局部作用域，当定义它的函数结束时，其作用域随之结束。</p><h4 id="修饰全局变量-1">2.修饰全局变量</h4><p>使用static修饰全局变量，称为静态全局变量，变量可以被当前文件内的所有函数访问，但不能被其它文件内的函数访问。其他文件可以定义与其同名的变量，两者互不影响。</p><h4 id="修饰函数">3.修饰函数</h4><p>函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数。静态函数只能在声明它的文件中被调用，不可被其它模块的函数调用，方便封装一些模块内部属性的功能。不同的文件可以使用相同名字的静态函数，互不影响。</p><h1 id="volatile">volatile</h1><p>用 volatile 关键字声明的变量是提醒编译器该变量随时都有可能改变(如被别的程序更新)，不要对该变量进行优化，需要存储或读取该变量时，直接从该变量地址中存储或读取数据。</p><p>使用 volatile 的场景主要有：</p><h4 id="存储器映射的硬件寄存器">1.存储器映射的硬件寄存器</h4><p>由于我们外部的数据都是直接进入内存区域，而程序只是引用它的值。编译器优化时可能就直接采用寄存器中的副本了，所以需要将这段内存对应的变量声明为volatile。如在STM32库文件中的各外设寄存器存储器映射：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230907171919476.png" alt="" /><figcaption>image-20230907171919476</figcaption></figure><h4 id="中断服务程序中改变对象值">2.中断服务程序中改变对象值</h4><p>中断服务程序中需要修改的变量，以供其它程序检测，则需要加volatile。如：</p><p>我们将变量定义为：<code>static int var=0;</code> ，然后在中断服务程序中将其修改：<code>var=1;</code>，但是在另一函数中使用它但不会修改它，那么编译器会认为它没有变化，从而直接使用寄存器中的副本。</p><p>如果我们将变量定义为：<code>volatile int var=0;</code> ，那么每次在函数中使用var变量时，都会重新读取寄存器中的值。</p><h4 id="多任务共享标志">3.多任务共享标志</h4><p>多任务共享时，其实也是一样的，在一个任务中修改了一个对象后，在另一个对象中应用它，但编译器并没发现在该任务中对它有修改。由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。从而并不能响应在另一任务下的变化。</p><p>在这种情况下，一般我们都需要使用volatile关键字来定义任务间共享的标识。</p><p><strong>链接：</strong></p><p><a href="https://blog.csdn.net/xingjiarong/article/details/47282255">C语言中const关键字的用法_xingjiarong的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/guotianqing/article/details/79828100">c语言中static关键字用法详解_static在c语言中的用法_guotianqing的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/foxclever/article/details/83721019?spm=1001.2014.3001.5502">C语言volatile关键字及其使用_foxclever的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在了解关键字之前，先来了解变量或函数的“声明”与“定义”之间的区别：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：告诉编译器，声明的变量或函数在程序中的某个位置，数据类型，参数顺序及返回类型，但未为它们分配内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/stro</summary>
      
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="关键字" scheme="http://example.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>Modbus通讯协议详解</title>
    <link href="http://example.com/2023/09/04/Modbus%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/09/04/Modbus%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-09-04T02:44:48.000Z</published>
    <updated>2023-09-06T14:37:48.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="modbus协议简介">Modbus协议简介</h1><p>Modbus协议是一种通用的工业通讯总线协议，跟I2C、SPI总线类似，通讯的服务器端和客户端都在同一条总线上。</p><p>Modbus协议最初是Modicon公司（现在的施耐德电气 Schneider Electric）于1979年为使用可编程逻辑控制器（PLC）通信而开发的，现在已成为工业领域通信协议的业界标准。</p><p>Modbus官网：<a href="https://modbus.org/">https://modbus.org/</a></p><p>本文主要以modbus官方文档（<a href="https://modbus.org/specs.php">Modbus Specifications and Implementation Guides</a>）进行说明。</p><h1 id="modbus协议传输方式">Modbus协议传输方式</h1><p>Modbus协议主要有以下几种传输方式：</p><ul><li><p><strong>基于串口的Modbus-RTU</strong></p><p>采用二进制表现形式以及紧凑数据结构，通信效率较高，应用比较广泛，在工业现场一般都是采用Modbus RTU协议。</p><p>RTU协议中的指令由地址码(一个字节），功能码（一个字节），起始地址（两个字节），数据（N个字节），校验码（两个字节）五个部分组成，其中数据又由数据长度（两个字节，表示的是寄存器个数，假定内容为M）和数据正文（M乘以2个字节）组成，而RTU协议是采用3.5个字节的空闲时间作为指令的起始和结束，一般而言，只有当从机返回数据或者主机写操作的时候，才会有数据正文，而其他时候比如主机读操作指令的时候，没有数据正文，只需要数据长度即可。</p></li><li><p><strong>基于串口的Modbus-ASCII</strong></p><p>采用ASCII码传输，并且利用特殊字符作为其字节的开始与结束标识，其传输效率要远远低于Modbus RTU协议，一般只有在通信数据量较小的情况下才使用Modbus ASCII通信。</p></li><li><p><strong>基于以太网的Modbus-TCP</strong></p><p>是在RTU协议上加一个MBAP报文头，由于TCP是基于可靠连接的服务，所以就不需要CRC校验了。</p></li></ul><h1 id="modbus协议数据帧">Modbus协议数据帧</h1><p>Modbus协议帧比较简洁，如下所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904153822090.png" alt="" /><figcaption>image-20230904153822090</figcaption></figure><p>一帧Modbus数据由客户端构建，开启数据传输（无错误发生）：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904155252355.png" alt="" /><figcaption>image-20230904155252355</figcaption></figure><p>当服务器检测到异常，则会发出异常码和异常功能码：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904155609179.png" alt="" /><figcaption>image-20230904155609179</figcaption></figure><h1 id="modbus数据编码和数据模型">Modbus数据编码和数据模型</h1><p>Modbus协议中采用的是 <strong>大端模式</strong> ，所以传输多字节地址和数据时，要先发送高位字节，如数据：<strong>0x1234</strong> ，要先发送高位字节 <strong>0x12</strong>，然后发送低位字节 <strong>0x34</strong> 。</p><p>Modbus协议规定，进行读写操作的数据类型主要分为以下4种：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904185445076.png" alt="" /><figcaption>image-20230904185445076</figcaption></figure><h1 id="功能码的分类与定义">功能码的分类与定义</h1><p>Modbus功能码主要有公共功能码(如：1~65 或 73~100 或 111~127)和自定义功能码（如：66~72 或 101~110）。</p><p>主要来看看公共功能码：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904164451733.png" alt="" /><figcaption>image-20230904164451733</figcaption></figure><p>因为PLC主要控制的是继电器触点，所以在PLC上还会经常对线圈（Coils）进行读写。</p><p>最常用的功能码：</p><ul><li><p><strong>03 (0x03) - 读保持寄存器</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904181240364.png" alt="" /><figcaption>image-20230904181240364</figcaption></figure></li><li><p><strong>04 (0x04) - 读输入寄存器</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904182100762.png" alt="" /><figcaption>image-20230904182100762</figcaption></figure></li><li><p><strong>06 (0x06) - 写单个寄存器</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904182705385.png" alt="" /><figcaption>image-20230904182705385</figcaption></figure></li><li><p><strong>16 (0x10) - 写多个寄存器</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904184016458.png" alt="" /><figcaption>image-20230904184016458</figcaption></figure></li></ul><p>可以看出，不同的功能码，对应的请求和响应不太一样，但一般 <strong>功能码占用1Byte，地址占用2Bytes，寄存器数量占用2Bytes，寄存器值占用2Bytes，数据字节数占用1Byte</strong>。另外，在实际应用中，还有设备地址占用1Byte，CRC校验占用2Bytes。如在Modbus RTU传输中：</p><ul><li><strong>03 (0x03) - 读保持寄存器</strong></li></ul><p><strong>请求</strong>：1byte设备地址 + 1byte功能代码 + 2bytes寄存器起始地址 + 2bytes寄存器数量 + 2bytes CRC校验</p><p><strong>响应</strong>：1byte设备地址 + 1byte功能代码 + 1byte数据字节数 + 2N bytes寄存器数据 + 2bytes CRC校验</p><ul><li><strong>06 (0x06) - 写单个寄存器</strong></li></ul><p><strong>请求</strong>：1byte设备地址 + 1byte功能代码 + 2bytes寄存器起始地址 + 2bytes数据 + 2bytes CRC校验</p><p><strong>响应</strong>：1byte设备地址 + 1byte功能代码 + 2bytes寄存器起始地址 + 2bytes数据 + 2bytes CRC校验</p><h1 id="modbus协议应用">Modbus协议应用</h1><p><a href="https://www.modbus.cn/11740.html">格力中央空调多联机 Modbus 通讯协议 | Modbus物联网云平台</a></p><p>Modbus官网有个外链驱动库：<a href="https://libmodbus.org/">libmodbus驱动库</a> ，在应用中可以直接移植到程序中，而不用自己重复的编写驱动。具体移植过程可参考：<a href="https://blog.csdn.net/whik1194/article/details/119010616?spm=1001.2014.3001.5501">Modbus驱动库—libmodbus驱动库的使用_whik1194的博客-CSDN博客</a>）</p><p><strong>链接：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/38920259">Modbus RTU/TCP协议解析 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;modbus协议简介&quot;&gt;Modbus协议简介&lt;/h1&gt;
&lt;p&gt;Modbus协议是一种通用的工业通讯总线协议，跟I2C、SPI总线类似，通讯的服务器端和客户端都在同一条总线上。&lt;/p&gt;
&lt;p&gt;Modbus协议最初是Modicon公司（现在的施耐德电气 Schne</summary>
      
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Modbus" scheme="http://example.com/tags/Modbus/"/>
    
  </entry>
  
  <entry>
    <title>关于OLED字模取模方式的选择</title>
    <link href="http://example.com/2023/09/02/%E5%85%B3%E4%BA%8EOLED%E5%AD%97%E6%A8%A1%E5%8F%96%E6%A8%A1%E6%96%B9%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <id>http://example.com/2023/09/02/%E5%85%B3%E4%BA%8EOLED%E5%AD%97%E6%A8%A1%E5%8F%96%E6%A8%A1%E6%96%B9%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9/</id>
    <published>2023-09-02T05:30:21.000Z</published>
    <updated>2023-09-04T02:44:10.554Z</updated>
    
    <content type="html"><![CDATA[<p>OLED（Organic Light-Emitting Diode）,有机发光二极体，属于一种电流型的有机发光器件，当电流流动时就会自行发光。因其简单，使用方便，所以在开发过程中会经常使用到这种显示器件。</p><p>市面上有很多OLED显示模块，根据控制显示的驱动芯片的不同，有不同的连接接口，一般大体会有四种：</p><ul><li><strong>6800并行接口</strong></li><li><strong>8080并行接口</strong></li><li><strong>4线SPI串行接口</strong></li><li><strong>I2C接口</strong></li></ul><p>下面主要是来看看OLED在显示中文信息时，需要注意的事项：</p><p>显示中文信息需要用到字模工具，如：<a href="https://gitee.com/kayoungzhang/my_codehub/blob/master/tools/PCtoLCD2018.zip">PCtoLCD</a> ，当然，还有其它的一些字模工具，功能都差不多。</p><p>PCtoLCD字符模式的配置（16*16汉字）与使用方式如图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230902141405518.png" alt="image-20230902141405518" style="zoom:80%;" /></p><p>将生成的数据放到一个二维数组中，可以将这个二维数组保存到一个头文件中，使用时，包含这个头文件即可。如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> OLEDFONT_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> OLEDFONT_H    </span><span class="hljs-type">char</span> <span class="hljs-type">const</span> SHOW[][<span class="hljs-number">32</span>]=&#123;    &#123;<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;,    &#123;<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;,<span class="hljs-comment">/*&quot;中&quot;,0*/</span>    <span class="hljs-comment">/* (16 X 16 , 宋体 )*/</span>    &#123;<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0x12</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0xF2</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0x12</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;,    &#123;<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x4A</span>,<span class="hljs-number">0x4C</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;,<span class="hljs-comment">/*&quot;国&quot;,1*/</span>    <span class="hljs-comment">/* (16 X 16 , 宋体 )*/</span>    &#123;<span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x44</span>,<span class="hljs-number">0x58</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x46</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>&#125;,    &#123;<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x18</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x00</span>&#125;,<span class="hljs-comment">/*&quot;光&quot;,2*/</span>    <span class="hljs-comment">/* (16 X 16 , 宋体 )*/</span>    &#123;<span class="hljs-number">0x00</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x88</span>,<span class="hljs-number">0x84</span>,<span class="hljs-number">0x43</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x0C</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x41</span>,<span class="hljs-number">0x82</span>,<span class="hljs-number">0x84</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;,    &#123;<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>&#125;,<span class="hljs-comment">/*&quot;谷&quot;,3*/</span>    <span class="hljs-comment">/* (16 X 16 , 宋体 )*/</span>&#125;;<span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* OLEDFONT_H */</span></span></code></pre></div><p>这里看一下它的取模方式，各种取模方式的演示，可查看软件上自带的演示示例。这四种方式各自的特点如下：</p><ul><li><p><strong>逐列式</strong></p><ul><li>从第一列开始向下每取8个点作为一个字节，如果最后不足8个点就补满8位。取模顺序是从低到高，即第一个点作为最低位。</li><li>不需要进行数据重组，取模软件取出数据直接运用。</li><li>写完一字节数据就需要重新设置一次地址，写一个16x16汉字，需要经历32次地址设置 ： 每一列数据需要设置2次，共16列。</li></ul></li><li><p><strong>逐行式</strong></p><ul><li><p>从第一行开始向右每取8个点作为一个字节，如果最后不足8个点就补满8位。取模顺序是从低到高 ，即第一个点作为最低位。</p></li><li><p>需要进行数据重组，取模软件取出的数值无法直接运用。</p></li><li><p>写1个字节数据需要对8个数据进行Bit位数值的提取和重组操作，写完16字节数据需要重新设置一次地址，写一个16x16汉字，需要经历2次地址设置 ： 汉字上半部分的页地址和汉字下半部分的页地址分别设置一次。</p></li></ul></li><li><p><strong>列行式</strong></p><ul><li>从第一列开始向下取8个点作为一个字节，然后从第二列开始向下取8个点作为第二个字节...依此类推。如果最后不足8个点就补满8位。取模顺序是从低到高，即第一个点作为最低位。</li><li>不需要进行数据重组，取模软件取出数据直接运用。</li><li>写完16字节数据需要重新设置一次地址，写一个16x16汉字，需要经历2次地址变换： 汉字上半部分的页地址和汉字下半部分的页地址分别设置一次。（注意这里和逐行式的做法本质上是一样的，只是在于数据是否可以直接运用）</li></ul></li><li><p><strong>行列式</strong></p><ul><li>从第一行开始向右取8个点作为一个字节，然后从第二行开始向右取8个点作为第二个字节...依此类推。如果最后不足8个点就补满8位。取模顺序是从低到高，即第一个点作为最位。</li><li>需要进行数据重组，取模软件取出的数值无法直接运用。</li><li>写1个字节数据需要对8个数据进行Bit位数值的提取和重组操作，写完8个字节数据就需要重新设置一次地址，写一个16x16汉字，需要经历4次地址设置：汉字分为左上部分、左下部分、右上部分、右下部分，共需要设置4次地址</li></ul></li></ul><p>通过对比，可以发现：</p><ul><li>从数据处理方面看，不进行数据重组，其书写速度上可以更快，因此逐列式和列行式更有优势。</li><li>从地址设置方面看，尽量少的程序设置地址，而尽量多的利用硬件自身的列地址自增的性质，这样速度更快，因此逐行式=列行式&gt;行列式&gt;逐列式。</li></ul><p>所以， 对于显示16x16汉字，列行式是最为突出的算法，不仅直接利用数据无需重组，而且尽量多的利用了其硬件特性，是最好的选择。</p><p>PCtoLCD图形模式的配置（128*64图片）与使用方式如图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230902152256627.png" alt="image-20230902152256627" style="zoom:67%;" /></p><p>同上一样，将生成的数据放到一个数组中，将这个数组保存到一个头文件中，使用时，包含这个头文件即可。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">char</span> <span class="hljs-type">const</span> pic[] = &#123;    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xE4</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF2</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xF2</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,    <span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,    <span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x05</span>,<span class="hljs-number">0x09</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x09</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x61</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x03</span>,<span class="hljs-number">0x05</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0x8F</span>,<span class="hljs-number">0x9F</span>,<span class="hljs-number">0x9F</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xD0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,    <span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0xFE</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x7F</span>,    <span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0x01</span>,    <span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xBF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xC8</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xE2</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x01</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x41</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xE7</span>,<span class="hljs-number">0xBF</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xBF</span>,<span class="hljs-number">0x41</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x43</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFC</span>,    <span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x3F</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x09</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x03</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x03</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x3F</span>,    <span class="hljs-number">0x3F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x13</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x03</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,    <span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x03</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x03</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;</code></pre></div><p><strong>链接：</strong></p><p><a href="https://blog.csdn.net/yagnruinihao/article/details/47133455">https://blog.csdn.net/yagnruinihao/article/details/47133455</a></p><p><a href="https://www.cnblogs.com/dragonet-Z/p/14689345.html">https://www.cnblogs.com/dragonet-Z/p/14689345.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;OLED（Organic Light-Emitting Diode）,有机发光二极体，属于一种电流型的有机发光器件，当电流流动时就会自行发光。因其简单，使用方便，所以在开发过程中会经常使用到这种显示器件。&lt;/p&gt;
&lt;p&gt;市面上有很多OLED显示模块，根据控制显示的驱动芯片</summary>
      
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="OLED" scheme="http://example.com/tags/OLED/"/>
    
  </entry>
  
  <entry>
    <title>cJSON使用教程</title>
    <link href="http://example.com/2023/08/29/cJSON%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2023/08/29/cJSON%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2023-08-29T07:52:37.000Z</published>
    <updated>2023-08-30T06:39:32.727Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JSON</strong> (JavaScript Object Notation) 是一种轻量级的数据交换格式。它采用完全独立于编程语言的文本格式来存储和表示数据，语法简洁、层次结构清晰，易于人阅读和编写，同时也易于机器解析和生成，有效的提升了网络传输效率。</p><h2 id="json-构建结构">JSON 构建结构</h2><p>JSON 构建结构主要有两种：</p><ul><li><strong>名称/值的集合。</strong>在不同的编程语言中，体现方式分别有 对象、记录、结构体、字典、哈希表、键值列表或关联数组。(object, record, struct, dictionary, hash table, keyed list, associative array)</li><li><strong>有序的数据列表。</strong>在大多数编程语言中，体现方式主要是数组、向量、列表或序列。(array, vector, list, sequence)</li></ul><h2 id="json-语法">JSON 语法</h2><ul><li>数据以 <strong>name：value</strong> (名称:值) 的形式存在，名称和值之间使用"<code>:</code>"分隔</li><li>每个数据由逗号 <strong><code>,</code></strong> 分隔</li><li>大括号 <strong><code>&#123;&#125;</code></strong> 内部保存对象，允许嵌套使用</li><li>中括号 <strong><code>[]</code></strong> 内部保存数组，数组可以包含多个对象</li></ul><p>JSON值类型有：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* cJSON Types: */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_False 0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_True 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_NULL 2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_Number 3</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_String 4</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_Array 5</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_Object 6</span></code></pre></div><p>示例如下：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JSON中国&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://www.json.org.cn&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;page&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">88</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;isNonProfit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;street&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;浙大路38号.&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;浙江杭州&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;country&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;中国&quot;</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;links&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Google&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://www.google.com&quot;</span>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Baidu&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SoSo&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://www.SoSo.com&quot;</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h2 id="cjson">cJSON</h2><p>cJSON是一个基于C的JSON解析库，这个库非常简短，提供有很多有用的API，支持JSON的解析和创建，移植时只需包含<code>cJSON.h</code>和<code>cJSON.c</code> 这两个文件，然后包含头文件即可调用其API函数。</p><p>cJSON项目托管在Github上，地址：<a href="https://github.com/DaveGamble/cJSON">https://github.com/DaveGamble/cJSON</a></p><h2 id="使用cjson库创建json数据">使用cJSON库创建JSON数据</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cJSON.h&quot;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    cJSON* cjson_test = <span class="hljs-literal">NULL</span>;    cJSON* cjson_address = <span class="hljs-literal">NULL</span>;    cJSON* cjson_skill = <span class="hljs-literal">NULL</span>;    <span class="hljs-type">char</span>* str = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/* 创建一个JSON数据对象(链表头结点) */</span>    cjson_test = cJSON_CreateObject();    <span class="hljs-comment">/* 添加一条字符串类型的JSON数据(添加一个链表节点) */</span>    cJSON_AddStringToObject(cjson_test, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;cjson&quot;</span>);    <span class="hljs-comment">/* 添加一条整数类型的JSON数据(添加一个链表节点) */</span>    cJSON_AddNumberToObject(cjson_test, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">10</span>);    <span class="hljs-comment">/* 添加一条浮点类型的JSON数据(添加一个链表节点) */</span>    cJSON_AddNumberToObject(cjson_test, <span class="hljs-string">&quot;weight&quot;</span>, <span class="hljs-number">20.3</span>);    <span class="hljs-comment">/* 添加一个嵌套的JSON数据（添加一个链表节点） */</span>    cjson_address = cJSON_CreateObject();    cJSON_AddStringToObject(cjson_address, <span class="hljs-string">&quot;country&quot;</span>, <span class="hljs-string">&quot;China&quot;</span>);    cJSON_AddNumberToObject(cjson_address, <span class="hljs-string">&quot;zip-code&quot;</span>, <span class="hljs-number">111111</span>);    cJSON_AddItemToObject(cjson_test, <span class="hljs-string">&quot;address&quot;</span>, cjson_address);    <span class="hljs-comment">/* 添加一个数组类型的JSON数据(添加一个链表节点) */</span>    cjson_skill = cJSON_CreateArray();    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString(<span class="hljs-string">&quot;C&quot;</span>));    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString(<span class="hljs-string">&quot;Java&quot;</span>));    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString(<span class="hljs-string">&quot;Python&quot;</span>));    cJSON_AddItemToObject(cjson_test, <span class="hljs-string">&quot;skill&quot;</span>, cjson_skill);    <span class="hljs-comment">/* 添加一个值为 False 的布尔类型的JSON数据(添加一个链表节点) */</span>    cJSON_AddFalseToObject(cjson_test, <span class="hljs-string">&quot;student&quot;</span>);    <span class="hljs-comment">/* 打印JSON对象(整条链表)的所有数据 */</span>    str = cJSON_Print(cjson_test);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<span class="hljs-comment">/* 释放内存 */</span>cJSON_Delete(cjson_test);cJSON_Delete(cjson_address);cJSON_Delete(cjson_skill);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>运行结果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830083025553.png" alt="image-20230830083025553" style="zoom:80%;" /></p><h2 id="使用cjson库来解析json数据">使用cJSON库来解析JSON数据</h2><p>用于测试JSON数据，我们先用一个char型的字符串来保存，由于JSON对象的name和value都需要使用引号（数值或逻辑型value除外），所以 <strong>在遇到引号时，要加反斜杠<code>\</code>来转义</strong>。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cJSON.h&quot;</span></span><span class="hljs-type">char</span> *message =                               <span class="hljs-string">&quot;&#123;\&quot;name\&quot;: \&quot;cjson\&quot;,                      \</span><span class="hljs-string">\&quot;age\&quot;:  10,                             \</span><span class="hljs-string">\&quot;weight\&quot;:       20.300000,              \</span><span class="hljs-string">\&quot;address\&quot;:      &#123;                       \</span><span class="hljs-string">\&quot;country\&quot;:      \&quot;China\&quot;,      \</span><span class="hljs-string">\&quot;zip-code\&quot;:     111111          \</span><span class="hljs-string">&#125;,                                        \</span><span class="hljs-string">\&quot;skill\&quot;:        [\&quot;C\&quot;, \&quot;Java\&quot;, \&quot;Python\&quot;],  \</span><span class="hljs-string">\&quot;student\&quot;:      false                   \</span><span class="hljs-string">&#125;&quot;</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  cJSON* cjson_test = <span class="hljs-literal">NULL</span>;  cJSON* cjson_name = <span class="hljs-literal">NULL</span>;  cJSON* cjson_age = <span class="hljs-literal">NULL</span>;  cJSON* cjson_weight = <span class="hljs-literal">NULL</span>;  cJSON* cjson_address = <span class="hljs-literal">NULL</span>;  cJSON* cjson_address_country = <span class="hljs-literal">NULL</span>;  cJSON* cjson_address_zipcode = <span class="hljs-literal">NULL</span>;  cJSON* cjson_skill = <span class="hljs-literal">NULL</span>;  cJSON* cjson_student = <span class="hljs-literal">NULL</span>;  <span class="hljs-type">int</span>    skill_array_size = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;  cJSON* cjson_skill_item = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">/* 解析整段JSON数据 */</span>  cjson_test = cJSON_Parse(message);  <span class="hljs-keyword">if</span>(cjson_test == <span class="hljs-literal">NULL</span>)  &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parse fail.\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  &#125;  <span class="hljs-comment">/* 依次根据名称提取JSON数据（键值对） */</span>  cjson_name = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;name&quot;</span>);  cjson_age = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;age&quot;</span>);  cjson_weight = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;weight&quot;</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s\n&quot;</span>, cjson_name-&gt;valuestring);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;age:%d\n&quot;</span>, cjson_age-&gt;valueint);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight:%.1f\n&quot;</span>, cjson_weight-&gt;valuedouble);  <span class="hljs-comment">/* 解析嵌套JSON数据 */</span>  cjson_address = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;address&quot;</span>);  cjson_address_country = cJSON_GetObjectItem(cjson_address, <span class="hljs-string">&quot;country&quot;</span>);  cjson_address_zipcode = cJSON_GetObjectItem(cjson_address, <span class="hljs-string">&quot;zip-code&quot;</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address-country:%s\naddress-zipcode:%d\n&quot;</span>, cjson_address_country-&gt;valuestring, cjson_address_zipcode-&gt;valueint);  <span class="hljs-comment">/* 解析数组 */</span>  cjson_skill = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;skill&quot;</span>);  skill_array_size = cJSON_GetArraySize(cjson_skill);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;skill:[&quot;</span>);  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; skill_array_size; i++)  &#123;    cjson_skill_item = cJSON_GetArrayItem(cjson_skill, i);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s,&quot;</span>, cjson_skill_item-&gt;valuestring);  &#125;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\b]\n&quot;</span>);  <span class="hljs-comment">/* 解析布尔型数据 */</span>  cjson_student = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;student&quot;</span>);  <span class="hljs-keyword">if</span>(cjson_student-&gt;valueint == <span class="hljs-number">0</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student: false\n&quot;</span>);  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student:error\n&quot;</span>);  <span class="hljs-comment">/* 释放内存 */</span>  cJSON_Delete(cjson_test);  cJSON_Delete(cjson_name);  cJSON_Delete(cjson_age);  cJSON_Delete(cjson_weight);  cJSON_Delete(cjson_address);  cJSON_Delete(cjson_address_country);  cJSON_Delete(cjson_address_zipcode);  cJSON_Delete(cjson_skill);  cJSON_Delete(cjson_student);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>运行结果：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830103105877.png" alt="" /><figcaption>image-20230830103105877</figcaption></figure><p>上面是针对JSON数据量较少的情况，通过一个字符串来保存，然后进行解析的方式。但实际使用中，JSON数据的内容较为庞大，<strong>一般都是使用文件的形式来保存JSON数据</strong>。</p><p>下面准备一个原始数据，如下面的json.txt：</p><div class="code-wrapper"><pre><code class="hljs c">&#123;    <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://www.json.org.cn&quot;</span>,    <span class="hljs-string">&quot;page&quot;</span>: <span class="hljs-number">88</span>,    <span class="hljs-string">&quot;address&quot;</span>: &#123;        <span class="hljs-string">&quot;street&quot;</span>: <span class="hljs-string">&quot;浙大路38号.&quot;</span>,        <span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;浙江杭州&quot;</span>,        <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;中国&quot;</span>    &#125;,    <span class="hljs-string">&quot;links&quot;</span>: [        &#123;            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Google&quot;</span>,            <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://www.google.com&quot;</span>        &#125;,        &#123;            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Baidu&quot;</span>,            <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>        &#125;,        &#123;            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;SoSo&quot;</span>,            <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://www.SoSo.com&quot;</span>        &#125;    ]&#125;</code></pre></div><p>解析这种JSON文件，使用要使用 <code>fopen()</code> 来打开这个文件,还要使用<code>fseek()</code>和<code>ftell()</code>来计算文件的大小，目的是用于后面的分配内存时指定大小。然后使用<code>fread()</code>将文件读入分配的内存中,接着使用<code>cJSON_Parse()</code> 将JSON数据解析为 <code>cJSON</code> 型的对象,然后就可以同上面的一样使用cJSON库中提供的各种函数API来操作这个对象了。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span> <span class="hljs-comment">//memset</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cJSON.h&quot;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> fileSize; <span class="hljs-comment">//文件大小</span><span class="hljs-type">char</span> *buf; <span class="hljs-comment">//分配内存buf</span><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, len = <span class="hljs-number">0</span>;<span class="hljs-comment">//数组长度</span>    <span class="hljs-comment">/* 打开JSON文件 */</span>     FILE *fp = fopen(<span class="hljs-string">&quot;json.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);    <span class="hljs-keyword">if</span>(fp == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-comment">/* 计算文件大小 */</span>     fseek(fp, <span class="hljs-number">0</span>, SEEK_END);<span class="hljs-comment">/* 定位文件指针到文件尾 */</span>     fileSize = ftell(fp);<span class="hljs-comment">/* 获取文件指针偏移量，即文件大小 */</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fileSize: %d Byte\r\n&quot;</span>, fileSize);fseek(fp, <span class="hljs-number">0</span>, SEEK_SET);<span class="hljs-comment">/* 再将文件指针移到文件开头 */</span>     <span class="hljs-comment">/* 根据文件大小分配内存，并读取文件到内存 */</span>     buf = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(fileSize * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, fileSize);    ret = fread(buf, fileSize, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), fp);    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)    &#123;        fclose(fp);        <span class="hljs-keyword">return</span>;    &#125;    fclose(fp);    <span class="hljs-comment">/* 把该字符串数据转成JSON数据 */</span>     cJSON *srcJsonData = cJSON_Parse(buf);    <span class="hljs-keyword">if</span>(srcJsonData == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;err\r\n&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;<span class="hljs-built_in">free</span>(buf);    <span class="hljs-comment">/* 解析JSON数据并输出显示 */</span>    <span class="hljs-comment">/*根据key值(url)获取对应的value*/</span>    cJSON *json_url = cJSON_GetObjectItem(srcJsonData, <span class="hljs-string">&quot;url&quot;</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;website: %s\r\n&quot;</span>, cJSON_Print(json_url));<span class="hljs-comment">/*根据key值(page)获取对应的value*/</span>    cJSON *json_page = cJSON_GetObjectItem(srcJsonData, <span class="hljs-string">&quot;page&quot;</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page: %d\r\n&quot;</span>, json_page-&gt;valueint);<span class="hljs-comment">/* 根据嵌套的key值(address)获取对应的value */</span>cJSON *json_address = cJSON_GetObjectItem(srcJsonData, <span class="hljs-string">&quot;address&quot;</span>);cJSON *json_street = cJSON_GetObjectItem(json_address, <span class="hljs-string">&quot;street&quot;</span>);cJSON *json_city = cJSON_GetObjectItem(json_address, <span class="hljs-string">&quot;city&quot;</span>);cJSON *json_country = cJSON_GetObjectItem(json_address, <span class="hljs-string">&quot;country&quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address-street: %s; address-city: %s; address-country: %s\r\n&quot;</span>, cJSON_Print(json_street), \      cJSON_Print(json_city), cJSON_Print(json_country));      <span class="hljs-comment">// /* 根据数组key值(links)获取对应的value */</span>    cJSON* json_links = cJSON_GetObjectItem(srcJsonData, <span class="hljs-string">&quot;links&quot;</span>);    len = cJSON_GetArraySize(json_links); <span class="hljs-comment">/* 获取该数组的大小 */</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; i++)    &#123;        <span class="hljs-comment">/* 先获取每一条信息 */</span>        cJSON *tmpValue = cJSON_GetArrayItem(json_links, i);        <span class="hljs-comment">/* 再获取每条信息中的具体内容 */</span>         cJSON *nameValue = cJSON_GetObjectItem(tmpValue,<span class="hljs-string">&quot;name&quot;</span>);cJSON *urlValue = cJSON_GetObjectItem(tmpValue,<span class="hljs-string">&quot;url&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] %s \t %s \t %s\r\n&quot;</span>, i+<span class="hljs-number">1</span>, nameValue-&gt;valuestring, urlValue-&gt;valuestring);    &#125;<span class="hljs-comment">/* 释放内存 */</span>cJSON_Delete(json_url);cJSON_Delete(json_page);cJSON_Delete(json_address);cJSON_Delete(json_street);cJSON_Delete(json_city);cJSON_Delete(json_country);cJSON_Delete(json_links);  cJSON_Delete(srcJsonData);&#125;</code></pre></div><p>运行结果：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830132151235.png" alt="" /><figcaption>image-20230830132151235</figcaption></figure><h2 id="cjson使用过程中的内存问题">cJSON使用过程中的内存问题</h2><p>cJSON在使用过程中<strong>大量的使用<code>malloc</code>从堆中分配内存的，所以用完之后，应及时释放内存 <code>(void) cJSON_Delete(cJSON *item)</code></strong>。</p><p>另外，cJSON中还可以通过 <strong>cJSON_Hooks</strong> ，自定义malloc函数和free函数。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cJSON_Hooks</span> &#123;</span>      <span class="hljs-type">void</span> *(*malloc_fn)(<span class="hljs-type">size_t</span> sz);      <span class="hljs-type">void</span> (*free_fn)(<span class="hljs-type">void</span> *ptr);&#125; cJSON_Hooks;<span class="hljs-type">void</span> <span class="hljs-title function_">cJSON_InitHooks</span><span class="hljs-params">(cJSON_Hooks* hooks)</span>&#123;    <span class="hljs-keyword">if</span> (!hooks) &#123; <span class="hljs-comment">/* Reset hooks */</span>        cJSON_malloc = <span class="hljs-built_in">malloc</span>;        cJSON_free = <span class="hljs-built_in">free</span>;        <span class="hljs-keyword">return</span>;    &#125;cJSON_malloc = (hooks-&gt;malloc_fn)?hooks-&gt;malloc_fn:<span class="hljs-built_in">malloc</span>;cJSON_free = (hooks-&gt;free_fn)?hooks-&gt;free_fn:<span class="hljs-built_in">free</span>;&#125;</code></pre></div><p>工程文件已上传Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/cjson/cjson_demo.zip">cjson_demo</a></p><p><strong>链接：</strong></p><p><strong>JSON在线工具：</strong><a href="http://www.json.org.cn/tools/JSONEditorOnline2.0/index.htm">http://www.json.org.cn/tools/JSONEditorOnline2.0/index.htm</a></p><p><a href="https://blog.csdn.net/Mculover666/article/details/103796256">https://blog.csdn.net/Mculover666/article/details/103796256</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;JSON&lt;/strong&gt; (JavaScript Object Notation) 是一种轻量级的数据交换格式。它采用完全独立于编程语言的文本格式来存储和表示数据，语法简洁、层次结构清晰，易于人阅读和编写，同时也易于机器解析和生成，有效的提升了网络传输效率</summary>
      
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JSON" scheme="http://example.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>国内开源镜像站汇总</title>
    <link href="http://example.com/2023/08/28/%E5%9B%BD%E5%86%85%E5%BC%80%E6%BA%90%E9%95%9C%E5%83%8F%E7%AB%99%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2023/08/28/%E5%9B%BD%E5%86%85%E5%BC%80%E6%BA%90%E9%95%9C%E5%83%8F%E7%AB%99%E6%B1%87%E6%80%BB/</id>
    <published>2023-08-28T14:12:31.000Z</published>
    <updated>2023-08-28T14:16:29.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="国内开源镜像站汇总">国内开源镜像站汇总</h2><h2 id="企业站点">企业站点</h2><ul><li><p>网易开源镜像站：<a href="http://mirrors.163.com/">http://mirrors.163.com/</a></p></li><li><p>搜狐开源镜像站：<a href="https://mirrors.sohu.com/">https://mirrors.sohu.com/</a></p></li><li><p>阿里云开源镜像站：<a href="https://mirrors.aliyun.com/">https://mirrors.aliyun.com/</a></p></li><li><p>腾讯软件源：<a href="https://mirrors.cloud.tencent.com/">https://mirrors.cloud.tencent.com/</a></p></li><li><p>华为开源镜像源：<a href="https://mirrors.huaweicloud.com/">https://mirrors.huaweicloud.com/</a></p></li><li><p>npmmirror 镜像站：<a href="https://npm.taobao.org/">https://npm.taobao.org/</a></p></li><li><p>开源社/Azure中国开源镜像站：<a href="https://mirror.azure.cn/">http://mirror.azure.cn/</a></p></li><li><p>中科院软件研究所开源镜像站：<a href="https://mirror.iscas.ac.cn/">https://mirror.iscas.ac.cn/</a></p></li><li><p>首都在线数据服务有限公司镜像站：<a href="http://mirrors.yun-idc.com/">http://mirrors.yun-idc.com/</a></p></li></ul><p>​</p><h2 id="高校站点">高校站点</h2><p>校园网联合镜像站：<a href="https://mirrors.cernet.edu.cn/">https://mirrors.cernet.edu.cn/</a> 本站提供对校园网镜像站的索引和跳转服务。</p><ul><li><p>OpenTUNA开源软件镜像站：<a href="https://opentuna.cn/">https://opentuna.cn/</a></p></li><li><p>清华大学开源软件镜像站：<a href="https://mirrors.tuna.tsinghua.edu.cn/">http://mirrors.tuna.tsinghua.edu.cn/</a></p></li><li><p>中国科学技术大学开源软件镜像站：<a href="https://mirrors.ustc.edu.cn/">http://mirrors.ustc.edu.cn/</a></p></li><li><p>北京大学开源镜像站：<a href="https://mirrors.pku.edu.cn/">http://mirrors.pku.edu.cn/</a></p></li><li><p>北京交通大学开源镜像站：<a href="https://mirror.bjtu.edu.cn/">https://mirror.bjtu.edu.cn/</a></p></li><li><p>北京邮电大学开源软件镜像站：<a href="https://mirrors.bupt.edu.cn/">http://mirrors.bupt.edu.cn/</a></p></li><li><p>北京外国语大学开源软件镜像站：<a href="https://mirrors.bfsu.edu.cn/">https://mirrors.bfsu.edu.cn/</a></p></li><li><p>哈尔滨工业大学开源镜像站: <a href="http://mirrors.hit.edu.cn">http://mirrors.hit.edu.cn</a></p></li><li><p>上海交通大学开源软件镜像站：<a href="https://ftp.sjtu.edu.cn/">http://ftp.sjtu.edu.cn/</a></p></li><li><p>南京大学开源镜像站：<a href="http://mirrors.nju.edu.cn/">http://mirrors.nju.edu.cn/</a></p></li><li><p>浙江大学开源软件镜像站：<a href="http://mirrors.zju.edu.cn/">http://mirrors.zju.edu.cn/</a></p></li><li><p>西安交通大学软件镜像站：<a href="https://mirrors.xjtu.edu.cn/">https://mirrors.xjtu.edu.cn/</a></p></li><li><p>兰州大学开源社区镜像站：<a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn/</a></p></li><li><p>重庆大学开源镜像站：<a href="http://mirrors.cqu.edu.cn/">http://mirrors.cqu.edu.cn/</a></p></li><li><p>吉林大学开源镜像站：<a href="https://mirrors.jlu.edu.cn/">https://mirrors.jlu.edu.cn/</a></p></li><li><p>南方科技大学开源镜像站：<a href="https://mirrors.sustech.edu.cn/">http://mirrors.sustech.edu.cn/</a></p></li><li><p>上海科技大学开源软件镜像站：<a href="https://mirrors.shanghaitech.edu.cn/">https://mirrors.shanghaitech.edu.cn/</a></p></li><li><p>东北大学开源镜像站：<a href="http://mirror.neu.edu.cn/">http://mirror.neu.edu.cn/</a></p></li><li><p>南京工业大学开源软件镜像站：<a href="https://mirrors.njtech.edu.cn/mirrors">https://mirrors.njtech.edu.cn/mirrors</a></p></li><li><p>华南农业大学开源镜像站：<a href="https://mirrors.scau.edu.cn/">https://mirrors.scau.edu.cn/</a></p></li><li><p>南阳理工学院开源软件镜像站：<a href="http://mirror.nyist.edu.cn/">http://mirror.nyist.edu.cn/</a></p></li><li><p>齐鲁工业大学开源软件镜像站：<a href="https://mirrors.qlu.edu.cn/">https://mirrors.qlu.edu.cn/</a></p></li><li><p>山东女子学院开源镜像站：<a href="http://mirrors.sdwu.edu.cn/">http://mirrors.sdwu.edu.cn/</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;国内开源镜像站汇总&quot;&gt;国内开源镜像站汇总&lt;/h2&gt;
&lt;h2 id=&quot;企业站点&quot;&gt;企业站点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;网易开源镜像站：&lt;a href=&quot;http://mirrors.163.com/&quot;&gt;http://mirrors.163.com/&lt;/</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="开源" scheme="http://example.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>结构体struct详解</title>
    <link href="http://example.com/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93struct%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93struct%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-28T03:41:37.000Z</published>
    <updated>2023-08-30T11:20:50.080Z</updated>
    
    <content type="html"><![CDATA[<p><strong>结构体(struct)</strong>是 C 编程中一种用户自定义的数据结构，它可以包含不同基本类型(char,int,float...)的数据项，在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。<strong>需要注意的是，结构体是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，会占用内存空间。</strong></p><p>在实际应用中，我们一般会使用结构体将某个对象的属性和行为进行封装声明，然后定义一个独立的整体变量进行使用。</p><h1 id="结构体的声明与定义">结构体的声明与定义</h1><p>结构体的声明和定义有多种形式：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 1.声明一个结构体然后进行定义 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">int</span> a;    <span class="hljs-type">char</span> b;    <span class="hljs-type">double</span> c;&#125;;<span class="hljs-comment">//分号不能少</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> <span class="hljs-title">t1</span>, <span class="hljs-title">t2</span>[10], *<span class="hljs-title">t3</span>;</span> <span class="hljs-comment">//定义了三个struct变量</span><span class="hljs-comment">/* 2.声明一个结构体的同时进行定义 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">int</span> a;    <span class="hljs-type">char</span> b;    <span class="hljs-type">double</span> c;&#125;t1, t2;<span class="hljs-comment">/* 3.声明一个结构体的同时进行定义,同时去掉tag标签 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><span class="hljs-class">&#123;</span>    <span class="hljs-type">int</span> a;    <span class="hljs-type">char</span> b;    <span class="hljs-type">double</span> c;&#125;t1, t2; <span class="hljs-comment">/* 4.用typedef创建新类型，比较常用 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">int</span> a;    <span class="hljs-type">char</span> b;    <span class="hljs-type">double</span> c;&#125;<span class="hljs-type">data_t</span>;<span class="hljs-type">data_t</span> t1, t2[<span class="hljs-number">10</span>], *t3; <span class="hljs-comment">//定义了三个struct变量</span></code></pre></div><h1 id="结构体变量的初始化">结构体变量的初始化</h1><p>和其它类型变量一样，对结构体变量可以在定义时指定初始值。用符号<code>&#123;&#125;</code>括起来，用逗号分隔各个数据项。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-type">int</span> a;  <span class="hljs-type">char</span> b;  <span class="hljs-type">double</span> c;&#125;;<span class="hljs-comment">//分号不能少</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> <span class="hljs-title">t1</span> =</span> &#123;  <span class="hljs-number">20</span>,  <span class="hljs-string">&quot;libs&quot;</span>,  <span class="hljs-number">890.234</span>&#125;; <span class="hljs-comment">//各个数据项要与声明时数据项一一对应</span></code></pre></div><p>在C99标准中，还支持给指定元素赋值：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> <span class="hljs-title">t1</span> =</span> &#123;  .c = <span class="hljs-number">890.234</span>  .a = <span class="hljs-number">20</span>,  .b = <span class="hljs-string">&quot;libs&quot;</span>,&#125;; <span class="hljs-comment">//各个数据项可以跟声明时数据项不对应</span></code></pre></div><h1 id="结构体成员变量的访问">结构体成员变量的访问</h1><p>如果定义的是结构体变量指针，我们需要用<code>-&gt;</code>来访问结构体的成员；如果定义的是结构体变量，我们需要用<code>.</code>来访问结构体成员。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">int</span> year;<span class="hljs-type">int</span> month;<span class="hljs-type">int</span> day;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">char</span> s_name[<span class="hljs-number">20</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span> <span class="hljs-title">birthday</span>;</span><span class="hljs-type">float</span> score;&#125;;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">stu</span> =</span> &#123; <span class="hljs-string">&quot;liuhai&quot;</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">99.5</span> &#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> *<span class="hljs-title">p_stu</span>;</span> <span class="hljs-comment">//定义一个结构体指针</span>p_stu = &amp;stu;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name=%s\n birtyday=%d.%d.%d\n score=%f\n&quot;</span>, stu.s_name, stu.birthday.year, stu.birthday.month, stu.birthday.day, stu.score);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name=%s\n birtyday=%d.%d.%d\n score=%f\n&quot;</span>, p_stu-&gt;s_name, p_stu-&gt;birthday.year, p_stu-&gt;birthday.month, p_stu-&gt;birthday.day, p_stu-&gt;score);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>运行如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830163315974.png" alt="" /><figcaption>image-20230830163315974</figcaption></figure><h1 id="函数与结构体参数">函数与结构体参数</h1><p>结构体和结构体指针都可以作为函数参数来使用。如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">school</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">char</span> s_name[<span class="hljs-number">20</span>];<span class="hljs-type">int</span> s_age;&#125;<span class="hljs-type">school_t</span>;<span class="hljs-comment">/* 结构体作为函数参数 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">print_a</span><span class="hljs-params">(<span class="hljs-type">school_t</span> sx)</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s age: %d\n&quot;</span>, sx.s_name, sx.s_age);&#125;<span class="hljs-comment">/* 结构体指针作为函数参数 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">print_b</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> school* sp)</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s age: %d\n&quot;</span>, sp-&gt;s_name, sp-&gt;s_age);&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">school</span> <span class="hljs-title">sx</span> =</span> &#123; <span class="hljs-string">&quot;wuhan&quot;</span>, <span class="hljs-number">20</span> &#125;;  print_a(sx);print_b(&amp;sx);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830180715263.png" alt="" /><figcaption>image-20230830180715263</figcaption></figure><p>在实际应用中，因为结构体作为行参在调用中是复制一份结构体实参，占用内存比较大，而结构体指针大小都一样，占用内存就不会太大，所以，使用结构体指针进行函数参数传递的方式更好一些。</p><h1 id="结构体大小的计算与对齐">结构体大小的计算与对齐</h1><p>不同的CPU架构，各种基础数据类型的大小不一样，具体如下：</p><table><thead><tr class="header"><th></th><th><strong>16位编译器</strong></th><th><strong>32位编译器</strong></th><th><strong>64位编译器</strong></th></tr></thead><tbody><tr class="odd"><td><strong>char/unsigned char</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>1</strong></td></tr><tr class="even"><td><strong>short/unsigned short</strong></td><td><strong>2</strong></td><td><strong>2</strong></td><td><strong>2</strong></td></tr><tr class="odd"><td><strong>int/unsigned int</strong></td><td><strong>2</strong></td><td><strong>4</strong></td><td><strong>4</strong></td></tr><tr class="even"><td><strong>float</strong></td><td><strong>4</strong></td><td><strong>4</strong></td><td><strong>4</strong></td></tr><tr class="odd"><td><strong>double</strong></td><td><strong>8</strong></td><td><strong>8</strong></td><td><strong>8</strong></td></tr><tr class="even"><td><strong>long</strong></td><td><strong>4</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr><tr class="odd"><td><strong>long long</strong></td><td><strong>8</strong></td><td><strong>8</strong></td><td><strong>8</strong></td></tr><tr class="even"><td><strong>long double</strong></td><td><strong>8</strong></td><td><strong>12</strong></td><td><strong>16</strong></td></tr><tr class="odd"><td><strong>pointer(*)</strong></td><td><strong>2</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr></tbody></table><p>可使用 <code>sizeof()</code> 运算符进行计算，如下在64位CPU架构下的各个数据类型大小：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830165411454.png" alt="" /><figcaption>image-20230830165411454</figcaption></figure><p>关于结构体大小的计算，需要把握三个规则：</p><ul><li><p><strong>结构体变量的首地址，必须是结构体变量的“最大基本数据类型成员所占字节数”的整数倍；</strong></p></li><li><p><strong>结构体变量中的每个成员相对于结构体首地址的偏移量，都是该成员基本数据类型所占字节数的整数倍；</strong></p></li><li><p><strong>结构体变量的总大小，为结构体变量中“最大基本数据类型成员所占字节”的整数倍；</strong></p></li></ul><p>CPU并非逐字节读写内存，而是以2,4,或8的倍数的字节块来读写内存，因此会对基本数据类型的地址进行字节对齐排列。程序中预处理指令 <code># pragma pack(n)</code> 可以改变默认对齐数。n取值有 <strong>1,2,4,8,16 </strong>。</p><p>举例如下：</p><p><strong>32位系统</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830191705893.png" alt="" /><figcaption>image-20230830191705893</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/640.png" alt="" /><figcaption>图片</figcaption></figure><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830185815016.png" alt="image-20230830185815016" style="zoom:80%;" /></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/640-16933926647246.png" alt="" /><figcaption>图片</figcaption></figure><p>从上图可以看出S0占用6字节，S2占用内存8字节，S3占用内存12字节，SU2占用内存32字节，SS1占用内存12字节，SS2占用内存6字节。使用 <code>sizeof()</code> 运算符计算，得到的结果与上一致。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830191935476.png" alt="" /><figcaption>image-20230830191935476</figcaption></figure><p><strong>参考：</strong></p><p><a href="https://huaweicloud.csdn.net/63a5662fb878a54545946303.html?spm=1001.2101.3001.6650.18&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-18-124280883-blog-127088224.235%5Ev38%5Epc_relevant_sort&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-18-124280883-blog-127088224.235%5Ev38%5Epc_relevant_sort&amp;utm_relevant_index=26#3.1%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE">C语言——结构体</a></p><p>https://mp.weixin.qq.com/s/VaIx5KjwqfQeLSlbcjywkQ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;结构体(struct)&lt;/strong&gt;是 C 编程中一种用户自定义的数据结构，它可以包含不同基本类型(char,int,float...)的数据项，在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。&lt;strong&gt;需要注意的是，结构体是创建变量</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="struct" scheme="http://example.com/tags/struct/"/>
    
  </entry>
  
  <entry>
    <title>共用体union详解</title>
    <link href="http://example.com/2023/08/28/%E5%85%B1%E7%94%A8%E4%BD%93union%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/28/%E5%85%B1%E7%94%A8%E4%BD%93union%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-28T03:41:03.000Z</published>
    <updated>2023-09-19T00:07:54.866Z</updated>
    
    <content type="html"><![CDATA[<p><strong>共用体（union）</strong>，也叫 <strong>联合体</strong>，是C语言中一种常用的构造复合数据结构，这种类型定义的变量也包含一系列成员，<strong>这些成员共用同一块内存空间，所以在同一时间，只能使用一个共用体成员。</strong></p><h2 id="共用体的定义">共用体的定义</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">/* 创建共用体模板，然后定义变量 */</span><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">stu</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-type">int</span> age;  <span class="hljs-type">char</span> name;&#125;;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">stu</span> <span class="hljs-title">ua</span>;</span><span class="hljs-comment">// 使用该共用体模板创建变量a</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;ua      :%p\n&quot;</span>, &amp;ua);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;ua.age  :%p\n&quot;</span>, &amp;(ua.age));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;ua.name :%p\n&quot;</span>, &amp;(ua.name));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230828150049478.png" alt="" /><figcaption>image-20230828150049478</figcaption></figure><p>可以看到：它们共用同一个内存空间。</p><h2 id="共用体的内存大小计算">共用体的内存大小计算</h2><p>一般情况下，一个共用体变量的大小以成员变量中占用内存空间最大的成员来确定。但占用最大空间的成员没有字节对齐，则需要按照字节对齐处理的方式来计算。</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Un</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">short</span> c[<span class="hljs-number">5</span>];<span class="hljs-comment">//1个short类型占2字节，5个占10字节</span><span class="hljs-type">int</span> i;<span class="hljs-comment">//4字节</span>&#125;;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">union</span> Un));<span class="hljs-comment">//打印12</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="共用体的应用">共用体的应用</h2><h4 id="检测当前处理器大小端模式">1.检测当前处理器大小端模式</h4><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Un</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">char</span> c;<span class="hljs-type">int</span> i;&#125;u;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;u.i = <span class="hljs-number">1</span>; <span class="hljs-comment">//0x 00 00 00 01</span><span class="hljs-keyword">if</span> (u.c == <span class="hljs-number">1</span>)<span class="hljs-comment">//01 00 00 00 小端存储 低位放低地址</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Little Endian\n&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-comment">//00 00 00 01 大端存储 低位放高地址</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Big Endian\n&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="浮点型转换与4字节整型之间转换">2.浮点型转换与4字节整型之间转换</h3><p>当我们使用串口传输浮点型数据时，常用的方法是将浮点数乘以一个倍数，变成整形数，然后进行字节传输。其实，使用共用体可以直接将浮点数据转换为4个单字节，然后就可以传输了，同理，也可以把4个单字节数转换为浮点型数。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-type">float</span> fdata;        <span class="hljs-comment">//fdata和dat共用存储空间</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> dat[<span class="hljs-number">4</span>];&#125; <span class="hljs-type">float_int_t</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;  <span class="hljs-type">float</span> f=<span class="hljs-number">123.567</span>;    <span class="hljs-comment">//要转换的浮点数</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> byte[<span class="hljs-number">4</span>]= &#123;<span class="hljs-number">0x4e</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0xf7</span>, <span class="hljs-number">0x42</span>&#125;; <span class="hljs-comment">//4个字节数据存放的数组</span>  <span class="hljs-type">float_int_t</span> fi;  <span class="hljs-meta">#<span class="hljs-keyword">if</span> 1  </span>  fi.fdata = f;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原始浮点数: %f\n&quot;</span>,fi.fdata);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;浮点数转Byte: %#x %#x %#x %#x \n&quot;</span>, fi.dat[<span class="hljs-number">0</span>], fi.dat[<span class="hljs-number">1</span>], fi.dat[<span class="hljs-number">2</span>], fi.dat[<span class="hljs-number">3</span>]);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>  fi.dat[<span class="hljs-number">0</span>] = byte[<span class="hljs-number">0</span>];  fi.dat[<span class="hljs-number">1</span>] = byte[<span class="hljs-number">1</span>];  fi.dat[<span class="hljs-number">2</span>] = byte[<span class="hljs-number">2</span>];  fi.dat[<span class="hljs-number">3</span>] = byte[<span class="hljs-number">3</span>];  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Byte转浮点数: %f\n&quot;</span>,fi.fdata);     <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230828172122333.png" alt="image-20230828172122333" /> <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230828172218764.png" alt="image-20230828172218764" /></p><p>可以看到，它们之间相互转换是OK的，因为float类型在计算机中的存储位数和方式会导致精度的偏差，一般的偏差都很小，double的精度更高一些。</p><p>参考链接：</p><p>https://blog.csdn.net/m0_57180439/article/details/120417270</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;共用体（union）&lt;/strong&gt;，也叫 &lt;strong&gt;联合体&lt;/strong&gt;，是C语言中一种常用的构造复合数据结构，这种类型定义的变量也包含一系列成员，&lt;strong&gt;这些成员共用同一块内存空间，所以在同一时间，只能使用一个共用体成员。&lt;/stro</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="union" scheme="http://example.com/tags/union/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法</title>
    <link href="http://example.com/2023/08/26/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/08/26/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-08-26T14:31:43.000Z</published>
    <updated>2023-08-28T03:37:53.355Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法是《数据结构与算法》中最基本的算法之一，常见的共有十种：</p><ol type="1"><li><a href="http://www.codebaoku.com/algorithm-sort/bubble-sort.html">冒泡排序（Bubble Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/selection-sort.html">选择排序（Selection Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/insertion-sort.html">插入排序（Insertion Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/shell-sort.html">希尔排序（Shell Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/merge-sort.html">归并排序（Merge Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/quick-sort.html">快速排序（Quick Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/heap-sort.html">堆排序（Heap Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/counting-sort.html">计数排序（Counting Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/bucket-sort.html">桶排序（Bucket Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/radix-sort.html">基数排序（Radix Sort）</a></li></ol><p>其中，前面七种属于比较排序，即通过比较来决定元素的相对次序。后面三种则属于非比较排序。</p><p>这十种排序方式的复杂度如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230827112203238.png" alt="" /><figcaption>image-20230827112203238</figcaption></figure><p>下面分别来看看这十种排序方式：</p><h2 id="冒泡排序bubble-sort">冒泡排序（Bubble Sort）</h2><p>冒泡排序的基本思想是，从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻元素大小比较进行交换，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9a152a7e13500cf688efd8e5297f9f6e.gif" alt="" /><figcaption>冒泡排序的动图演示</figcaption></figure><p>在数据完全有序的时候展现出最优时间复杂度，为O(n)。其他情况下，几乎总是O( n2 )。因此，算法在数据基本有序的情况下，性能最好。 要使算法在最佳情况下有O(n)复杂度，需要做一些改进，增加一个<code>swap</code>的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> i, j, temp;    <span class="hljs-type">bool</span> swap;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)    &#123;        swap = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)        &#123;            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])             &#123;                temp = arr[j];                arr[j] = arr[j + <span class="hljs-number">1</span>];                arr[j + <span class="hljs-number">1</span>] = temp;                swap = <span class="hljs-literal">true</span>;            &#125;                    &#125;         <span class="hljs-keyword">if</span>(swap == <span class="hljs-literal">false</span>) <span class="hljs-comment">//有序</span>            <span class="hljs-keyword">break</span>;    &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">22</span>, <span class="hljs-number">34</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">82</span>, <span class="hljs-number">55</span>, <span class="hljs-number">89</span>, <span class="hljs-number">50</span>, <span class="hljs-number">37</span>, <span class="hljs-number">5</span>, <span class="hljs-number">64</span>, <span class="hljs-number">35</span>, <span class="hljs-number">9</span>, <span class="hljs-number">70</span> &#125;;    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);    bubble_sort(arr, len);    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高,基本为O(n2)，在数据量大的时候不适合使用。</p><h2 id="选择排序selection-sort">选择排序（Selection Sort）</h2><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p><p>它的排序思想是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/c7322fccb46e3cc0ea3c107781d1e880.gif" alt="" /><figcaption>选择排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span> <span class="hljs-comment">//交互两个变量</span>&#123;    <span class="hljs-type">int</span> temp = *a;    *a = *b;    *b = temp;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">selection_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>&#123;    <span class="hljs-type">int</span> i,j;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; len - <span class="hljs-number">1</span> ; i++)    &#123;<span class="hljs-type">int</span> min = i;<span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; len; j++) <span class="hljs-comment">//遍历未排序的元素</span>        &#123;    <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min])    <span class="hljs-comment">//找到目前最小值</span>        min = j;      <span class="hljs-comment">//记录最小值序号            </span>        &#125;swap(&amp;arr[min], &amp;arr[i]);     <span class="hljs-comment">//做交換</span>     &#125;&#125;</code></pre></div><p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。</p><h2 id="插入排序insertion-sort">插入排序（Insertion Sort）</h2><p>插入排序的基本方法是：从待排序的n个元素中的第二个元素开始，依次与前面的元素比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6d867acd56e40fb32975f9e91d041fa9.gif" alt="" /><figcaption>插入排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertion_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>&#123;    <span class="hljs-type">int</span> i,j,key;    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;len;i++)    &#123;        key = arr[i];        j=i<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>((j&gt;=<span class="hljs-number">0</span>) &amp;&amp; (arr[j]&gt;key))         &#123;            arr[j+<span class="hljs-number">1</span>] = arr[j];            j--;        &#125;        arr[j+<span class="hljs-number">1</span>] = key;    &#125;&#125;</code></pre></div><p>插入排序由于O( n2 )的复杂度，在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。</p><h2 id="希尔排序shell-sort">希尔排序（Shell Sort）</h2><p>希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p>希尔排序基本思想是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/e250b339f4595451ca75ba3b83c83704.gif" alt="" /><figcaption>十大经典排序算法动画与解析，看我就够了！（配代码完全版）</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> gap, i, j;    <span class="hljs-type">int</span> temp;        <span class="hljs-keyword">for</span> (gap = len &gt;&gt; <span class="hljs-number">1</span>; gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>)    &#123;    <span class="hljs-keyword">for</span> (i = gap; i &lt; len; i++)         &#123;            temp = arr[i];            <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)            &#123;                arr[j + gap] = arr[j];            &#125;            arr[j + gap] = temp;    &#125;            &#125;&#125;</code></pre></div><p>Shell排序虽然快，但是毕竟是插入排序，其数量级并没有后起之秀--快速排序O(n㏒n)快。在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。</p><h2 id="归并排序merge-sort">归并排序（Merge Sort）</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p>它的基本思路是：</p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2f9f62d486be19b87a3f37f13eb75786.gif" alt="" /><figcaption>归并排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;    <span class="hljs-keyword">return</span> x &lt; y ? x : y;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> *a = arr;    <span class="hljs-type">int</span> *b = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));    <span class="hljs-type">int</span> seg, start;        <span class="hljs-keyword">for</span> (seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg)     &#123;        <span class="hljs-keyword">for</span> (start = <span class="hljs-number">0</span>; start &lt; len; start += seg * <span class="hljs-number">2</span>)         &#123;            <span class="hljs-type">int</span> low = start, mid = min(start + seg, len), high = min(start + seg * <span class="hljs-number">2</span>, len);            <span class="hljs-type">int</span> k = low;            <span class="hljs-type">int</span> start1 = low, end1 = mid;            <span class="hljs-type">int</span> start2 = mid, end2 = high;                        <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            <span class="hljs-keyword">while</span> (start1 &lt; end1)                b[k++] = a[start1++];            <span class="hljs-keyword">while</span> (start2 &lt; end2)                b[k++] = a[start2++];        &#125;        <span class="hljs-type">int</span> *temp = a;        a = b;        b = temp;    &#125;    <span class="hljs-keyword">if</span> (a != arr)     &#123;        <span class="hljs-type">int</span> i;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        &#123;            b[i] = a[i];                    &#125;        b = a;    &#125;    <span class="hljs-built_in">free</span>(b);&#125;</code></pre></div><p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。</p><h2 id="快速排序quick-sort">快速排序（Quick Sort）</h2><p>冒泡排序总的比较与移动次数较多，快速排序又称分区交换排序，是对冒泡排序的改进，快速排序采用的思想是分治思想。</p><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/eaca66d26efe27519e8c462d3a7d4593.gif" alt="" /><figcaption>快速排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//a：待排序数组，low：最低位的下标，high：最高位的下标</span><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span>&#123;    <span class="hljs-keyword">if</span>(low&gt;=high)    &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">int</span> left=low;    <span class="hljs-type">int</span> right=high;    <span class="hljs-type">int</span> key=a[left];    <span class="hljs-comment">/*用数组的第一个记录作为分区元素*/</span>    <span class="hljs-keyword">while</span>(left!=right)    &#123;        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[right]&gt;=key)    <span class="hljs-comment">/*从右向左扫描，找第一个码值小于key的记录，并交换到key*/</span>            --right;        a[left]=a[right];        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[left]&lt;=key)            ++left;        a[right]=a[left];    <span class="hljs-comment">/*从左向右扫描，找第一个码值大于key的记录，并交换到右边*/</span>    &#125;    a[left]=key;    <span class="hljs-comment">/*分区元素放到正确位置*/</span>    quickSort(a,low,left<span class="hljs-number">-1</span>);    quickSort(a,left+<span class="hljs-number">1</span>,high);&#125;</code></pre></div><p>快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。</p><h2 id="堆排序heap-sort">堆排序（Heap Sort）</h2><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序原理就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</p><figure><img src="https://ask.qcloudimg.com/http-save/yehe-8223537/2c40662fc38e7e7ba7882786f1ee19e2.gif" alt="" /><figcaption>十大经典排序算法动画与解析，看我就够了！（配代码完全版）</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> &#123;    <span class="hljs-type">int</span> temp = *b;    *b = *a;    *a = temp;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;    <span class="hljs-comment">// 建立父節點指標和子節點指標</span>    <span class="hljs-type">int</span> dad = start;    <span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (son &lt;= end)     &#123; <span class="hljs-comment">// 若子節點指標在範圍內才做比較</span>        <span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 先比較兩個子節點大小，選擇最大的</span>            son++;        <span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">//如果父節點大於子節點代表調整完畢，直接跳出函數</span>            <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">else</span>         &#123; <span class="hljs-comment">// 否則交換父子內容再繼續子節點和孫節點比較</span>            swap(&amp;arr[dad], &amp;arr[son]);            dad = son;            son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        &#125;    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> i;    <span class="hljs-comment">// 初始化，i從最後一個父節點開始調整</span>    <span class="hljs-keyword">for</span> (i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)        max_heapify(arr, i, len - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢</span>    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);        max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, \                 <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);    heap_sort(arr, len);    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p><hr /><h2 id="计数排序counting-sort">计数排序（Counting Sort）</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>它的基本方法是：</p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/25fdb31acd81f931cd443cb932140ab9.gif" alt="" /><figcaption>冒泡排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">print_arr</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-type">int</span> i;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, arr[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">counting_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *ini_arr, <span class="hljs-type">int</span> *sorted_arr, <span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-type">int</span> *count_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100</span>);    <span class="hljs-type">int</span> i, j, k;    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">100</span>; k++)        count_arr[k] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)        count_arr[ini_arr[i]]++;    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">100</span>; k++)        count_arr[k] += count_arr[k - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (j = n; j &gt; <span class="hljs-number">0</span>; j--)        sorted_arr[--count_arr[ini_arr[j - <span class="hljs-number">1</span>]]] = ini_arr[j - <span class="hljs-number">1</span>];    <span class="hljs-built_in">free</span>(count_arr);&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> i;    <span class="hljs-type">int</span> *arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * n);    <span class="hljs-type">int</span> *sorted_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * n);    srand(time(<span class="hljs-number">0</span>));    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)        arr[i] = rand() % <span class="hljs-number">100</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ini_array: &quot;</span>);    print_arr(arr, n);    counting_sort(arr, sorted_arr, n);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sorted_array: &quot;</span>);    print_arr(sorted_arr, n);    <span class="hljs-built_in">free</span>(arr);    <span class="hljs-built_in">free</span>(sorted_arr);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>排序目标要能够映射到整数域，其最大值最小值应当容易辨别。例如高中生考试的总分数，显然用0-750就OK啦；又比如一群人的年龄，用个0-150应该就可以了，再不济就用0-200喽。另外，计数排序需要占用大量空间，它比较适用于数据比较集中的情况。</p><h2 id="桶排序bucket-sort">桶排序（Bucket Sort）</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9095a2947d144f4b960369dbc1d259d7.gif" alt="" /><figcaption>img</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 使用桶排序法对数列 [5，2，30，98，20，1，45，80] 从小到大排序 */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> m[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">30</span>,<span class="hljs-number">98</span>,<span class="hljs-number">20</span>,<span class="hljs-number">1</span>,<span class="hljs-number">45</span>,<span class="hljs-number">80</span>&#125;;    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组a存放[1,10]的数,将数组a赋值为零*/</span>    <span class="hljs-type">int</span> b[<span class="hljs-number">40</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组b存放[11,50]的数,将数组b赋值为零*/</span>    <span class="hljs-type">int</span> c[<span class="hljs-number">50</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组c存放[51,100]的数,将数组c赋值为零*/</span>    <span class="hljs-type">int</span> i;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)    &#123;        <span class="hljs-comment">/* 定义三个桶 */</span>        <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">0</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">11</span>))             a[m[i]<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;               <span class="hljs-comment">/*假如i=0,那么m[i]=5;将5放在数组a的第5个位置，即a[4]中,所以是a[m[i]-1] */</span>        <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">10</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">51</span>))             b[m[i]<span class="hljs-number">-10</span><span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;           <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">51</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">101</span>))             c[m[i]<span class="hljs-number">-50</span><span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;        &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)                         <span class="hljs-comment">/*输出数组a的结果*/</span>      <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)                         <span class="hljs-comment">/*输出数组b的结果*/</span>      <span class="hljs-keyword">if</span>(b[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">11</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">50</span>;i++)                         <span class="hljs-comment">/*输出数组c的结果*/</span>      <span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">51</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;</code></pre></div><p>桶排序可用于最大最小值相差较大的数据情况，但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。</p><h2 id="基数排序radix-sort">基数排序（Radix Sort）</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/88cb17eb223c8838182dcaff3dfcde17.gif" alt="" /><figcaption>基数排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 20</span><span class="hljs-comment">//#define SHOWPASS</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> BASE 10</span><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-type">int</span> i;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)   &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, a[i]);  &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">radixsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-type">int</span> i, b[MAX], m = a[<span class="hljs-number">0</span>], <span class="hljs-built_in">exp</span> = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)   &#123;    <span class="hljs-keyword">if</span> (a[i] &gt; m)       m = a[i];  &#125;  <span class="hljs-keyword">while</span> (m / <span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">0</span>)   &#123;    <span class="hljs-type">int</span> bucket[BASE] = &#123; <span class="hljs-number">0</span> &#125;;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)     &#123;      bucket[(a[i] / <span class="hljs-built_in">exp</span>) % BASE]++;    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; BASE; i++)     &#123;      bucket[i] += bucket[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)     &#123;      b[--bucket[(a[i] / <span class="hljs-built_in">exp</span>) % BASE]] = a[i];    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)     &#123;      a[i] = b[i];    &#125;    <span class="hljs-built_in">exp</span> *= BASE;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SHOWPASS</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nPASS   : &quot;</span>);    print(a, n);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>  &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <span class="hljs-type">int</span> arr[MAX];  <span class="hljs-type">int</span> i, n;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter total elements (n &lt;= %d) : &quot;</span>, MAX);  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  n = n &lt; MAX ? n : MAX;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter %d Elements : &quot;</span>, n);  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)   &#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);  &#125;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nARRAY  : &quot;</span>);  print(&amp;arr[<span class="hljs-number">0</span>], n);  radixsort(&amp;arr[<span class="hljs-number">0</span>], n);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nSORTED : &quot;</span>);  print(&amp;arr[<span class="hljs-number">0</span>], n);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>基数排序要求较高，元素必须是整数，整数时长度10W以上，最大值100W以下效率较好，但是基数排序比其他排序好在可以适用字符串，或者其他需要根据多个条件进行排序的场景，例如日期，先排序日，再排序月，最后排序年 ，其它排序算法可是做不了的。</p><p>参考链接：</p><p>https://zhuanlan.zhihu.com/p/42586566</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;排序算法是《数据结构与算法》中最基本的算法之一，常见的共有十种：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codebaoku.com/algorithm-sort/bubble-sort.html&quot;&gt;冒泡排序（Bubble S</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>常见的开发概念及开源资源</title>
    <link href="http://example.com/2023/08/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E5%8F%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BC%80%E6%BA%90%E8%B5%84%E6%BA%90/"/>
    <id>http://example.com/2023/08/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E5%8F%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BC%80%E6%BA%90%E8%B5%84%E6%BA%90/</id>
    <published>2023-08-20T04:09:58.000Z</published>
    <updated>2023-09-08T02:54:59.599Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/gnu-100-b98545.png"><p align="center"><b style="font-size:25px">GNU</b></p></p><p>GNU是一个开源组织，同时也是一个100%自由软件的操作系统，包含了所有的官方GNU软件包，也包括非GNU自由软件。</p><p>官网：<a href="https://www.gnu.org/">https://www.gnu.org/</a></p><ul><li><p><strong>GCC/G++</strong>：GNU工具链中的编译器。</p></li><li><p><strong><a href="https://www.gnu.org/software/make/">Make</a></strong>：GNU工具链中的构建生成器，搭配makefile文件使用。</p></li><li><p><strong><a href="https://www.sourceware.org/gdb/">GDB（GNU Debuger）</a></strong>：GNU 开源组织发布的一个强大的UNIX 下的程序调试工具。</p></li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6ac65d24163b5b6e0.jpeg"><p align="center"><b style="font-size:25px">LLVM</b></p></p><p>LLVM是编译器和工具链技术的集合。</p><p>官网： <a href="https://clang.llvm.org/">https://clang.llvm.org/</a></p><p><strong>clang/clang++</strong> ：LLVM工具链中C/C++/Objective-C 编译器。</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/weq.png"><p align="center"><b style="font-size:25px">Cygwin</b></p></p><p>Cygwin是GNU编译器和大量开源工具的集合，能够在Windows系统上提供类似于Linux系统的功能。它提供了大量的POSIX API功能。</p><p>官网：<a href="https://www.cygwin.com/index.html">https://www.cygwin.com/index.html</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/%EF%BC%ADinGW-w64-long.png"><p align="center"><b style="font-size:25px">MinGw</b></p></p><p>MinGW(Minimalist GNU for Windows)是一个开源的基于GNU的编译器套件，允许你在Windows平台生成本地的Windows程序而不需要系统运行库(C Runtime library，静态库lib或动态库dll)。</p><p>官网：<a href="https://www.mingw-w64.org/">https://www.mingw-w64.org/</a></p><p><a href="https://zhuanlan.zhihu.com/p/76613134?utm_source=QQ_article_bottom">MinGW-w64安装教程——著名C/C++编译器GCC的Windows版本</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/RE1Mu3b.png"><p align="center"><b style="font-size:25px">MSVC</b></p></p><p>MSVC(Microsoft Visual C/C++)是微软公司开发的Windows下编译器工具链，已经集成到Microsoft Visual Studio环境中。</p><p>官网：<a href="https://learn.microsoft.com/zh-cn/cpp/build/projects-and-build-systems-cpp?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/build/projects-and-build-systems-cpp?view=msvc-170</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/Cmake-logo-header.png"><p align="center"><b style="font-size:25px">CMake</b></p></p><p>CMake(Cross platform make)是比Make更高一层的工具,搭配CmakeList.txt文件，产生标准的建构档，再依一般的建构方式进行项目构建。</p><p>官网：<a href="https://cmake.org/">https://cmake.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/Qt-logo-neon-small.png" alt="img" style="zoom:33%;" /><p align="center"><b style="font-size:25px">qmake</b></p></p><p>qmake 是QT工程的项目构建生成器。</p><p>官网：<a href="https://www.qt.io/product/development-tools">https://www.qt.io/product/development-tools</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825103236069.png"><p align="center"><b style="font-size:25px">QCustomPlot</b></p></p><p>QCustomPlot 是用于Qt中绘图和数据可视化的一个开源C++库。该绘图库专注于制作精美、可打印的高质量2D图形表，并在应用程序内显示实时数据。</p><p>官网：<a href="https://www.qcustomplot.com/">https://www.qcustomplot.com/</a></p><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/SCons-Bricks.png"><p align="center"><b style="font-size:25px">SCons</b></p></p><p>SCons 是项目构建工具，使用 SConstruct 和 SConscript 文件来替代复杂规则的makefile文件，像RT-thread系统构建中有使用。</p><p>官网：<a href="https://www.scons.org/">https://www.scons.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/tux.png"><p align="center"><b style="font-size:25px">Linux</b></p></p><ul><li><p><strong>Linux Kernel</strong> ：Linux内核 ，Linux系统核心。</p><p>官网：<a href="https://kernel.org/">https://kernel.org/</a></p></li><li><p><strong>U-Boot</strong>：Linux系统启动引导代码。全称 Universal Boot Loader。</p><p>官网：<a href="https://u-boot.readthedocs.io/en/latest/">https://u-boot.readthedocs.io/en/latest/</a></p><p>源码网址：</p><ul><li><a href="https://source.denx.de/u-boot/u-boot">https://source.denx.de/u-boot/u-boot</a></li><li><a href="https://ftp.denx.de/pub/u-boot/">https://ftp.denx.de/pub/u-boot/</a> （或 <a href="ftp://ftp.denx.de/pub/u-boot/">ftp://ftp.denx.de/pub/u-boot/</a>）</li></ul></li><li><p><strong>BusyBox</strong>：BusyBox 是一个集成了众多最常用 linux 命令和工具的精简工具箱。它提供了一个比较完善的环境，可用于构建轻量级的根文件系统。</p><p>官网：<a href="https://busybox.net/">https://busybox.net/</a></p><p><a href="http://www.taodudu.cc/news/show-318004.html?action=onClick">busybox详解</a></p></li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818231609048.png" alt="image-20230818231609048" style="zoom:50%;" /><p align="center"><b style="font-size:25px">OpenOCD</b></p></p><p><strong>OpenOCD(Open On-Chip Debugger)</strong>是一个开源片上调试器，用于嵌入式系统的开发和调试。</p><p>官网：<a href="https://www.openocd.org/">https://www.openocd.org/</a></p><p>下载地址：<a href="https://sourceforge.net/projects/openocd/files/">https://sourceforge.net/projects/openocd/files/</a></p><p>Windows下openocd：<a href="https://gnutoolchains.com/arm-eabi/openocd/">https://gnutoolchains.com/arm-eabi/openocd/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818232211015.png" alt="image-20230818232211015" style="zoom:67%;" /><p align="center"><b style="font-size:25px">FatFs</b></p></p><p>FatFs 是用于小型嵌入式系统的通用 FAT/exFAT 文件系统开源项目。</p><p>官网：<a href="http://elm-chan.org/fsw/ff/00index_e.html">http://elm-chan.org/fsw/ff/00index_e.html</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/floating.png" alt="Back to Savannah Homepage" style="zoom:80%;" /><p align="center"><b style="font-size:25px">lwIP</b></p></p><p><strong>lwIP(light weight IP)</strong>是一个开源的小型轻量级的 TCP/IP 协议栈。</p><p>官网：<a href="http://savannah.nongnu.org/projects/lwip/">http://savannah.nongnu.org/projects/lwip/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/logo_lvgl.png" alt="logo" style="zoom: 67%;" /><p align="center"><b style="font-size:25px">LVGL</b></p></p><p><strong>LVGL(Light and Versatile Graphics Library )</strong>,是一个开源的轻量级嵌入式图形库，可为任何 MCU、MPU 和显示类型创建漂亮的 UI。</p><p>官网：<a href="https://lvgl.io/">https://lvgl.io/</a></p><p>源码：<a href="https://github.com/lvgl/lvgl/releases">https://github.com/lvgl/lvgl/releases</a></p><p>百问网LVGL：<a href="http://lvgl.100ask.net/8.2/index.html">http://lvgl.100ask.net/8.2/index.html</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230819001230032.png"><p align="center"><b style="font-size:25px">MQTT</b></p></p><p>MQTT(Message Queuing Telemetry Transport,消息队列遥测传输协议)是一种基于发布/订阅(PUBLISH/SUBSCRIBE)模式的轻量级的物联网通信协议。</p><p>官网：<a href="https://mqtt.org/">https://mqtt.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/logo.png"><p align="center"><b style="font-size:25px">OpenCV</b></p></p><p>OpenCV是一个开源跨平台的计算机视觉库，被用于各种各样的计算机视觉应用程序中，包括人脸检测、目标识别、图像分割、机器人视觉、运动跟踪、手势识别等。OpenCV提供了许多用于图像处理和计算机视觉的功能，包括图像滤波、特征检测、特征匹配、图像分割、摄像机校准、三维重建等。它还提供了C++、Python和Java等编程语言的接口，方便用户在各种平台上进行开发。</p><p>官网：<a href="https://opencv.org/">https://opencv.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230821084024530.png"><p align="center"><b style="font-size:25px">CMSIS</b></p></p><p><strong>CMSIS(Common Microcontroller Software Interface Standard)</strong> : ARM Cortex™通用微控制器软件接口标准，由ARM公司跟芯片软件厂商共同提出的，开源。它提供了一种内核与外设、实时操作系统和中间件接口的通用方法。参考：<a href="https://blog.csdn.net/m0_54929728/article/details/128695058?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-128695058-blog-126438165.235%5Ev38%5Epc_relevant_sort&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-128695058-blog-126438165.235%5Ev38%5Epc_relevant_sort&amp;utm_relevant_index=11">CMSIS到底是个什么东西</a></p><p>官网：<a href="https://www.arm.com/technologies/cmsis">https://www.arm.com/technologies/cmsis</a></p><p>CMSIS资源包含：</p><ul><li><a href="http://arm-software.github.io/CMSIS_5/RTOS2/html/index.html">CMSIS-RTOS</a> ：一个 API，能够使中间件和库组件实现一致的软件层</li><li><a href="http://arm-software.github.io/CMSIS_5/DSP/html/index.html">CMSIS-DSP</a> ：DSP库是Arm针对各种Cortex-M处理器内核优化的DSP功能的丰富集合</li><li><a href="http://arm-software.github.io/CMSIS_5/Driver/html/index.html">CMSIS-Driver</a>：CMSIS驱动程序接口可用于许多微控制器系列</li><li><a href="http://arm-software.github.io/CMSIS_5/Pack/html/index.html">CMSIS-Pack</a>：定义了包含软件组件的软件包结构</li><li><a href="http://arm-software.github.io/CMSIS_5/SVD/html/index.html">CMSIS-SVD</a>：该文件允许查看具有当前寄存器状态的设备外设的详细视图</li><li><a href="http://arm-software.github.io/CMSIS_5/DAP/html/index.html">CMSIS-DAP</a>：它是 Cortex 调试访问端口（DAP）的标准化接口</li><li><a href="http://arm-software.github.io/CMSIS_5/NN/html/index.html">CMSIS-NN</a>：这是高效神经网络内核的集合</li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/logo_new.jpg"><p align="center"><b style="font-size:25px">Modbus</b></p></p><p><strong>Modbus</strong>是一种免费的用于工业现场的总线协议，是Modicon公司（现在的施耐德电气 Schneider Electric）于1979年为使用可编程逻辑控制器（PLC）通信而开发的。现在已成为工业领域通信协议的业界标准，有了它，不同厂商生产的控制设备可以连成工业聚群，进行集中监控。Modbus协议目前存在用于串口、以太网以及其他支持互联网协议网络的版本。</p><p>值得注意的是2020年7月，Modbus组织委员会发布通知，设备间通信过程中使用 <strong>客户端-服务器端(Client-Server)</strong> 替换之前协议里的 <strong>主设备-从设备(Master-Slave)</strong> 的描述。</p><p>官网：<a href="https://modbus.org/">https://modbus.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230823133444089.png"><p align="center"><b style="font-size:25px">MIPI Alliance</b></p></p><p><strong>MIPI(Mobile Industry Processor Interface)移动行业处理器接口</strong>，MIPI联盟是一个全球协作组织，制定和推进移动设备接口技术标准，提供一个世界性，全面性的接口规范生态系统，有效地互连各种移动组件和受移动影响的设备。这些规范标准涵盖了设备所需的所有接口应用，包括调制解调器、应用处理器、相机、显示器、音频、存储、天线、调谐器、功率放大器、滤波器、开关、电池等的接口。</p><p>官网：<a href="https://www.mipi.org/">https://www.mipi.org/</a></p><p>MIPI联盟各接口规格及开发工作组主要有（非MIPI联盟成员只能查看接口公开版规格书）：</p><ul><li><strong>Audio</strong><ul><li><a href="https://www.mipi.org/groups/audio"><strong>Audio Working Group</strong></a></li></ul></li><li><strong>Camera &amp; Imaging</strong><ul><li><strong><a href="https://www.mipi.org/groups/camera">Camera Working Group</a></strong></li></ul></li><li><strong>Chip-to-chip/IPC</strong><ul><li><strong><a href="https://www.mipi.org/groups/unipro-working-group">UniPro Working Group</a></strong></li></ul></li><li><strong>Control &amp; Data</strong><ul><li><strong><a href="https://www.mipi.org/groups/i3c">I3C Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/rf-front-end">RF Front-End Control Working Group</a></strong></li></ul></li><li><strong>Debug &amp; Trace</strong><ul><li><strong><a href="https://www.mipi.org/groups/debug">Debug Working Group</a></strong></li></ul></li><li><strong>Display &amp; Touch</strong><ul><li><strong><a href="https://www.mipi.org/groups/display">Display Working Group</a></strong></li></ul></li><li><strong>Physical Layers</strong><ul><li><strong><a href="https://www.mipi.org/groups/phy">PHY Steering Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/a-phy">A-PHY Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/c-phy">C-PHY Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/d-phy">D-PHY Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/m-phy">M-PHY Working Group</a></strong></li></ul></li><li><strong>Software Integration</strong><ul><li><strong><a href="https://www.mipi.org/groups/software">Software Working Group</a></strong></li></ul></li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/sqlite370_banner.gif"><p align="center"><b style="font-size:25px">SQLite</b></p></p><p>SQLite 是一款开源的嵌入式轻型C语言数据库，它实现了一个独立的、无服务器的、零配置的事务性 SQL 数据库引擎，且是世界上使用最多的数据库引擎，占用资源非常低，处理速度快。参考教程：<a href="http://www.codebaoku.com/sqlite/sqlite-index.html">SQLite教程</a></p><p>官网：<a href="https://www.sqlite.org">https://www.sqlite.org</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825161343265.png"><p align="center"><b style="font-size:25px">Lua</b></p></p><p><a href="https://www.leixue.com/so/Lua">Lua</a> 是一个简洁、轻量、可扩展的脚本语言，由标准 C 编写而成，并以源代码形式开放，几乎在所有操作系统和平台上都可以编译，运行，主要用于嵌入式系统、游戏开发、网络编程、科学计算等领域。Lua 在葡萄牙语中的意思是月亮。参考：<a href="http://www.codebaoku.com/lua/lua-index.html">Lua 教程</a></p><p>官网：<a href="http://www.lua.org">http://www.lua.org</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825163324396.png"><p align="center"><b style="font-size:25px">Docker</b></p></p><p>Docker 是一个开源的应用容器引擎，可以轻松地为任何应用创建一个轻量级、可移植的、安全的容器。它可以让开发者打包他们的应用和依赖包到一个轻量级、可移植的容器中，然后发布到其它机器上，也可以实现虚拟化。、</p><p>容器和虚拟机具有类似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。</p><p>容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台计算机上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为隔离进程运行。容器占用的空间比 VM 少（容器映像大小通常为 数十 MB），可以处理更多应用程序，并且需要更少的 VM 和操作系统。</p><p>虚拟机 （VM） 是将一台服务器转换为多台服务器的物理硬件的抽象。虚拟机监控程序允许多个 VM 在一台计算机上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本，占用数十 GB。 VM 的启动速度也可能很慢。<strong>参考</strong>：<a href="https://baijiahao.baidu.com/s?id=1675253978950340809&amp;wfr=spider&amp;for=pc">什么是Docker？看这一篇干货文章就够了！</a></p><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p><a href="http://www.codebaoku.com/docker/docker-index.html">Docker 教程</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230908095902194.png"><p align="center"><b style="font-size:25px">Kubernetes</b></p></p><p><strong>Kubernetes</strong> 也称为 K8s，是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。可以在本地机器、云或你自己的数据中心上部署 Kubernetes 集群。</p><p><a href="https://zhuanlan.zhihu.com/p/87186261">Kubernetes和Docker到底有啥关系？ - 知乎 (zhihu.com)</a></p><p>官网：<a href="https://kubernetes.io/">https://kubernetes.io/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230908103944775.png"><p align="center"><b style="font-size:25px">openstack</b></p></p><p>OpenStack是一个开源的云操作系统，为了云计算服务的，通过数据中心可控制大型的计算、存储、网络等资源池。所有的管理通过前端界面管理员就可以完成，同样也可以通过web接口让最终用户部署资源。OpenStack拥有众多的组件，通过组件之间协同进行工作，除了标准的基础架构即服务功能外，其他组件还提供编排、故障管理和服务管理以及其他服务，以确保用户应用程序的高可用性。</p><p><a href="https://zhuanlan.zhihu.com/p/35598437">OpenStack入门科普，看这一篇就够啦！ - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/goldsunshine/p/9872142.html">OpenStack VS Kubernetes，谁是你心中的王者？ - 金色旭光 - 博客园 (cnblogs.com)</a></p><p>官网：<a href="https://www.openstack.org/">https://www.openstack.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825164813557.png"><p align="center"><b style="font-size:25px">POSTMAN</b></p></p><p>Postman 是一个用于API测试的最流行的软件测试工具。借助该工具，开发人员可以轻松地创建，测试，共享和文档化API。这是一个简单的图形用户界面，用于发送和查看HTTP请求和响应。 使用Postman进行测试时，不需要编写任何HTTP客户端网络代码。在此工具中，几乎嵌入了任何开发人员可能需要的所有功能。</p><p>官网：<a href="https://www.postman.com/">https://www.postman.com/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825165153458.png"><p align="center"><b style="font-size:25px">Nginx</b></p></p><p>Nginx（engine x) 是一款免费开源的高性能、轻量级的 HTTP 和 反向代理 Web 服务器，Nginx 的功能可以分为：基本 HTTP 服务、高级 HTTP 服务和邮件服务等三大类。它以运行的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而闻名，其主要特点是占用内存少，并发能力强。Nginx 的并发能力在同类型的网页服务器中表现最好。在中国，所有大中型的网站几乎都在使用 Nginx：包括阿里、腾讯、百度、京东、新浪、网易等。</p><p>官网：<a href="http://www.nginx.org">http://www.nginx.org</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/vue-js_UzKKG.png"><p align="center"><b style="font-size:25px">Vue.js</b></p></p><p>Vue 是一个用于构建Web用户界面的渐进式JavaScript框架，需要了解关于 HTML、CSS 和 JavaScript 的相关知识，Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。对浏览器提供的修改 Dom 结构API进行封装，只需要对数据对象进行操作，由 Vue 负责调用底层浏览器 API。数据和视图双向绑定，当一方发生变化，另一方同时也会发生变化。</p><p>参考：<a href="http://www.codebaoku.com/vue3/vue3-index.html">Vue3 教程</a></p><p>官网：<a href="https://vuejs.org/">https://vuejs.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/circle_screenshot_1_Node.js.png"><p align="center"><b style="font-size:25px">Node.js</b></p></p><p>Node.js® 是一个开源、跨平台的 JavaScript 运行时环境。</p><p>官网：<a href="https://nodejs.org/">https://nodejs.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/circle_screenshot_1_About%20the%20Django%20Software%20Foundation%20Django.png"><p align="center"><b style="font-size:25px">Django</b></p></p><p>Python 目前主要流行的web框架：flask、Django、Tornado。Django 是使用 Python 开发的免费开源 MVC 风格的 Web 应用程序框架，自带大量常用工具和框架，可轻松、迅速开发出一个功能齐全的Web应用。强大的数据库访问组件，灵活的URL映射，丰富的模板语言，健全的后台管理系统，完整的错误信息提示和强大的缓存支持，并支持多种语言。使用这种架构，程序员可以方便、快捷地创建高品质、易维护、数据库驱动的应用程序。</p><p>参考：<a href="http://www.codebaoku.com/django/django-index.html">Django 教程</a></p><p>官网：<a href="https://www.djangoproject.com/">https://www.djangoproject.com/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230826175843615.png"><p align="center"><b style="font-size:25px">Flask</b></p></p><p>Flask 是一个 Python 实现的基于 WSGI 的 Web 开发微框架， 自由、灵活、可扩展性很强，很适用于开发小型应用。</p><p>参考：<a href="http://www.codebaoku.com/flask/flask-index.html">Flask 教程</a></p><p>官网：<a href="https://flask.palletsprojects.com">https://flask.palletsprojects.com</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/tornado.png"><p align="center"><b style="font-size:25px">Tornado</b></p></p><p>Tornado 是一个开源的 Python Web非阻塞轻量级服务器框架，速度相当快，其用于异步非阻塞IO的处理方式，具有实现高并发、高性能的特点。</p><p>官网：<a href="https://www.tornadoweb.org">https://www.tornadoweb.org</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/scrapylogo.png"><p align="center"><b style="font-size:25px">Scrapy</b></p></p><p>Scrapy 是一套用Python实现的基于 Twisted 异步处理网络爬虫和网络抓取框架，它应用广泛，从数据挖掘，到监控数据，及自动化测试。使用者只需要定制开发几个简单的模块，就能够轻松的实现一个爬虫，用来抓取网页内容以及各种图片，使用非常简单方便。</p><p>参考：<a href="http://www.codebaoku.com/scrapy/scrapy-index.html">Scrapy 教程</a></p><p>官网：<a href="https://scrapy.org/">https://scrapy.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/json160.gif"><p align="center"><b style="font-size:25px">JSON</b></p></p><p><strong>JSON</strong>(JavaScript Object Notation) 是一种轻量级的数据交换格式。它采用完全独立于编程语言的文本格式来存储和表示数据，语法简洁、层次结构清晰，易于人阅读和编写，同时也易于机器解析和生成，有效的提升了网络传输效率。</p><p>JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</p><p>官网：<a href="https://www.json.org/">https://www.json.org/</a></p><p>JSON在线格式化工具：<a href="http://www.json.org.cn/tools/JSONEditorOnline2.0/index.htm">http://www.json.org.cn/tools/JSONEditorOnline2.0/index.htm</a></p><p>为了方便和使用JSON，官网上有很多不同编程语言写的构建和解析JSON格式的库文件。在嵌入式中比较常用的有：</p><ul><li><p><a href="http://github.com/DaveGamble/cJSON">cJSON</a></p></li><li><p><a href="http://www.digip.org/jansson/">Jansson</a></p></li><li><p><a href="https://github.com/open-source-parsers/jsoncpp">jsoncpp</a></p></li></ul><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://gitee.com/kayoungzhang/picgo_res/raw/master/img/gnu-100-b98545.png&quot;&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;b style=&quot;fo</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="开源" scheme="http://example.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>编译工具链</title>
    <link href="http://example.com/2023/08/18/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>http://example.com/2023/08/18/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/</id>
    <published>2023-08-18T06:40:47.000Z</published>
    <updated>2023-08-18T06:54:23.796Z</updated>
    
    <content type="html"><![CDATA[<p>在编写程序后，一般需要进行编译处理，生成可执行的程序文件，才能下载到芯片中运行，在IDE集成开发环境中，编译的过程都是由其内部的编译工具链进行处理。但在Linux开发过程中，一般需要自己进行编译器的配置等操作，下面简单了解下编译工具链的相关知识。</p><h2 id="编译工具链简介">编译工具链简介</h2><p>编译程序是一个由多个步骤组成的过程，每个步骤都需要使用不同的工具进行处理。这些工具紧密协作，前一个工具的输出会成为后一个工具的输入，故称之为工具链，习惯称为编译工具链。这个工具链中包含多种工具和相关C库，如预编译器，编译器，汇编器，链接器，调试器等等。</p><h2 id="编译工具链分类">编译工具链分类</h2><p>针对不同的应用平台和芯片架构，编译工具链种类有很多，有免费开源授权版和付费授权版。</p><p><strong>免费版工具链</strong> 主要有两大主流：</p><ul><li><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/gnu-100-b98545-16923412898262.png" alt="gnu-100-b98545" /> <a href="https://www.gnu.org/">GNU Toolchain</a></p></li><li><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6ac54669f4b30cb07094375cbd65d24163b5b6e0.jpeg" alt="6ac54669f4b30cb07094375cbd65d24163b5b6e0" /> <a href="https://llvm.org/">LLVM Toolchain</a></p></li></ul><p>对于开源的这两大工具链，主要是ARM和Linaro开发社区提供：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818145258689.png" alt="image-20230818145258689" /> <a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain">arm Developer</a></p><p>arm主要提供GNU工具链。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818131408554.png" alt="image-20230818131408554" /> <a href="https://www.linaro.org/">Linaro</a></p><p>Linaro两种都有提供。</p><p><strong>收费版工具链</strong> 主要是一些大公司开发的专用工具链，必须购买获取授权，才能使用，像ARM原厂提供的armcc、IAR EWARM，微软的MSVC等等。</p><h2 id="编译工具链一般命名规则">编译工具链一般命名规则</h2><p>编译工具链的命名规则为： <strong>arch [-vendor] [-os] [-(gnu)eabi]</strong></p><p><strong>arch</strong> - 芯片体系架构，如arm，mips，aarch64等。</p><p><strong>vendor</strong> - 工具链提供商，可以是none、unknow或者省略。</p><p><strong>os</strong> - 目标操作系统，这个字段一般是linux或者none。</p><p><strong>eabi</strong> - 嵌入式应用二进制接口（Embedded Application Binary Interface)，它指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。</p><p>如：</p><p>arm-none-eabi</p><p>aarch64-none-linux-gnu</p><p>arm-none-linux-gnueabihf</p><h2 id="gnu编译工具链">GNU编译工具链</h2><h4 id="arm-gnu-toolchain">Arm GNU Toolchain</h4><p>下载地址：https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain</p><p>由ARM公司开发用于Arm架构的GNU开源编译工具链（称作“Arm GNU Toolchain”），可以让合作伙伴，开发人员和社区能够使用新功能，这些功能来自最新Arm架构和GCC，Binutils，glibc，Newlib和GDB的开源项目。</p><ul><li><a href="https://gcc.gnu.org/"><strong>GNU C/C++ Compiler (GCC)</strong></a> ： 编译工具，把源程序编译为可执行文件。</li><li><a href="https://www.gnu.org/software/binutils/"><strong>Binutils</strong></a> ：一组二进制工具程序集合。</li><li><a href="https://www.sourceware.org/gdb/"><strong>GDB</strong></a>：GNU本地调试器，可以用来调试C、C++和其他语言编写的程序。<br /></li><li><a href="https://sourceware.org/newlib/"><strong>Newlib</strong></a>：C库</li><li><a href="https://www.gnu.org/software/libc/libc.html"><strong>Glibc</strong></a>：C库</li></ul><p><strong>注意</strong>： Arm发布的旧版GNU工具链有两种：一种针对A系列芯片，另一种是针对M系列和R系列芯片(<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads">GNU Toolchain for A-profile processors</a> 和 <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">GNU Arm Embedded Toolchain</a>)。现在已经合二为一。</p><h3 id="gnu-toolchain">GNU Toolchain</h3><p>其他开源组织开发的GNU编译工具链</p><p>https://gnutoolchains.com/download/</p><h3 id="llvm-toolchain">LLVM Toolchain</h3><p>下载地址：https://github.com/llvm/llvm-project/releases/</p><p>LLVM项目是一个模块化和可重用的编译器和工具链技术的集合。LLVM 核心库提供了一个独立的代码优化器，且支持大多数流行的CPU的代码生成。</p><ul><li><strong><a href="https://clang.llvm.org/">Clang compiler</a></strong>：LLVM工具链中的编译器。</li><li><a href="https://lldb.llvm.org/"><strong>LLDB debugger</strong></a>：本机调试器。</li><li><strong><a href="https://libcxx.llvm.org/">libc++</a></strong> :C++标准库</li><li><a href="https://compiler-rt.llvm.org/"><strong>Compiler-RT runtime libraries</strong></a>：编译运行库</li><li><strong><a href="https://lld.llvm.org/">LLD linker</a></strong>：链接器</li></ul><p>以上是关于编译器的一些介绍，如果不是做编译器底层开发的话，不建议深入学习，毕竟还是有点复杂，对于我们一般开发者而言，了解它的一般原理，知道在哪下载，怎么使用，这些已足够了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在编写程序后，一般需要进行编译处理，生成可执行的程序文件，才能下载到芯片中运行，在IDE集成开发环境中，编译的过程都是由其内部的编译工具链进行处理。但在Linux开发过程中，一般需要自己进行编译器的配置等操作，下面简单了解下编译工具链的相关知识。&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="编译" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>内存的分区(栈区、堆区、全局区、常量区和代码区)</title>
    <link href="http://example.com/2023/08/13/%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E5%8C%BA-%E6%A0%88%E5%8C%BA%E3%80%81%E5%A0%86%E5%8C%BA%E3%80%81%E5%85%A8%E5%B1%80%E5%8C%BA%E3%80%81%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8C%BA/"/>
    <id>http://example.com/2023/08/13/%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E5%8C%BA-%E6%A0%88%E5%8C%BA%E3%80%81%E5%A0%86%E5%8C%BA%E3%80%81%E5%85%A8%E5%B1%80%E5%8C%BA%E3%80%81%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8C%BA/</id>
    <published>2023-08-13T14:30:12.000Z</published>
    <updated>2023-08-28T05:39:44.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存分区简介">内存分区简介</h2><p>内存一般分为四个区域：<strong>堆区、栈区、全局区（静态区）、代码区</strong>。而编译程序占用的内存分为以下五个部分：<strong>堆区、栈区、全局区（静态区）、常量区、代码区</strong> 。</p><p>C、C++程序在编译链接后生成的映像（image）中，将只包含 <strong>代码段(.Text)</strong>、<strong>只读数据段(.rodata)</strong> 和 <strong>读写数据段(.data)</strong> 。在程序运行之前，将生成 <strong>未初始化数据段(.bss)</strong>，在程序的运行时还将动态生成 <strong>堆(Heap)区域</strong> 和 <strong>栈(Stack)区域</strong> 。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230821192124971.png" alt="" /><figcaption>image-20230821192124971</figcaption></figure><h2 id="内存各分区功能">内存各分区功能</h2><ul><li><p><strong>栈区（Read and Write）</strong></p><ul><li>临时创建的局部变量和const定义的局部变量及函数形参、返回值存放在栈上。</li><li>栈区按内存地址由高到低方向生长，先进后出原则。</li><li>栈区由编译器自动分配释放，无须手动管理。栈上内容在函数运行结束就会自动销毁。</li></ul></li><li><p><strong>堆区（Read and Write）</strong></p><ul><li>由程序员分别调用malloc()和free()函数分配和释放内存。若申请了内存，忘记释放会造成内存泄漏。</li><li>堆区按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。</li></ul></li><li><p><strong>全局区(静态区)（Read and Write）</strong></p><ul><li><strong>.data段</strong>：存放初始化的全局变量和静态(static)变量。编译期间其大小及数据被确定，这些变量<strong>需要占用内存空间</strong>。</li><li><strong>.bss段(Block Started by Symbol)</strong>：存放未初始化的全局变量和静态(static)变量。程序运行之前被内核初始化为 0 或者空（NULL）。这些变量<strong>在程序运行之前不占内存空间</strong>。</li></ul></li><li><p><strong>常量区（Read Only）</strong></p><ul><li>存放 <strong>字符串</strong>、<strong>数字</strong> 等常量。</li><li>存放 <strong>const修饰的全局变量</strong>。</li></ul></li><li><p><strong>代码区（Read Only）</strong></p><ul><li><p>存放程序的编译后的可执行二进制代码，CPU执行的机器指令。</p></li><li><p>代码区的地址:函数的地址,程序的入口地址，函数的名称也是一个指针，可以通过查询函数名称所处的内存地址，查询函数存放的区域。</p></li><li><p>字符串常量和define定义的常量也有可能存放在代码区。</p></li></ul></li></ul><h2 id="举例">举例</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> a;   <span class="hljs-comment">//存放在全局未初始化区 .bss段</span><span class="hljs-type">char</span>* p1;   <span class="hljs-comment">//存放在全局未初始化区</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> b;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span>* p2;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span>* p3 = <span class="hljs-string">&quot;123456&quot;</span>;<span class="hljs-comment">//123456\0在常量区，p3在栈区。</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>；<span class="hljs-comment">//全局(静态)初始化区 .data段</span>p1 = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);p2 = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);<span class="hljs-comment">//使用malloc分配得来得10和20字节的区域就在堆区。</span><span class="hljs-built_in">strcpy</span>(p1, <span class="hljs-string">&quot;123456&quot;</span>);<span class="hljs-comment">//123456\0在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span>&#125;</code></pre></div><p><strong>参考:</strong></p><p><a href="https://blog.csdn.net/u014470361/article/details/79297601?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%2279297601%22%2C%22source%22%3A%22zky0830%22%7D&amp;fromshare=blogdetail">什么是代码区、常量区、静态区（全局区）、堆区、栈区？</a></p><p><a href="https://blog.csdn.net/weixin_44364057/article/details/126541545">五大内存分区</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存分区简介&quot;&gt;内存分区简介&lt;/h2&gt;
&lt;p&gt;内存一般分为四个区域：&lt;strong&gt;堆区、栈区、全局区（静态区）、代码区&lt;/strong&gt;。而编译程序占用的内存分为以下五个部分：&lt;strong&gt;堆区、栈区、全局区（静态区）、常量区、代码区&lt;/strong&gt; 。&lt;</summary>
      
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="内存" scheme="http://example.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>计算机结构</title>
    <link href="http://example.com/2023/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/</id>
    <published>2023-08-13T11:42:45.000Z</published>
    <updated>2023-08-28T05:25:52.532Z</updated>
    
    <content type="html"><![CDATA[<p>计算机的五个基本组成部分：<strong>运算器、控制器、存储器、输入设备、输出设备</strong> 。</p><p>计算机常见的两种结构，<strong>哈佛结构（Harvard Architecture）</strong>和 <strong>冯·诺依曼结构（Von Neumann Architecture）</strong>：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230813204135256.png" /></p><p>从这两种结构图上可以看出，它们的主要区别是内存存在方式的不同。</p><h3 id="哈佛结构">哈佛结构</h3><p>哈佛结构是一种将程序指令储存和数据储存分开的存储器结构。每个存储器独立编址，使用两条独立的总线传输，中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作(通常是执行)。程序指令储存和数据储存分开，<strong>数据和指令的储存可以同时进行</strong>，可以使指令和数据有不同的数据宽度。</p><p>哈佛结构的微处理器执行时可以预先读取下一条指令，因此具有较高的执行效率。</p><h3 id="冯诺依曼结构">冯诺依曼结构</h3><p>冯诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的结构。指令和数据统一编址，使用同一条总线传输，节约了资源。</p><p>冯.诺依曼结构中，将程序和数据一样看待，<strong>将程序编码为数据，然后与数据一同存放在存储器中</strong>，无论什么程序，最终都是会转换为数据的形式存储在存储器中，要执行相应的程序只需要从存储器中依次取出指令、执行，这样减少了硬件的连接。</p><h3 id="改进型哈佛结构">改进型哈佛结构</h3><p>现在的计算机，其实是这两种结构的混合体。对于一台计算机的整体来说，我们可以认为是冯·诺依曼结构，计算机中的内存是统一的，并没有明确分为指令内存还是数据内存。</p><p>相对于CPU的速度来说，从内存读取数据和写入数据都很慢的，因此CPU内部有另外一种速度更快的存储介质来存放数据和指令，我们称之为缓存（Cache），分为D-Cache和l-Cache，分别用于存储数据和程序指令。在CPU外部则使用RAM存储数据和指令。只有需要改变数据时，缓存才会到RAM中加载新的数据。现代计算机中缓存通常有多层，每一层都比下一层快，但比下一层可以存放的数据少。</p><p>实际上，这种结构从内部看属于哈佛结构，从外部看则属于冯诺依曼结构， 这是一种混合式结构，而现在的计算机CPU大多采用这样的结构， 已经不再是纯粹的冯诺依曼结构或者哈佛结构了。</p><h4 id="参考链接">参考链接</h4><p>https://zhuanlan.zhihu.com/p/63322067</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机的五个基本组成部分：&lt;strong&gt;运算器、控制器、存储器、输入设备、输出设备&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;计算机常见的两种结构，&lt;strong&gt;哈佛结构（Harvard Architecture）&lt;/strong&gt;和 &lt;strong&gt;冯·诺依曼结构（Von</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>stm32 sct分散加载文件详解</title>
    <link href="http://example.com/2023/08/09/stm32-sct%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/09/stm32-sct%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-09T10:28:31.000Z</published>
    <updated>2023-08-10T11:32:50.678Z</updated>
    
    <content type="html"><![CDATA[<p>keil软件在编译过程中会生成分散加载文件（Scatter-Loading Description File），它可以用来描述链接器生成映像文件时需要的信息，通过这些信息分配 Code、RO-Data，RW-Data，ZI-Data 等数据的存放地址。</p><p>一个sct文件主要由一个<strong>加载区（load region）</strong>和多个<strong>执行区（execution region）</strong>构成。</p><p>加载区是用来保存永久性数据（程序和只读变量）的区域；执行区是程序执行时，从加载区域将数据复制到相应执行区后才能被正确执行。</p><p>sct文件一般格式：</p><div class="code-wrapper"><pre><code class="hljs assembly">LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region  ER_IROM1 0x08000000 0x00080000  &#123;  ; load address = execution address   *.o (RESET, +First)    *(InRoot$$Sections)    .ANY (+RO)   &#125;  RW_IRAM1 0x20000000 0x00010000  &#123;  ; RW data   .ANY (+RW +ZI)   &#125;&#125;</code></pre></div><p>下面分别通过三个方面详细了解一下其格式语法：</p><h4 id="加载区域语法">1. 加载区域语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">加载区名(基地址|&quot;+&quot;偏移地址)[属性][大小]&#123;执行区操作+    ;+号表示可以有一个或者多个运行区&#125;</code></pre></div><p>属性列表：</p><ul><li>ABSOLUTE：绝对地址；</li><li>PI：与位置无关；</li><li>RELOC：可重定位；</li><li>OVERLAY：覆盖；</li><li>NOCOMPRESS：不能进行压缩。</li></ul><h4 id="执行区语法">2. 执行区语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">执行区名(基地址|&quot;+&quot;偏移地址)[属性][大小|&quot; &quot;长度]&#123;输入段内容&#125;</code></pre></div><p>属性列表：</p><ul><li><p>ABSOLUTE：绝对地址；</p></li><li><p>PI：与位置无关；</p></li><li><p>RELOC：可重定位；</p></li><li><p>OVERLAY：覆盖；</p></li><li><p>FIXED：固定地址。</p></li><li><p>ALIGNalignment：将执行区的对齐约束从 4 增加到 alignment。alignment 必须为 2 的正数幂。如果执行区具有 base_address，则它必须为 alignment 对齐。如果执行区具有 offset，则链接器将计算的区基址与 alignment 边界对齐；</p></li><li><p>EMPTY：在执行区中保留一个给定长度的空白内存块，通常供堆或堆栈使用。</p></li><li><p>ZEROPAD：零初始化的段作为零填充块写入 ELF 文件，因此，运行时无需使用零进行填充；</p></li><li><p>PADVALUE：定义任何填充的值。如果指定 PADVALUE，则必须为其赋值；</p></li><li><p>NOCOMPRESS：不能进行压缩；</p></li><li><p>UNINIT：未初始化的数据。</p></li></ul><h4 id="输入段内容语法">3. 输入段内容语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">module_select_pattern [ &quot;(&quot; input_section_selector ( &quot;,&quot; input_section_selector )* &quot;)&quot; ](&quot;+&quot; input_section_attr | input_section_pattern | input_symbol_pattern)</code></pre></div><ul><li>module_select_pattern：目标文件滤波器，支持通配符“*”与“?”。字符不区分大小写。</li><li>input_section_selector: 模块选择器模式,有以下几种：<ul><li>包含段和目标文件的名称；</li><li>库成员名称（不带前导路径名）；</li><li>库的完整名称（包括路径名）。如果名称包含空格，则可以使用通配符简化。例如，使用*libname.lib 匹配 C:dir.lib。</li></ul></li><li>nput_section_attr：属性选择器与输入段属性相匹配。每个 input_section_attr 的前面有“+”号。如果指定一个模式以匹配输入段名称，名称前面必须有一个“+”号。可以省略紧靠“+”号前面的任何逗号。选择器不区分大小写。可以识别以下选择器：<ul><li>RO-CODE，RO-DATA，RO（RO-CODE 和 RO-DATA），CODE（RO-CODE）、CONST（RO-DATA），TEXT（RO）</li><li>RW-DATA，RW-CODE，RW（RW-CODE 和 RW-DATA），DATA（RW）</li><li>ZI，BSS（ZI）</li><li>ENTRY（即包含 ENTRY 点的段），FIRST，LAST</li></ul></li></ul><p>通过使用特殊模块选择器模式.ANY 可以将输入段分配给执行区，而无需考虑其父模块。可以使用一个或多个.ANY 模式以任意分配方式填充运行区。在大多数情况下，使用单个.ANY 等效于使用*模块选择器。</p><p>由以上语法分析，查看具体实例，如下所示：</p><div class="code-wrapper"><pre><code class="hljs assembly">; IROM1加载区，地址：0x08000000，大小：0x00080000LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region  ; ER_IROM1执行区，地址：0x08000000，大小：0x00080000  ER_IROM1 0x08000000 0x00080000    &#123;  ; load address = execution address   *.o (RESET, +First) ;将REST段最先放到本区，+First表示强制放到首地址   *(InRoot$$Sections) ;将ARM相关库放进来，InRoot$$Sections即ARM库的链接器标号，主要作用COPY RW区到RAM，然后再RW区后面创建ZI区。   .ANY (+RO) ;执行所有目标文件的只读属性数据  &#125;    ; RW_IRAM1执行区，地址：0x20000000，大小：0x00010000  RW_IRAM1 0x20000000 0x00010000    &#123;  ; RW data   .ANY (+RW +ZI) ;执行所有目标文件的可读可写属性及初始化为零的数据  &#125;&#125;</code></pre></div><p>以上就是sct分散加载文件的简要介绍，一般作为了解内存的分布情况，若想尝试修改区域数据存放的内存位置，可参考附件内周立功老师关于其具体使用的介绍。</p><p><a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/stm32%20sct%20file%20.zip">附件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;keil软件在编译过程中会生成分散加载文件（Scatter-Loading Description File），它可以用来描述链接器生成映像文件时需要的信息，通过这些信息分配 Code、RO-Data，RW-Data，ZI-Data 等数据的存放地址。&lt;/p&gt;
&lt;p&gt;一个</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sct" scheme="http://example.com/tags/sct/"/>
    
  </entry>
  
  <entry>
    <title>stm32 map文件详解</title>
    <link href="http://example.com/2023/08/09/stm32-map%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/09/stm32-map%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-09T10:25:35.000Z</published>
    <updated>2023-08-14T10:54:30.924Z</updated>
    
    <content type="html"><![CDATA[<p>MDK-ARM在编译时会生成很多类型的中间文件，最终通过这些中间文件生成可下载到MCU的hex文件。.map 文件就是其中编译器链接时生成的一个文件，主要包含了交叉链接信息。</p><p>通过 .map 文件，可以知晓工程中函数的大小，入口地址，变量、调用关系、FLASH 和 RAM 占用空间大小等信息，根据这些信息，可以对代码进行优化。</p><p>要生成 .map 文件，需要在keil软件中进行如下相应设置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809191148933.png" alt="image-20230809191148933" style="zoom: 80%;" /></p><p>为了更好的分析 map 文件，需要了解一些基础概念：</p><ul><li>Section：描述映像文件的代码或数据块，我们简称程序段</li><li>RO：包括只读数据（RO data）和代码（RO code）两部分内容，占用 FLASH 空间</li><li>RW：包含可读写数据（RW data，有初值，且不为 0），占用 FLASH（存储初值）和 RAM（读写操作）</li><li>ZI：Zero initialized 的缩写，包含初始化为 0 的数据（ZI data），占用 RAM 空间。</li><li>.text：相当于 RO code</li><li>.constdata：相当于 RO data</li><li>.bss：相当于 ZI data</li><li>.data：相当于 RW data</li></ul><p>使用notepad打开map文件，会发现map文件主要有 5 个组成部分：</p><ul><li><strong>程序段交叉引用关系（Section Cross References）</strong></li><li><strong>删除映像未使用的程序段（Removing Unused input sections from the image）</strong></li><li><strong>映像符号表（Image Symbol Table）</strong></li><li><strong>映像内存分布图（Memory Map of the image）</strong></li><li><strong>映像组件大小（Image component sizes）</strong></li></ul><p>下面分别进行介绍：</p><h4 id="程序段交叉引用关系section-cross-references">1.程序段交叉引用关系（Section Cross References）</h4><p>这部分内容描述了各个文件（.c/.s 等）之间函数（程序段）的调用关系。</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 1.程序段交叉引用关系</span><span class="hljs-comment"> * .o文件是.c源文件生成的中间文件，括号内是文件或函数入口地址，每句末尾表示被调用的函数或内容</span><span class="hljs-comment"> */</span>Section Cross References     startup_stm32f103xe.o(RESET) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    startup_stm32f103xe.o(RESET) refers to startup_stm32f103xe.o(.text) <span class="hljs-keyword">for</span> Reset_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.NMI_Handler) <span class="hljs-keyword">for</span> NMI_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.HardFault_Handler) <span class="hljs-keyword">for</span> HardFault_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.MemManage_Handler) <span class="hljs-keyword">for</span> MemManage_Handler    省略......    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash_ex.o(i.FLASH_OB_RDP_LevelConfig) <span class="hljs-keyword">for</span> FLASH_OB_RDP_LevelConfig    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash.o(i.FLASH_WaitForLastOperation) <span class="hljs-keyword">for</span> FLASH_WaitForLastOperation    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash.o(.bss) <span class="hljs-keyword">for</span> pFlash    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry10a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>D) <span class="hljs-keyword">for</span> __rt_final_cpp    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry11a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>F) <span class="hljs-keyword">for</span> __rt_final_exit    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry7b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000008</span>) <span class="hljs-keyword">for</span> _main_clock    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry8b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>A) <span class="hljs-keyword">for</span> _main_cpp_init    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry9a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>B) <span class="hljs-keyword">for</span> _main_init    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) <span class="hljs-keyword">for</span> _main_scatterload    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000001</span>) <span class="hljs-keyword">for</span> _main_stk    entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000001</span>) refers to entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00002712</span>) <span class="hljs-keyword">for</span> __lit__00000000    entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00002712</span>) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    entry2.o(__vectab_stack_and_reset_area) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    entry2.o(__vectab_stack_and_reset_area) refers to entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) <span class="hljs-keyword">for</span> __main    entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) refers to init.o(.text) <span class="hljs-keyword">for</span> __scatterload    entry9a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>B) refers to main.o(i.main) <span class="hljs-keyword">for</span> main    entry9b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>C) refers to main.o(i.main) <span class="hljs-keyword">for</span> main    init.o(.text) refers to entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) <span class="hljs-keyword">for</span> __main_after_scatterload</code></pre></div><h4 id="删除映像未使用的程序段removing-unused-input-sections-from-the-image">2.删除映像未使用的程序段（Removing Unused input sections from the image）</h4><p>这部分内容描述了工程中由于未被调用而被删除的冗余程序段（函数/数据）。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 2. 删除映像未使用的程序段</span><span class="hljs-comment"> * 每行显示删除的文件，位置及大小</span><span class="hljs-comment"> * 这部分最末显示删除的汇总信息。</span><span class="hljs-comment"> */</span>Removing Unused <span class="hljs-selector-tag">input</span> sections from the image.    Removing startup_stm32f103xe<span class="hljs-selector-class">.o</span>(HEAP), (<span class="hljs-number">512</span> bytes).    Removing <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>(.rev16_text), (<span class="hljs-number">4</span> bytes).    Removing <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>(.revsh_text), (<span class="hljs-number">4</span> bytes).    省略......    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_ClearConfigLine), (<span class="hljs-number">104</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_ClearPending), (<span class="hljs-number">20</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GenerateSWI), (<span class="hljs-number">20</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetConfigLine), (<span class="hljs-number">140</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetHandle), (<span class="hljs-number">12</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetPending), (<span class="hljs-number">24</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_IRQHandler), (<span class="hljs-number">36</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_RegisterCallback), (<span class="hljs-number">14</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_SetConfigLine), (<span class="hljs-number">164</span> bytes).<span class="hljs-number">226</span> unused <span class="hljs-selector-tag">section</span>(s) (total <span class="hljs-number">11022</span> bytes) removed from the image.</code></pre></div><h4 id="映像符号表image-symbol-table">3.映像符号表（Image Symbol Table）</h4><p>映像符号表（Image Symbol Table）描述了被引用的各个符号（程序段/数据）在存储器中的存储地址、类型、大小等信息。映像符号表分为两类：本地符号（Local Symbols）和全局符号（Global Symbols）。</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 3. 映像符号表</span><span class="hljs-comment"> * 映像符号包括Local Symbols（本地符号）和Global Symbols（全局符号）</span><span class="hljs-comment"> * 每行描述映像符号的名称、地址、类型、大小及生成目标。</span><span class="hljs-comment"> */</span>Image Symbol Table    Local Symbols    Symbol Name                              Value     Ov Type        Size  <span class="hljs-built_in">Object</span>(Section)    ../Core/Src/dma<span class="hljs-selector-class">.c</span>                        <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  dma<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/gpio<span class="hljs-selector-class">.c</span>                       <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  gpio<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>                       <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/stm32f1xx_hal_msp<span class="hljs-selector-class">.c</span>          <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_msp<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/stm32f1xx_it<span class="hljs-selector-class">.c</span>               <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_it<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/system_stm32f1xx<span class="hljs-selector-class">.c</span>           <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  system_stm32f1xx<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/usart<span class="hljs-selector-class">.c</span>                      <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  usart<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_cortex<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_cortex<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_dma<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_dma<span class="hljs-selector-class">.o</span> ABSOLUTE    省略......    Global Symbols    Symbol Name                              Value     Ov Type        Size  <span class="hljs-built_in">Object</span>(Section)    BuildAttributes$<span class="hljs-variable">$THM_ISAv4</span><span class="hljs-variable">$P</span><span class="hljs-variable">$D</span><span class="hljs-variable">$K</span><span class="hljs-variable">$B</span><span class="hljs-variable">$S</span><span class="hljs-variable">$PE</span><span class="hljs-variable">$A</span>:L22UL41UL21<span class="hljs-variable">$X</span>:L11<span class="hljs-variable">$S22US41US21</span><span class="hljs-variable">$IEEE1</span><span class="hljs-variable">$IW</span><span class="hljs-variable">$USESV6</span>$~STKCKD<span class="hljs-variable">$USESV7</span>$~SHL<span class="hljs-variable">$OSPACE</span><span class="hljs-variable">$EBA8</span><span class="hljs-variable">$MICROLIB</span><span class="hljs-variable">$REQ8</span><span class="hljs-variable">$PRES8</span><span class="hljs-variable">$EABIv2</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  anon$<span class="hljs-variable">$obj</span><span class="hljs-selector-class">.o</span> ABSOLUTE    __ARM_use_no_argv                        <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> ABSOLUTE    __cpp_initialize__aeabi_                  - Undefined Weak Reference    __cxa_finalize                            - Undefined Weak Reference    __decompress                              - Undefined Weak Reference    _clock_init                               - Undefined Weak Reference    _microlib_exit                            - Undefined Weak Reference    __Vectors_Size                           <span class="hljs-number">0</span>x00000130   Number         <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span> ABSOLUTE    __Vectors                                <span class="hljs-number">0</span>x08000000   Data           <span class="hljs-number">4</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(RESET)    __Vectors_End                            <span class="hljs-number">0</span>x08000130   Data           <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(RESET)    __main                                   <span class="hljs-number">0</span>x08000131   Thumb Code     <span class="hljs-number">0</span>  entry<span class="hljs-selector-class">.o</span>(<span class="hljs-selector-class">.ARM</span>.Collect$$$$<span class="hljs-number">00000000</span>)    _main_stk                                <span class="hljs-number">0</span>x08000131   Thumb Code     <span class="hljs-number">0</span>  entry2<span class="hljs-selector-class">.o</span>(<span class="hljs-selector-class">.ARM</span>.Collect$$$$<span class="hljs-number">00000001</span>)    省略......    SystemCoreClock                          <span class="hljs-number">0</span>x20000030   Data           <span class="hljs-number">4</span>  system_stm32f1xx<span class="hljs-selector-class">.o</span>(.data)    uwTickFreq                               <span class="hljs-number">0</span>x20000034   Data           <span class="hljs-number">1</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    uwTickPrio                               <span class="hljs-number">0</span>x20000038   Data           <span class="hljs-number">4</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    uwTick                                   <span class="hljs-number">0</span>x2000003c   Data           <span class="hljs-number">4</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    huart1                                   <span class="hljs-number">0</span>x20000040   Data          <span class="hljs-number">72</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    hdma_usart1_rx                           <span class="hljs-number">0</span>x20000088   Data          <span class="hljs-number">68</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    hdma_usart1_tx                           <span class="hljs-number">0</span>x200000cc   Data          <span class="hljs-number">68</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    __initial_sp                             <span class="hljs-number">0</span>x20000510   Data           <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(STACK)</code></pre></div><h4 id="映像内存分布图memory-map-of-the-image">4.映像内存分布图（Memory Map of the image）</h4><p>映像文件分为加载域（Load Region）和运行域（Execution Region），一个加载域必须有至少一个运行域（可以有多个运行域），而一个程序又可以有多个加载域。加载域为映像程序的实际存储区域，而运行域则是 MCU 上电后的运行状态。加载域和运行域的简化关系（这里仅表示一个加载域的情况）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809213411201.png" alt="image-20230809213411201" style="zoom:80%;" /></p><div class="code-wrapper"><pre><code class="hljs dns">/* * <span class="hljs-number">4</span>. 映像内存分布图 * 映像文件分为加载域（Load Region）和运行域（Execution Region）。 */Memory Map of the image  /* 映象入口地址 */  Image Entry point : <span class="hljs-number">0x08000131</span>     /* LR_IROM1加载域地址及大小 */  Load Region LR_IROM1 (Base: <span class="hljs-number">0x08000000</span>, Size: <span class="hljs-number">0</span>x<span class="hljs-number">000017c8</span>, Max: <span class="hljs-number">0x00080000</span>, ABSOLUTE)     /* ER_IROM1运行域地址及大小 */  Execution Region ER_IROM1 (Base: <span class="hljs-number">0x08000000</span>, Size: <span class="hljs-number">0x00001788</span>, Max: <span class="hljs-number">0x00080000</span>, ABSOLUTE)     Base Addr    Size         Type   Attr      Idx    E Section Name        Object    <span class="hljs-number">0x08000000</span>   <span class="hljs-number">0x00000130</span>   Data   RO            <span class="hljs-number">3</span>    RESET               startup_stm32f103xe.o    <span class="hljs-number">0x08000130</span>   <span class="hljs-number">0x00000000</span>   Code   RO         <span class="hljs-number">1809</span>  * .ARM.Collect$$$$<span class="hljs-number">00000000</span>  mc_w.l(entry.o)    <span class="hljs-number">0x08000130</span>   <span class="hljs-number">0x00000004</span>   Code   RO         <span class="hljs-number">1816</span>    .ARM.Collect$$$$<span class="hljs-number">00000001</span>  mc_w.l(entry2.o)    <span class="hljs-number">0x08000134</span>   <span class="hljs-number">0x00000004</span>   Code   RO         <span class="hljs-number">1819</span>    .ARM.Collect$$$$<span class="hljs-number">00000004</span>  mc_w.l(entry5.o)    省略......    <span class="hljs-number">0x08001708</span>   <span class="hljs-number">0x00000034</span>   Code   RO           <span class="hljs-number">15</span>    i.main              main.o    <span class="hljs-number">0</span>x0800173c   <span class="hljs-number">0x00000010</span>   Data   RO          <span class="hljs-number">364</span>    .constdata          system_stm32f1xx.o    <span class="hljs-number">0</span>x0800174c   <span class="hljs-number">0x00000008</span>   Data   RO          <span class="hljs-number">365</span>    .constdata          system_stm32f1xx.o    <span class="hljs-number">0x08001754</span>   <span class="hljs-number">0x00000012</span>   Data   RO         <span class="hljs-number">1023</span>    .constdata          stm32f1xx_hal_rcc.o    <span class="hljs-number">0x08001766</span>   <span class="hljs-number">0x00000002</span>   PAD    <span class="hljs-number">0x08001768</span>   <span class="hljs-number">0x00000020</span>   Data   RO         <span class="hljs-number">1832</span>    Region$$Table       anon$$obj.o    /* RW_IRAM1运行域，地址，大小 */    Execution Region RW_IRAM1 (Base: <span class="hljs-number">0x20000000</span>, Size: <span class="hljs-number">0x00000510</span>, Max: <span class="hljs-number">0x00010000</span>, ABSOLUTE)     Base Addr    Size         Type   Attr      Idx    E Section Name        Object    <span class="hljs-number">0x20000000</span>   <span class="hljs-number">0</span>x0000002f   Data   RW           <span class="hljs-number">16</span>    .data               main.o    <span class="hljs-number">0</span>x2000002f   <span class="hljs-number">0x00000001</span>   PAD    <span class="hljs-number">0x20000030</span>   <span class="hljs-number">0x00000004</span>   Data   RW          <span class="hljs-number">366</span>    .data               system_stm32f1xx.o    <span class="hljs-number">0x20000034</span>   <span class="hljs-number">0</span>x0000000c   Data   RW          <span class="hljs-number">860</span>    .data               stm32f1xx_hal.o    <span class="hljs-number">0x20000040</span>   <span class="hljs-number">0</span>x<span class="hljs-number">000000d0</span>   Zero   RW          <span class="hljs-number">200</span>    .bss                usart.o    <span class="hljs-number">0x20000110</span>   <span class="hljs-number">0x00000400</span>   Zero   RW            <span class="hljs-number">1</span>    STACK               startup_stm32f103xe.o</code></pre></div><h4 id="映像组件大小image-component-sizes">5.映像组件大小（Image component sizes）</h4><p>各文件编译后所占代码空间的大小，keil IDE编译后输出框显示的文件占用空间大小与此部分一致。</p><div class="code-wrapper"><pre><code class="hljs tap">/* * 5. 映像组件大小 * 文件编译后所占代码空间的大小。 */Image component sizes/* 代码大小(内联函数大小) 只读大小  读写大小  零初始化大小  调试大小  文件名 */      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name       <span class="hljs-number"> 60 </span>        <span class="hljs-number"> 4 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 682 </span>  dma.o       <span class="hljs-number"> 28 </span>        <span class="hljs-number"> 6 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 663 </span>  gpio.o      <span class="hljs-number"> 150 </span>       <span class="hljs-number"> 10 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 47 </span>        <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 455148 </span>  main.o       <span class="hljs-number"> 36 </span>        <span class="hljs-number"> 8 </span>      <span class="hljs-number"> 304 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1024 </span>      <span class="hljs-number"> 760 </span>  startup_stm32f103xe.o      <span class="hljs-number"> 164 </span>       <span class="hljs-number"> 28 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 12 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 6105 </span>  stm32f1xx_hal.o      <span class="hljs-number"> 198 </span>       <span class="hljs-number"> 14 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 28331 </span>  stm32f1xx_hal_cortex.o     <span class="hljs-number"> 1236 </span>       <span class="hljs-number"> 52 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4358 </span>  stm32f1xx_hal_dma.o      <span class="hljs-number"> 504 </span>       <span class="hljs-number"> 42 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1928 </span>  stm32f1xx_hal_gpio.o       <span class="hljs-number"> 60 </span>        <span class="hljs-number"> 8 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 786 </span>  stm32f1xx_hal_msp.o     <span class="hljs-number"> 1240 </span>       <span class="hljs-number"> 84 </span>       <span class="hljs-number"> 18 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4604 </span>  stm32f1xx_hal_rcc.o     <span class="hljs-number"> 1500 </span>       <span class="hljs-number"> 24 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 10186 </span>  stm32f1xx_hal_uart.o       <span class="hljs-number"> 56 </span>       <span class="hljs-number"> 18 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4700 </span>  stm32f1xx_it.o        <span class="hljs-number"> 2 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 24 </span>        <span class="hljs-number"> 4 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 987 </span>  system_stm32f1xx.o      <span class="hljs-number"> 276 </span>       <span class="hljs-number"> 30 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 208 </span>     <span class="hljs-number"> 1728 </span>  usart.o    -------------------------------------------------------------------<span class="language-yaml"><span class="hljs-meta">---</span></span><span class="language-yaml">      <span class="hljs-number">5522        </span><span class="hljs-number">328</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">520966</span>   <span class="hljs-string">Object</span> <span class="hljs-string">Totals</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>         <span class="hljs-number">32</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Generated)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器生成的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">        <span class="hljs-number">12</span>          <span class="hljs-number">0</span>          <span class="hljs-number">2</span>          <span class="hljs-number">1</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Padding)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器填充的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span>  <span class="hljs-string">库文件名</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Member</span> <span class="hljs-string">Name</span></span><span class="language-yaml"></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry10a.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry11a.o</span></span><span class="language-yaml">         <span class="hljs-number">8</span>          <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry2.o</span></span><span class="language-yaml">         <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry5.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry7b.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry8b.o</span></span><span class="language-yaml">         <span class="hljs-number">8</span>          <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry9a.o</span></span><span class="language-yaml">        <span class="hljs-number">30</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">handlers.o</span></span><span class="language-yaml">        <span class="hljs-number">36</span>          <span class="hljs-number">8</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>         <span class="hljs-number">68</span>   <span class="hljs-string">init.o</span></span><span class="language-yaml">        <span class="hljs-number">36</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">108</span>   <span class="hljs-string">memseta.o</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Totals</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Padding)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器填充的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span>  <span class="hljs-string">库文件名</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Name</span></span><span class="language-yaml"></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">mc_w.l</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Totals</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   </span><span class="language-yaml"></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">518434</span>   <span class="hljs-string">Grand</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">整个映像大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">518434</span>   <span class="hljs-string">ELF</span> <span class="hljs-string">Image</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">ELF可执行格式映像大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">ROM</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">整个ROM大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">RO</span>  <span class="hljs-string">Size</span> <span class="hljs-string">(Code</span> <span class="hljs-string">+</span> <span class="hljs-string">RO</span> <span class="hljs-string">Data)</span>                 <span class="hljs-number">6024</span> <span class="hljs-string">(</span>   <span class="hljs-number">5.</span><span class="hljs-string">88kB)</span></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">RW</span>  <span class="hljs-string">Size</span> <span class="hljs-string">(RW</span> <span class="hljs-string">Data</span> <span class="hljs-string">+</span> <span class="hljs-string">ZI</span> <span class="hljs-string">Data)</span>              <span class="hljs-number">1296</span> <span class="hljs-string">(</span>   <span class="hljs-number">1.</span><span class="hljs-string">27kB)</span></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">ROM</span> <span class="hljs-string">Size</span> <span class="hljs-string">(Code</span> <span class="hljs-string">+</span> <span class="hljs-string">RO</span> <span class="hljs-string">Data</span> <span class="hljs-string">+</span> <span class="hljs-string">RW</span> <span class="hljs-string">Data)</span>       <span class="hljs-number">6088</span> <span class="hljs-string">(</span>   <span class="hljs-number">5.</span><span class="hljs-string">95kB)</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span></code></pre></div><p>Code是代码区，RO-data 代表常量区，RW-data 代表已初始化的全局变量和静态变量，属于静态区（全局区），ZI-data 代表未初始化但被编译器初始化为0的全局变量和静态变量，属于静态区（全局区）。</p><p><a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/stm32_map_file.zip">hal uart map文件与正点原子详解附件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MDK-ARM在编译时会生成很多类型的中间文件，最终通过这些中间文件生成可下载到MCU的hex文件。.map 文件就是其中编译器链接时生成的一个文件，主要包含了交叉链接信息。&lt;/p&gt;
&lt;p&gt;通过 .map 文件，可以知晓工程中函数的大小，入口地址，变量、调用关系、FLAS</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="map" scheme="http://example.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>stm32启动文件详解</title>
    <link href="http://example.com/2023/08/08/stm32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/08/stm32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-08T04:30:03.000Z</published>
    <updated>2023-08-09T10:00:07.283Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道程序一般是从<code>main</code>函数开始运行的，但在<code>main</code>函数运行之前，程序已经做了一些准备工作，对于STM32F1芯片，这些准备工作是通过启动文件来完成的。下面来详细看看stm32库中的启动代码文件（STM32Cube_FW_F1_V1.8.532F1xx_stm32f103xe.s）。</p><p>启动文件是由汇编语言编写，是系统上电复位后第一个执行的程序。首先我们来看看启动文件使用的ARM汇编指令：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809173349258.png" alt="" /><figcaption>image-20230809173349258</figcaption></figure><p>整个启动文件主要做了以下操作：</p><ul><li>**设置初始化堆栈指针SP = _initial_sp**</li><li><strong>设置初始化计数器指针PC = Reset_Handler</strong></li><li><strong>设置堆栈大小</strong></li><li><strong>初始化中断向量表</strong></li><li><strong>调用 SystemInit() 函数初始化系统时钟</strong></li><li>**跳转到C库中的 __main 函数初始化用户堆栈（最终调用main()函数）**</li></ul><div class="code-wrapper"><pre><code class="hljs assembly">;1-栈 ######;开辟栈的大小为 0X00000400（1K字节），名字为 STACK， NOINIT 即不初始化，可读可写， 8（2^3）字节对齐。;标号__initial_sp 表示栈的结束地址，即栈顶地址，栈是由高向低生长的。; Amount of memory (in bytes) allocated for Stack  ; Tailor this value to your application needs    ; &lt;h&gt; Stack Configuration   ;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;   ; &lt;/h&gt;Stack_Size      EQU     0x00000400                    AREA    STACK, NOINIT, READWRITE, ALIGN=3  Stack_Mem       SPACE   Stack_Size   __initial_sp</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;2-堆 ######;开辟堆的大小为 0X00000200（512字节），名字为 HEAP， 不初始化，可读可写， 8（2^3）字节对齐。;标号__heap_base 表示堆的起始地址， __heap_limit 表示堆的结束地址。堆是由低向高生长的，跟栈的生长方向相反。                                                  ; &lt;h&gt; Heap Configuration  ;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;  ; &lt;/h&gt;Heap_Size       EQU     0x00000200                  AREA    HEAP, NOINIT, READWRITE, ALIGN=3 __heap_baseHeap_Mem        SPACE   Heap_Size__heap_limit</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;3-向量表; 定义一个名为RESET的数据段，只读，并声明三个全局属性的标号 __Vectors、 __Vectors_End 和__Vectors_Size; Vector Table Mapped to Address 0 at Reset                AREA    RESET, DATA, READONLY                EXPORT  __Vectors                EXPORT  __Vectors_End                EXPORT  __Vectors_Size__Vectors       DCD     __initial_sp               ; Top of Stack #栈顶                DCD     Reset_Handler              ; Reset Handler                DCD     NMI_Handler                ; NMI Handler                DCD     HardFault_Handler          ; Hard Fault Handler                DCD     MemManage_Handler          ; MPU Fault Handler                DCD     BusFault_Handler           ; Bus Fault Handler                DCD     UsageFault_Handler         ; Usage Fault Handler                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     SVC_Handler                ; SVCall Handler                DCD     DebugMon_Handler           ; Debug Monitor Handler                DCD     0                          ; Reserved                DCD     PendSV_Handler             ; PendSV Handler                DCD     SysTick_Handler            ; SysTick Handler                ; External Interrupts #外部中断                DCD     WWDG_IRQHandler            ; Window Watchdog                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect                DCD     TAMPER_IRQHandler          ; Tamper                DCD     RTC_IRQHandler             ; RTC                DCD     FLASH_IRQHandler           ; Flash                DCD     RCC_IRQHandler             ; RCC                DCD     EXTI0_IRQHandler           ; EXTI Line 0                DCD     EXTI1_IRQHandler           ; EXTI Line 1                DCD     EXTI2_IRQHandler           ; EXTI Line 2                DCD     EXTI3_IRQHandler           ; EXTI Line 3                DCD     EXTI4_IRQHandler           ; EXTI Line 4                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7                DCD     ADC1_2_IRQHandler          ; ADC1 &amp; ADC2                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break                DCD     TIM1_UP_IRQHandler         ; TIM1 Update                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare                DCD     TIM2_IRQHandler            ; TIM2                DCD     TIM3_IRQHandler            ; TIM3                DCD     TIM4_IRQHandler            ; TIM4                DCD     I2C1_EV_IRQHandler         ; I2C1 Event                DCD     I2C1_ER_IRQHandler         ; I2C1 Error                DCD     I2C2_EV_IRQHandler         ; I2C2 Event                DCD     I2C2_ER_IRQHandler         ; I2C2 Error                DCD     SPI1_IRQHandler            ; SPI1                DCD     SPI2_IRQHandler            ; SPI2                DCD     USART1_IRQHandler          ; USART1                DCD     USART2_IRQHandler          ; USART2                DCD     USART3_IRQHandler          ; USART3                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10                DCD     RTC_Alarm_IRQHandler        ; RTC Alarm through EXTI Line                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break                DCD     TIM8_UP_IRQHandler         ; TIM8 Update                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare                DCD     ADC3_IRQHandler            ; ADC3                DCD     FSMC_IRQHandler            ; FSMC                DCD     SDIO_IRQHandler            ; SDIO                DCD     TIM5_IRQHandler            ; TIM5                DCD     SPI3_IRQHandler            ; SPI3                DCD     UART4_IRQHandler           ; UART4                DCD     UART5_IRQHandler           ; UART5                DCD     TIM6_IRQHandler            ; TIM6                DCD     TIM7_IRQHandler            ; TIM7                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5__Vectors_End__Vectors_Size  EQU  __Vectors_End - __Vectors</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;4-复位中断程序，系统上电后第一个要执行的程序;调用外部 SystemInit() 函数初始化系统时钟，然后调用 C 库函数_mian()，最终调用 main()函数去到 C 的世界。               ; Reset handlerReset_Handler   PROC                EXPORT  Reset_Handler             [WEAK]                IMPORT  __main                IMPORT  SystemInit                LDR     R0, =SystemInit                BLX     R0                               LDR     R0, =__main                BX      R0                ENDP</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;5-空的中断服务函数，[WEAK]弱声明无限循环函数，用户可以对其进行重定义。             ; Dummy Exception Handlers (infinite loops which can be modified)NMI_Handler     PROC                EXPORT  NMI_Handler                [WEAK]                B       .                ENDPHardFault_Handler\                PROC                EXPORT  HardFault_Handler          [WEAK]                B       .                ENDPMemManage_Handler\                PROC                EXPORT  MemManage_Handler          [WEAK]                B       .                ENDPBusFault_Handler\                PROC                EXPORT  BusFault_Handler           [WEAK]                B       .                ENDPUsageFault_Handler\                PROC                EXPORT  UsageFault_Handler         [WEAK]                B       .                ENDPSVC_Handler     PROC                EXPORT  SVC_Handler                [WEAK]                B       .                ENDPDebugMon_Handler\                PROC                EXPORT  DebugMon_Handler           [WEAK]                B       .                ENDPPendSV_Handler  PROC                EXPORT  PendSV_Handler             [WEAK]                B       .                ENDPSysTick_Handler PROC                EXPORT  SysTick_Handler            [WEAK]                B       .                ENDPDefault_Handler PROC                EXPORT  WWDG_IRQHandler            [WEAK]                EXPORT  PVD_IRQHandler             [WEAK]                EXPORT  TAMPER_IRQHandler          [WEAK]                EXPORT  RTC_IRQHandler             [WEAK]                EXPORT  FLASH_IRQHandler           [WEAK]                EXPORT  RCC_IRQHandler             [WEAK]                EXPORT  EXTI0_IRQHandler           [WEAK]                EXPORT  EXTI1_IRQHandler           [WEAK]                EXPORT  EXTI2_IRQHandler           [WEAK]                EXPORT  EXTI3_IRQHandler           [WEAK]                EXPORT  EXTI4_IRQHandler           [WEAK]                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]                EXPORT  ADC1_2_IRQHandler          [WEAK]                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]                EXPORT  CAN1_RX1_IRQHandler        [WEAK]                EXPORT  CAN1_SCE_IRQHandler        [WEAK]                EXPORT  EXTI9_5_IRQHandler         [WEAK]                EXPORT  TIM1_BRK_IRQHandler        [WEAK]                EXPORT  TIM1_UP_IRQHandler         [WEAK]                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]                EXPORT  TIM1_CC_IRQHandler         [WEAK]                EXPORT  TIM2_IRQHandler            [WEAK]                EXPORT  TIM3_IRQHandler            [WEAK]                EXPORT  TIM4_IRQHandler            [WEAK]                EXPORT  I2C1_EV_IRQHandler         [WEAK]                EXPORT  I2C1_ER_IRQHandler         [WEAK]                EXPORT  I2C2_EV_IRQHandler         [WEAK]                EXPORT  I2C2_ER_IRQHandler         [WEAK]                EXPORT  SPI1_IRQHandler            [WEAK]                EXPORT  SPI2_IRQHandler            [WEAK]                EXPORT  USART1_IRQHandler          [WEAK]                EXPORT  USART2_IRQHandler          [WEAK]                EXPORT  USART3_IRQHandler          [WEAK]                EXPORT  EXTI15_10_IRQHandler       [WEAK]                EXPORT  RTC_Alarm_IRQHandler        [WEAK]                EXPORT  USBWakeUp_IRQHandler       [WEAK]                EXPORT  TIM8_BRK_IRQHandler        [WEAK]                EXPORT  TIM8_UP_IRQHandler         [WEAK]                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]                EXPORT  TIM8_CC_IRQHandler         [WEAK]                EXPORT  ADC3_IRQHandler            [WEAK]                EXPORT  FSMC_IRQHandler            [WEAK]                EXPORT  SDIO_IRQHandler            [WEAK]                EXPORT  TIM5_IRQHandler            [WEAK]                EXPORT  SPI3_IRQHandler            [WEAK]                EXPORT  UART4_IRQHandler           [WEAK]                EXPORT  UART5_IRQHandler           [WEAK]                EXPORT  TIM6_IRQHandler            [WEAK]                EXPORT  TIM7_IRQHandler            [WEAK]                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]WWDG_IRQHandlerPVD_IRQHandlerTAMPER_IRQHandlerRTC_IRQHandlerFLASH_IRQHandlerRCC_IRQHandlerEXTI0_IRQHandlerEXTI1_IRQHandlerEXTI2_IRQHandlerEXTI3_IRQHandlerEXTI4_IRQHandlerDMA1_Channel1_IRQHandlerDMA1_Channel2_IRQHandlerDMA1_Channel3_IRQHandlerDMA1_Channel4_IRQHandlerDMA1_Channel5_IRQHandlerDMA1_Channel6_IRQHandlerDMA1_Channel7_IRQHandlerADC1_2_IRQHandlerUSB_HP_CAN1_TX_IRQHandlerUSB_LP_CAN1_RX0_IRQHandlerCAN1_RX1_IRQHandlerCAN1_SCE_IRQHandlerEXTI9_5_IRQHandlerTIM1_BRK_IRQHandlerTIM1_UP_IRQHandlerTIM1_TRG_COM_IRQHandlerTIM1_CC_IRQHandlerTIM2_IRQHandlerTIM3_IRQHandlerTIM4_IRQHandlerI2C1_EV_IRQHandlerI2C1_ER_IRQHandlerI2C2_EV_IRQHandlerI2C2_ER_IRQHandlerSPI1_IRQHandlerSPI2_IRQHandlerUSART1_IRQHandlerUSART2_IRQHandlerUSART3_IRQHandlerEXTI15_10_IRQHandlerRTC_Alarm_IRQHandlerUSBWakeUp_IRQHandlerTIM8_BRK_IRQHandlerTIM8_UP_IRQHandlerTIM8_TRG_COM_IRQHandlerTIM8_CC_IRQHandlerADC3_IRQHandlerFSMC_IRQHandlerSDIO_IRQHandlerTIM5_IRQHandlerSPI3_IRQHandlerUART4_IRQHandlerUART5_IRQHandlerTIM6_IRQHandlerTIM7_IRQHandlerDMA2_Channel1_IRQHandlerDMA2_Channel2_IRQHandlerDMA2_Channel3_IRQHandlerDMA2_Channel4_5_IRQHandler                B       .                ENDP                ALIGN</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;6-将堆栈地址传递给C库函数_main()，利用C库函数初始化堆栈或由用户自己初始化堆栈。;*******************************************************************************; User Stack and Heap initialization;*******************************************************************************                 IF      :DEF:__MICROLIB  ;#keil-MDK IDE勾选MicroLIB宏                ;#赋予以下三个标号全局属性                 EXPORT  __initial_sp                 EXPORT  __heap_base                 EXPORT  __heap_limit                                 ELSE        ;#keil-MDK IDE没有勾选MicroLIB宏                                 IMPORT  __use_two_region_memory ;#导入双段存储器模式，需要用户自己实现。                 EXPORT  __user_initial_stackheap ;#赋予标号__user_initial_stackheap全局属性                 __user_initial_stackheap                 LDR     R0, =  Heap_Mem                 LDR     R1, =(Stack_Mem + Stack_Size)                 LDR     R2, = (Heap_Mem +  Heap_Size)                 LDR     R3, = Stack_Mem                 BX      LR                 ALIGN</code></pre></div><p><a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/startup_stm32f103xe.zip">启动文件与正点原子详解附件</a></p><p>参考链接：</p><p>https://www.elecfans.com/news/1802838.html</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道程序一般是从&lt;code&gt;main&lt;/code&gt;函数开始运行的，但在&lt;code&gt;main&lt;/code&gt;函数运行之前，程序已经做了一些准备工作，对于STM32F1芯片，这些准备工作是通过启动文件来完成的。下面来详细看看stm32库中的启动代码文件（STM32Cube_F</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="startup" scheme="http://example.com/tags/startup/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_sd库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T10:30:31.000Z</published>
    <updated>2023-08-14T00:03:33.381Z</updated>
    
    <content type="html"><![CDATA[<p>Secure Digital,简称SD,SD内存卡是一种使用非常广泛的存储设备，以下来看看HAL库关于SD卡的使用方法。</p><h3 id="sd外设库的使用">SD外设库的使用</h3><p>这是一个通用分层的SDIO存储驱动，它使用HAL SDIO驱动函数来连接SD内存卡。</p><p><strong>1. 初始化SDIO底层。HAL_SD_MspInit()</strong></p><ul><li>使能SDIO接口时钟。__HAL_RCC_SDIO_CLK_ENABLE()</li><li>配置SDIO引脚<ul><li>使能SDIO GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置SDIO引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_SD_ReadBlocks_DMA() ， HAL_SD_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDIO和DMA中断优先级，DMA优先级高于SDIO。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code> ， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code> ，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_SD_ReadBlocks_IT()，HAL_SD_WriteBlocks_IT()<ul><li>配置SDIO中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code> ， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code> ，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. SD卡的初始化和配置</strong></p><p>使用HAL_SD_Init()函数来初始化SD卡，并进入睡眠状态（已准备好数据传输）。SD卡初始化后，就可以执行SD卡的读、写、擦除操作。</p><ul><li><p>以400KHz的频率配置初始化SD卡。</p><p>SD卡频率：SDIO_CK = SDIOCLK / (ClockDiv + 2)；</p><p>初始化时，根据SD卡标准，确保SDIO_CK频率不要超过400KHz，通过SDIO底层函数 SDIO_Init()和SDIO_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化SD卡。HAL_SD_InitCard()</p><p>这个函数用于初始化和识别SDIO及检查SD卡的类型（标准容量或高容量），此初始化流程与SD卡标准兼容。这个函数也可以在插拔时重新初始化SD卡。</p></li><li><p>配置SD卡数据传输频率，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据SD卡标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDIO外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的SD卡。</p></li><li><p>配置SD卡宽总线模式：4位数据。</p></li></ul><p><strong>3. SD卡的读操作</strong></p><ul><li><p>轮询模式下读取SD卡。HAL_SD_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态。</p></li><li><p>DMA模式下读取SD卡。HAL_SD_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Rx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取SD卡。HAL_SD_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Rx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. SD卡的写操作</strong></p><ul><li><p>轮询模式下向SD卡写操作。HAL_SD_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD卡的状态。</p></li><li><p>DMA模式下向SD卡写操作。HAL_SD_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Tx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向SD卡写操作。HAL_SD_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Tx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取SD卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取SD卡信息。HAL_SDIO_GetCardInfo()</p><p>它会返回关于SD卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_SDIO_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_SDIO_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="sd-hal常用宏定义列表">SD HAL常用宏定义列表</h3><ul><li><p>__HAL_SD_ENABLE : 使能 SD设备</p></li><li><p>__HAL_SD_DISABLE : 禁止 SD 设备</p></li><li><p>__HAL_SD_DMA_ENABLE: 使能 SD DMA 传输</p></li><li><p>__HAL_SD_DMA_DISABLE: 禁止 SD DMA 传输</p></li><li><p>__HAL_SD_ENABLE_IT: 使能 SD 设备中断</p></li><li><p>__HAL_SD_DISABLE_IT: 禁止 SD 设备中断</p></li><li><p>__HAL_SD_GET_FLAG:检查 SD 标志是否设置</p></li><li><p>__HAL_SD_CLEAR_FLAG: 清除 SD 的挂起标志</p></li></ul><h3 id="sd回调函数的注册">SD回调函数的注册</h3><p>当 USE_HAL_SD_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_SD_RegisterCallback(), HAL_SD_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>ErrorCallback : 发生错误回调函数</li><li>AbortCpltCallback : 中止完成回调函数</li><li>MspInitCallback : SD 相关MCU初始化回调函数</li><li>MspDeInitCallback : SD 相关MCU去初始化回调函数</li></ul><p>默认情况下, SD 初始化（HAL_SD_Init()）后，当状态是 HAL_SD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SD_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Secure Digital,简称SD,SD内存卡是一种使用非常广泛的存储设备，以下来看看HAL库关于SD卡的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;sd外设库的使用&quot;&gt;SD外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用分层的SDIO存储驱动，它使用HAL SDIO驱动函数来连</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sd" scheme="http://example.com/tags/sd/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_mmc库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T09:30:31.000Z</published>
    <updated>2023-08-14T00:03:33.327Z</updated>
    
    <content type="html"><![CDATA[<p>MultiMediaCard,简称MMC,它属于SD卡的一种，是一种一体化、可拆卸、多功能的内存卡,以下来看看HAL库关于MMC的使用方法。</p><h3 id="mmc外设库的使用">MMC外设库的使用</h3><p>这是一个通用分层的MMC存储器驱动，它使用HAL SDMMC 驱动函数来连接MMC和eMMC卡。</p><p><strong>1. 初始化MMC底层。HAL_MMC_MspInit()</strong></p><ul><li>使能MMC接口时钟。__HAL_RCC_SDMMC_CLK_ENABLE()</li><li>配置MMC引脚<ul><li>使能MMC GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置MMC引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_MMC_ReadBlocks_DMA() ， HAL_MMC_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDMMC和DMA中断优先级，DMA优先级高于SDMMC。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code> ， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code> ，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_MMC_ReadBlocks_IT()，HAL_MMC_WriteBlocks_IT()<ul><li>配置SDMMC中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code> ， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code> ，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. MMC的初始化和配置</strong></p><p>使用HAL_MMC_Init()函数来初始化SDMMC，并进入睡眠状态（已准备好数据传输）。MMC卡初始化后，就可以执行MMC 读、写、擦除操作。</p><ul><li><p>使用默认配置初始化SDMMC外设接口。默认频率：400KHz。</p><p>MMC频率：SDMMC_CK = SDMMCCLK / (ClockDiv + 2)；</p><p>初始化时，根据MMC标准，确保SDMMC_CK频率不要超过400KHz，通过SDMMC底层函数 SDMMC_Init()和SDMMC_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化MMC卡。HAL_MMC_InitCard()</p><p>这个函数用于初始化和识别MMC及检查MMC卡的类型（标准容量或高容量），此初始化流程与MMC标准兼容。这个函数也可以在插拔时重新初始化MMC卡。</p></li><li><p>配置MMC卡数据传输频率，默认传输频率是24MHz，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据MMC标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDMMC外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的MMC卡。</p></li><li><p>配置MMC宽总线模式：4位数据。</p></li></ul><p><strong>3. MMC的读操作</strong></p><ul><li><p>轮询模式下读取MMC卡。HAL_MMC_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下读取MMC卡。HAL_MMC_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Rx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取MMC卡。HAL_MMC_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Rx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. MMC的写操作</strong></p><ul><li><p>轮询模式下向MMC卡写操作。HAL_MMC_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下向MMC卡写操作。HAL_MMC_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Tx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向MMC卡写操作。HAL_MMC_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Tx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取MMC卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取MMC卡信息。HAL_MMC_GetCardInfo()</p><p>它会返回关于MMC卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_MMC_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_MMC_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="mmc-hal常用宏定义列表">MMC HAL常用宏定义列表</h3><ul><li><p>__HAL_MMC_ENABLE : 使能 MMC设备</p></li><li><p>__HAL_MMC_DISABLE : 禁止 MMC 设备</p></li><li><p>__HAL_MMC_DMA_ENABLE: 使能 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_DMA_DISABLE: 禁止 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_ENABLE_IT: 使能 MMC 设备中断</p></li><li><p>__HAL_MMC_DISABLE_IT: 禁止 MMC 设备中断</p></li><li><p>__HAL_MMC_GET_FLAG:检查 MMC 标志是否设置</p></li><li><p>__HAL_MMC_CLEAR_FLAG: 清除 MMC 的挂起标志</p></li></ul><h3 id="mmc回调函数的注册">MMC回调函数的注册</h3><p>当 USE_HAL_MMC_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_MMC_RegisterCallback(), HAL_MMC_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>ErrorCallback : 发生错误回调函数</li><li>AbortCpltCallback : 中止完成回调函数</li><li>MspInitCallback : MMC 相关MCU初始化回调函数</li><li>MspDeInitCallback : MMC 相关MCU去初始化回调函数</li></ul><p>默认情况下, MMC 初始化（HAL_MMC_Init()）后，当状态是 HAL_MMC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_MMC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_MMC_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MultiMediaCard,简称MMC,它属于SD卡的一种，是一种一体化、可拆卸、多功能的内存卡,以下来看看HAL库关于MMC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;mmc外设库的使用&quot;&gt;MMC外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用分层的MMC存储器驱动，它使用HA</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="mmc" scheme="http://example.com/tags/mmc/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_nor库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T04:15:11.000Z</published>
    <updated>2023-08-14T00:03:33.347Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于Nor flash存储器的使用方法。</p><h3 id="nor存储器外设库的使用">NOR存储器外设库的使用</h3><p>此驱动是一个通用的分层驱动程序，包含一组用于控制NOR闪存的API。它使用FSMC层函数来连接NOR 闪存。</p><ol type="1"><li><p>配置NOR flash 存储器的控制和时序参数。HAL_NOR_Init()</p></li><li><p>读取NOR flash 存储器制造商和设备ID。HAL_NOR_Read_ID()</p><p>读取的信息存储在函数调用的NOR_ID_TypeDef类型结构体中。</p></li><li><p>对NOR flash存储器进行读写操作。HAL_NOR_Read(), HAL_NOR_Program()</p></li><li><p>执行NOR flash块擦除或芯片擦除操作。 HAL_NOR_Erase_Block() , HAL_NOR_Erase_Chip()</p></li><li><p>读取NOR flash的通用闪存接口ID（CFI IDs）。HAL_NOR_Read_CFI()</p><p>读取的信息存储在被上述函数调用的已声明NOR_CFI_TypeDef结构体中。</p></li><li><p>可分别通过调用 HAL_NOR_WriteOperation_Enable() / HAL_NOR_WriteOperation_Disable()函数来使能/禁止 NOR Flash的写操作，从而控制NOR Flash设备。</p></li><li><p>监测NOR设备状态。 HAL_NOR_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通NOR flash操作APIs。如果NOR flash设备包含不同的操作和方法，应该单独实施。</p><h3 id="nor存储器外设常用宏定义">NOR存储器外设常用宏定义</h3><ul><li>NOR_WRITE : NOR 存储器向指定的地址写入数据。</li></ul><h3 id="nor存储器回调函数的注册">NOR存储器回调函数的注册</h3><p>当 USE_HAL_NOR_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_NOR_RegisterCallback(), HAL_NOR_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : NOR 相关MCU初始化回调函数</li><li>MspDeInitCallback : NOR 相关MCU去初始化回调函数</li></ul><p>默认情况下, NOR 初始化（HAL_NOR_Init()）后，当状态是 HAL_NOR_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_NOR_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_NOR_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于Nor flash存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;nor存储器外设库的使用&quot;&gt;NOR存储器外设库的使用&lt;/h3&gt;
&lt;p&gt;此驱动是一个通用的分层驱动程序，包含一组用于控制NOR闪存的API。它使用FSMC层函数来连接NOR 闪存。&lt;/p&gt;</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="nor" scheme="http://example.com/tags/nor/"/>
    
  </entry>
  
</feed>
