<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-07T13:00:33.830Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>stm32f1xx_hal_sd库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T10:30:31.000Z</published>
    <updated>2023-08-07T13:00:33.830Z</updated>
    
    <content type="html"><![CDATA[<p>SecureDigital,简称SD,SD内存卡是一种使用非常广泛的存储设备，以下来看看HAL库关于SD卡的使用方法。</p><h3 id="sd外设库的使用">SD外设库的使用</h3><p>这是一个通用分层的SDIO存储驱动，它使用HALSDIO驱动函数来连接SD内存卡。</p><p><strong>1. 初始化SDIO底层。HAL_SD_MspInit()</strong></p><ul><li>使能SDIO接口时钟。__HAL_RCC_SDIO_CLK_ENABLE()</li><li>配置SDIO引脚<ul><li>使能SDIO GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置SDIO引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_SD_ReadBlocks_DMA() ，HAL_SD_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDIO和DMA中断优先级，DMA优先级高于SDIO。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code>， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code>，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_SD_ReadBlocks_IT()，HAL_SD_WriteBlocks_IT()<ul><li>配置SDIO中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code>， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code>，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. SD卡的初始化和配置</strong></p><p>使用HAL_SD_Init()函数来初始化SD卡，并进入睡眠状态（已准备好数据传输）。SD卡初始化后，就可以执行SD卡的读、写、擦除操作。</p><ul><li><p>以400KHz的频率配置初始化SD卡。</p><p>SD卡频率：SDIO_CK = SDIOCLK / (ClockDiv + 2)；</p><p>初始化时，根据SD卡标准，确保SDIO_CK频率不要超过400KHz，通过SDIO底层函数SDIO_Init()和SDIO_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化SD卡。HAL_SD_InitCard()</p><p>这个函数用于初始化和识别SDIO及检查SD卡的类型（标准容量或高容量），此初始化流程与SD卡标准兼容。这个函数也可以在插拔时重新初始化SD卡。</p></li><li><p>配置SD卡数据传输频率，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据SD卡标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDIO外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的SD卡。</p></li><li><p>配置SD卡宽总线模式：4位数据。</p></li></ul><p><strong>3. SD卡的读操作</strong></p><ul><li><p>轮询模式下读取SD卡。HAL_SD_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态。</p></li><li><p>DMA模式下读取SD卡。HAL_SD_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDRx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取SD卡。HAL_SD_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDRx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. SD卡的写操作</strong></p><ul><li><p>轮询模式下向SD卡写操作。HAL_SD_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD卡的状态。</p></li><li><p>DMA模式下向SD卡写操作。HAL_SD_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDTx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向SD卡写操作。HAL_SD_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDTx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取SD卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取SD卡信息。HAL_SDIO_GetCardInfo()</p><p>它会返回关于SD卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_SDIO_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_SDIO_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="sd-hal常用宏定义列表">SD HAL常用宏定义列表</h3><ul><li><p>__HAL_SD_ENABLE : 使能 SD设备</p></li><li><p>__HAL_SD_DISABLE : 禁止 SD 设备</p></li><li><p>__HAL_SD_DMA_ENABLE: 使能 SD DMA 传输</p></li><li><p>__HAL_SD_DMA_DISABLE: 禁止 SD DMA 传输</p></li><li><p>__HAL_SD_ENABLE_IT: 使能 SD 设备中断</p></li><li><p>__HAL_SD_DISABLE_IT: 禁止 SD 设备中断</p></li><li><p>__HAL_SD_GET_FLAG:检查 SD 标志是否设置</p></li><li><p>__HAL_SD_CLEAR_FLAG: 清除 SD 的挂起标志</p></li></ul><h3 id="sd回调函数的注册">SD回调函数的注册</h3><p>当 USE_HAL_SD_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SD_RegisterCallback(),HAL_SD_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>ErrorCallback : 发生错误回调函数</li><li>AbortCpltCallback : 中止完成回调函数</li><li>MspInitCallback : SD 底层初始化回调函数</li><li>MspDeInitCallback : SD 底层析构回调函数</li></ul><p>默认情况下, SD 初始化（HAL_SD_Init()）后，当状态是HAL_SD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SD_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Secure
Digital,简称SD,SD内存卡是一种使用非常广泛的存储设备，以下来看看HAL库关于SD卡的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;sd外设库的使用&quot;&gt;SD外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用分层的SDIO存储驱动，它使用HAL
SDIO驱动函数</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sd" scheme="http://example.com/tags/sd/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_mmc库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T09:30:31.000Z</published>
    <updated>2023-08-07T11:56:52.191Z</updated>
    
    <content type="html"><![CDATA[<p>MultiMediaCard,简称MMC,它属于SD卡的一种，是一种一体化、可拆卸、多功能的内存卡,以下来看看HAL库关于MMC的使用方法。</p><h3 id="mmc外设库的使用">MMC外设库的使用</h3><p>这是一个通用分层的MMC存储器驱动，它使用HAL SDMMC驱动函数来连接MMC和eMMC卡。</p><p><strong>1. 初始化MMC底层。HAL_MMC_MspInit()</strong></p><ul><li>使能MMC接口时钟。__HAL_RCC_SDMMC_CLK_ENABLE()</li><li>配置MMC引脚<ul><li>使能MMC GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置MMC引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_MMC_ReadBlocks_DMA() ，HAL_MMC_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDMMC和DMA中断优先级，DMA优先级高于SDMMC。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code>， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code>，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_MMC_ReadBlocks_IT()，HAL_MMC_WriteBlocks_IT()<ul><li>配置SDMMC中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code>， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code>，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. MMC的初始化和配置</strong></p><p>使用HAL_MMC_Init()函数来初始化SDMMC，并进入睡眠状态（已准备好数据传输）。MMC卡初始化后，就可以执行MMC读、写、擦除操作。</p><ul><li><p>使用默认配置初始化SDMMC外设接口。默认频率：400KHz。</p><p>MMC频率：SDMMC_CK = SDMMCCLK / (ClockDiv + 2)；</p><p>初始化时，根据MMC标准，确保SDMMC_CK频率不要超过400KHz，通过SDMMC底层函数SDMMC_Init()和SDMMC_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化MMC卡。HAL_MMC_InitCard()</p><p>这个函数用于初始化和识别MMC及检查MMC卡的类型（标准容量或高容量），此初始化流程与MMC标准兼容。这个函数也可以在插拔时重新初始化MMC卡。</p></li><li><p>配置MMC卡数据传输频率，默认传输频率是24MHz，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据MMC标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDMMC外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的MMC卡。</p></li><li><p>配置MMC宽总线模式：4位数据。</p></li></ul><p><strong>3. MMC的读操作</strong></p><ul><li><p>轮询模式下读取MMC卡。HAL_MMC_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下读取MMC卡。HAL_MMC_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCRx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取MMC卡。HAL_MMC_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCRx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. MMC的写操作</strong></p><ul><li><p>轮询模式下向MMC卡写操作。HAL_MMC_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下向MMC卡写操作。HAL_MMC_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCTx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向MMC卡写操作。HAL_MMC_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCTx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取MMC卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取MMC卡信息。HAL_MMC_GetCardInfo()</p><p>它会返回关于MMC卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_MMC_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_MMC_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="mmc-hal常用宏定义列表">MMC HAL常用宏定义列表</h3><ul><li><p>__HAL_MMC_ENABLE : 使能 MMC设备</p></li><li><p>__HAL_MMC_DISABLE : 禁止 MMC 设备</p></li><li><p>__HAL_MMC_DMA_ENABLE: 使能 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_DMA_DISABLE: 禁止 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_ENABLE_IT: 使能 MMC 设备中断</p></li><li><p>__HAL_MMC_DISABLE_IT: 禁止 MMC 设备中断</p></li><li><p>__HAL_MMC_GET_FLAG:检查 MMC 标志是否设置</p></li><li><p>__HAL_MMC_CLEAR_FLAG: 清除 MMC 的挂起标志</p></li></ul><h3 id="mmc回调函数的注册">MMC回调函数的注册</h3><p>当 USE_HAL_MMC_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_MMC_RegisterCallback(),HAL_MMC_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : callback when a transmission transfer iscompleted.</li><li>RxCpltCallback : callback when a reception transfer iscompleted.</li><li>ErrorCallback : callback when error occurs.</li><li>AbortCpltCallback : callback when abort is completed.</li><li>MspInitCallback : MMC 底层初始化回调函数</li><li>MspDeInitCallback : MMC 底层析构回调函数</li></ul><p>默认情况下, MMC 初始化（HAL_MMC_Init()）后，当状态是HAL_MMC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_MMC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_MMC_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MultiMediaCard,简称MMC,它属于SD卡的一种，是一种一体化、可拆卸、多功能的内存卡,以下来看看HAL库关于MMC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;mmc外设库的使用&quot;&gt;MMC外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用分层的MMC存储器驱动，它使用HA</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="mmc" scheme="http://example.com/tags/mmc/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_nor库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T04:15:11.000Z</published>
    <updated>2023-08-07T05:34:38.718Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于Nor flash存储器的使用方法。</p><h3 id="nor存储器外设库的使用">NOR存储器外设库的使用</h3><p>此驱动是一个通用的分层驱动程序，包含一组用于控制NOR闪存的API。它使用FSMC层函数来连接NOR闪存。</p><ol type="1"><li><p>配置NOR flash 存储器的控制和时序参数。HAL_NOR_Init()</p></li><li><p>读取NOR flash 存储器制造商和设备ID。HAL_NOR_Read_ID()</p><p>读取的信息存储在函数调用的NOR_ID_TypeDef类型结构体中。</p></li><li><p>对NOR flash存储器进行读写操作。HAL_NOR_Read(),HAL_NOR_Program()</p></li><li><p>执行NOR flash块擦除或芯片擦除操作。 HAL_NOR_Erase_Block() ,HAL_NOR_Erase_Chip()</p></li><li><p>读取NOR flash的通用闪存接口ID（CFI IDs）。HAL_NOR_Read_CFI()</p><p>读取的信息存储在被上述函数调用的已声明NOR_CFI_TypeDef结构体中。</p></li><li><p>可分别通过调用 HAL_NOR_WriteOperation_Enable() /HAL_NOR_WriteOperation_Disable()函数来使能/禁止 NORFlash的写操作，从而控制NOR Flash设备。</p></li><li><p>监测NOR设备状态。 HAL_NOR_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通NOR flash操作APIs。如果NORflash设备包含不同的操作和方法，应该单独实施。</p><h3 id="nor存储器外设常用宏定义">NOR存储器外设常用宏定义</h3><ul><li>NOR_WRITE : NOR 存储器向指定的地址写入数据。</li></ul><h3 id="nor存储器回调函数的注册">NOR存储器回调函数的注册</h3><p>当 USE_HAL_NOR_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_NOR_RegisterCallback(),HAL_NOR_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : NOR 底层初始化回调函数</li><li>MspDeInitCallback : NOR 底层析构回调函数</li></ul><p>默认情况下, NOR 初始化（HAL_NOR_Init()）后，当状态是HAL_NOR_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_NOR_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_NOR_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于Nor flash存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;nor存储器外设库的使用&quot;&gt;NOR存储器外设库的使用&lt;/h3&gt;
&lt;p&gt;此驱动是一个通用的分层驱动程序，包含一组用于控制NOR闪存的API。它使用FSMC层函数来连接NOR
闪存。&lt;/p</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="nor" scheme="http://example.com/tags/nor/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_pccard库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-pccard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-pccard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T04:15:11.000Z</published>
    <updated>2023-08-07T05:42:50.629Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于PCCARD存储器的使用方法。</p><h3 id="pccard存储器外设库的使用">PCCARD存储器外设库的使用</h3><p>此驱动是一个通用的分层驱动程序，包含一组用于控制PCCARD/小型闪存的API。它使用FSMC层函数来连接PCCARD存储器。</p><ol type="1"><li><p>配置PCCARD/小型闪存的控制和时序参数。HAL_PCCARD_Init()/HAL_CF_Init()</p></li><li><p>读取PCCARD/小型闪存制造商和设备ID。HAL_PCCARD_Read_ID()/HAL_CF_Read_ID()</p><p>读取的信息存储在函数调用的CompactFlash_ID结构体中。</p></li><li><p>对PCCARD/小型闪存进行扇区读写操作：</p><ul><li><p>HAL_PCCARD_Read_Sector()/ HAL_PCCARD_Write_Sector()</p></li><li><p>HAL_CF_Read_Sector()/HAL_CF_Write_Sector()</p></li></ul></li><li><p>执行PCCARD/小型闪存复位操作。HAL_PCCARD_Reset()/HAL_CF_Reset()</p></li><li><p>执行PCCARD/小型闪存扇区擦除操作。HAL_PCCARD_Erase_Sector()/HAL_CF_Erase_Sector()</p></li><li><p>读取PCCARD/小型闪存的状态。HAL_PCCARD_ReadStatus()/HAL_CF_ReadStatus()</p></li><li><p>监测PCCARD/小型闪存的状态。HAL_PCCARD_GetState()/HAL_CF_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通PCCARD/小型闪存操作API。如果PCCARD/小型闪存设备包含不同的操作和方法，应该单独实施。</p><h3 id="pccard存储器回调函数的注册">PCCARD存储器回调函数的注册</h3><p>当 USE_HAL_PCCARD_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_PCCARD_RegisterCallback(),HAL_PCCARD_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : PCCARD 底层初始化回调函数</li><li>MspDeInitCallback : PCCARD 底层析构回调函数</li></ul><p>默认情况下, PCCARD 初始化（HAL_PCCARD_Init()）后，当状态是HAL_PCCARD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_PCCARD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_PCCARD_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于PCCARD存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;pccard存储器外设库的使用&quot;&gt;PCCARD存储器外设库的使用&lt;/h3&gt;
&lt;p&gt;此驱动是一个通用的分层驱动程序，包含一组用于控制PCCARD/小型闪存的API。它使用FSMC层函数来连接PC</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="pccard" scheme="http://example.com/tags/pccard/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_nand库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-nand%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-nand%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T14:32:31.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于NAND flash存储器的使用方法。</p><h3 id="nand外设库的使用">NAND外设库的使用</h3><ol type="1"><li><p>配置NAND flash 存储器。HAL_NAND_Init()</p></li><li><p>读取NAND flash 存储器制造商和设备ID。HAL_NAND_Read_ID()</p><p>读取的信息存储在函数调用的NAND_ID_TypeDef类型结构体中。</p></li><li><p>对NAND flash存储器进行读写操作：</p><ul><li>HAL_NAND_Read_Page_8b()/HAL_NAND_Read_SpareArea_8b()</li><li>HAL_NAND_Write_Page_8b()/HAL_NAND_Write_SpareArea_8b()</li><li>HAL_NAND_Read_Page_16b()/HAL_NAND_Read_SpareArea_16b()</li><li>HAL_NAND_Write_Page_16b()/HAL_NAND_Write_SpareArea_16b()</li></ul><p>这些函数使用用户在 NAND_DeviceConfigTypeDef结构体中预定义的设备信息(块、页面大小等)，结构体中包含读写地址信息。</p></li><li><p>执行NAND flash复位操作。HAL_NAND_Reset()</p></li><li><p>执行NAND flash块擦除操作。HAL_NAND_Erase_Block()</p><p>块擦除信息作为参数传入Nand_Address_Typedef结构体。</p></li><li><p>读取NAND flash的状态操作。HAL_NAND_Read_Status()</p></li><li><p>分别通过调用 HAL_NAND_ECC_Enable() /HAL_NAND_ECC_Disable()函数来使能/禁止 ECC码更正特性，或通过HAL_NAND_GetECC() 函数获取 ECC更正码，从而控制NAND 设备。</p></li><li><p>监测NAND设备状态。 HAL_NAND_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通NAND flash操作APIs。如果NANDflash设备包含不同的操作和方法，应该单独实施。</p><h3 id="nand回调函数的注册">NAND回调函数的注册</h3><p>当 USE_HAL_NAND_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_NAND_RegisterCallback(),HAL_NAND_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : NAND 底层初始化回调函数</li><li>MspDeInitCallback : NAND 底层析构回调函数</li></ul><p>默认情况下, NAND 初始化（HAL_NAND_Init()）后，当状态是HAL_NAND_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_NAND_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_NAND_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于NAND flash存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;nand外设库的使用&quot;&gt;NAND外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;配置NAND flash 存储器。HAL_NAND_Init()&lt;/p&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="nand" scheme="http://example.com/tags/nand/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_rtc库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-rtc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-rtc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T13:10:31.000Z</published>
    <updated>2023-08-07T14:39:01.246Z</updated>
    
    <content type="html"><![CDATA[<p>Real TimeClock，简称RTC，实时时钟，以下来看看HAL库关于RTC的使用方法。</p><h3 id="rtc外设库的使用">RTC外设库的使用</h3><ol type="1"><li>使能RTC域。</li><li>配置RTC预分频系数(异步预分频器生成RTC 1Hz时基)。 HAL_RTC_Init()</li><li>配置时间和日期。<ul><li>配置RTC日历(时间和日期)。HAL_RTC_SetTime()，HAL_RTC_SetDate()</li><li>读RTC日历。HAL_RTC_GetTime() ，HAL_RTC_GetDate()</li></ul></li><li>闹钟配置。<ul><li>配置RTC闹钟。HAL_RTC_SetAlarm() ，HAL_RTC_SetAlarm_IT()</li><li>读RTC闹钟。HAL_RTC_GetAlarm()</li></ul></li><li>RTC 入侵检测配置。RTC Tamper<ul><li>使能RTCTamper，配置Tamper电平。HAL_RTCEx_SetTamper()，HAL_RTCEx_SetTamper_IT()</li><li>TAMPER1 复用功能映射到PC13 。</li></ul></li><li>配置备份数据寄存器（Backup Data Registers）<ul><li>向RTC备份数据寄存器写数据。HAL_RTCEx_BKUPWrite()</li><li>读RTC备份数据寄存器。HAL_RTCEx_BKUPRead()</li></ul></li></ol><h3 id="警告-hal-rtc驱动限制条件">==警告: HAL RTC驱动限制条件==</h3><ul><li>STM32F1系列芯片上的RTC版本是V1，F1系列芯片不支持V2版本（其它系列）的所有特性。</li><li>对于V2版本，RTC主要的特性是通过硬件控制的。但在F1芯片，日期特性完全由软件控制。</li><li>跟其它系列芯片相比，F1系列芯片有一些限制：<ul><li>HAL库只支持24小时格式（不支持12小时）。</li><li>日期保存在SRAM中，当MCU处于停止或待机模式时，日期就会丢失。用户应该在进入低功耗模式之前保存日期。（基于备份寄存器的固件包提供了一个示例）</li><li>每次调用时间和日期函数时，日期就会自动更新。HAL_RTC_GetTime()，HAL_RTC_GetDate()</li><li>闹钟检测被限制在一天内，它只会过期一次（无重复闹钟，需要编一个新的闹钟）。</li></ul></li></ul><h3 id="备用域操作条件">备用域操作条件</h3><ul><li>当主电源关闭时，可通过VBAT电源来给RTC和RTC备份寄存器供电。当VDD关闭，为了维持RTC备份寄存器的内容和给RTC供电，VBAT引脚连接到一个电池或其它电源的备用电源。</li><li>当主数字电源（VDD）关闭，为了RTC的操作，VBAT引脚需为以下模块供电：<ul><li>RTC</li><li>LSE振荡器</li><li>使能低功耗备用稳压器时的备用SRAM</li><li>PC13 ~ PC15 I/O引脚，加上 PI8引脚 (当可使用时)</li></ul></li><li>当备用域通过VDD（模拟开关连接到VDD）供电，可使用PC13引脚，用作入侵检测引脚。</li><li>当备用域通过VBAT（模拟开关连接到VBAT，因为VDD不存在）供电，可使用PC13引脚，用作入侵检测引脚。</li></ul><h3 id="备用域复位">备用域复位</h3><ul><li>备用域复位将所有的RTC寄存器和RCC_BDCR寄存器设为复位值。</li><li>当发生以下任一事件，就会产生备用域复位：<ul><li>设置RCC备用域控制寄存器（RCC_BDCR）中的BDRST位触发软件复位。</li><li>如果两个供电之前都关闭了，那么VDD或VBAT电压就会打开。</li><li>入侵检测事件复位所有的数据备份寄存器。</li></ul></li></ul><h3 id="访问备用域">访问备用域</h3><ul><li>复位后, 备用域 (RTC寄存器,RTC备份数据寄存器和备份SRAM)就会被保护，不能进行写操作。</li><li>为了访问RTC域和RTC寄存器，可通过以下方式：<ul><li>调用HAL_RCCEx_PeriphCLKConfig()函数，其中PeriphClockSelection为RCC_PERIPHCLK_RTC，并选择RTCClockSelection(LSE, LSI 或 HSE)。</li><li>使能备用域时钟。__HAL_RCC_BKP_CLK_ENABLE()</li></ul></li></ul><h3 id="rtc和低功耗模式">RTC和低功耗模式</h3><ul><li>通过RTC复用函数可把MCU从低功耗模式中唤醒。</li><li>RTC复用函数是RTC闹钟（闹钟A）和检测RTC入侵事件。这些复用函数可将系统从停止和待机低功耗模式下唤醒。</li><li>系统还可以通过RTC闹钟从低功耗模式下唤醒，而无需依赖外部中断（自动唤醒模式）</li></ul><h3 id="rtc回调函数的注册">RTC回调函数的注册</h3><p>当 USE_HAL_RTC_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_RTC_RegisterCallback(),HAL_RTC_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>AlarmAEventCallback : RTC Alarm A Event callback.</p></li><li><p>Tamper1EventCallback : RTC Tamper 1 Event callback.</p></li><li><p>MspInitCallback : RTC MspInit callback.</p></li><li><p>MspDeInitCallback : RTC MspDeInit callback.</p></li></ul><p>默认情况下, RTC 初始化（HAL_RTC_Init()）后，当状态是HAL_RTC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_RTC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_RTC_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Real Time
Clock，简称RTC，实时时钟，以下来看看HAL库关于RTC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;rtc外设库的使用&quot;&gt;RTC外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;使能RTC域。&lt;/li&gt;
&lt;li&gt;配置RTC预分频系数(</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="rtc" scheme="http://example.com/tags/rtc/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_spi库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-spi%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-spi%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:50:31.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>Serial PeripheralInterface，简称SPI，串行外设接口。以下来看看HAL库关于SPI的使用方法。</p><h3 id="spi外设库的使用">SPI外设库的使用</h3><ol type="1"><li><p>声明一个 SPI_HandleTypeDef 结构体,如：SPI_HandleTypeDefhspi;</p></li><li><p>初始化SPI底层。HAL_SPI_MspInit()</p></li></ol><ul><li>使能SPIx 接口时钟。</li><li>配置SPI引脚<ul><li>使能SPI GPIO 时钟</li><li>配置SPI引脚为复用推挽模式</li></ul></li><li>如果使用到中断，则配置NVIC。<ul><li>配置SPIx 中断优先级</li><li>使能NVIC SPI IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体参数。</li><li>配置DMA Tx或Rx通道。</li><li>将hdma_tx 或hdma_rx 跟 hspi DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置hspi初始化结构体中各参数。</li><li>调用 HAL_SPI_Init() 函数初始化 SPI寄存器。</li></ol><h3 id="循环模式规则">循环模式规则</h3><ul><li>当SPI配置在以下模式时，就不能使用DMA循环模式：<ul><li>主机2线只接收 (Master 2Lines RxOnly)</li><li>主机1线接收 (Master 1Line Rx)</li></ul></li><li>当使能DMA循环模式时，就不能使用CRC功能。</li><li>当使用了SPI DMA暂停/停止功能时，必须只能在SPI回调函数中使用HAL_SPI_DMAPause()/HAL_SPI_DMAStop()函数。</li></ul><h3 id="主机接收模式规则">主机接收模式规则</h3><p>在主机单向接收模式 (MSTR =1, BIDIMODE=0, RXONLY=1) 或双向接收模式(MSTR=1, BIDIMODE=1,BIDIOE=0)，为了确保SPI没有发起新的数据传输，需要重视以下函数：</p><ul><li><p>HAL_SPI_DeInit()</p></li><li><p>HAL_SPI_Init()</p></li></ul><h3 id="spi回调函数的注册">SPI回调函数的注册</h3><p>当 USE_HAL_SPI_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SPI_RegisterCallback(),HAL_SPI_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxCpltCallback : SPI 发送完成回调函数</p></li><li><p>RxCpltCallback : SPI 接收完成回调函数</p></li><li><p>TxRxCpltCallback : SPI 发送接收完成回调函数</p></li><li><p>TxHalfCpltCallback : SPI 发送过半回调函数</p></li><li><p>RxHalfCpltCallback : SPI 接收过半回调函数</p></li><li><p>TxRxHalfCpltCallback : SPI 发送接收过半回调函数</p></li><li><p>ErrorCallback : SPI 错误回调函数</p></li><li><p>AbortCpltCallback : SPI 中止回调函数</p></li><li><p>MspInitCallback : SPI 底层初始化回调函数</p></li><li><p>MspDeInitCallback : SPI 底层析构回调函数</p></li></ul><p>默认情况下, SPI 初始化（HAL_SPI_Init()）后，当状态是HAL_SPI_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SPI_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SPI_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Serial Peripheral
Interface，简称SPI，串行外设接口。以下来看看HAL库关于SPI的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;spi外设库的使用&quot;&gt;SPI外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;声明一个 SPI_Han</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="spi" scheme="http://example.com/tags/spi/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_smartcard库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-smartcard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-smartcard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:32:31.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>Smart Card，智能卡，以下来看看HAL库关于SMARTCARD的使用方法。</p><h3 id="smartcard外设库的使用">SMARTCARD外设库的使用</h3><ol type="1"><li><p>声明一个 SMARTCARD_HandleTypeDef 结构体。</p></li><li><p>初始化SMARTCARD底层。HAL_SMARTCARD_MSMARTCARDnit()</p></li></ol><ul><li>使能SMARTCARDx关联到USARTx 的接口时钟。</li><li>配置SMARTCARD引脚<ul><li>使能SMARTCARD GPIO 时钟</li><li>配置SMARTCARD引脚为复用上拉模式</li></ul></li><li>如果使用到中断（HAL_SMARTCARD_Transmit_IT()，HAL_SMARTCARD_Receive_IT()），则配置NVIC。<ul><li>配置USARTx中断优先级</li><li>使能NVIC USART IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_SMARTCARD_Transmit_DMA()，HAL_SMARTCARD_Receive_DMA()<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体Tx/Rx参数。</li><li>配置DMA Tx或Rx通道。</li><li>将DMA 跟 SMARTCARD DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置SMARTCARD初始化结构体中各参数。</li><li>调用 HAL_SMARTCARD_Init() 函数初始化 SMARTCARD寄存器。</li></ol><p>在发送和接收过程中，使用宏定义 __HAL_SMARTCARD_ENABLE_IT() 和__HAL_SMARTCARD_DISABLE_IT() 来管理SMARTCARD的中断(发送完成中断，接收非空中断，错误中断)。</p><h3 id="smartcard轮询模式io操作">SMARTCARD轮询模式IO操作</h3><ul><li>阻塞方式下，发送一定数量的数据。HAL_SMARTCARD_Transmit()</li><li>阻塞方式下，接收一定数量的数据。HAL_SMARTCARD_Receive()</li></ul><h3 id="smartcard中断模式io操作">SMARTCARD中断模式IO操作</h3><ul><li><p>非阻塞方式下，发送一定数量的数据。HAL_SMARTCARD_Transmit_IT()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_SMARTCARD_TxCpltCallback()</p></li><li><p>非阻塞方式下，接收一定数量的数据。HAL_SMARTCARD_Receive_IT()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_SMARTCARD_RxCpltCallback()</p></li><li><p>传输出错时，执行出错回调函数，用户自行添加代码。HAL_SMARTCARD_ErrorCallback()</p></li></ul><h3 id="smartcard-dma-模式io操作">SMARTCARD DMA 模式IO操作</h3><ul><li><p>非阻塞方式(DMA)下，发送一定数量的数据。HAL_SMARTCARD_Transmit_DMA()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_SMARTCARD_TxCpltCallback()</p></li><li><p>非阻塞方式(DMA)下，接收一定数量的数据。HAL_SMARTCARD_Receive_DMA()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_SMARTCARD_RxCpltCallback()</p></li><li><p>传输出错时，执行出错回调函数，用户自行添加代码。HAL_SMARTCARD_ErrorCallback()</p></li></ul><h3 id="smartcard-常用宏定义">SMARTCARD 常用宏定义</h3><ul><li><p>__HAL_SMARTCARD_ENABLE: 使能SMARTCARD 外设</p></li><li><p>__HAL_SMARTCARD_DISABLE: 禁止SMARTCARD 外设</p></li><li><p>__HAL_SMARTCARD_GET_FLAG : 检查SMARTCARD 标志是否设置</p></li><li><p>__HAL_SMARTCARD_CLEAR_FLAG : 清除 SMARTCARD 挂起标志</p></li><li><p>__HAL_SMARTCARD_ENABLE_IT: 使能 SMARTCARD 中断</p></li><li><p>__HAL_SMARTCARD_DISABLE_IT: 禁止 SMARTCARD 中断</p></li></ul><h3 id="smartcard回调函数的注册">SMARTCARD回调函数的注册</h3><p>当 USE_HAL_SMARTCARD_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SMARTCARD_RegisterCallback(),HAL_SMARTCARD_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxCpltCallback : 发送完成回调函数</p></li><li><p>RxCpltCallback : 接收完成回调函数</p></li><li><p>ErrorCallback : 错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>AbortTransmitCpltCallback : 中止发送完成回调函数</p></li><li><p>AbortReceiveCpltCallback : 中止接收完成回调函数</p></li><li><p>MspInitCallback : SMARTCARD 底层初始化回调函数</p></li><li><p>MspDeInitCallback : SMARTCARD 底层析构回调函数</p></li></ul><p>默认情况下, SMARTCARD 初始化（HAL_SMARTCARD_Init()）后，当状态是HAL_SMARTCARD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SMARTCARD_STATE_READY状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SMARTCARD_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Smart Card，智能卡，以下来看看HAL库关于SMARTCARD的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;smartcard外设库的使用&quot;&gt;SMARTCARD外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;声明一个 SMARTCARD_Handle</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="smartcard" scheme="http://example.com/tags/smartcard/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_tim库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-tim%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-tim%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:20:30.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>timer,简称TIM，定时器是MCU控制中使用最广泛的外设，STM32中有多个TIM，下面来看看HAL库关于TIM的介绍和使用方法。</p><h3 id="tim外设库的一般特性">TIM外设库的一般特性</h3><ul><li>16位向上，向下，向上向下自动重装载计数器</li><li>16位可编程预分频系数，允许对计数器时钟进行 1 ~ 65536 的分频。</li><li>多达4各独立的通道：<ul><li>输入捕获 Input Capture</li><li>输出比较 Output Compare</li><li>产生PWM（边沿和中心对齐模式）</li><li>单脉冲模式输出 One-pulse mode output</li></ul></li><li>用外部信号的同步电路来控制定时器，并将多个定时器互连在一起。</li><li>支持增量编码器的定位目的</li></ul><h3 id="tim外设库的使用">TIM外设库的使用</h3><ol type="1"><li><p>根据所选的功能特性，初始化TIM底层：</p><ul><li>Time Base : HAL_TIM_Base_MspInit()</li><li>Input Capture : HAL_TIM_IC_MspInit()</li><li>Output Compare : HAL_TIM_OC_MspInit()</li><li>PWM generation : HAL_TIM_PWM_MspInit()</li><li>One-pulse mode output : HAL_TIM_OnePulse_MspInit()</li><li>Encoder mode output : HAL_TIM_Encoder_MspInit()</li><li>Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()</li></ul></li><li><p>使能TIM接口时钟。__HAL_RCC_TIMx_CLK_ENABLE()</p></li><li><p>配置TIM引脚。</p><ul><li>使能TIM GPIOs时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置TIM引脚复用功能。HAL_GPIO_Init()</li></ul></li><li><p>默认时钟是来自APBx的内部时钟，如果有需要，可配置外部时钟。HAL_TIM_ConfigClockSource()</p><p>该配置需在任何启动函数之前完成。</p></li><li><p>在所需的功能模式下配置TIM：</p><ul><li><p>使用定时器产生时基（time base）。HAL_TIM_Base_Init()</p></li><li><p>使用定时器产生输出比较信号。 HAL_TIM_OC_Init() ,HAL_TIM_OC_ConfigChannel()</p></li><li><p>使用定时器产生PWM信号。HAL_TIM_PWM_Init() ,HAL_TIM_PWM_ConfigChannel()</p></li><li><p>使用定时器测量外部信号。HAL_TIM_IC_Init() ,HAL_TIM_IC_ConfigChannel()</p></li><li><p>单脉冲模式下使用定时器。HAL_TIM_OnePulse_Init() ,HAL_TIM_OnePulse_ConfigChannel()</p></li><li><p>使用定时器编码接口。HAL_TIM_Encoder_Init()</p></li><li><p>使用定时器 HallSensor接口，如果有需要中断和DMA请求，则配置通信事件。HAL_TIMEx_HallSensor_Init()， HAL_TIMEx_ConfigCommutEvent()</p><p><strong>注意</strong>：一个定时器用于与Hallsensor接口连接，另一个定时器用于通信事件。</p></li></ul></li><li><p>根据功能特性开启TIM外设：</p><ul><li>Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(),HAL_TIM_Base_Start_IT()</li><li>Input Capture : HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(),HAL_TIM_IC_Start_IT()</li><li>Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(),HAL_TIM_OC_Start_IT()</li><li>PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(),HAL_TIM_PWM_Start_IT()</li><li>One-pulse mode output : HAL_TIM_OnePulse_Start(),HAL_TIM_OnePulse_Start_IT()</li><li>Encoder mode output : HAL_TIM_Encoder_Start(),HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT()</li><li>Complementary Output Compare : HAL_TIMEx_OCN_Start(),HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OCN_Start_IT()</li><li>Complementary PWM generation : HAL_TIMEx_PWMN_Start(),HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()</li><li>Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(),HAL_TIMEx_OnePulseN_Start_IT()</li><li>Hall Sensor output : HAL_TIMEx_HallSensor_Start(),HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().</li></ul></li><li><p>管理控制DMA Busrt功能。HAL_TIM_DMABurst_WriteStart()，HAL_TIM_DMABurst_ReadStart()</p></li></ol><h3 id="tim回调函数的注册">TIM回调函数的注册</h3><p>当 USE_HAL_TIM_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_TIM_RegisterCallback(),HAL_TIM_UnRegisterCallback()</p><p>回调函数：</p><ul><li>Base_MspDeInitCallback : TIM 时基底层析构回调函数</li><li>IC_MspInitCallback : TIM 输入捕获底层初始化回调函数</li><li>IC_MspDeInitCallback : TIM 输入捕获底层析构回调函数</li><li>OC_MspInitCallback : TIM 输出比较底层初始化回调函数</li><li>OC_MspDeInitCallback : TIM 输出比较底层析构回调函数</li><li>PWM_MspInitCallback : TIM PWM 底层初始化回调函数</li><li>PWM_MspDeInitCallback : TIM PWM 底层析构回调函数</li><li>OnePulse_MspInitCallback : TIM 单脉冲底层初始化回调函数</li><li>OnePulse_MspDeInitCallback : TIM 单脉冲底层析构回调函数</li><li>Encoder_MspInitCallback : TIM 编码器底层初始化回调函数</li><li>Encoder_MspDeInitCallback : TIM 编码器底层析构回调函数</li><li>HallSensor_MspInitCallback : TIM Hall Sensor 底层初始化回调函数</li><li>HallSensor_MspDeInitCallback : TIM Hall Sensor 析构回调函数</li><li>PeriodElapsedCallback : TIM 周期时间结束回调函数</li><li>PeriodElapsedHalfCpltCallback : TIM 半周期时间结束回调函数</li><li>TriggerCallback : TIM 触发回调函数</li><li>TriggerHalfCpltCallback : TIM 半触发回调函数</li><li>IC_CaptureCallback : TIM 输入捕获回调函数</li><li>IC_CaptureHalfCpltCallback : TIM 半输入捕获回调函数</li><li>OC_DelayElapsedCallback : TIM 输出比较延时回调函数</li><li>PWM_PulseFinishedCallback : TIM PWM 脉冲结束回调函数</li><li>PWM_PulseFinishedHalfCpltCallback : TIM PWM 半脉冲结束回调函数</li><li>ErrorCallback : TIM 错误回调函数</li><li>CommutationCallback : TIM 通信回调函数</li><li>CommutationHalfCpltCallback : TIM 半通信回调函数</li><li>BreakCallback : TIM 打断回调函数</li></ul><p>默认情况下, TIM初始化（HAL_TIM_Init()）后，当状态是HAL_TIM_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_TIM_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_TIM_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;timer,
简称TIM，定时器是MCU控制中使用最广泛的外设，STM32中有多个TIM，下面来看看HAL库关于TIM的介绍和使用方法。&lt;/p&gt;
&lt;h3 id=&quot;tim外设库的一般特性&quot;&gt;TIM外设库的一般特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;16位向上，向下，向上向下</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="tim" scheme="http://example.com/tags/tim/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_sram库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-sram%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-sram%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T11:20:30.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于SRAM 内存的使用方法。</p><h3 id="sram外设库的使用">SRAM外设库的使用</h3><p>这是一个通用的分层驱动，包含一套控制SRAM内存的API。它使用FSMC层函数与SRAM设备进行连接。要配置FSMC与SRAM/PSRAM的连接，应遵循以下顺序：</p><ol type="1"><li><p>声明一个SRAM_HandleTypeDef类型结构体。如：SRAM_HandleTypeDefhsram;</p><ul><li>对SRAM_HandleTypeDef 句柄中“Init”中成员赋值。</li><li>对SRAM_HandleTypeDef句柄中“Instance”填入预先定义的NOR或SRAM设备基地址寄存器实例。</li><li>对SRAM_HandleTypeDef句柄中“Extended”填入预先定义的NOR或SRAM扩展模式基地址寄存器实例。</li></ul></li><li><p>为正常模式和扩展模式声明两个 FSMC_NORSRAM_TimingTypeDef类型结构体，并进行赋值。如：</p><p>​ FSMC_NORSRAM_TimingTypeDef Timing ， FSMC_NORSRAM_TimingTypeDefExTiming;</p></li><li><p>初始化 SRAM 控制器。HAL_SRAM_Init()</p><ul><li>配置底层硬件。HAL_SRAM_MspInit()</li><li>使用 FSMC NORSRAM 接口配置控制寄存器。FSMC_NORSRAM_Init()</li><li>使用 FSMC NORSRAM接口配置时序寄存器。FSMC_NORSRAM_Timing_Init()</li><li>使用 FSMC NORSRAM接口配置扩展模式时序寄存器。FSMC_NORSRAM_Extended_Timing_Init()</li><li>使能SRAM设备。__FSMC_NORSRAM_ENABLE()</li></ul></li><li><p>在这个阶段，你就可以执行内存与NOR/SRAM Bank之间的读、写操作。</p><ul><li>轮询模式下的读写：HAL_SRAM_Read()/HAL_SRAM_Write()</li><li>DMA模式下的读写：HAL_SRAM_Read_DMA()/HAL_SRAM_Write_DMA()</li></ul></li><li><p>你也可以通过调用HAL_SRAM_WriteOperation_Enable() /HAL_SRAM_WriteOperation_Disable() 函数来控制SRAM设备的写操作。</p></li><li><p>你可以持续监测SRAM设备的状态。HAL_SRAM_GetState()</p></li></ol><h3 id="sram回调函数的注册">SRAM回调函数的注册</h3><p>当 USE_HAL_SRAM_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SRAM_RegisterCallback(),HAL_SRAM_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : SRAM 底层初始化回调函数</li><li>MspDeInitCallback : SRAM 底层析构回调函数</li></ul><p>默认情况下, SRAM 初始化（HAL_SRAM_Init()）后，当状态是HAL_SRAM_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SRAM_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SRAM_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于SRAM 内存的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;sram外设库的使用&quot;&gt;SRAM外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用的分层驱动，包含一套控制SRAM内存的API。它使用FSMC层函数与SRAM设备进行连接。要配置FSMC与SRAM/PSR</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sram" scheme="http://example.com/tags/sram/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_hcd库和pcd的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-hcd%E5%BA%93%E5%92%8Cpcd%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-hcd%E5%BA%93%E5%92%8Cpcd%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T10:30:31.000Z</published>
    <updated>2023-08-07T14:49:16.982Z</updated>
    
    <content type="html"><![CDATA[<p>Host Controller Driver 和 Peripheral ControllerDriver，分别简称HCD，PCD，它们是USB外设控制器相关驱动，下面来看看HAL库关于HCD和PCD的使用方法介绍。</p><h3 id="hcd外设库的使用">HCD外设库的使用</h3><ol type="1"><li>声明一个 HCD_HandleTypeDef 类型结构体。如：HCD_HandleTypeDefhhcd;</li><li>对hhcd结构体的各参数进行赋值。</li><li>初始化 HCD外设。HAL_HCD_Init();</li><li>初始化HCD底层。HAL_HCD_MspInit();<ul><li>使能 HCD/USB 底层接口时钟。__HAL_RCC_USB_OTG_FS_CLK_ENABLE();</li><li>初始化相关GPIO时钟</li><li>配置HCD引脚为输出模式</li><li>配置HCD NVIC中断</li></ul></li><li>将上层USB主机栈关联到HAL HCD驱动。hhcd.pData = phost;</li><li>使能HCD发送和接收。HAL_HCD_Start();</li></ol><h3 id="pcd外设库的使用">PCD外设库的使用</h3><ol type="1"><li>声明一个 PCD_HandleTypeDef 类型结构体。如：PCD_HandleTypeDefhpcd;</li><li>对hpcd结构体的各参数进行赋值。</li><li>初始化 PCD外设。HAL_PCD_Init();</li><li>初始化PCD底层。HAL_PCD_MspInit();<ul><li>使能 PCD/USB 底层接口时钟。<ul><li>对于一般USB设备：__HAL_RCC_USB_CLK_ENABLE();</li><li>对于USB全速设备：__HAL_RCC_USB_OTG_FS_CLK_ENABLE();</li></ul></li><li>初始化相关GPIO时钟</li><li>配置PCD引脚为输出模式</li><li>配置PCD NVIC中断</li></ul></li><li>将上层USB设备栈关联到HAL PCD驱动。hpcd.pData = pdev;</li><li>使能PCD发送和接收。HAL_PCD_Start();</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Host Controller Driver 和 Peripheral Controller
Driver，分别简称HCD，PCD，它们是USB外设控制器相关驱动，下面来看看HAL库关于HCD和PCD的使用方法介绍。&lt;/p&gt;
&lt;h3 id=&quot;hcd外设库的使用&quot;&gt;HCD</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="hcd" scheme="http://example.com/tags/hcd/"/>
    
    <category term="pcd" scheme="http://example.com/tags/pcd/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_eth库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-eth%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-eth%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T09:30:31.000Z</published>
    <updated>2023-08-07T05:07:43.020Z</updated>
    
    <content type="html"><![CDATA[<p>Ethernet，简称ETH，以太网，以下来看看HAL库关于ETH的使用方法。</p><h3 id="eth外设库的使用">ETH外设库的使用</h3><ol type="1"><li><p>声明一个ETH_HandleTypeDef 类型结构体，如：ETH_HandleTypeDefheth;</p></li><li><p>对初始化结构体heth中参数进行赋值。</p></li><li><p>初始化ETH。Call HAL_ETH_Init()</p></li><li><p>初始化ETH底层。HAL_ETH_MspInit()</p><ul><li><p>使能ETH接口时钟。<code>__HAL_RCC_ETHMAC_CLK_ENABLE()</code>，<code>__HAL_RCC_ETHMACTX_CLK_ENABLE()</code>，<code>__HAL_RCC_ETHMACRX_CLK_ENABLE()</code></p></li><li><p>初始化相关GPIO时钟。</p></li><li><p>配置ETH引脚为输出</p></li><li><p>配置ETH NVIC中断（中断模式）</p></li></ul></li><li><p>以链模式（chain mode ）初始化ETHDMA描述符并指向已分配的缓冲区：</p></li></ol><ul><li>发送过程：HAL_ETH_DMATxDescListInit()</li><li>接收过程：HAL_ETH_DMARxDescListInit()</li></ul><ol start="6" type="1"><li><p>使能MAC并进行DMA发送和接收。HAL_ETH_Start()</p></li><li><p>准备好 ETH DMA 发送描述符，助力于ETH DMA传输数据帧到 MAC TXFIFO。HAL_ETH_TransmitFrame()</p></li><li><p>轮询接收ETHDMA接收描述符中的数据帧，并获取数据帧参数。HAL_ETH_GetReceivedFrame()(在无限循环中调用)</p></li><li><p>当ETH接收中断发生时，获取一帧接收数据。HAL_ETH_GetReceivedFrame_IT()(仅在中断模式中调用)</p></li><li><p>与外部PHY通信:</p><ul><li>从PHY中读取指定寄存器。HAL_ETH_ReadPHYRegister();</li><li>向指定的PHY寄存器中写入数据。HAL_ETH_WritePHYRegister();</li></ul></li><li><p>当 ETH 外设初始化后配置MAC。HAL_ETH_ConfigMAC()</p><p>所有的MAC参数都应该赋值。</p></li><li><p>当 ETH 外设初始化后配置DMA 。HAL_ETH_ConfigDMA()</p><p>所有的DMA参数都应该赋值。</p></li></ol><p><strong>注意</strong>：本驱动不支持PTP 协议和DMA描述符环状模式（DMAdescriptors ring mode）。</p><h3 id="eth回调函数的注册">ETH回调函数的注册</h3><p>当 USE_HAL_ETH_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_ETH_RegisterCallback(),HAL_ETH_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>DMAErrorCallback : DMA 错误回调函数</li><li>MspInitCallback : 底层初始化回调函数</li><li>MspDeInitCallback: 底层析构回调函数</li></ul><p>默认情况下, ETH 初始化（HAL_ETH_Init()）后，当状态是HAL_ETH_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_ETH_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_ETH_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Ethernet，简称ETH，以太网，以下来看看HAL库关于ETH的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;eth外设库的使用&quot;&gt;ETH外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;声明一个ETH_HandleTypeDef 类型结构体，如：ETH_H</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="eth" scheme="http://example.com/tags/eth/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_cec库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-cec%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-cec%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T08:30:31.000Z</published>
    <updated>2023-08-07T05:07:43.010Z</updated>
    
    <content type="html"><![CDATA[<p>Consumer Electronics Control，简称CEC，消费电子控制，是一种允许用户通过一个遥控器控制多个电子设备的技术，通常用于家庭娱乐系统。以下来看看HAL库关于CEC的使用方法。</p><h3 id="cec外设库的使用">CEC外设库的使用</h3><ol type="1"><li><p>声明一个CEC_HandleTypeDef 类型结构体。</p></li><li><p>初始化CEC底层。HAL_CEC_MspInit()</p></li></ol><ul><li>使能CEC接口时钟。</li><li>配置CEC引脚<ul><li><p>使能CEC GPIO 时钟</p></li><li><p>配置CEC引脚为复用上拉模式</p></li><li><p>如果使用到中断，如：HAL_CEC_Transmit_IT() ，HAL_CEC_Receive_IT()</p><ul><li>配置CEC 中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC CEC IRQ。HAL_NVIC_EnableIRQ()</li><li>在发送和接收过程中使用宏定义 __HAL_CEC_ENABLE_IT() 和__HAL_CEC_DISABLE_IT()来控制CEC的中断（发送完成中断，接收非空中断，错误中断）。</li></ul></li></ul></li></ul><ol start="3" type="1"><li>在hcec初始化结构体中设置位定时错误模式和位周期错误模式。Bit TimingError Mode / Bit Period Error Mode</li><li>初始化CEC寄存器。HAL_CEC_Init()</li></ol><h3 id="cec回调函数的注册">CEC回调函数的注册</h3><p>当 USE_HAL_CEC_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_CEC_RegisterCallback(),HAL_CEC_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>ErrorCallback : 错误回调函数</li><li>MspInitCallback : CEC 底层初始化回调函数</li><li>MspDeInitCallback : CEC 底层析构回调函数</li></ul><p>默认情况下, CEC 初始化（HAL_CEC_Init()）后，当状态是HAL_CEC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_CEC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_CEC_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Consumer Electronics Control
，简称CEC，消费电子控制，是一种允许用户通过一个遥控器控制多个电子设备的技术，通常用于家庭娱乐系统。以下来看看HAL库关于CEC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;cec外设库的使用&quot;&gt;CEC外设库的使用&lt;/</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="cec" scheme="http://example.com/tags/cec/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_can库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-can%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-can%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T07:50:31.000Z</published>
    <updated>2023-08-07T05:07:43.010Z</updated>
    
    <content type="html"><![CDATA[<p>Controller AreaNetwork，简称CAN，控制器局域网，是一种用于实现设备间通信的网络技术，广泛应用于汽车、工业自动化等领域。以下来看看HAL库关于CAN的使用方法。</p><h3 id="can外设库的使用">CAN外设库的使用</h3><ol type="1"><li><p>初始化CAN底层。HAL_CAN_MspInit()</p><ul><li>使能CAN接口时钟。__HAL_RCC_CANx_CLK_ENABLE()</li><li>配置CAN引脚<ul><li>使能CAN GPIO 时钟</li><li>配置CAN引脚为复用开漏模式</li></ul></li><li>如果使用到中断，如：HAL_CAN_ActivateNotification()<ul><li>配置CAN 中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC CAN IRQ。HAL_NVIC_EnableIRQ()</li><li>调用HAL_CAN_IRQHandler()</li></ul></li></ul></li><li><p>初始化CAN外设。HAL_CAN_Init()</p><p>此初始化函数会使用HAL_CAN_MspInit() 为底层进行初始化。</p></li><li><p>配置接收过滤器。HAL_CAN_ConfigFilter()</p></li><li><p>开启CAN模组。HAL_CAN_Start()</p><p>此时CAN总线被激活，可以接收信息，也能发送信息。</p></li><li><p>为了管理信息发送，可以使用以下发送控制函数：</p><ul><li>请求发送新信息。HAL_CAN_AddTxMessage()</li><li>中止挂起信息的发送。HAL_CAN_AbortTxRequest()</li><li>获取空闲发送邮箱的数量 。HAL_CAN_GetTxMailboxesFreeLevel()</li><li>检查发送邮箱信息是否挂起。HAL_CAN_IsTxMessagePending()</li><li>当使能时间触发通信模式时，获取发送信息的时间戳。HAL_CAN_GetTxTimestamp()</li></ul></li><li><p>当CAN Rx FIFOs接收到一条信息时，可使用HAL_CAN_GetRxMessage()函数获取信息。HAL_CAN_GetRxFifoFillLevel()函数允许知道RxFIFO接收到多少信息。</p></li><li><p>停止CAN模组。HAL_CAN_Stop()</p></li><li><p>CAN的析构函数：HAL_CAN_DeInit()</p></li></ol><h3 id="can-轮询模式操作">CAN 轮询模式操作</h3><ul><li><p>接收</p><ul><li>监测信息的接收，直到至少接收到一条信息。HAL_CAN_GetRxFifoFillLevel()</li><li>获取信息。HAL_CAN_GetRxMessage()</li></ul></li><li><p>发送</p><ul><li>监测可用的发送邮箱，直到至少有一个发送邮箱是空闲的。HAL_CAN_GetTxMailboxesFreeLevel()</li><li>请求发送信息。HAL_CAN_AddTxMessage()</li></ul></li></ul><h3 id="can-中断模式操作">CAN 中断模式操作</h3><ul><li>使用HAL_CAN_ActivateNotification()函数激活通知提示，然后通过HAL_CAN_xxxCallback()回调函数来控制，使用同样的APIs：HAL_CAN_GetRxMessage() 和 HAL_CAN_AddTxMessage()</li><li>可使用 HAL_CAN_DeactivateNotification()函数使通知提示失效。</li><li>需要特别留心 <strong>CAN_IT_RX_FIFO0_MSG_PENDING</strong> 和<strong>CAN_IT_RX_FIFO1_MSG_PENDING</strong> 的通知提示，它们会触发HAL_CAN_RxFIFO0MsgPendingCallback() 和HAL_CAN_RxFIFO1MsgPendingCallback() 回调函数。这里有两种做法：<ul><li><ol type="1"><li>在回调函数中直接获取接收的信息。HAL_CAN_GetRxMessage()</li></ol></li><li><ol start="2" type="1"><li>在回调函数中让通知提示失效，而不获取接收的信息。之后使用HAL_CAN_GetRxMessage()函数获取接收的信息，一旦读取接收的信息，通知提示就会被再次激活。</li></ol></li></ul></li></ul><h3 id="can-睡眠模式">CAN 睡眠模式</h3><ul><li><p>CAN 外设可进入睡眠模式（低功耗）。HAL_CAN_RequestSleep()</p><p>只要当前CAN完成发送或接收过程就能进入睡眠模式。</p></li><li><p>当进入睡眠模式时，可激活一个通知用来提示。</p></li><li><p>HAL_CAN_IsSleepActive()函数可用来检查CAN是否进入睡眠模式。<strong>注意</strong>：只要发送了睡眠模式请求（还没进入睡眠模式），CAN的状态（用HAL_CAN_GetState()函数获取）是HAL_CAN_STATE_SLEEP_PENDING，当睡眠模式生效，它的状态就是HAL_CAN_STATE_SLEEP_ACTIVE</p></li><li><p>从睡眠模式中唤醒有两种方式：</p><ul><li><p>使用函数： HAL_CAN_WakeUp()</p><p>当从此函数返回，就会退出睡眠模式（返回状态是 HAL_OK）。</p></li><li><p>如果激活自动唤醒模式，当CAN外设检测到RxCAN数据帧的开启。</p></li></ul></li></ul><h3 id="can回调函数的注册">CAN回调函数的注册</h3><p>当 USE_HAL_CAN_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_CAN_RegisterCallback(),HAL_CAN_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxMailbox0CompleteCallback : 邮箱0发送完成回调函数</li><li>TxMailbox1CompleteCallback : 邮箱1发送完成回调函数</li><li>TxMailbox2CompleteCallback : 邮箱2发送完成回调函数</li><li>TxMailbox0AbortCallback : 中止邮箱0的发送回调函数</li><li>TxMailbox1AbortCallback : 中止邮箱1的发送回调函数</li><li>TxMailbox2AbortCallback : 中止邮箱2的发送回调函数</li><li>RxFifo0MsgPendingCallback : Rx FIFO0 信息挂起回调函数</li><li>RxFifo0FullCallback : Rx FIFO0 已满回调函数</li><li>RxFifo1MsgPendingCallback : Rx FIFO1 信息挂起回调函数</li><li>RxFifo1FullCallback : Rx FIFO1 已满回调函数</li><li>SleepCallback : 睡眠回调函数</li><li>WakeUpFromRxMsgCallback : 从接收到信息唤醒回调函数</li><li>ErrorCallback : 错误回调函数</li><li>MspInitCallback : CAN 底层初始化回调函数</li><li>MspDeInitCallback : CAN 底层析构回调函数</li></ul><p>默认情况下, CAN 初始化（HAL_CAN_Init()）后，当状态是HAL_CAN_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_CAN_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_CAN_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Controller Area
Network，简称CAN，控制器局域网，是一种用于实现设备间通信的网络技术，广泛应用于汽车、工业自动化等领域。以下来看看HAL库关于CAN的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;can外设库的使用&quot;&gt;CAN外设库的使用&lt;/h3&gt;
&lt;ol</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="can" scheme="http://example.com/tags/can/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_i2s库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-i2s%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-i2s%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T05:50:31.000Z</published>
    <updated>2023-08-07T05:07:43.020Z</updated>
    
    <content type="html"><![CDATA[<p>Integrated InterchipSound，简称I2S，是关于音频相关的驱动，下面来看看HAL库关于I2S的使用方法。</p><h3 id="i2s外设库的使用">I2S外设库的使用</h3><ol type="1"><li>声明一个 I2S_HandleTypeDef 结构体,如：I2S_HandleTypeDef hi2s;</li><li>初始化I2S底层。HAL_I2S_MspInit()</li></ol><ul><li>使能SPIx 接口时钟。</li><li>配置I2S引脚<ul><li>使能I2S GPIO 时钟</li><li>配置I2S引脚为复用上拉模式</li></ul></li><li>如果使用到中断，则配置NVIC。HAL_I2S_Transmit_IT() 和HAL_I2S_Receive_IT()<ul><li>配置I2Sx 中断优先级</li><li>使能NVIC I2S IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_I2S_Transmit_DMA() 和HAL_I2S_Receive_DMA()<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体Tx、Rx参数。</li><li>配置DMA Tx或Rx通道。</li><li>将DMA句柄和hi2s DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置hi2s初始化结构体中各参数。</li><li>I2S中断模式（发送完成中断，接收非空中断，错误中断）下发送和接收过程中，使用宏定义__HAL_I2S_ENABLE_IT() 和 __HAL_I2S_DISABLE_IT()来控制。</li><li>I2SxCLK 时钟源是系统时钟（由HSI、HSE或PLL提供，产生 AHB时钟源）。对于互联型芯片，为了获得最大的精确度，I2SxCLK时钟源可以由SYSCLK 时钟或 PLL3 VCO (2 x PLL3CLK)时钟提供。</li></ol><h3 id="i2s-io操作的三种模式">I2S IO操作的三种模式：</h3><ul><li><p>轮询模式IO操作</p><ul><li>阻塞模式下发送一定数量的数据。HAL_I2S_Transmit()</li><li>阻塞模式下接收一定数量的数据。HAL_I2S_Receive()</li></ul></li><li><p>中断模式IO操作</p><ul><li><p>非阻塞模式下发送一定数量的数据。HAL_I2S_Transmit_IT()</p><p>发送过半，执行发送过半回调函数，用户自行添加代码。HAL_I2S_TxHalfCpltCallback()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_I2S_TxCpltCallback()</p></li><li><p>非阻塞模式下接收一定数量的数据。HAL_I2S_Receive_IT()</p><p>接收过半，执行接收过半回调函数，用户自行添加代码。HAL_I2S_RxHalfCpltCallback()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_I2S_RxCpltCallback()</p></li><li><p>当传输发生错误时，执行错误回调函数，用户自行添加代码。HAL_I2S_ErrorCallback()</p></li></ul></li><li><p>DMA模式IO操作</p><ul><li><p>非阻塞模式下(DMA)发送一定数量的数据。HAL_I2S_Transmit_DMA()</p><p>发送过半，执行发送过半回调函数，用户自行添加代码。HAL_I2S_TxHalfCpltCallback()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_I2S_TxCpltCallback()</p></li><li><p>非阻塞模式下(DMA)接收一定数量的数据。HAL_I2S_Receive_DMA()</p><p>接收过半，执行接收过半回调函数，用户自行添加代码。HAL_I2S_RxHalfCpltCallback()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_I2S_RxCpltCallback()</p></li><li><p>当传输发生错误时，执行错误回调函数，用户自行添加代码。HAL_I2S_ErrorCallback()</p></li><li><p>暂停DMA传输。HAL_I2S_DMAPause()</p></li><li><p>恢复DMA传输。HAL_I2S_DMAResume()</p></li><li><p>停止DMA传输。HAL_I2S_DMAStop()</p><p>在从模式下，如果HAL_I2S_DMAStop()用来停止通信，当主机继续传输数据时，HAL_I2S_ERROR_BUSY_LINE_RX就会产生错误。当__HAL_I2S_FLUSH_RX_DR宏用来刷新数据寄存器中的剩余值时，要避免在下次传输时使用DeInit/Init进程。</p></li></ul></li></ul><h3 id="i2s-hal常用宏定义">I2S HAL常用宏定义</h3><ul><li>__HAL_I2S_ENABLE: 使能SPI外设 (I2S 模式)</li><li>__HAL_I2S_DISABLE: 禁止SPI外设 (I2S 模式)</li><li>__HAL_I2S_ENABLE_IT : 使能I2S中断</li><li>__HAL_I2S_DISABLE_IT : 禁止I2S中断</li><li>__HAL_I2S_GET_FLAG: 检查I2S标志是否设置</li><li>__HAL_I2S_FLUSH_RX_DR: 读取数据寄存器的值来刷新接收的数据</li></ul><h3 id="i2s回调函数的注册">I2S回调函数的注册</h3><p>当 USE_HAL_I2S_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_I2S_RegisterCallback(),HAL_I2S_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : I2S 发送完成回调函数</li><li>RxCpltCallback : I2S 接收完成回调函数</li><li>TxHalfCpltCallback : I2S 发送过半回调函数</li><li>RxHalfCpltCallback : I2S 接收过半回调函数</li><li>ErrorCallback : I2S 错误回调函数</li><li>MspInitCallback : I2S 底层初始化回调函数</li><li>MspDeInitCallback : I2S 底层析构回调函数</li></ul><p>默认情况下, I2S 初始化（HAL_I2S_Init()）后，当状态是HAL_I2S_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_I2S_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_I2S_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p><h3 id="i2s勘误">I2S勘误</h3><p>主机模式时，I2S仅支持无数据扩展的16位模式，和使用PCM长同步模式（PCMlong synchronization mode）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Integrated Interchip
Sound，简称I2S，是关于音频相关的驱动，下面来看看HAL库关于I2S的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;i2s外设库的使用&quot;&gt;I2S外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;声明一个 I2S_Han</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="i2s" scheme="http://example.com/tags/i2s/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_i2c库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-i2c%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-i2c%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T01:10:31.000Z</published>
    <updated>2023-08-07T05:07:43.020Z</updated>
    
    <content type="html"><![CDATA[<p>Inter Integrated Circuit，简称I2C，下面来看看 I2CHAL库关于I2C的使用方法。</p><h3 id="i2c外设库的使用">I2C外设库的使用</h3><ol type="1"><li>声明一个 I2C_HandleTypeDef 结构体,如：I2C_HandleTypeDef hi2c;</li><li>初始化I2C底层。HAL_I2C_MspInit()</li></ol><ul><li><p>使能I2Cx 接口时钟。</p></li><li><p>配置I2C引脚</p><ul><li>使能I2C GPIO 时钟</li><li>配置I2C引脚为复用开漏模式</li></ul></li><li><p>如果使用到中断，则配置NVIC</p><ul><li>配置I2Cx 中断优先级</li><li>使能NVIC I2C IRQ通道</li></ul></li><li><p>如果使用到DMA，则配置DMA</p><ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA句柄参数。</li><li>配置DMA Tx或Rx通道。</li><li>将DMA句柄和hi2c DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置hi2c初始化结构体中各参数。</li><li>初始化I2C寄存器，HAL_I2C_Init()，同时配置底层硬件（GPIO，CLOCK，NVIC等等）HAL_I2C_MspInit()。</li><li>检查目标设备是否已经准备好通信。HAL_I2C_IsDeviceReady()</li></ol><h3 id="i2c-io操作的三种模式">I2C IO操作的三种模式：</h3><ul><li><p>轮询模式IO操作</p><ul><li>主模式下，以阻塞方式发送一定数量的数据。HAL_I2C_Master_Transmit()</li><li>主模式下，以阻塞方式接收一定数量的数据。HAL_I2C_Master_Receive()</li><li>从模式下，以阻塞方式发送一定数量的数据。HAL_I2C_Slave_Transmit()</li><li>从模式下，以阻塞方式接收一定数量的数据。HAL_I2C_Slave_Receive()</li></ul></li><li><p>中断模式IO操作</p><ul><li><p>主模式下，以非阻塞方式发送一定数量的数据。HAL_I2C_Master_Transmit_IT()</p><p>发送完成后，执行回调函数，用户自行添加代码。HAL_I2C_MasterTxCpltCallback()</p></li><li><p>主模式下，以非阻塞方式接收一定数量的数据。HAL_I2C_Master_Receive_IT()</p><p>接收完成后，执行回调函数，用户自行添加代码。HAL_I2C_MasterRxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式发送一定数量的数据。HAL_I2C_Slave_Transmit_IT()</p><p>发送完成后，执行回调函数，用户自行添加代码。HAL_I2C_SlaveTxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式接收一定数量的数据。HAL_I2C_Slave_Receive_IT()</p><p>接收完成后，执行回调函数，用户自行添加代码。HAL_I2C_SlaveRxCpltCallback()</p></li><li><p>如果传输出错，则执行错误回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li><li><p>主模式下，使用中断中止通信。HAL_I2C_Master_Abort_IT()</p></li><li><p>中止通信后执行中止回调函数，用户自行添加代码。HAL_I2C_AbortCpltCallback()</p></li></ul></li><li><p>DMA模式IO操作</p><ul><li><p>主模式下，以非阻塞方式（DMA）传输一定数量的数据。HAL_I2C_Master_Transmit_DMA()</p><p>传输完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterTxCpltCallback()</p></li><li><p>主模式下，以非阻塞方式（DMA）接收一定数量的数据。HAL_I2C_Master_Receive_DMA()</p><p>接收完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterRxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式（DMA）传输一定数量的数据。HAL_I2C_Slave_Transmit_DMA()</p><p>传输完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveTxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式（DMA）接收一定数量的数据。HAL_I2C_Slave_Receive_DMA()</p><p>接收完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveRxCpltCallback()</p></li><li><p>当传输出错时，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li><li><p>中止主模式下的传输。HAL_I2C_Master_Abort_IT()</p><p>中止的末尾，执行回调函数，用户自行添加代码。HAL_I2C_AbortCpltCallback()</p></li></ul></li></ul><h3 id="i2c-io-内存操作的三种模式">I2C IO 内存操作的三种模式</h3><ul><li><p>轮询模式IO内存操作</p><ul><li>以阻塞方式向指定的内存地址写入一定数量的数据。HAL_I2C_Mem_Write()</li><li>以阻塞方式从指定的内存地址读出一定数量的数据。HAL_I2C_Mem_Read()</li></ul></li><li><p>中断模式下IO内存操作</p><ul><li><p>非阻塞方式下，向指定的内存地址写入一定数量的数据。HAL_I2C_Mem_Write_IT()</p><p>在内存写传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemTxCpltCallback()</p></li><li><p>非阻塞方式下，从指定的内存地址读出一定数量的数据。HAL_I2C_Mem_Read_IT()</p><p>在内存读传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemRxCpltCallback()</p></li><li><p>传输出错时，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li></ul></li><li><p>DMA模式IO内存操作</p><ul><li><p>以非阻塞方式（DMA）向指定的内存地址写入一定数量的数据。HAL_I2C_Mem_Write_DMA()</p><p>在内存写传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemTxCpltCallback()</p></li><li><p>以非阻塞方式（DMA）从指定的内存地址读出一定数量的数据。HAL_I2C_Mem_Read_DMA()</p><p>在内存读传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemRxCpltCallback()</p></li><li><p>当传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li></ul></li></ul><h3id="i2c中断或dma模式下-io-顺序操作-sequential-operation">I2C中断或DMA模式下IO 顺序操作 （sequential operation）</h3><p>在传输过程中方向改变时，这些接口允许通过重复启动来控制传输顺序。</p><ul><li><p>通过一个指定的可选域（Optionfield）来控制顺序传输的步骤。</p></li><li><p>可选域的值通过 <strong>I2C_XferOptions_definition</strong>来定义：</p><ol type="1"><li><p>I2C_FIRST_AND_LAST_FRAME：用于非顺序传输，功能与非顺序模式下的关联接口相同。</p></li><li><p>I2C_FIRST_FRAME：用于顺序传输，此选项允许控制传输有开启条件，地址和传输的数据而没有停止条件。</p></li><li><p>I2C_FIRST_AND_NEXT_FRAME：仅主模式下用于顺序传输，此选项允许控制传输有开启条件，地址和传输的数据而没有停止条件，然后允许多次调用主模式下顺序传输接口函数（如：HAL_I2C_Master_Seq_Transmit_IT()或 HAL_I2C_Master_Seq_Transmit_DMA()）。</p></li><li><p>I2C_NEXT_FRAME：用于顺序传输，此选项允许控制传输有重新开启条件，地址以及当方向改变时新的传输数据或方向未改变时仅控制传输的新数据而没有停止条件。</p></li><li><p>I2C_LAST_FRAME：用于顺序传输，此选项允许控制传输有重新开启条件，地址以及当方向改变时新的传输数据或方向未改变时仅控制传输的新数据，最后加上停止条件。</p></li><li><p>I2C_LAST_FRAME_NO_STOP：仅主模式下用于顺序传输，当多次调用同一个主模式顺序接口（类同于I2C_FIRST_AND_NEXT_FRAME）后，此选项允许控制一个重新开启条件。用法是逐个传输多个字节：HAL_I2C_Master_Seq_Transmit_IT、HAL_I2C_Master_Seq_Receive_IT、HAL_I2C_Master_Seq_Transmit_DMA、HAL_I2C_Master_Seq_Receive_DMA(可选I2C_FIRST_AND_NEXT_FRAME 然后I2C_NEXT_FRAME)。 I2C_LAST_FRAME_NO_STOP的用途是在最后一个顺序传输或接收，允许调用相反的接口来接收或传输，而不需要停止通信和产生重新开启条件。</p></li><li><p>I2C_OTHER_FRAME:仅主模式下用于顺序传输，当每次调用同一个主模式顺序接口后，此选项允许控制一个重新开启条件。用法是逐个传输多个字节，每个字节之间重新启动从设备地址：HAL_I2C_Master_Seq_Transmit_IT、HAL_I2C_Master_Seq_Receive_IT、HAL_I2C_Master_Seq_Transmit_DMA、HAL_I2C_Master_Seq_Receive_DMA（可选I2C_FIRST_FRAME然后 I2C_OTHER_FRAME）。I2C_OTHER_AND_LAST_FRAME的用途是在最后一个传输时帮助自动产生停止条件。</p></li></ol></li><li><p>不同顺序的I2C接口如下：</p><ol type="1"><li><p>主模式下,以非阻塞方式顺序发送一定数量的数据。HAL_I2C_Master_Seq_Transmit_IT()或HAL_I2C_Master_Seq_Transmit_DMA()</p><p>当前帧传输完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterTxCpltCallback()</p></li><li><p>主模式下,以非阻塞方式顺序接收一定数量的数据。HAL_I2C_Master_Seq_Receive_IT()或HAL_I2C_Master_Seq_Receive_DMA()</p><p>当前帧接收完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterRxCpltCallback()</p></li><li><p>主模式下，以中断方式中止中断或DMA通信。HAL_I2C_Master_Abort_IT()</p><p>中止后，执行回调函数，用户自行添加代码。HAL_I2C_AbortCpltCallback()</p></li><li><p>从模式下，使能、禁止地址监听模式(Address listenmode)。HAL_I2C_EnableListen_IT() ，HAL_I2C_DisableListen_IT()</p><p>当从设备地址匹配，执行回调函数，用户自行添加地址匹配的检查代码和主设备请求的传输方向（写、读）代码。HAL_I2C_AddrCallback()</p><p>在监听模式末尾，执行回调函数，用户自行添加代码。HAL_I2C_ListenCpltCallback()</p></li><li><p>从模式下，以非阻塞方式顺序发送一定数量的数据。HAL_I2C_Slave_Seq_Transmit_IT()或HAL_I2C_Slave_Seq_Transmit_DMA()</p><p>当前帧发送完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveTxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式顺序接收一定数量的数据。HAL_I2C_Slave_Seq_Receive_IT()或HAL_I2C_Slave_Seq_Receive_DMA()</p><p>当前帧接收完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveRxCpltCallback()</p></li><li><p>当传输出错时，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li></ol></li></ul><h3 id="i2c-hal常用宏定义">I2C HAL常用宏定义</h3><ul><li>__HAL_I2C_ENABLE: 使能I2C外设</li><li>__HAL_I2C_DISABLE: 禁止 I2C 外设</li><li>__HAL_I2C_GET_FLAG: 检查I2C标志是否设置</li><li>__HAL_I2C_CLEAR_FLAG: 清除I2C挂起标志</li><li>__HAL_I2C_ENABLE_IT: 使能I2C中断</li><li>__HAL_I2C_DISABLE_IT: 禁止I2C中断</li></ul><h3 id="i2c回调函数的注册">I2C回调函数的注册</h3><p>当 USE_HAL_I2C_REGISTER_CALLBACKS 为1时，允许用户注册或注销回调函数。HAL_I2C_RegisterCallback()或HAL_I2C_RegisterAddrCallback()，HAL_I2C_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>MasterTxCpltCallback : 主机发送完成回调函数</p></li><li><p>MasterRxCpltCallback : 主机接收完成回调函数</p></li><li><p>SlaveTxCpltCallback : 从机发送完成回调函数</p></li><li><p>SlaveRxCpltCallback : 从机接收完成回调函数</p></li><li><p>ListenCpltCallback : 监听模式完成回调函数</p></li><li><p>MemTxCpltCallback : 内存发送完成回调函数</p></li><li><p>MemRxCpltCallback : 内存接收完成回调函数</p></li><li><p>ErrorCallback : 错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>MspInitCallback : 底层初始化回调函数</p></li><li><p>MspDeInitCallback : 底层析构回调函数</p></li></ul><p>默认情况下, I2C 初始化（HAL_I2C_Init()）后，当状态是HAL_I2C_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_I2C_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_I2C_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p><h3 id="i2c勘误">I2C勘误</h3><p>i2c因为硅限制，会发生以下错误，所以对于 STM32F1xx 芯片，官方对 I2CHAL Driver给出了临时措施，详细内容查看 ErrataSheet：</p><ol type="1"><li><p>将错误的数据读到数据寄存器 (轮询和中断模式)</p></li><li><p>错位的停止条件后，不能产生开启条件。</p></li><li><p>在传输当前字节之前，必须管理一些软件事件。</p><p>临时措施：一般使用DMA，除了当主机正在接收一个字节。对于中断模式，I2C应该有最高优先级。</p></li><li><p>重启条件的Setup时间参数不匹配。</p><p>临时措施：减少频率到88kHz或当从机支持I2C快速模式，则使用快速模式。</p></li><li><p>数据有效时间 (tVD;DAT) 违反而没有设置OVR标志。</p><p>临时措施：如果从机允许，使用时钟扩展机制，在 HAL_I2C_Init()中将NoStretchMode = I2C_NOSTRETCH_DISABLE 。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Inter Integrated Circuit，简称I2C，下面来看看 I2C
HAL库关于I2C的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;i2c外设库的使用&quot;&gt;I2C外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;声明一个 I2C_HandleTypeD</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="i2c" scheme="http://example.com/tags/i2c/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_irda库的使用</title>
    <link href="http://example.com/2023/08/05/stm32f1xx-hal-irda%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/05/stm32f1xx-hal-irda%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-05T14:19:31.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>infrared data association, 红外通信技术，简称IRDA，通过USART同步串口进行数据传输。HAL库中关于IRDA外设库的使用方法如下：</p><h3 id="irda外设库的使用">IRDA外设库的使用</h3><ol type="1"><li>声明一个 IRDA_HandleTypeDef结构体句柄。如： IRDA_HandleTypeDefhirda。</li><li>初始化IRDA底层配置。HAL_IRDA_MspInit()<ul><li>使能串口 USARTx 时钟。</li><li>IRDA引脚的配置。<ul><li>使能IRDA GPIO时钟。</li><li>配置 IRDA 引脚为复用功能，上拉。</li></ul></li><li>如果需要使用中断，则配置NVIC。HAL_IRDA_Transmit_IT()，HAL_IRDA_Receive_IT()<ul><li>配置串口 USARTx 中断优先级</li><li>使能NVIC USART IRQ中断。</li></ul></li><li>如果需要使用DMA，则配置DMA。HAL_IRDA_Transmit_DMA()，HAL_IRDA_Receive_DMA()<ul><li>为串口Tx和Rx通道声明一个DMA结构体句柄。</li><li>使能DMAx接口时钟。</li><li>配置刚声明的DMA结构体中所需要的Tx/Rx参数。</li><li>配置DMA Tx/Rx 通道。</li><li>将DMA句柄和串口Tx/Rx句柄进行关联。</li><li>当DMATx/Rx通道数据传输完成产生中断时，则配置NVIC的优先级并使能。</li><li>配置USART中断优先级并使能NVIC USARTIRQ中断。（用于DMA非循环模式下的最后一个字节发送完成的检测）</li></ul></li></ul></li><li>在串口hirda初始化结构体中配置串口的波特率、字节长度，停止位，奇偶校验位，硬件流控和模式（接收/发送）。</li><li>初始化IRDA寄存器。HAL_IRDA_Init()</li></ol><p>指定的IRDA中断(传输完成中断，接收非空中断和错误中断）可使用宏定义控制。__HAL_IRDA_ENABLE_IT(), __HAL_IRDA_DISABLE_IT()</p><p>HAL_IRDA_Init()底层硬件初始化都会调用 HAL_IRDA_MspInit()。</p><h3 id="irda的操作模式">IRDA的操作模式</h3><ul><li>轮询模式IO的操作<ul><li>以阻塞模式发送一定数量的数据。HAL_IRDA_Transmit()</li><li>以阻塞模式接收一定数量的数据。HAL_IRDA_Receive()</li></ul></li><li>中断模式IO的操作<ul><li>非阻塞模式发送一定数量的数据。HAL_IRDA_Transmit_IT()</li><li>传输完成，执行HAL_IRDA_TxCpltCallback()回调函数，用户自行添加代码。</li><li>非阻塞模式接收一定数量的数据。HAL_IRDA_Receive_IT()</li><li>接收完成，执行HAL_IRDA_RxCpltCallback()回调函数，用户自行添加代码。</li><li>当传输出错时，执行HAL_IRDA_ErrorCallback()回调函数，用户自行添加代码。</li></ul></li><li>DMA模式IO的操作<ul><li>非阻塞DMA模式发送一定数量的数据。HAL_IRDA_Transmit_DMA()</li><li>传输过半，执行 HAL_IRDA_TxHalfCpltCallback()回调函数，用户自行添加代码。</li><li>传输完成，执行 HAL_IRDA_TxCpltCallback()回调函数，用户自行添加代码。</li><li>非阻塞DMA模式接收一定数量的数据。HAL_IRDA_Receive_DMA()</li><li>接收过半，执行HAL_IRDA_RxHalfCpltCallback()回调函数，用户自行添加代码。</li><li>接收完成，执行HAL_IRDA_RxCpltCallback()回调函数，用户自行添加代码。</li><li>当传输出错时，执行HAL_IRDA_ErrorCallback()回调函数，用户自行添加代码。</li><li>DMA传输暂停。 HAL_IRDA_DMAPause()</li><li>重新开始串口DMA传输。HAL_IRDA_DMAResume()</li><li>停止串口DMA传输。HAL_IRDA_DMAStop()</li></ul></li></ul><h3 id="irda-hal常用宏定义列表">IRDA HAL常用宏定义列表</h3><ul><li>__HAL_IRDA_ENABLE: 使能IRDA</li><li>___HAL_IRDA_DISABLE: 关闭IRDA</li><li>__HAL_IRDA_GET_FLAG : 获取IRDA标志是否设置</li><li>__HAL_IRDA_CLEAR_FLAG : 清除IRDA挂起标志</li><li>__HAL_IRDA_ENABLE_IT: 使能IRDA中断</li><li>__HAL_IRDA_DISABLE_IT: 关闭IRDA中断</li><li>__HAL_IRDA_GET_IT_SOURCE: 检查IRDA是否发生中断</li></ul><h3 id="回调函数的注册">回调函数的注册</h3><ol type="1"><li>USE_HAL_IRDA_REGISTER_CALLBACKS设置为1，用户就可以使用回调函数了。回调函数的注册和注销函数分别是：HAL_IRDA_RegisterCallback()、HAL_IRDA_UnRegisterCallback()</li></ol><p>​ 回调函数ID：</p><ul><li><p>TxHalfCpltCallback : 发送过半</p></li><li><p>TxCpltCallback : 发送完成</p></li><li><p>RxHalfCpltCallback : 接收过半</p></li><li><p>RxCpltCallback : 接收完成</p></li><li><p>ErrorCallback : 发生错误</p></li><li><p>AbortCpltCallback : 中止完成</p></li><li><p>AbortTransmitCpltCallback : 中止发生完成</p></li><li><p>AbortReceiveCpltCallback : 中止接收完成</p></li><li><p>MspInitCallback : IRDA底层初始化</p></li><li><p>MspDeInitCallback : IRDA 析构</p></li></ul><ol start="2" type="1"><li>默认情况下，IRDA初始化之后，当它的状态是<strong>HAL_IRDA_STATE_RESET</strong>，所有的回调函数被设置为相应的弱函数。如：HAL_IRDA_TxCpltCallback(),HAL_IRDA_RxHalfCpltCallback()。</li><li>只有在IRDA状态HAL_IRDA_STATE_READY 时，回调函数才能注册或注销。</li><li>当USE_HAL_IRDA_REGISTER_CALLBACKS设置为0，注册的回调函数特性就不能使用，回调函数就当作一个弱函数使用。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;infrared data association, 红外通信技术，简称
IRDA，通过USART同步串口进行数据传输。HAL库中关于IRDA外设库的使用方法如下：&lt;/p&gt;
&lt;h3 id=&quot;irda外设库的使用&quot;&gt;IRDA外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="irda" scheme="http://example.com/tags/irda/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_flash库的使用</title>
    <link href="http://example.com/2023/08/05/stm32f1xx-hal-flash%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/05/stm32f1xx-hal-flash%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-05T08:12:31.000Z</published>
    <updated>2023-08-07T05:07:43.020Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看 Flash HAL库关于Flash存储器的特性和使用方法。</p><h3 id="flash外设库的特性">Flash外设库的特性</h3><ul><li>Flash存储器接口管理着CPU AHB I-Code 和D-Code总线访问Flash存储器。它实现了擦除和编程闪存操作以及读写保护机制。</li><li>Flash存储器接口使用系统预取方式加速了代码的执行。</li><li>Flash存储器的主要特性有：<ul><li>Flash存储器的读操作</li><li>Flash存储器的编程和擦除操作</li><li>读写保护</li><li>I-Code 总线的预取功能</li><li>选项字节编程 Option Bytes programming</li></ul></li></ul><h3 id="flash外设库的使用">Flash外设库的使用</h3><p>该Flash外设库对所有的 STM32F1xx 芯片都适用。</p><ul><li>Flash存储器 I/O编程函数：<ul><li>锁定和解锁Flash接口</li><li>擦除函数：页擦除，擦除所有的页</li><li>编程函数：半字写入，字写入和双字写入</li></ul></li><li>Flash可选项字节编程函数：<ul><li>锁定和解锁可选项字节</li><li>设置、复位写保护</li><li>设置读保护级别</li><li>编程用户可选项字节</li><li>加载启动可选项字节加载程序</li><li>擦除可选项字节</li><li>编程数据可选项字节</li><li>获取写保护</li><li>获取用户可选项字节</li></ul></li><li>中断和标志管理函数：<ul><li>处理Flash中断</li><li>根据当前Flash状态，等待最后一次Flash操作</li><li>获取错误标志状态</li></ul></li></ul><h3 id="flash外设库常用的宏定义">Flash外设库常用的宏定义</h3><ul><li><p>__HAL_FLASH_SET_LATENCY ,__HAL_FLASH_GET_LATENCY():设置、获取等待时间</p></li><li><p>__HAL_FLASH_PREFETCH_BUFFER_ENABLE() ,__HAL_FLASH_PREFETCH_BUFFER_DISABLE():使能、禁止预取缓冲</p></li><li><p>__HAL_FLASH_HALF_CYCLE_ACCESS_ENABLE() ,__HAL_FLASH_HALF_CYCLE_ACCESS_DISABLE() : 使能、禁止半周期访问</p></li><li><p>__HAL_FLASH_ENABLE_IT() ,__HAL_FLASH_DISABLE_IT():使能、禁止FLASH中断</p></li><li><p>__HAL_FLASH_GET_FLAG() : 获取FLASH标志状态</p></li><li><p>__HAL_FLASH_CLEAR_FLAG() : 清除FLASH标志</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看 Flash HAL库关于Flash存储器的特性和使用方法。&lt;/p&gt;
&lt;h3 id=&quot;flash外设库的特性&quot;&gt;Flash外设库的特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Flash存储器接口管理着CPU AHB I-Code 和D-Code总线访问Flash
存</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="flash" scheme="http://example.com/tags/flash/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_crc库的使用</title>
    <link href="http://example.com/2023/08/05/stm32f1xx-hal-crc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/05/stm32f1xx-hal-crc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-05T07:17:31.000Z</published>
    <updated>2023-08-07T05:07:43.020Z</updated>
    
    <content type="html"><![CDATA[<p>Cyclic RedundancyCheck，简称CRC，冗余循环校验，ST官方库关于CRC的介绍很简单，下面来看看Cyclic Redundancy Check HAL库关于CRC校验库的使用方法。</p><h3 id="crc外设库的使用">CRC外设库的使用</h3><ul><li>使能CRC AHB时钟。__HAL_RCC_CRC_CLK_ENABLE()</li><li>初始化CRC计算器<ul><li>指定生成的多项式polynomial（外设默认或非默认）</li><li>指定初始值（外设默认或非默认）</li><li>指定输入数据格式</li><li>如果可能，指定输入或输出反转模式</li></ul></li><li>使用HAL_CRC_Accumulate()函数计算输入数据缓冲区的CRC值，从之前计算的CRC作为初始值开始。</li><li>使用 HAL_CRC_Calculate()函数计算输入数据缓冲区的CRC值，从已定义的初始值（默认或非默认）来初始化CRC的计算开始。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Cyclic Redundancy
Check，简称CRC，冗余循环校验，ST官方库关于CRC的介绍很简单，下面来看看
Cyclic Redundancy Check HAL库关于CRC校验库的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;crc外设库的使用&quot;&gt;CRC外设库的使</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="crc" scheme="http://example.com/tags/crc/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_iwdg库的使用</title>
    <link href="http://example.com/2023/08/05/stm32f1xx-hal-iwdg%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/05/stm32f1xx-hal-iwdg%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-05T05:12:31.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看 IWDG HAL库关于 独立看门狗的特性和使用方法。</p><h3 id="iwdg外设库的一般特性">IWDG外设库的一般特性</h3><ul><li><p>独立看门狗可以通过软件或硬件开启。 (通过可选字节（optionbyte）进行配置)</p></li><li><p>独立看门狗时钟时LSI提供（Low-Speed Internalclock），即使没有主时钟，它也能维持运行。</p></li><li><p>一旦独立看门狗开启，LSI时钟就会被强制打开，这两者就不会关闭。计数值从复位值（0xFFF）向下计数，当计数到0，就会产生复位信号（IWDG复位）。</p></li><li><p>每当键值（key value）<strong>0x0000 AAAA</strong> 写入到IWDG_KR寄存器，IWDG_RLR 值就会被重装载到计数器中，以阻止看门狗复位。</p></li><li><p>IWDG工作在 VDD电压域，在 停止（STOP） 和 待机（STANDBY）模式下也能正常工作（IWDG复位能够把CPU从待机中唤醒）。RCC_CSR寄存器中复位标志用来提示独立看门狗发生了复位。</p></li><li><p>Debug模式：当微控制器进入debug模式（核心停止），IWDG计数器要么继续正常工作，要么停止，取决于DBG模块DBG_IWDG_STOP 位，可通过宏定义配置：__HAL_DBGMCU_FREEZE_IWDG() 和__HAL_DBGMCU_UNFREEZE_IWDG()</p></li><li><p>最小、最大的超时时间 <span class="citation"data-cites="32KHz">@32KHz</span> (LSI): 125us、32.7s</p><p>独立看门狗的超时时间可能会因为LSI时钟频率变化而发生变化。STM32F1xx芯片可以测量LSI时钟频率（LSI时钟内部连接到TIM5_CH4输入捕获引脚）。测量值可用于IWDG超时时间，它具有可接受的精度。</p></li><li><p>默认的超时时间（IWDG_SR 状态寄存器进行更新）：</p><p>LSI_VALUE常量通过名义上的LSI时钟频率来决定，这个频率如上所述，会发生变化，所以默认的超时时间（通过HAL_IWDG_DEFAULT_TIMEOUT定义）可能会变得很短，也可能会变得很长，这种情况下，默认的超时时间用户可以通过重定义LSI_VALUE常量来进行微调。（比如：如上以测量的LSI时钟频率为基准）</p></li></ul><h3 id="iwdg外设库的使用">IWDG外设库的使用</h3><ol type="1"><li>IWDG的初始化。HAL_IWDG_Init()<ul><li>在IWDG_KEY寄存器中写入开启的键值来使能IWDG，LSI时钟被强制打开，IWDG计数器开始向下计数。</li><li>写使能配置寄存器： IWDG_PR 和 IWDG_RLR 。</li><li>配置IWDG预分频系数和计数重装载值。每次看门狗重装载时，此值就会被装载到IWDG的计数器中，然后IWDG从这个值开始向下计数。</li><li>等待状态标志被重置。</li></ul></li><li>应用程序必须在正常运行期间定期刷新IWDG计数器，以防止MCU复位。HAL_IWDG_Refresh()</li></ol><h3 id="iwdg-hal常用宏定义">IWDG HAL常用宏定义</h3><ul><li>__HAL_IWDG_START: 使能IWDG外设</li><li>__HAL_IWDG_RELOAD_COUNTER:把重装载寄存器中的值重装载到IWDG计数器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看 IWDG HAL库关于 独立看门狗的特性和使用方法。&lt;/p&gt;
&lt;h3 id=&quot;iwdg外设库的一般特性&quot;&gt;IWDG外设库的一般特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;独立看门狗可以通过软件或硬件开启。 (通过可选字节（option
byte）进行配置)&lt;</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="iwdg" scheme="http://example.com/tags/iwdg/"/>
    
  </entry>
  
</feed>
