<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-29T00:21:09.606Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STM32CubeMx 之输入捕获</title>
    <link href="http://example.com/2023/05/28/STM32CubeMx-%E4%B9%8B%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/"/>
    <id>http://example.com/2023/05/28/STM32CubeMx-%E4%B9%8B%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/</id>
    <published>2023-05-28T14:00:00.000Z</published>
    <updated>2023-05-29T00:21:09.606Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>STM32CubeMX 之PWM输出</title>
    <link href="http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8BPWM%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8BPWM%E8%BE%93%E5%87%BA/</id>
    <published>2023-05-28T12:55:09.000Z</published>
    <updated>2023-05-29T00:21:09.522Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pwm-简介">PWM 简介</h3><p>脉冲宽度调制（PWM,Pulse WidthModulation）简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。PWM输出就是对外输出脉宽（即占空比）可调的方波信号，信号频率由自动重装寄存器ARR 的值决定，占空比由比较寄存器 CCR 的值决定。PWM原理如下图示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528210627064.png" alt="image-20230528210627064" style="zoom:67%;" /></p><p>图中定时器工作在向上计数PWM模式，当CNT &lt; CCRx时输出低电平0，当CNT&gt;=CCRx时输出高电平1，当CNT值达到ARR的时候，重新归零，然后重新向上计数，依次循环。</p><p>PWM 模式分为两种，PWM1 和 PWM2，它们的区别如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528211623737.png" alt="image-20230528211623737" style="zoom:67%;" /></p><h3 id="硬件设计">硬件设计</h3><p>LED灯的呼吸灯效果可以很好的查看PWM的调节情况，查看定时器复用功能重映射，刚好TIM3第二通道可以重映射到LED0上。所以，可以通过TIM3的通道2输出PWM信号，控制LED0的亮度。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528211500355.png" alt="image-20230528211500355" style="zoom:67%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72MHz；</li><li>TIM3的时钟挂载在APB1上，因为APB1 Prescacler设置为2，所以TIM3时钟为36x2=72MHz；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528200120931.png" alt="image-20230528200120931" style="zoom:67%;" /></p><ul><li><p>激活TIM3定时器，**Timeout = (Prescaler-1)*(Period-1)/72MHz**</p><p>时钟源选择为内部时钟，设置通道2为PWM模式，选中PB5的TIM3_CH2完成重映射，预分频系数设置为72-1，向上计数，自动重装载值设为500-1，则计时器时钟频率为1MHz，计时器周期为1us，PWM周期为500 * 1 = 500us，PWM频率为1/500us =2KHz，PWM模式选择PWM1，Pulse默认为0，PWM极性设置为低电平（由于LED低电平点亮）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528213741747.png" alt="image-20230528213741747" style="zoom:80%;" /></p></li><li><p>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral ；点击GENERATE CODE，生成工程代码</p></li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在tim.c文件中可以看到TIM3的初始化相关函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_TIM3_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  TIM_ClockConfigTypeDef sClockSourceConfig = &#123;<span class="hljs-number">0</span>&#125;;  TIM_MasterConfigTypeDef sMasterConfig = &#123;<span class="hljs-number">0</span>&#125;;  TIM_OC_InitTypeDef sConfigOC = &#123;<span class="hljs-number">0</span>&#125;;  htim3.Instance = TIM3;  htim3.Init.Prescaler = <span class="hljs-number">71</span>;  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;  htim3.Init.Period = <span class="hljs-number">499</span>;  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIM_Base_Init(&amp;htim3) != HAL_OK)  &#123;    Error_Handler();  &#125;  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;  <span class="hljs-keyword">if</span> (HAL_TIM_ConfigClockSource(&amp;htim3, &amp;sClockSourceConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;  <span class="hljs-keyword">if</span> (HAL_TIM_PWM_Init(&amp;htim3) != HAL_OK)  &#123;    Error_Handler();  &#125;  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIMEx_MasterConfigSynchronization(&amp;htim3, &amp;sMasterConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;  sConfigOC.OCMode = TIM_OCMODE_PWM1;  sConfigOC.Pulse = <span class="hljs-number">0</span>;  sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIM_PWM_ConfigChannel(&amp;htim3, &amp;sConfigOC, TIM_CHANNEL_2) != HAL_OK)  &#123;    Error_Handler();  &#125;  HAL_TIM_MspPostInit(&amp;htim3);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_Base_MspInit</span><span class="hljs-params">(TIM_HandleTypeDef* tim_baseHandle)</span>&#123;  <span class="hljs-keyword">if</span>(tim_baseHandle-&gt;Instance==TIM3)  &#123;    __HAL_RCC_TIM3_CLK_ENABLE();  &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_MspPostInit</span><span class="hljs-params">(TIM_HandleTypeDef* timHandle)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-keyword">if</span>(timHandle-&gt;Instance==TIM3)  &#123;    __HAL_RCC_GPIOB_CLK_ENABLE();    <span class="hljs-comment">/**TIM3 GPIO Configuration</span><span class="hljs-comment">    PB5     ------&gt; TIM3_CH2</span><span class="hljs-comment">    */</span>    GPIO_InitStruct.Pin = GPIO_PIN_5;    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;    HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);    __HAL_AFIO_REMAP_TIM3_PARTIAL();  &#125;&#125;</code></pre></div><ul><li>在main函数中编写代码，周期性的改变CCR1的值来改变PWM占空比</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>  <span class="hljs-type">uint8_t</span> dir = <span class="hljs-number">1</span>;<span class="hljs-comment">//计数方向</span>  <span class="hljs-type">uint16_t</span> ledpwmval = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数值</span>  <span class="hljs-comment">/* USER CODE END 1 */</span>  <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>  <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>  HAL_Init();  <span class="hljs-comment">/* USER CODE BEGIN Init */</span>  <span class="hljs-comment">/* USER CODE END Init */</span>  <span class="hljs-comment">/* Configure the system clock */</span>  SystemClock_Config();  <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>  <span class="hljs-comment">/* USER CODE END SysInit */</span>  <span class="hljs-comment">/* Initialize all configured peripherals */</span>  MX_GPIO_Init();  MX_TIM3_Init();  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);<span class="hljs-comment">//开启定时器PWM输出</span>  <span class="hljs-comment">/* USER CODE END 2 */</span>  <span class="hljs-comment">/* Infinite loop */</span>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;HAL_Delay(<span class="hljs-number">10</span>);<span class="hljs-keyword">if</span>(dir)ledpwmval++;<span class="hljs-keyword">else</span>ledpwmval--;<span class="hljs-keyword">if</span>(ledpwmval &gt; <span class="hljs-number">300</span>)dir = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ledpwmval == <span class="hljs-number">0</span>)dir = <span class="hljs-number">1</span>;TIM3-&gt;CCR2 = ledpwmval;<span class="hljs-comment">//更改CCR2的值来改变PWM的占空比</span>    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>  &#125;  <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><ul><li>编译后下载到开发板，可以看到LED0由暗变亮，再由亮变暗，呈现呼吸灯的效果。</li></ul><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/pwm_out.zip">pwm_output</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pwm-简介&quot;&gt;PWM 简介&lt;/h3&gt;
&lt;p&gt;脉冲宽度调制（PWM,Pulse Width
Modulation）简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。PWM
输出就是对外输出脉宽（即占空比）可调的方波信号，信号频率</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX 之窗口看门狗</title>
    <link href="http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <id>http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97/</id>
    <published>2023-05-28T07:19:32.000Z</published>
    <updated>2023-05-29T00:21:09.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="窗口看门狗简介">窗口看门狗简介</h3><p>窗口看门狗（WWDG）通常被用来监测由外部干扰或不可预见的逻辑条件造成的应用程序背离正常的运行序列而产生的软件故障。递减计数器需要在一个有限的时间窗口中被刷新才不会产生MCU复位，否则就会产生RESET。WWDG</p><p>窗口看门狗时序图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528174707824.png" alt="image-20230528174707824" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528174924225.png" alt="image-20230528174924225" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>我们将通过USART1来打印调试信息，然后通过 LED1提示复位状态。(LED1常亮则系统正常，LED1闪烁则系统一直复位)</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M；</li><li>IWDG的时钟默认为LSI时钟；</li><li>PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528170246253.png" alt="image-20230528170246253" style="zoom:67%;" /></p><ul><li><p>激活WWDG，Timeout = 4096 x Prescaler x (上窗口值 - 下窗口值)/36MHz</p><p>WWDG挂载在APB1上，时钟为36MHz，计数器预分频值设为8，窗口寄存器设为W[6:0]= 0x5A，递减计数器刷新值设置为T[6:0] = 0x7F；根据公式算出超时时间为（4096 * 8）*（0x7F-0x3F）/ 36MHz =58.3ms；使能EWI中断，在NVIC设置中开启窗口看门狗中断</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528175822680.png" alt="image-20230528175822680" style="zoom:67%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在wwdg.c文件中可以看到独立看门狗的初始化函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_WWDG_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  hwwdg.Instance = WWDG;  hwwdg.Init.Prescaler = WWDG_PRESCALER_8;  hwwdg.Init.Window = <span class="hljs-number">0x5a</span>;  hwwdg.Init.Counter = <span class="hljs-number">0x7f</span>;  hwwdg.Init.EWIMode = WWDG_EWI_ENABLE;  <span class="hljs-keyword">if</span> (HAL_WWDG_Init(&amp;hwwdg) != HAL_OK)  &#123;    Error_Handler();  &#125;&#125;</code></pre></div><ul><li>在<strong>stm32f1xx_hal_wwdg.c</strong>文件中找到弱符号早期唤醒中断函数原型，并在wwdg.c中自定义该回调函数<code>__weak void HAL_WWDG_EarlyWakeupCallback(WWDG_HandleTypeDef *hwwdg)</code></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_WWDG_EarlyWakeupCallback</span><span class="hljs-params">(WWDG_HandleTypeDef *hwwdg)</span>&#123;HAL_WWDG_Refresh(hwwdg);<span class="hljs-comment">//在早期唤醒中断函数中喂狗</span>&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main函数中编写代码：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nWWDG Test!!!\r\n&quot;</span>);HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);<span class="hljs-comment">//熄灭LED0</span>HAL_Delay(<span class="hljs-number">500</span>);HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);<span class="hljs-comment">//点亮LED0</span>MX_WWDG_Init();<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-comment">/* Infinite loop */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nHello, WWDG...!\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">1000</span>);    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;<span class="hljs-comment">/* USER CODE END 3 */</span></code></pre></div><ul><li>实验现象：</li></ul><p>LED1常亮，且串口助手显示一直在喂狗：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528191522516.png" alt="image-20230528191522516" style="zoom:67%;" /></p><p>如果注释掉早期唤醒中断函数中的喂狗函数，则LED1闪烁且串口输出，需要<strong>注意</strong>的是，<code>MX_WWDG_Init()</code>函数需要放到LED闪烁函数之后，否则程序一直在复位，根本执行不到后面的部分：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528192419226.png" alt="image-20230528192419226" style="zoom:67%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/wwdg.zip">wwdg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;窗口看门狗简介&quot;&gt;窗口看门狗简介&lt;/h3&gt;
&lt;p&gt;窗口看门狗（WWDG）通常被用来监测由外部干扰或不可预见的逻辑条件造成的应用程序背离正常的运行序列而产生的软件故障。递减计数器需要在一个有限的时间窗口中被刷新才不会产生MCU复位，否则就会产生RESET。WWDG</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX 之独立看门狗</title>
    <link href="http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8B%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <id>http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8B%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97/</id>
    <published>2023-05-28T07:18:47.000Z</published>
    <updated>2023-05-29T00:21:09.575Z</updated>
    
    <content type="html"><![CDATA[<h3 id="独立看门狗简介">独立看门狗简介</h3><p>STM32F1内部自带了 2个看门狗：独立看门狗（IWDG）和窗口看门狗（WWDG)。这一章主要来看看独立看门狗，从功能上说它在程序发生意外（程序进入死循环或跑飞）的时候，能重新回复到系统刚上电状态。</p><p>独立看门狗由内部专门的 40Khz 低速RC时钟驱动，即使主时钟发生故障，它也仍然有效。但它是在 30~60Khz之间的一个可变化的时钟，只是我们在估算的时候，以 40Khz的频率来计算，时钟有些偏差，都是可以接受的。</p><p>实际上独立看门口狗是一个递减计数器，当计时器的值减到0时，IWDG会产生一个复位信号，系统复位重新启动。为避免产生看门狗复位，则需在计数器减到0之前重载计数器,即“喂狗”。</p><p>独立看门狗功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528161307256.png" alt="image-20230528161307256" style="zoom:80%;" /></p><p>独立看门狗超时时间（40KHz的输入时钟LSI）：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528161857687.png" alt="image-20230528161857687" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>我们将通过USART1来打印调试信息，然后通过 LED0提示复位状态。(LED0常亮则系统正常，LED0闪烁则系统一直复位)</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M；</li><li>IWDG的时钟默认为LSI时钟；</li><li>PB5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528170246253.png" alt="image-20230528170246253" style="zoom:67%;" /></p><ul><li><p>激活IWDG，Timeout = (Prescaler*ReloadValue/40)ms;</p><p>IWDG的时钟为40kHz,此时设置计数器时钟为32分频，则分频后的时钟频率为1.25KHz（时钟周期为1s/1250= 0.8ms），递减基础器重载值（down-counter reloadvalue）配置为1000，即800ms不刷新IWDG，则系统复位。</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528164949027.png" alt="image-20230528164949027" style="zoom: 67%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在iwdg.c文件中可以看到独立看门狗的初始化函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_IWDG_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  hiwdg.Instance = IWDG;  hiwdg.Init.Prescaler = IWDG_PRESCALER_32;  hiwdg.Init.Reload = <span class="hljs-number">1000</span>;  <span class="hljs-keyword">if</span> (HAL_IWDG_Init(&amp;hiwdg) != HAL_OK)  &#123;    Error_Handler();  &#125;&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main函数中编写代码:</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nIWDG Test!!!\r\n&quot;</span>);HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);<span class="hljs-comment">//熄灭LED0</span>HAL_Delay(<span class="hljs-number">300</span>);HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_RESET);<span class="hljs-comment">//点亮LED0</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-comment">/* Infinite loop */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//HAL_IWDG_Refresh(&amp;hiwdg);</span>    <span class="hljs-comment">//printf(&quot;\r\nRefreshes the IWDG...!\r\n&quot;);</span>    HAL_Delay(<span class="hljs-number">500</span>); <span class="hljs-comment">//每500ms喂狗一次 &lt; 800ms</span>    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;<span class="hljs-comment">/* USER CODE END 3 */</span></code></pre></div><ul><li>实验现象：</li></ul><p>LED0常亮，且串口助手显示一直在喂狗：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528171626961.png" alt="image-20230528171626961" style="zoom:67%;" /></p><p>如果注释掉while循环里的喂狗动作，则LED0闪烁且串口输出：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528173055722.png" alt="image-20230528173055722" style="zoom:67%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/iwdg.zip">iwdg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;独立看门狗简介&quot;&gt;独立看门狗简介&lt;/h3&gt;
&lt;p&gt;STM32F1内部自带了 2
个看门狗：独立看门狗（IWDG）和窗口看门狗（WWDG)。这一章主要来看看独立看门狗，从功能上说它在程序发生意外（程序进入死循环或跑飞）的时候，能重新回复到系统刚上电状态。&lt;/p&gt;</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX 之定时器中断</title>
    <link href="http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD/"/>
    <id>http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD/</id>
    <published>2023-05-28T03:53:40.000Z</published>
    <updated>2023-05-29T00:21:09.550Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定时器中断简介">定时器中断简介</h3><p>STM32 的定时器功能十分强大，有 TIME1 和 TIME8 等高级定时器，也有TIME2~TIME5 等通用定时器，还有 TIME6 和TIME7等基本定时器。这一章主要介绍通用定时器，是一个通过可编程预分频器（PSC）驱动的16 位自动装载计数器（CNT）构成。STM32的通用定时器可以被用于：测量输入信号的脉冲长度(输入捕获)或者产生输出波形(输出比较和PWM)等。</p><p>通用定时器功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528194943205.png" alt="image-20230528194943205" style="zoom:67%;" /></p><h3 id="硬件设计">硬件设计</h3><p>通过 TIM3 的中断来控制 LED1 的亮灭。TIM3属于MCU内部资源，只需要软件设置即可正常工作。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72MHz；</li><li>TIM3的时钟挂载在APB1上，因为APB1 Prescacler设置为2，所以TIM3时钟为36x2=72MHz；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528200120931.png" alt="image-20230528200120931" style="zoom:67%;" /></p><ul><li><p>PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</p></li><li><p>激活TIM3定时器，**Timeout = (Prescaler-1)*(Period-1)/72MHz**</p><p>时钟源选择为内部时钟，PSC预分频设置为7200-1，向上计数，自动重装载值(ARR)设置为10000-1，在NVIC设置中激活TIM3定时器中断；根据公式可算出：计数器时钟CK_CNT= 72M/7200 = 10000Hz，计时器中断时间为 ARR/10000 = 1s</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528200912377.png" alt="image-20230528200912377" style="zoom: 67%;" /></p></li><li><p>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral ；点击GENERATE CODE，生成工程代码</p></li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在 tim.c 文件中可以看到定时器3的初始化函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_TIM3_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  TIM_ClockConfigTypeDef sClockSourceConfig = &#123;<span class="hljs-number">0</span>&#125;;  TIM_MasterConfigTypeDef sMasterConfig = &#123;<span class="hljs-number">0</span>&#125;;  htim3.Instance = TIM3;  htim3.Init.Prescaler = <span class="hljs-number">7199</span>;  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;  htim3.Init.Period = <span class="hljs-number">9999</span>;  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;  <span class="hljs-keyword">if</span> (HAL_TIM_Base_Init(&amp;htim3) != HAL_OK)  &#123;    Error_Handler();  &#125;  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;  <span class="hljs-keyword">if</span> (HAL_TIM_ConfigClockSource(&amp;htim3, &amp;sClockSourceConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIMEx_MasterConfigSynchronization(&amp;htim3, &amp;sMasterConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;&#125;</code></pre></div><ul><li>找到弱符号周期运行回调函数原型，并在tim.c中自定义该回调函数<code>__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</code></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_PeriodElapsedCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>&#123;    <span class="hljs-keyword">if</span>(htim == &amp;htim3)    &#123;        HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);<span class="hljs-comment">//LED1状态每1s翻转一次</span>    &#125;&#125;</code></pre></div><ul><li>在main.c中启动TIM3：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_TIM_Base_Start_IT(&amp;htim3); <span class="hljs-comment">//启动TIM3</span><span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div><p>编译下载到开发板，可以看到LED1每1s状态翻转一次，达到预期效果。</p><p>工程文件Gitee: <ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/tim3.zip">tim3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定时器中断简介&quot;&gt;定时器中断简介&lt;/h3&gt;
&lt;p&gt;STM32 的定时器功能十分强大，有 TIME1 和 TIME8 等高级定时器，也有
TIME2~TIME5 等通用定时器，还有 TIME6 和TIME7
等基本定时器。这一章主要介绍通用定时器，是一个通过可</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX 之UART</title>
    <link href="http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8BUART/"/>
    <id>http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8BUART/</id>
    <published>2023-05-28T03:53:27.000Z</published>
    <updated>2023-05-29T00:21:09.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="串口简介">串口简介</h3><p>STM32F103ZET6 最多可提供 5路串口，有分数波特率发生器、支持同步单线通信和半双工单线通讯、支持LIN、支持调制解调器操作、智能卡协议和 IrDA SIR ENDEC 规范、具有DMA等。</p><p>我们通常使用的是异步通信，异步通信规定传输的数据格式由起始位（startbit）、数据位（data bit）、奇偶校验位（parity bit）和停止位（stopbit）组成。在进行传输之前，双方一定要使用相同的波特率，波特率就是每秒钟传输的数据位数。串口通讯有HAL库轮询，中断，DMA 三种通信模式：</p><ul><li><strong>轮询方式</strong>：CPU不断查询IO设备，如设备有请求则加以处理。例如CPU不断查询串口是否传输完成，如传输超过则返回超时错误。轮询方式会占用CPU处理时间，效率较低。</li><li><strong>中断控制方式</strong>：当I/O操作完成时，输入输出设备控制器通过中断请求线向处理器发出中断信号，处理器收到中断信号之后，转到中断处理程序，对数据传送工作进行相应的处理。</li><li><strong>直接内存存取技术（DMA）方式</strong>：所谓直接传送，即在内存与IO设备间传送一个数据块的过程中，不需要CPU的任何中间干涉，只需要CPU在过程开始时向设备发出“传送块数据”的命令，然后通过中断来得知过程是否结束和下次操作是否准备就绪。</li></ul><h3 id="硬件设计">硬件设计</h3><p>战舰开发板板载了 1 个 USB和 2 个 RS232串口。通过CH340芯片把串口1与PC的USB口进行连接，实现串口传输。我们将利用串口1不停的打印信息到电脑上，同时接收从串口发过来的数据，把发送过来的数据直接送回给电脑。</p><p><img src="E:\KayoungZhang.github.io\source\_posts\STM32CubeMX-之UART\image-20230528133425092.png" alt="image-20230528133425092" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li></ul><figure><imgsrc="E:\KayoungZhang.github.io\source_posts\STM32CubeMX-之UART\image-20230528134337560.png"alt="image-20230528134337560" /><figcaption aria-hidden="true">image-20230528134337560</figcaption></figure><ul><li>若使用中断方式，还需要开启串口中断</li></ul><figure><imgsrc="E:\KayoungZhang.github.io\source_posts\STM32CubeMX-之UART\image-20230528134456998.png"alt="image-20230528134456998" /><figcaption aria-hidden="true">image-20230528134456998</figcaption></figure><ul><li>若使用直接内存存取（DMA）方式，除以上步骤外（串口中断要开启，否则程序只能发送一次数据，且不能判断DMA传输是否完成，USART一直处于busy状态）还需要设置DMA传输方向、通道、优先级、数据长度以及指针递增与否</li></ul><figure><imgsrc="E:\KayoungZhang.github.io\source_posts\STM32CubeMX-之UART\image-20230528134749373.png"alt="image-20230528134749373" /><figcaption aria-hidden="true">image-20230528134749373</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated periphera initialization as a pair of ‘.c/.h’ filesper IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm软件编程">MDK-ARM软件编程</h4><p>在生成的usart.c文件中，软件已经帮我们实现了UART1和GPIO的初始化操作，以下只看轮询方式初始化函数。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_USART1_UART_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN USART1_Init 0 */</span>  <span class="hljs-comment">/* USER CODE END USART1_Init 0 */</span>  <span class="hljs-comment">/* USER CODE BEGIN USART1_Init 1 */</span>  <span class="hljs-comment">/* USER CODE END USART1_Init 1 */</span>  huart1.Instance = USART1;  huart1.Init.BaudRate = <span class="hljs-number">115200</span>;  huart1.Init.WordLength = UART_WORDLENGTH_8B;  huart1.Init.StopBits = UART_STOPBITS_1;  huart1.Init.Parity = UART_PARITY_NONE;  huart1.Init.Mode = UART_MODE_TX_RX;  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;  huart1.Init.OverSampling = UART_OVERSAMPLING_16;  <span class="hljs-keyword">if</span> (HAL_UART_Init(&amp;huart1) != HAL_OK)  &#123;    Error_Handler();  &#125;  <span class="hljs-comment">/* USER CODE BEGIN USART1_Init 2 */</span>  <span class="hljs-comment">/* USER CODE END USART1_Init 2 */</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_MspInit</span><span class="hljs-params">(UART_HandleTypeDef* uartHandle)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-keyword">if</span>(uartHandle-&gt;Instance==USART1)  &#123;  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspInit 0 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspInit 0 */</span>    <span class="hljs-comment">/* USART1 clock enable */</span>    __HAL_RCC_USART1_CLK_ENABLE();    __HAL_RCC_GPIOA_CLK_ENABLE();    <span class="hljs-comment">/**USART1 GPIO Configuration</span><span class="hljs-comment">    PA9     ------&gt; USART1_TX</span><span class="hljs-comment">    PA10     ------&gt; USART1_RX</span><span class="hljs-comment">    */</span>    GPIO_InitStruct.Pin = GPIO_PIN_9;    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);    GPIO_InitStruct.Pin = GPIO_PIN_10;    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;    GPIO_InitStruct.Pull = GPIO_NOPULL;    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspInit 1 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspInit 1 */</span>  &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_MspDeInit</span><span class="hljs-params">(UART_HandleTypeDef* uartHandle)</span>&#123;  <span class="hljs-keyword">if</span>(uartHandle-&gt;Instance==USART1)  &#123;  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspDeInit 0 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspDeInit 0 */</span>    <span class="hljs-comment">/* Peripheral clock disable */</span>    __HAL_RCC_USART1_CLK_DISABLE();    <span class="hljs-comment">/**USART1 GPIO Configuration</span><span class="hljs-comment">    PA9     ------&gt; USART1_TX</span><span class="hljs-comment">    PA10     ------&gt; USART1_RX</span><span class="hljs-comment">    */</span>    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_9|GPIO_PIN_10);  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspDeInit 1 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspDeInit 1 */</span>  &#125;&#125;</code></pre></div><p>打印输出会使用到printf函数，若要printf输出到串口，需要将fputc函数里面的输出指向串口(重定向)，在<code>usart.c</code>文件中重定向<code>fputc</code>函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span>&#123;HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span>*)&amp;ch, <span class="hljs-number">1</span>, <span class="hljs-number">0xffff</span>);<span class="hljs-keyword">return</span> ch;&#125;</code></pre></div><p>同时需要勾选 <strong>Use MicroLIB</strong></p><p><img src="E:\KayoungZhang.github.io\source\_posts\STM32CubeMX-之UART\image-20230528140811005.png" alt="image-20230528140811005" style="zoom:80%;" /></p><p>下面在main函数中针对UART1三种操作方式进行编写程序：</p><ul><li>轮询方式</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    HAL_UART_Transmit(&amp;huart1, <span class="hljs-string">&quot;HAL_UART_Transmit Test...&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-number">0xffff</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n uart test...\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">500</span>);    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;</code></pre></div><p>实验现象：</p><p><img src="E:\KayoungZhang.github.io\source\_posts\STM32CubeMX-之UART\image-20230528141728742.png" alt="image-20230528141728742" style="zoom:80%;" /></p><ul><li>中断方式</li></ul><p>在<strong>stm32f1xx_hal_uart.c</strong>文件中找到弱符号中断接收完成回调函数原型，并在usart.c中自定义该回调函数<code>__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</code></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> RxMsg[<span class="hljs-number">20</span>];<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_RxCpltCallback</span><span class="hljs-params">(UART_HandleTypeDef *huart)</span>&#123;<span class="hljs-keyword">if</span>(huart-&gt;Instance == USART1)&#123;HAL_UART_Transmit(&amp;huart1,RxMsg,<span class="hljs-number">10</span>,<span class="hljs-number">0xffff</span>);<span class="hljs-comment">//将接收的数据通过串口1发送回去</span>HAL_UART_Receive_IT(&amp;huart1,RxMsg,<span class="hljs-number">10</span>);<span class="hljs-comment">//再次开启接收中断</span>&#125;&#125;</code></pre></div><p>在<strong>main.c</strong>中添加以下代码： <div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint8_t</span> TxMsg[] = <span class="hljs-string">&quot;\r\n*****USART communication based on IT*****\r\n&quot;</span>;<span class="hljs-type">uint8_t</span> RxMsg[<span class="hljs-number">20</span>];<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_UART_Transmit_IT(&amp;huart1,TxMsg,<span class="hljs-keyword">sizeof</span>(TxMsg)); <span class="hljs-comment">//开启发送数据中断</span>HAL_UART_Receive_IT(&amp;huart1,RxMsg,<span class="hljs-number">10</span>); <span class="hljs-comment">//开启接收数据中断</span><span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div></p><p>使用串口助手发送10个字符，串口助手回显发送的数据；串口要发够10个字符才会触发中断；超过10个字符，串口只会发送10个字符（<strong>注意</strong>不要勾选‘发送新行’）</p><p>实验现象：</p><p><img src="E:\KayoungZhang.github.io\source\_posts\STM32CubeMX-之UART\image-20230528144050587.png" alt="image-20230528144050587" style="zoom:80%;" /></p><ul><li>DMA方式</li></ul><p>在 main.c中添加如下代码：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint8_t</span> TxMsg[] = <span class="hljs-string">&quot;\r\n*****USART communication based on DMA*****\r\n&quot;</span>;<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    HAL_UART_Transmit_DMA(&amp;huart1,TxMsg,<span class="hljs-keyword">sizeof</span>(TxMsg));    HAL_Delay(<span class="hljs-number">500</span>);    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;<span class="hljs-comment">/* USER CODE END 3 */</span></code></pre></div><p>另外需要<strong>注意</strong>,软件会将DMA初始化函数放到uart初始化函数后面，这样无法实现DMA寄存器设置，无法实现功能。必须将MX_DMA_Init函数放在UARTDMA配置之前调用。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Initialize all configured peripherals */</span>MX_DMA_Init();MX_GPIO_Init();MX_USART1_UART_Init();<span class="hljs-comment">/* USER CODE BEGIN 2 */</span></code></pre></div><p>实验现象：</p><p><img src="E:\KayoungZhang.github.io\source\_posts\STM32CubeMX-之UART\image-20230528150421728.png" alt="image-20230528150421728" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/uart.zip">uart</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;串口简介&quot;&gt;串口简介&lt;/h3&gt;
&lt;p&gt;STM32F103ZET6 最多可提供 5
路串口，有分数波特率发生器、支持同步单线通信和半双工单线通讯、支持
LIN、支持调制解调器操作、智能卡协议和 IrDA SIR ENDEC 规范、具有
DMA等。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX 之EXTI</title>
    <link href="http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8BEXTI/"/>
    <id>http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8BEXTI/</id>
    <published>2023-05-28T03:51:37.000Z</published>
    <updated>2023-05-29T00:21:09.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="exti介绍">EXTI介绍</h3><p>STM32F103 的外部中断/事件控制器支持19个外部中断/事件请求（互联网型产品支持20个）。每个中断设有状态位，每个中断/事件都有独立的触发和屏蔽设置。</p><p>STM32F103的19个外部中断为：</p><ul><li>EXTI线0~15：对应外部IO口的输入中断</li><li>EXTI线16：连接到PVD输出</li><li>EXTI线17：连接到RTC闹钟事件</li><li>EXTI线18：连接到USB唤醒事件</li><li>EXTI线19：连接到以太网唤醒事件（互联网型产品）</li></ul><p>其中112个GPIO通过以下方式映射到16个外部中断/事件线上：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528115852770.png" alt="image-20230528115852770" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528102842722.png"alt="image-20230528102842722" /><figcaption aria-hidden="true">image-20230528102842722</figcaption></figure><p>这一章主要是通过外部中断的方式，用开发板上的4个按钮（KEY_UP、KEY0、KEY1 和 KEY2）来控制板上的 2 个 LED（DS0 和DS1）和蜂鸣器。</p><ul><li>KEY_UP 控制蜂鸣器，按一次叫，再按一次停；</li><li>KEY2 控制 DS0，按一次亮，再按一次灭；</li><li>KEY1 控制 DS1，效果同 KEY2；</li><li>KEY0 则同时控制 DS0 和 DS1，按一次，他们的状态就翻转一次。</li></ul><p><strong>注意</strong>：KEY0、KEY1 和 KEY2外部没有上下拉电阻，所以需要在MCU内部设置上下拉。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx配置">STM32CubeMx配置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PA0设置为<strong>GPIO外部中断上升沿触发模式</strong>、下拉；</li><li>PE2/PE3/PE4设置为<strong>GPIO外部中断下降沿触发模式</strong>、上拉；</li><li>PB8设置为GPIO推挽输出模式、上拉、高速、默认输出电平为低电平；</li><li>PB5和PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li></ul><h4id="section"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528122534347.png" alt="image-20230528122534347"  /></h4><ul><li>在NVIC(嵌套向量中断控制器)中，勾选EXIT Line0/2/3/4interrupt，使能PA0和PE2/3/4中断。右边两个选项设置抢占优先级和响应优先级</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528123030801.png"alt="image-20230528123030801" /><figcaption aria-hidden="true">image-20230528123030801</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated periphera initialization as a pair of ‘.c/.h’ filesper IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在gpio.c文件中可以看到gpio初始化函数。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_GPIO_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">/* GPIO Ports Clock Enable */</span>  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(BEEP_GPIO_Port, BEEP_Pin, GPIO_PIN_RESET);  <span class="hljs-comment">/*Configure GPIO pins : PE2 PE3 PE4 */</span>  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4;  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;  GPIO_InitStruct.Pull = GPIO_PULLUP;  HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED1_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(LED1_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PA0 */</span>  GPIO_InitStruct.Pin = GPIO_PIN_0;  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;  GPIO_InitStruct.Pull = GPIO_PULLDOWN;  HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pins : PBPin PBPin */</span>  GPIO_InitStruct.Pin = LED0_Pin|BEEP_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);  <span class="hljs-comment">/* EXTI interrupt init*/</span>  HAL_NVIC_SetPriority(EXTI0_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);  HAL_NVIC_EnableIRQ(EXTI0_IRQn);  HAL_NVIC_SetPriority(EXTI2_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);  HAL_NVIC_EnableIRQ(EXTI2_IRQn);  HAL_NVIC_SetPriority(EXTI3_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);  HAL_NVIC_EnableIRQ(EXTI3_IRQn);  HAL_NVIC_SetPriority(EXTI4_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  HAL_NVIC_EnableIRQ(EXTI4_IRQn);&#125;</code></pre></div><p>在<strong>stm32f1xx_hal_gpio.c</strong>文件中找到GPIOEXTI弱符号中断回调函数原型，并在gpio.c中自定义该回调函数<code>__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)</code></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span>&#123;HAL_Delay(<span class="hljs-number">10</span>);<span class="hljs-comment">/* PA0 -&gt; EXTI0 */</span><span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_0)&#123;HAL_GPIO_TogglePin(BEEP_GPIO_Port, BEEP_Pin);&#125;<span class="hljs-comment">/* PE2 -&gt; EXTI2 */</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_2)&#123;HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);&#125;<span class="hljs-comment">/* PE3 -&gt; EXTI3 */</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_3)&#123;HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);&#125;<span class="hljs-comment">/* PE4 -&gt; EXTI4 */</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_4)&#123;HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);&#125;&#125;<span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div><p>main.c函数不需要添加任何代码，编译下载，跟按键输入一章同样的现象，获得预期目标。</p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/exti.zip">exti</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;exti介绍&quot;&gt;EXTI介绍&lt;/h3&gt;
&lt;p&gt;STM32F103 的外部中断/事件控制器支持
19个外部中断/事件请求（互联网型产品支持20个）。每个中断设有状态位，每个中断/事件都有独立的触发和屏蔽设置。&lt;/p&gt;
&lt;p&gt;STM32F103的19个外部中断为</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX 之按键输入</title>
    <link href="http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8B%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5/"/>
    <id>http://example.com/2023/05/28/STM32CubeMX-%E4%B9%8B%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5/</id>
    <published>2023-05-28T02:13:19.000Z</published>
    <updated>2023-05-29T00:21:09.562Z</updated>
    
    <content type="html"><![CDATA[<p>上一节介绍了GPIO的输出使用，这一节介绍一下GPIO的输入，GPIO口作为输入使用的时候，是通过读取GPIOx_IDR寄存器内容来获得IO口的状态。</p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528102842722.png"alt="image-20230528102842722" /><figcaption aria-hidden="true">image-20230528102842722</figcaption></figure><p>通过开发板上的4 个按钮（KEY_UP、KEY0、KEY1 和 KEY2）来控制板上的 2 个LED（DS0 和 DS1）和蜂鸣器。</p><ul><li>KEY_UP 控制蜂鸣器，按一次叫，再按一次停；</li><li>KEY2 控制 DS0，按一次亮，再按一次灭；</li><li>KEY1 控制 DS1，效果同 KEY2；</li><li>KEY0 则同时控制 DS0 和 DS1，按一次，他们的状态就翻转一次。</li></ul><p><strong>注意</strong>：KEY0、KEY1 和 KEY2外部没有上下拉电阻，所以需要在MCU内部设置上下拉。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PA0设置为GPIO输入模式、下拉；</li><li>PE2/PE3/PE4设置为GPIO输入模式、上拉；</li><li>PB8设置为GPIO推挽输出模式、上拉、高速、默认输出电平为低电平；</li><li>PB5和PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528104919285.png"alt="image-20230528104919285" /><figcaption aria-hidden="true">image-20230528104919285</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated periphera initialization as a pair of ‘.c/.h’ filesper IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm软件编程">MDK-ARM软件编程</h4><ol type="1"><li>在gpio.c文件中可以看到各GPIO管脚的初始化函数</li></ol><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_GPIO_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">/* GPIO Ports Clock Enable */</span>  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(BEEP_GPIO_Port, BEEP_Pin, GPIO_PIN_RESET);  <span class="hljs-comment">/*Configure GPIO pins : PEPin PEPin PEPin */</span>  GPIO_InitStruct.Pin = KEY2_Pin|KEY1_Pin|KEY0_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;  GPIO_InitStruct.Pull = GPIO_PULLUP;  HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED1_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(LED1_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = WK_UP_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;  GPIO_InitStruct.Pull = GPIO_PULLDOWN;  HAL_GPIO_Init(WK_UP_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pins : PBPin PBPin */</span>  GPIO_InitStruct.Pin = LED0_Pin|BEEP_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);&#125;</code></pre></div><ol start="2" type="1"><li>在工程的应用文件目录下创建key文件夹，并在文件夹中创建key.c和key.h文件，然后编写按键相关函数</li></ol><ul><li>key.h文件：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _KEY_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> _KEY_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f1xx.h&quot;</span></span><span class="hljs-comment">//下面的方式是通过直接操作HAL库函数方式读取IO</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0        HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_4)  <span class="hljs-comment">//KEY0按键PE4</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1        HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_3)  <span class="hljs-comment">//KEY1按键PE3</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY2        HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_2) <span class="hljs-comment">//KEY2按键PE2</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WK_UP       HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0)  <span class="hljs-comment">//WKUP按键PA0</span></span><span class="hljs-comment">//定义按键按下时的键值</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_PRES 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_PRES2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY2_PRES3</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_PRES   4</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">key_scan</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> mode)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><ul><li>key.c文件：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;key.h&quot;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief按键处理函数,返回按键值(注意此函数有响应优先级,KEY0&gt;KEY1&gt;KEY2&gt;WK_UP!!)</span><span class="hljs-comment">  * @parammode:0 不支持连续按；1 支持连续按</span><span class="hljs-comment">  * @retval按键值</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">key_scan</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> mode)</span>&#123;    <span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> key_up=<span class="hljs-number">1</span>;     <span class="hljs-comment">//按键松开标志</span>    <span class="hljs-keyword">if</span>(mode==<span class="hljs-number">1</span>)key_up=<span class="hljs-number">1</span>;    <span class="hljs-comment">//支持连按</span>    <span class="hljs-keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="hljs-number">0</span>||KEY1==<span class="hljs-number">0</span>||KEY2==<span class="hljs-number">0</span>||WK_UP==<span class="hljs-number">1</span>))    &#123;        HAL_Delay(<span class="hljs-number">10</span>);<span class="hljs-comment">//按键消抖</span>        key_up=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(KEY0==<span class="hljs-number">0</span>)       <span class="hljs-keyword">return</span> KEY0_PRES;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY1==<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> KEY1_PRES;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY2==<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> KEY2_PRES;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(WK_UP==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> WKUP_PRES;              &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY0==<span class="hljs-number">1</span>&amp;&amp;KEY1==<span class="hljs-number">1</span>&amp;&amp;KEY2==<span class="hljs-number">1</span>&amp;&amp;WK_UP==<span class="hljs-number">0</span>)key_up=<span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//无按键按下</span>&#125;</code></pre></div><ul><li>在main.c函数中编写相关程序</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>  <span class="hljs-type">uint8_t</span> key;  <span class="hljs-comment">/* USER CODE END 1 */</span>  <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>  <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>  HAL_Init();  <span class="hljs-comment">/* USER CODE BEGIN Init */</span>  <span class="hljs-comment">/* USER CODE END Init */</span>  <span class="hljs-comment">/* Configure the system clock */</span>  SystemClock_Config();  <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>  <span class="hljs-comment">/* USER CODE END SysInit */</span>  <span class="hljs-comment">/* Initialize all configured peripherals */</span>  MX_GPIO_Init();  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>  <span class="hljs-comment">/* USER CODE END 2 */</span>  <span class="hljs-comment">/* Infinite loop */</span>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>key = key_scan(<span class="hljs-number">0</span>);<span class="hljs-keyword">switch</span>(key)    &#123;<span class="hljs-keyword">case</span> WKUP_PRES:&#123;<span class="hljs-comment">/* 控制蜂鸣器 */</span>HAL_GPIO_TogglePin(BEEP_GPIO_Port, BEEP_Pin);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> KEY2_PRES:&#123;<span class="hljs-comment">/* LED0 */</span>HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> KEY1_PRES:&#123;<span class="hljs-comment">/* LED1 */</span>HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> KEY0_PRES:&#123;<span class="hljs-comment">/* LED0 &amp; LED1 */</span>HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);<span class="hljs-keyword">break</span>;&#125;    &#125;HAL_Delay(<span class="hljs-number">10</span>);  &#125;  <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><ol start="3" type="1"><li>程序验证</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528114108663.png" alt="image-20230528114108663" style="zoom:80%;" /></p><p>注意添加头文件，设置下载器选项，编译下载程序，分别按下按键，现象和预期一致，达到了实验目的。</p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/key.zip">key</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一节介绍了GPIO的输出使用，这一节介绍一下GPIO的输入，GPIO口作为输入使用的时候，是通过读取GPIOx_IDR寄存器内容来获得IO口的状态。&lt;/p&gt;
&lt;h3 id=&quot;硬件设计&quot;&gt;硬件设计&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX 之LED闪烁</title>
    <link href="http://example.com/2023/05/27/STM32CubeMX-%E4%B9%8BLED%E9%97%AA%E7%83%81/"/>
    <id>http://example.com/2023/05/27/STM32CubeMX-%E4%B9%8BLED%E9%97%AA%E7%83%81/</id>
    <published>2023-05-27T14:39:01.000Z</published>
    <updated>2023-05-29T00:21:09.521Z</updated>
    
    <content type="html"><![CDATA[<p>下面结合正点原子战舰开发板，对多个外设介绍，并编程实验。</p><p>开发板使用的MCU是STM32F103ZET6，进入ST官网，下载其相关资料。<ahref="https://www.st.com/en/microcontrollers-microprocessors/stm32f103ze.html#documentation">STM32F103ZE</a></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527225335619.png"alt="image-20230527225335619" /><figcaption aria-hidden="true">image-20230527225335619</figcaption></figure><h3 id="gpio口简介">GPIO口简介</h3><p>每个GPIO端口有两个32位配置寄存器（GPIOx_CRL和GPIOx_CRH），两个32位数据寄存器（GPIOx_IDR和GPIOx_ODR），一个32位置位/复位寄存器（GPIOx_BSRR），一个16位复位寄存器（GPIOx_BRR）和一个32位锁定寄存器（GPIOx_LCKR）。在HAL库中，GPIO端口的每个位可以由软件分别配置成多种模式：</p><ul><li>浮空输入模式</li><li>开漏输出模式</li><li>复用推挽模式</li><li>复用输入模式</li><li>模拟模式</li><li>上升沿触发中断模式</li><li>下降沿触发中断模式</li><li>上升沿/下降沿触发中断模式</li><li>上升沿触发事件模式</li><li>下降沿触发事件模式</li><li>上升沿/下降沿触发事件模式</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527225635350.png" alt="image-20230527225635350" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">1. STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PB5和PE5设置为GPIO推挽输出模式、上拉、低速、默认输出电平为高电平</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527232409961.png" alt="image-20230527232409961"  /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated periphera initialization as a pair of ‘.c/.h’ filesper IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="keil工程代码的编写">2.keil工程代码的编写</h4><ul><li>CubeMX已经帮我们完成gpio初始化的过程。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_GPIO_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">/* GPIO Ports Clock Enable */</span>  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED1_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  HAL_GPIO_Init(LED1_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED0_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  HAL_GPIO_Init(LED0_GPIO_Port, &amp;GPIO_InitStruct);&#125;</code></pre></div><ul><li>我们只需要在main.c函数中编写LED闪烁程序即可（<strong>注意编写的程序应该在相应的USERCODE范围内，否则再次使用CubeMX修改配置时，USERCODE范围之外的程序会被清除</strong>）</li></ul><p>在<strong>stm32f1xx_hal_gpio.h</strong>库文件中,找到可以改变引脚电平的API函数</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_WritePin</span><span class="hljs-params">(GPIO_TypeDef *GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin, GPIO_PinState PinState)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_TogglePin</span><span class="hljs-params">(GPIO_TypeDef *GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span>;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527234410653.png" alt="image-20230527234410653" style="zoom:80%;" /></p><ul><li>下载程序</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527235236622.png" alt="image-20230527235236622" style="zoom:80%;" /></p><p>可以看到两个LED不停的闪烁。</p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/led.zip">LED</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面结合正点原子战舰开发板，对多个外设介绍，并编程实验。&lt;/p&gt;
&lt;p&gt;开发板使用的MCU是STM32F103ZET6，进入ST官网，下载其相关资料。&lt;a
href=&quot;https://www.st.com/en/microcontrollers-microprocess</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX 之开发环境的搭建</title>
    <link href="http://example.com/2023/05/27/STM32CubeMX-%E4%B9%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2023/05/27/STM32CubeMX-%E4%B9%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2023-05-27T12:39:20.000Z</published>
    <updated>2023-05-29T00:21:09.561Z</updated>
    
    <content type="html"><![CDATA[<p>在ST公司推出HAL库之前，开发SMT32一般使用的是标准库，但后来为了便于移植程序，官方不再更新STM32标准库，而大力推崇HAL库，伴随HAL库的兴起，ST推出了STM32CubeMX开发工具，它是STM32芯片图形化配置工具，允许用户使用图形化向导生成C初始化代码，极大限度内减少了工程师的工作量，转而把工作重点放在项目逻辑层、应用层的实现。另外，ST也同时推出一整套IDE软件STM32CubeIDE，本章不做过多介绍。</p><p>HAL 的全称是：<strong>Hardware Abstraction Layer(硬件抽象层)</strong>，HAL位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化。它是一个由ST公司基于硬件抽象层而设计的软件函数包，由程序、数据结构、宏等组成，包括了微控制器所有外设的性能特征。此外HAL函数库包括每一个外设的驱动描述和应用实例，为开发者访问底层硬件提供了一个中间API，所以说通过使用 HAL库，工程师不需要花过多精力去深入掌握底层硬件细节，就可以应用STM32的每个外设，实现快速二次开发的目的。</p><h3 id="smt32开发环境的搭建">SMT32开发环境的搭建</h3><p><strong>友情提醒：全程下载安装过程中尽量不要使用中文目录，防止个别异常情况发生。</strong></p><h4 id="一keil-mdk-arm软件的安装">一、Keil MDK-ARM软件的安装</h4><ol type="1"><li>获取Keil MDK-ARM软件：<ahref="https://developer.arm.com/Tools%20and%20Software/Keil%20MDK">官网</a></li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527210314137.png"alt="image-20230527210314137" /><figcaption aria-hidden="true">image-20230527210314137</figcaption></figure><p>可以安装社区版，免费正版使用一年，需要进行注册才能下载，为了学习可以在网上查找其他方式进行安装。</p><ol start="2" type="1"><li>获取STM32芯片设备安装包：<ahref="https://www.keil.arm.com/devices/?q=&amp;vendor=stmicroelectronics&amp;core=Cortex-M3&amp;sort_by=">官网</a></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527210938403.png" alt="image-20230527210938403"  /></p><p>选择对应的厂商和内核版本，进行相应下载即可。</p><ol start="3" type="1"><li>安装keil软件和STM32设备安装包</li></ol><h4 id="二stm32cubemx软件的安装">二、STM32CubeMX软件的安装</h4><p>安装STM32CubeMX必须具备的条件：</p><ul><li>JRE（Java Runtime Environment）：JAVA运行环境。</li><li>STM32CubeMX软件：生成初始化代码的地方。</li><li>HAL库PACK包：F0、F1、F3、H7等Cortex内核，都需要对应的PACK包安装。</li></ul><ol type="1"><li>安装JRE：JRE官网下载链接：https://www.java.com/en/download/manual.jsp</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527212452472.png" alt="image-20230527212452472" style="zoom:80%;" /></p><ol start="2" type="1"><li>获取STM32CubeMX：<ahref="https://www.st.com/en/development-tools/stm32cubemx.html">官网</a></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527211706175.png" alt="image-20230527211706175"  /></p><ol start="3" type="1"><li>获取HAL库 PACK包，由两种方式：</li></ol><ul><li>通过STM32CubeMX软件进行安装</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527213020674.png" alt="image-20230527213020674" style="zoom: 67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527213741351.png" alt="image-20230527213741351" style="zoom: 80%;" /></p><ul><li>下载离线PACK包，然后通过STM32CubeMX软件进行安装：<ahref="https://www.st.com/en/development-tools/stm32cubemx.html#tools-software">官网</a></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527214001528.png" alt="image-20230527214001528" style="zoom: 67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527213852127.png" alt="image-20230527213852127" style="zoom:80%;" /></p><h4 id="三stm32cubemx使用">三、STM32CubeMX使用</h4><ul><li>新建工程，选择对应开发MCU</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527214446420.png" alt="image-20230527214446420"  /></p><ul><li>RCC设置，选择HSE（外部高速时钟）为Crystal/CeramicResonator（晶振/陶瓷谐振器）</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527214726370.png" alt="image-20230527214726370"  /></p><ul><li>时钟配置，STM32F103最高时钟为72M</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527215030571.png" alt="image-20230527215030571"  /></p><ul><li>功能外设配置，以PA0/PA1为例，设置GPIO引脚相关参数</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527215605956.png" alt="image-20230527215605956"  /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527215826116.png"alt="image-20230527215826116" /><figcaption aria-hidden="true">image-20230527215826116</figcaption></figure><ul><li>工程设置并生成Keil工程</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527220345421.png"alt="image-20230527220345421" /><figcaption aria-hidden="true">image-20230527220345421</figcaption></figure><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528000940001.png" alt="image-20230528000940001"  /></p><ul><li>点击OpenProject，打开keil工程，至此就配置好了工程外设初始化；在gpio.c文件中可以看到PA0/PA1管脚的初始化函数；至此用户可以根据自已的需求编写应用程序</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527221407553.png" alt="image-20230527221407553" style="zoom: 80%;" /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527222104592.png"alt="image-20230527222104592" /><figcaption aria-hidden="true">image-20230527222104592</figcaption></figure><h4 id="参考链接">参考链接：</h4><p><a href="http://t.csdn.cn/dnLul">STM32CubeMX系列</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在ST公司推出HAL库之前，开发SMT32一般使用的是标准库，但后来为了便于移植程序，官方不再更新STM32标准库，而大力推崇HAL库，伴随HAL库的兴起，ST推出了STM32CubeMX开发工具，它是STM32芯片图形化配置工具，
允许用户使用图形化向导生成C
初始化</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>经典运放电路的分析与计算</title>
    <link href="http://example.com/2023/05/27/%E7%BB%8F%E5%85%B8%E8%BF%90%E6%94%BE%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%A1%E7%AE%97/"/>
    <id>http://example.com/2023/05/27/%E7%BB%8F%E5%85%B8%E8%BF%90%E6%94%BE%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%A1%E7%AE%97/</id>
    <published>2023-05-27T04:36:24.000Z</published>
    <updated>2023-05-29T00:21:09.608Z</updated>
    
    <content type="html"><![CDATA[<p>基本运放电路是模拟电路的学习重点，复杂的模拟电路很多都是由基本运放电路组成的。在运放电路中，一般运用运放的“虚短”和“虚断”来进行分析，然后应用欧姆定律等电流电压关系，即可得输入输出的关系。</p><p><strong>“虚短”</strong>是指在分析运算放大器处于线性状态时，可把两输入端视为等电位（<strong>V+= V-</strong>），这一特性称为虚假短路，简称虚短。显然不能将两输入端真正短路。</p><p><strong>“虚断”</strong>是指在分析运放处于线性状态时，可以把两输入端视为等效开路（<strong>ib-= ib+ =0</strong>），这一特性称为虚假开路，简称虚断。显然不能将两输入端真正断路。（差模输入电阻无穷大）</p><p>以下详细看看基本运放电路：</p><ul><li><strong>反向运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527131553159.png" alt="image-20230527131553159" style="zoom:80%;" /></p><ul><li><strong>同向运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527133057553.png" alt="image-20230527133057553" style="zoom:80%;" /></p><ul><li><strong>反相求和运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527134531510.png" alt="image-20230527134531510" style="zoom:80%;" /></p><ul><li><strong>同相求和运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527140528733.png" alt="image-20230527140528733" style="zoom:80%;" /></p><ul><li><strong>减法运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527141757901.png" alt="image-20230527141757901" style="zoom:80%;" /></p><ul><li><strong>积分电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527143345994.png" alt="image-20230527143345994" style="zoom:80%;" /></p><ul><li><strong>微分电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527144506543.png" alt="image-20230527144506543" style="zoom:80%;" /></p><ul><li><strong>差分运算电路</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527155455519.png"alt="image-20230527155455519" /><figcaption aria-hidden="true">image-20230527155455519</figcaption></figure><ul><li><strong>电流检测电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527163159557.png" alt="image-20230527163159557" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527163453552.png" alt="image-20230527163453552" style="zoom:80%;" /></p><ul><li><strong>电压检测电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527175438392.png" alt="image-20230527175438392" style="zoom:80%;" /></p><p>以上是基本的运放电路及分析，掌握了基本的运放电路分析方法，对于复杂的运放电路，可以进行拆解分析，在实际应用中要做到举一反三。</p><p><strong>参考链接：</strong></p><p>http://t.csdn.cn/xbhB9</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基本运放电路是模拟电路的学习重点，复杂的模拟电路很多都是由基本运放电路组成的。在运放电路中，一般运用运放的“虚短”和“虚断”来进行分析，然后应用欧姆定律等电流电压关系，即可得输入输出的关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“虚短”&lt;/strong&gt;是指在分析运算放大器处于</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="电路" scheme="http://example.com/tags/%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>几种常用的电平转换方法</title>
    <link href="http://example.com/2023/05/26/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%B5%E5%B9%B3%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2023/05/26/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%B5%E5%B9%B3%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</id>
    <published>2023-05-26T14:48:58.000Z</published>
    <updated>2023-05-29T00:21:09.607Z</updated>
    
    <content type="html"><![CDATA[<p>在电路设计时，有时会遇到电压域不匹配的问题，如外部接口芯片为1.8V供电，而MCU为3.3V供电。这时候就需要进行电平转换才能通讯。下面总结几种常用的电平转换电路。</p><h3 id="二极管电平转换电路">二极管电平转换电路</h3><p>一些通讯模块（4G、NB模块等）的串口是1.8V电平，与常用MCU的3.3V，这时就需要电平转换。需要注意转换的方向，高电压端和低电压端不可调换。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526230229375.png" alt="image-20230526230229375" style="zoom:80%;" /></p><p>当TX为低电平时，D1导通，RX被拉低；</p><p>当TX为高电平3.3V时，D1截止，RX被拉高到1.8V高电平;</p><h3 id="三极管电平转换电路">三极管电平转换电路</h3><ul><li>IC为1.8V电平，MCU为3.3V电平。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526232323959.png" alt="image-20230526232323959" style="zoom:80%;" /></p><p>当TXD为低电平时，Q1导通，RXD被拉低；</p><p>当TXD为高电平1.8V时，Q1截止，RXD被拉到高电平。</p><ul><li>将外接的信号转化为稳定的高低电平。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526232932554.png" alt="image-20230526232932554" style="zoom:80%;" /></p><p>当输入 S_IN 为低电平时，三极管 Q1关断，三极管 Q2 基极为高电平，导致Q2 导通，输出端 S_OUT被拉低，实现两端都为低电平。</p><p>当输入 S_IN 为高电平 (VDD_EXT) 时，三极管 Q1导通，三极管Q2关断，输出端 S_OUT 被 R4 拉高到VDD_MCU，实现两端都为高电平。</p><p>❤️三极管电平转换电路，便宜实用，但是只能单向转化。而且不适用于波特率过高的应用（大概大于400Kbps 就不建议用了）。</p><h3 id="mos管电平转换电路">MOS管电平转换电路</h3><p>在使用I2C、SPI等接口做不同电压域通讯时，就需要用到双向的电平转换电路。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526233821002.png" alt="image-20230526233821002" style="zoom:80%;" /></p><p>取SDA数据线进行分析：</p><p>当SDA1输出高电平时：MOS管Q1的Vgs =0，MOS管关闭，SDA2被电阻R3上拉到5V。</p><p>当SDA1输出低电平时：MOS管Q1的Vgs =3.3V，大于导通电压，MOS管导通，SDA2通过MOS管被拉到低电平。</p><p>当SDA2输出高电平时：MOS管Q1的Vgs不变，MOS维持关闭状态，SDA1被电阻R2上拉到3.3V。</p><p>当SDA2输出低电平时：MOS管不导通，但是它有体二极管，MOS管里的体二极管把SDA1拉低到低电平，此时Vgs约等于3.3V，MOS管导通，进一步拉低了SDA1的电压。</p><h3 id="电平转换芯片">电平转换芯片</h3><p>在一些高速通讯的场合，就需要用到专用的电平转换芯片。芯片有很多种，单向电平转换、带方向控制的双向电平转换、自动双向电平转换等。如SN74LVC4245A、TXS0108EPWR。</p><p>❤️成本相对前面较高，但是速度快，双向并且能够自动检测方向，高速低速场合都适用。</p><p>如果对成本不敏感，电平转换芯片是最稳定可靠的方式。</p><h3 id="参考链接">参考链接</h3><p>http://t.csdn.cn/9Tvhd</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在电路设计时，有时会遇到电压域不匹配的问题，如外部接口芯片为1.8V供电，而MCU为3.3V供电。这时候就需要进行电平转换才能通讯。下面总结几种常用的电平转换电路。&lt;/p&gt;
&lt;h3 id=&quot;二极管电平转换电路&quot;&gt;二极管电平转换电路&lt;/h3&gt;
&lt;p&gt;一些通讯模块（4G、N</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="电路" scheme="http://example.com/tags/%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>PT100测温电路总结分析</title>
    <link href="http://example.com/2023/05/25/PT100%E6%B5%8B%E6%B8%A9%E7%94%B5%E8%B7%AF%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/05/25/PT100%E6%B5%8B%E6%B8%A9%E7%94%B5%E8%B7%AF%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/</id>
    <published>2023-05-25T14:31:38.000Z</published>
    <updated>2023-05-26T08:59:12.378Z</updated>
    
    <content type="html"><![CDATA[<p>PT100温度传感器是一种以铂(Pt)作成的电阻式温度传感器，属于正电阻系数,其电阻和温度变化的关系为：<strong>R=R0(1+αT)其中α=0.003851,Ro 为 100Ω(在 0℃的电阻值),T 为摄氏温度</strong>。</p><p>PT100测温采样电路主要有电桥法、恒流源法、集成芯片法等，分别介绍如下：</p><h3 id="一惠斯通电桥法">一、惠斯通电桥法</h3><p>惠斯通电桥（<strong>Wheatstonebridge</strong>）又称为惠斯登电桥，是一种测量工具，用来精确测量电阻器的电阻值。它的拓扑图如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526091948810.png"alt="image-20230526091948810" /><figcaption aria-hidden="true">image-20230526091948810</figcaption></figure><p>在实际使用中，一般会将电阻的变化量转化为电压的变化，我们通常将其中三个电阻值固定，而将另外一个电阻换成热敏电阻、压敏电阻、PT100等，这时候就可以用电桥来测物理量了。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-22233.png"alt="image-22233" /><figcaption aria-hidden="true">image-22233</figcaption></figure><p>如果将PT100接入电桥，PT100的阻值发生变化导致ΔV发生变化，通过差分运放放大后送入AD转换芯片或直接进入单片机的AD采样部分，再对照PT100的电阻-温度对应表就可以知道当前温度了。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230114357429.png"alt="image-20230114357429" /><figcaption aria-hidden="true">image-20230114357429</figcaption></figure><p><strong>恒压源：</strong></p><p>这里采用TL431通过分压产生+4.096V恒压源，也可通过REF3140作为基准源。</p><p><strong>电桥部分：</strong></p><p>因为PT100厚膜铂电阻温度传感器允许通过的工作<em>电流</em>为:<em>≦5mA</em>，所以电桥部分电阻阻值需要注意。RP2电位器主要作用是调节温度的下限，设计中可以设置为固定值。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-202305150017095.png"alt="image-202305150017095" /><figcaption aria-hidden="true">image-202305150017095</figcaption></figure><p><strong>RF部分：</strong></p><p>参考AD623芯片手册进行滤波干扰处理。</p><p><strong>放大电路：</strong></p><p>RG阻值可改变放大倍数G，RG = 100 kΩ/(G − 1) ，它们的关系如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-202306142609555.png"alt="image-202306142609555" /><figcaption aria-hidden="true">image-202306142609555</figcaption></figure><p>运算放大器还可以用AD620、AD627、OP07、MCP355X等芯片。</p><p><strong>应用</strong></p><p>比如VCC电压为 <strong>+5V</strong>，设置运放增益为<strong>100</strong>，则最大输入电压为 <strong>50mV(5V/100)</strong>.</p><p>运算放大器反向端电压：V- = 4.096*RP2/(2500+RP2)</p><p>运算放大器同向端电压：V+ = V- + 50mV;</p><p>则通过分压原理，PT100最大阻值：R = (2500*V+) / (4.096-V+);</p><p>譬如设置最低温度下限为 <strong>-50℃</strong>，则对应PT100阻值:<strong>80.31Ω</strong>，为了电桥平衡，设置RP2为<strong>80.31Ω</strong>，由以上公式PT100最大阻值R=<strong>113.23Ω</strong>，对应的温度：<strong>30.4℃</strong>。则温度测试的范围（-50~30.4℃），可通过调小运放增益来扩宽温度的范围。（电阻的取值要根据市面上相近的阻值来确定，计算的阻值不见得有）</p><h3 id="二恒流源法">二、恒流源法</h3><p>参考<ahref="https://blog.csdn.net/z3y3m3/article/details/86225594">PT100恒流源测温电路</a></p><h3 id="三芯片集成法">三、芯片集成法</h3><p>集成芯片测PT100，市面有很多，如ADS1120、MAX31865、HX712、HX717、CS1237、TM7711等，查看其芯片手册，一般都会有典型应用线路。</p><h3 id="参考链接">参考链接</h3><p><ahref="PT100/PT1000温度采集电路方案">PT100/PT1000温度采集电路方案</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PT100
温度传感器是一种以铂(Pt)作成的电阻式温度传感器，属于正电阻系数,其电阻和温度变化的关系为：&lt;strong&gt;R=R0(1+αT)
其中α=0.003851,Ro 为 100Ω(在 0℃的电阻值),T 为摄氏温度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;PT10</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="电路" scheme="http://example.com/tags/%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>pcb layout 审核表</title>
    <link href="http://example.com/2023/05/25/pcb-layout-%E5%AE%A1%E6%A0%B8%E8%A1%A8/"/>
    <id>http://example.com/2023/05/25/pcb-layout-%E5%AE%A1%E6%A0%B8%E8%A1%A8/</id>
    <published>2023-05-25T09:32:57.000Z</published>
    <updated>2023-05-25T10:17:06.975Z</updated>
    
    <content type="html"><![CDATA[<p>PCB设计完成需要进行综合检查，除了设计软件设定的规则外，还需要手动确认一些其它重要的信息。</p><h3 id="结构">结构</h3><ul><li><p>PCB中的定位孔位置大小是否和结构的要求一致，旁边是否有挨得太近的器件（保留间距大于1mm）；</p></li><li><p>接插件的型号，方向，顺序是否和要求一致，位置是否合理；</p></li><li><p>母板，子板的连接座的方向，顺序是否一致，位置是否合理；</p></li><li><p>新器件的封装，脚位定义，电气连接都需校对；</p></li></ul><h3 id="原理图和pcb">原理图和PCB</h3><ul><li>确保从原理图导入的网表无误（务必在审核PCB时实际导入，核对）；</li><li>核对PCB的板层设置是否合理；</li></ul><h3 id="电源">电源</h3><ul><li>电源线路要求尽量短，粗，考虑温升；</li><li>关掉敷铜层和走线，点亮地网络，检查地过孔是否足够；</li><li>IC的散热焊盘上是否有多过孔接地；</li></ul><h3 id="usb">USB</h3><ul><li>USB的脚位排序是否正确（VBUS/DM/DP/GND）；</li><li>USB DM,DP走线是否满足差分要求，不要有节点；</li><li>请注意DM，DP走线是否和其它数据线平行（临层平行）</li><li>HOST端口的电源走线宽度是否满足要求；</li></ul><h3 id="wifi">WIFI</h3><ul><li>WIFI天线是否进行包地处理；</li><li>WIFI的接地检查；模块是否可靠接地，模块的散热焊盘不能全敷铜接地；</li><li>晶体Layout检查；晶体电路下方必须铺地，且下面的其它层尽量只走控制线，最好铺地；</li></ul><h3 id="audio">Audio</h3><ul><li>电源的滤波电容是否靠近IC电源管脚，电源线是否有数据线干扰；</li><li>音频IC的下方不能走数据线；</li><li>音频的输入，输出走线（包括MIC）是否包地，是否有高频干扰信号，临层是否有电源层和数字信号；</li><li>如音频线的走线比较长（100mil以上)，建议左右声道中间隔地；</li><li>I2S走线是否分组，在同一区域布线，各数据线是否等长；</li></ul><h3 id="sd">SD</h3><ul><li>SDIO走线是否为一组，在同一区域布线，各数据和CLK等长，CLK尽量包地；</li><li>SD卡座电源管脚位置放置10uF的电容；</li><li>检查SD卡脚位的正确性；</li></ul><h3 id="sdram">SDRAM</h3><ul><li>DDR的走线分四组：数据线（DQ，DM，DQS），地址线，命令线，CLK线。</li></ul><ol start="2" type="1"><li>DQS走线位置应在组内的DQ中间；</li><li>DQS与时钟不要相邻；</li><li>地址/命令/控制信号采用T型拓扑方式，分叉点到DDR芯片两端的长度须尽量等长（若不等长，可走蛇形线使两端等长）；</li><li>蛇形线的中心间距至少3倍线宽；</li></ol><ul><li>尽量拉大数据线与数据线的距离；相邻层的数据线避免正对并行；</li><li>DDR的数据线尽量走PCB的表层，方便阻抗匹配；</li><li>CLK差分对之间是否有端接电阻；</li></ul><h3 id="camera">Camera</h3><ul><li>电源的滤波电容是否靠近相应的IC电源管脚，电源走线是否受到数据线干扰；</li><li>数据线分组，Layout在同一区域，需要控制数据线的等长，误差在500mil之内；</li><li>CLKin/out信号串电阻并电容，复位信号高低电平；</li><li>CLKin和CLKout应包地处理，不要其它数据线相互平行（注意临层平行）；</li></ul><h3 id="lcd">LCD</h3><ul><li>核对LCD座的封装，脚位顺序，屏的插入方式；</li><li>LCD的走线分组，Layout在同一区域，需要控制数据线和CLK的线的等长，误差在500mil之内，特别是有HDMI和RK1000S时；</li><li>LCD的clk最好能包地，串磁珠，并电容；CLK的参考层最好不要换；</li><li>TMDS信号是否按差分线要求Layout；</li><li>LCD的数据线最好的方式是走中间层，尽量少走外层；</li><li>LCD部分的走线和器件需要屏蔽（包括LVDS IC，HDMI IC）</li><li>LCD的FPC位置下面的表层PCB上要留有接地的漏铜区，便于FPC包屏蔽材料接地(如需过EMI测试，LCD一定会要可靠接地）；</li></ul><h3 id="hdmi">HDMI</h3><ul><li>数据线是否分组，同一区域布线，是否等长（误差不超过500mil），CLK上需要串串磁珠并电容到地；</li><li>电源的滤波电容是否靠近IC电源管脚，电源走线是否避开数据线；</li><li>TMDS信号是否按差分线要求Layout；</li><li>HDMI走线和器件需严控屏蔽；</li></ul><h3 id="g">3G</h3><ul><li>电源的走线宽度是否足够宽；滤波电容是否靠近相应的电源管脚；</li><li>3G整机需要有严格的屏蔽（RF电路和数字电路分开屏蔽）；</li><li>3G通话要注意结构上喇叭和MIC位置的处理，喇叭和MIC要有各自的腔体；</li><li>天线的Layout检查；</li></ul><h3 id="gps">GPS</h3><ul><li>电源和滤波电容的位置；</li><li>是否有有严格的屏蔽（RF电路和数字电路分开屏蔽）,所有的具有数字信号的器件都有要求，如Code,LCD,LVDS,HDMI，并且LCD的FPC，摄像头的FPC，喇叭连接线附近都要预留漏铜区便于相关连接线屏蔽接地；</li><li>GPS的天线位置是否合理，和金属部件的距离是否有6mm以上的距离；</li></ul><h3 id="compass">Compass</h3><ul><li>尽量不要放在屏蔽壳内(如有必要，需采用)；</li><li>周围是否大电流的数据线；</li><li>是否和磁感器件，软铁材料保持需要的距离（喇叭，SD卡座）</li></ul><h3 id="测试点检查">测试点检查</h3><ul><li>是否放置如下测试点：开机键；USB口；触摸屏；电池座，耳机座，DC座;外响焊点；</li><li>测试点直径需要0.8mm，测试点与测试点的距离不能小于1.25mm，测试点与器件的距离不能小于0.2mm；</li></ul><h3 id="发热器件">发热器件</h3><ul><li>发热器件应该放置在利于散热的位置上,且注意不要放置在对温度敏感的器件旁边；</li><li>不同发热器件的距离最好能拉开距离，尽量保持在20mm以上；</li></ul><h3 id="其它">其它</h3><ul><li>WIFI天线不能放在手能握住的地方，避免客户使用机器的时候信号不好；</li><li>调试口是否接出；</li><li>PCB的版本和日期是否标识清晰；</li><li>如果有其它器件，请参考它们的Layout规格；</li></ul><p>以上部分摘录自PCB联盟网，PCB设计完成后，对照审核表进行详细检查，可以避免PCB设计的错误，另外，“<ahref="https://dfm.elecfans.com/viewer/?tid=DFM-dh">华秋DFM</a>”软件可检查PCB的可制造性，它可自动分析PCB的设计缺陷。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230525180738659.png" alt="image-20230525180738659" style="zoom:80%;" /></p><p><a href="https://gitee.com/kayoungzhang/my_codehub.git">PCB layoutchecklist</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PCB设计完成需要进行综合检查，除了设计软件设定的规则外，还需要手动确认一些其它重要的信息。&lt;/p&gt;
&lt;h3 id=&quot;结构&quot;&gt;结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;PCB中的定位孔位置大小是否和结构的要求一致，旁边是否有挨得太近的器件（保留间距大于1mm）；&lt;/p&gt;</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="pcb" scheme="http://example.com/tags/pcb/"/>
    
  </entry>
  
  <entry>
    <title>PCB layout rules</title>
    <link href="http://example.com/2023/05/24/PCB-layout-rules/"/>
    <id>http://example.com/2023/05/24/PCB-layout-rules/</id>
    <published>2023-05-24T11:23:43.000Z</published>
    <updated>2023-05-24T14:40:06.233Z</updated>
    
    <content type="html"><![CDATA[<p>PCB设计过程中，器件的整体布局和关键信号的layout至关重要，布局得当，信号线layout顺畅，就会在后续设计开发过程中，减少不必要的麻烦，相反，布局不当，layout失误，一是影响PCB整体的美观程度，二是在测试应用中带来诸多麻烦。为了减少不必要的设计麻烦，下面介绍一些常用的PCB设计的布局和layout规则：</p><h3 id="pcb布局">PCB布局</h3><ul><li>首先对结构有限高或位置要求的器件进行摆放。布局要美观，器件间尽量对齐。</li><li>PCB整体布局要考虑散热，电源，模拟、数字电路和高速、中速、低速电路等要分开布局。强电流、高电压、强辐射元件要远离弱电流、低电压、敏感器件。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524194603654.png" alt="image-20230524194603654" style="zoom:80%;" /></p><ul><li><p>以每个功能电路的核心组件为中心，围绕它进行布局，尽量减少和缩短各零件间的引线和连接。</p></li><li><p>高压元器件和低压元器件之间最好要有较宽的电气隔离带。</p></li><li><p>布局要考虑布线通道和空间，预估电源通道，不要来回绕。</p></li><li><p>接口保护器件尽量靠近接口摆放，采用一字型布局。信号转换芯片靠近插接口放置。</p></li><li><p>插拔器件或板边连接器周围3mm范围内尽量不布置SMD，以防止连接器插拔时产生的应力损伤器件。</p></li><li><p>器件摆放要外围留有足够的焊接空间，考虑后期可手动焊接。</p></li><li><p>有极性或方向性的插件器件在布局上方向一致，排列整齐。</p></li><li><p>对于会产生磁场的元件，如变压器、扬声器、电感等，布局时应注意减少磁力线对印制导线的切割，相邻元件磁场方向应相互垂直，减少彼此之间的耦合。</p></li></ul><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524222945408.png" /></p><ul><li><p>晶振不要放置到PCB板边，滤波电容与晶体采用π型滤波方式摆放。</p></li><li><p>元器件的编号应该紧靠元器件的边框布置，大小统一，方向整齐，不与元器件、过孔和焊盘重叠。</p></li><li><p>滤波电容尽量靠近芯片管脚，容值越小，越靠近管脚且先经过电容再进入芯片。</p></li></ul><h3 id="pcb-layout">PCB layout</h3><ul><li>首先对重要的信号或要求比较严格的信号进行走线，信号线的过孔尽量少，信号线与其回路构成的环面积要尽可能小，环面积越小，对外的辐射越少，接收外界的干扰也越小。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524202049996.png" alt="image-20230524202049996" style="zoom:80%;" /></p><ul><li>输入/输出端导线尽量避免相邻平行，最好加地线隔离，以免发生耦合。</li><li>电源部分尽量采用铺铜方式，保证载流得当。</li><li>CHIP器件走线和焊盘连接要避免不对称走线。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524214904856.png" alt="image-20230524214904856" style="zoom:80%;" /></p><ul><li>贴片焊盘上不要有过孔，走线避免出现直角或锐角。</li><li>对于密间距的IC，走线从焊盘出线时，宽度不能比焊盘宽。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524214930539.png" alt="image-20230524214930539" style="zoom:80%;" /></p><p>以上是设计中常用的规则，应该还有其它常用的规则，后续遇到了再进行添加。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PCB设计过程中，器件的整体布局和关键信号的layout至关重要，布局得当，信号线layout顺畅，就会在后续设计开发过程中，减少不必要的麻烦，相反，布局不当，layout失误，一是影响PCB整体的美观程度，二是在测试应用中带来诸多麻烦。为了减少不必要的设计麻烦，下面介绍一</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="pcb" scheme="http://example.com/tags/pcb/"/>
    
  </entry>
  
  <entry>
    <title>pcb设计之重要信号线layout注意事项</title>
    <link href="http://example.com/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%87%8D%E8%A6%81%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://example.com/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%87%8D%E8%A6%81%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-05-20T09:46:27.000Z</published>
    <updated>2023-05-24T10:18:09.964Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇主要看看pcb设计中重要信号线的layout注意事项：</p><ul><li><strong>差分信号线尽量在一起同一层走线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521104356728.png" alt="image-20230521104356728" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521104659980.png" alt="image-20230521104659980" style="zoom:80%;" /></p><ul><li><strong>差分间距无法满足20mil，最好进行包地</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521104926751%20-%20%E5%89%AF%E6%9C%AC.png"alt="image-20230521104926751 - 副本" /><figcaption aria-hidden="true">image-20230521104926751 -副本</figcaption></figure><ul><li><strong>usb按90欧姆差分阻抗进行走线，等长处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520105039307.png" alt="image-20230520105039307" style="zoom:80%;" /></p><ul><li><strong>usb打孔换层应在旁边放置地过孔回流</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105612441%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105612441 - 副本" style="zoom:80%;" /></p><ul><li><strong>网口按100欧姆差分阻抗走线，等长处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105139287%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105139287 - 副本" style="zoom:80%;" /></p><ul><li><strong>LVDS差分信号包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105447526%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105447526 - 副本" style="zoom:80%;" /></p><ul><li><strong>差分线等长处理不易幅度过大</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105746352%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105746352 - 副本" style="zoom:80%;" /></p><ul><li><strong>DDR所有的走线都应该在ddr的电源分割区域内，且分割区域不能有其他信号线</strong></li></ul><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps1%20-%20%E5%89%AF%E6%9C%AC.jpg" /></p><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps2%20-%20%E5%89%AF%E6%9C%AC.jpg" /></p><ul><li><strong>DDR走线要保证同组同层，不要表层一部分，内层一部分</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521110154465%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521110154465 - 副本" style="zoom:80%;" /></p><ul><li><strong>DDR布线要满足3W原则</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521110323383%20-%20%E5%89%AF%E6%9C%AC.png" style="zoom:80%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇主要看看pcb设计中重要信号线的layout注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;差分信号线尽量在一起同一层走线&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kayoungzhang/p</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="pcb" scheme="http://example.com/tags/pcb/"/>
    
  </entry>
  
  <entry>
    <title>pcb设计之普通信号线layout注意事项</title>
    <link href="http://example.com/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%99%AE%E9%80%9A%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://example.com/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%99%AE%E9%80%9A%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-05-20T09:45:57.000Z</published>
    <updated>2023-05-24T10:18:09.948Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇主要看普通信号线的layout注意事项：</p><ul><li><strong>走线不要出现直角锐角</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215258665.png" alt="image-20230520215258665" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215440544.png" alt="image-20230520215440544" style="zoom:80%;" /></p><ul><li><strong>走线不要超过焊盘宽度，应以焊盘同宽出线，可出完焊盘后立即加粗</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215531104.png" alt="image-20230520215531104" style="zoom:80%;" /></p><ul><li><strong>尽量减少环路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215751818.png" alt="image-20230520215751818" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215820652.png" alt="image-20230520215820652" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520222742879.png" alt="image-20230520222742879" style="zoom:80%;" /></p><ul><li><strong>7个地焊盘只有两个地孔，最多最多三个焊盘一个过孔</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520102020202.jpg" alt="img" style="zoom:80%;" /></p><ul><li><strong>所有层中间间距拉开一点，加到15mil~20mil</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215958770.png" alt="image-20230520215958770" style="zoom:80%;" /></p><ul><li><strong>走线不要压到电源内缩层</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/20230520102020203.jpg"alt="20230520102020203" /><figcaption aria-hidden="true">20230520102020203</figcaption></figure><ul><li><strong>走线优化，拉直。</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520102541420.jpg" alt="img" style="zoom:80%;" /></p><ul><li><strong>不要从IC狭窄处走线，影响焊接</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520220316490.png" alt="image-20230520220316490" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520220340784.png"alt="image-20230520220340784" /><figcaption aria-hidden="true">image-20230520220340784</figcaption></figure><ul><li><strong>电源处有多少过孔，地焊盘周边也打同样数量过孔，便于回流</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520220556496.png" alt="image-20230520220556496" style="zoom:80%;" /></p><ul><li><strong>走线间距太小容易串扰，需满足3W原则</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20220520220712824.png" alt="image-20230520220712824" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20220520221701707.png" alt="image-20230520221701707" style="zoom:80%;" /></p><ul><li><strong>预留地回流的通道</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20220520220803115.png" alt="image-20230520220803115" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520231118917.png" alt="image-20210520231118917" style="zoom:80%;" /></p><ul><li><strong>可以一同走的线，避免单独绕环线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221029160.png" alt="image-20210520221029160" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221053269.png" alt="image-20210520221053269" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223724436.png" alt="image-20210520223724436" style="zoom:80%;" /></p><ul><li><strong>铺铜的地方就不要再走细线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221230603.png" alt="image-20210520221230603" style="zoom:80%;" /></p><ul><li><strong>焊盘之间的窄小铜皮使用cutout进行去除，避免手动焊接短路风险</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221545131.png" alt="image-20210520221545131" style="zoom:80%;" /></p><ul><li><strong>相邻层走线不要重叠</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221806754.png" alt="image-20210520221806754" style="zoom:80%;" /></p><ul><li><strong>不要横向连接多个焊盘，容易造成不良焊接，可以先焊盘各自拉线出来，再两两相连</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222136579.png" alt="image-20210520222136579" style="zoom:80%;" /></p><ul><li><strong>走线能短则短</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222412740.png" alt="image-20210520222412740" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223011614.png" alt="image-20210520223011614" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225850852.png" alt="image-20210520225850852" style="zoom:80%;" /></p><ul><li><strong>走线不要太靠板边</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222521807.png" alt="image-20210520222521807" style="zoom:80%;" /></p><ul><li><strong>高压跟低压部分的间距最少保持5mm的间距</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222521890.jpg" alt="image-20210520222521890" style="zoom:80%;" /></p><ul><li><strong>合理布局</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223236635.png" alt="image-20210520223236635" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223544644.png" alt="image-20210520223544644" style="zoom:80%;" /></p><ul><li><strong>管脚之间阻焊层相连，需要修改Rule规则阻焊外扩距离</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225318763.png" alt="image-20210520225318763" style="zoom:80%;" /></p><ul><li><strong>走线不要太绕</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225618301.png" alt="image-20210520225618301" style="zoom:80%;" /></p><ul><li><p><strong>晶振采用Π型滤波模式，且对信号线进行包地处理，晶振下面不要走线</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233516091.png" alt="image-20210520233516091" style="zoom:80%;" /></p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225725174.png" alt="image-20210520225725174" style="zoom:80%;" /></p><ul><li><strong>电感中间不要有铜皮，且不要走线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230103302.png" alt="image-20210520230103302" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230711630.png" alt="image-20210520230711630" style="zoom:80%;" /></p><ul><li><strong>光耦所有层中间要挖空隔开，不要走线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230201233.png" alt="image-20210520230201233" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102742621.png" alt="image-20210521102742621" style="zoom:80%;" /></p><ul><li><strong>GPRS模块下面需要打回流地过孔，一方面为了散热，一方面利于信号</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230429986.png" alt="image-20210520230429986" style="zoom:80%;" /></p><ul><li><strong>尽量减少打孔换层</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230555960.png" alt="image-20210520230555960" style="zoom:80%;" /></p><ul><li><strong>多排走线不要并排打孔，容易造成地平面隔离，影响完整性</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520231520271.png" alt="image-20210520231520271" style="zoom:80%;" /></p><ul><li><strong>相同模块尽量保持一致，比较美观</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520231649818.png" alt="image-20210520231649818" style="zoom:80%;" /></p><ul><li><strong>过孔需要盖油</strong></li></ul><p><strong>低版本：</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520232756374.png" alt="image-20210520232756374" style="zoom:80%;" /></p><p><strong>高版本：</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520232709864.png" alt="image-20210520232709864" style="zoom:80%;" /></p><ul><li><strong>不可将过孔打在焊盘上</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520232908468.png" alt="image-20210520232908468" style="zoom:80%;" /></p><ul><li><strong>过孔焊盘直径应为孔径2倍(+/- 2mil)</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233133110.png" alt="image-20210520233133110" style="zoom:80%;" /></p><ul><li><strong>丝印文字常用字宽与字高比例：4/25mil 5/30mil 6/45mil,丝印不要放到阻焊层上</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233730194.png" alt="image-20210520233730194"  /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233755149.png" alt="image-20210520233755149" style="zoom:80%;" /></p><ul><li><strong>继电器下面不要走线，且部分走线要加粗</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521101637502.png" alt="image-20210521101637502" style="zoom:80%;" /></p><ul><li><strong>FM天线部分下面不要走线，且要包地处理</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521101821828.png"alt="image-20210521101821828" /><figcaption aria-hidden="true">image-20210521101821828</figcaption></figure><ul><li><strong>WIFI模块下面要挖空处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102020202.png" alt="image-20210521102020202" style="zoom:80%;" /></p><ul><li><strong>喇叭走线需要包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102222760.png" alt="image-20210521102222760" style="zoom:80%;" /></p><ul><li><strong>天线模块下面要挖空，天线走线要控制50欧姆阻抗</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102541420.png" alt="image-20210521102541420" style="zoom:80%;" /></p><ul><li><strong>网口部分要挖空处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102851161.png" alt="image-20210521102851161" style="zoom:80%;" /></p><ul><li><strong>射频部分严格按照阻抗要求走线，转弯部分用圆弧走线，包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/Imge-16846362511801.jpg" alt="Imge-16846362511801" style="zoom:80%;" /></p><ul><li><strong>时钟信号不要离干扰源太近，距离普通信号线要大于20mil，最好做包地处理</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-16846364276462.jpg"alt="image-16846364276462" /><figcaption aria-hidden="true">image-16846364276462</figcaption></figure><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-16846364395533.jpg"alt="image-16846364395533" /><figcaption aria-hidden="true">image-16846364395533</figcaption></figure><ul><li><strong>MIC属于模拟信号，要类差分走线，包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521103714413.png" alt="image-20210521103714413" style="zoom:80%;" /></p><ul><li><strong>模拟信号加粗处理，部分进行包地</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521103853551.png" alt="image-20210521103853551" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521103923788.png" alt="image-20210521103923788" style="zoom:80%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇主要看普通信号线的layout注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;走线不要出现直角锐角&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kayoungzhang/picgo_res/raw</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="pcb" scheme="http://example.com/tags/pcb/"/>
    
  </entry>
  
  <entry>
    <title>pcb设计之电源layout注意事项</title>
    <link href="http://example.com/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%94%B5%E6%BA%90layout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://example.com/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%94%B5%E6%BA%90layout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-05-20T09:44:54.000Z</published>
    <updated>2023-05-24T10:18:09.964Z</updated>
    
    <content type="html"><![CDATA[<p>pcb设计中，在layout时需要遵循一定规范，才会避免设计出不合格的pcb板，下面几篇文章主要总结一下layout过程中常见的问题，本篇是关于电源layout，内容主要来源自pcb联盟网论坛。</p><ul><li><strong>电源滤波电容尽量靠近IC管脚放置。</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205025967.png" alt="image-20230520205025967" style="zoom:80%;" /></p><ul><li><strong>电源走线载流过小，加大铺铜宽度，保证载流量</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205236535.png" alt="image-20230520205236535" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205310933.png"alt="image-20230520205310933" /><figcaption aria-hidden="true">image-20230520205310933</figcaption></figure><ul><li><strong>电源分割线20mil以上，分割的区域尽量宽</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205632526.png" alt="image-20230520205632526" style="zoom:80%;" /></p><ul><li><strong>芯片电源输出口先经过去耦电容再给其他元件供电</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520210452461.png" alt="image-20230520210452461" style="zoom:80%;" /></p><ul><li><strong>对于输入和输出，滤波电容遵循先大电容，后小电容放置</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520210844679.png" alt="image-20230520210844679" style="zoom:80%;" /></p><ul><li><strong>电源的反馈信号要接到最后一个滤波电容之后</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211057631.png" alt="image-20230520211057631" style="zoom:80%;" /></p><ul><li><strong>多个滤波电容应该放置到一起，且先大后小摆放</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211345243.png" alt="image-20230520211345243" style="zoom:80%;" /></p><ul><li><strong>电源路径不能过细，需要满足过载量，一般20mil线宽通1A电流</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211653288.png" alt="image-20230520211653288" style="zoom:80%;" /></p><ul><li><strong>电源输入和输出尽量L型或一字型布局</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211931150.png" alt="image-20230520211931150" style="zoom:80%;" /></p><ul><li><strong>电源线不要绕成圈</strong></li></ul><p><img src= "https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520212159692.png" alt="image-20230520212159692" style="zoom:80%;" /></p><ul><li><strong>高压部分走线要加粗，且不能从变压器中间穿</strong></li></ul><p><img src= "https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520212345079.png" alt="image-20230520212345079" style="zoom:80%;" /></p><ul><li><strong>电源层铺铜尽量保证完整性</strong></li></ul><p><img src= "https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520234104774.png" alt="image-20230520234104774" style="zoom:80%;" /></p><ul><li><strong>电源分割</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123010522.png" alt="image-20230521123010522" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123053217.png" alt="image-20230521123053217" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123123868.png" alt="image-20230521123123868" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123147836.png" alt="image-20230521123147836" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123209186.png" alt="image-20230521123209186" style="zoom:80%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;pcb设计中，在layout时需要遵循一定规范，才会避免设计出不合格的pcb板，下面几篇文章主要总结一下layout过程中常见的问题，本篇是关于电源layout，内容主要来源自pcb联盟网论坛。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;电源滤波电容尽量靠近IC管脚放置</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="pcb" scheme="http://example.com/tags/pcb/"/>
    
  </entry>
  
  <entry>
    <title>Altium Designer软件应用常见问题</title>
    <link href="http://example.com/2023/05/19/Altium-Designer%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/05/19/Altium-Designer%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2023-05-19T14:42:13.000Z</published>
    <updated>2023-05-24T10:18:09.948Z</updated>
    
    <content type="html"><![CDATA[<p>使用AltiumDesigner时，有时候会碰到一些不常见的问题，以下总结几个，后续发现了问题，再增加。</p><ul><li><strong>高版本AD无法寻找系统设置项</strong></li></ul><p>解决方法：</p><p>高版本在软件右上角有个设置图标即是设置项或 Tools -&gt;Preferences.</p><ul><li><strong>在低版本AD，PCB中拖动元件，元件不显示。</strong></li></ul><p>解决方法：</p><ol type="1"><li>Preferences -&gt; PCB Editor -&gt; Display -&gt; 去掉Use AlphaBlending对勾。</li><li>Preferences -&gt; PCB Editor -&gt; Display -&gt; 选中Use DirectX ifpossible。</li></ol><ul><li><strong>在PCB中元器件随时绿色报错，影响视觉。</strong></li></ul><p>解决方法：</p><ol type="1"><li>Tools -&gt; Design Rule Check -&gt;除了Electrical，其他项对勾都去掉。</li><li>Design-&gt;Rules -&gt; Electrical Clearance -&gt; 设置Minimumclearance 5mil.</li><li>快捷键T -&gt; M，复位报错。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519231617128.png" alt="image-20230519231617128" style="zoom:80%;" /></p><ul><li><strong>原理图导入PCB中，总是有元件无法导入，可能是footprint的uniqueID相同。</strong></li></ul><p>解决方法：复位零件ID。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519230324234.png"alt="image-20230519230324234" /><figcaption aria-hidden="true">image-20230519230324234</figcaption></figure><ul><li><strong>低版本AD中，原理图导出pdf文件，中文字体不显示/乱码</strong></li></ul><p>解决方法：</p><p>打开Preference界面，System-&gt;General，将系统字体改为中文；如果还不显示，可能原理图之前的文字没有修正过来，需要手动修改。</p><ul><li><strong>PCB编辑界面左上角悬浮框怎么取消</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519231723071.png" alt="image-20230519231723071" style="zoom: 80%;" /></p><p>解决方法：</p><p>按快捷键Shift+H，可以选择打开或者关闭抬头显示；</p><p>按快捷键Shift+G，抬头跟随鼠标移动，再次按下Shift+G即可固定。</p><ul><li><strong>原理图库引脚上面一横怎么添加的（表示低电平有效）</strong></li></ul><p>解决方法：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519232255161.png" alt="image-20230519232255161" style="zoom:80%;" /></p><ul><li><strong>pcb设计中某个零件需要铺铜，铺完后发现不理想，不想重新铺铜，怎么操作。</strong></li></ul><p>解决方法：</p><ol type="1"><li>低版本，使用快捷键 M + G进行修铜即可。</li><li>高版本，直接通过鼠标选择边框进行修改，然后重新铺铜。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519234223510.png" alt="image-20230519234223510" style="zoom:80%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用Altium
Designer时，有时候会碰到一些不常见的问题，以下总结几个，后续发现了问题，再增加。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高版本AD无法寻找系统设置项&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;高版本在软</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="pcb" scheme="http://example.com/tags/pcb/"/>
    
  </entry>
  
  <entry>
    <title>Altium Designer Gerber Files 生成步骤</title>
    <link href="http://example.com/2023/05/18/Altium-Designer-Gerber-Files-%E7%94%9F%E6%88%90%E6%AD%A5%E9%AA%A4/"/>
    <id>http://example.com/2023/05/18/Altium-Designer-Gerber-Files-%E7%94%9F%E6%88%90%E6%AD%A5%E9%AA%A4/</id>
    <published>2023-05-18T13:35:48.000Z</published>
    <updated>2023-05-18T14:52:03.168Z</updated>
    
    <content type="html"><![CDATA[<p>pcblayout完成后，然后就可以发送到PCB板厂进行生产制造了，一般为了保密性质，发送给厂商的是GerberFiles文件，所以，就需要生成GerberFiles。以下说一下AltiumDesigner生成GerberFiles的具体的操作步骤：</p><p>生成Gerber文件前，需要设置PCB原点，工艺边，定位孔，钻孔描述(drill层放置'.legend')，尺寸标注(一般为mechanic1、2层)。但是对于普通PCB设计者来说，这些不是必须要设置的。</p><ol type="1"><li><p>打开Gerber Setup，Files -&gt; Fabrication Outputs -&gt; GerberFiles</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps1.jpg" alt="img"  /></p></li><li><p>勾选要生成Gerber文件层面，在右侧Mechanical列表中选择要加载到各个Gerber层的机械尺寸信息。勾选左侧的Mechanical1，则在光绘文件GM1单层显示，勾选右侧的Mechanical1则每层都会加入机械层信息，“Include unconnected mid-layerpads”项仅限于包含了中间层的PCB 文件输出Gerber 时使能。</p></li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps2.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="3" type="1"><li>勾选Drill层</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps3.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="4" type="1"><li>勾选光圈</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps4.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="5" type="1"><li>设置影像大小</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps5.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="6" type="1"><li>生成钻孔文件，Files -&gt; Fabrication Outputs -&gt; NC Drillfiles</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps6.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="7" type="1"><li>生成测试网表，Files -&gt; Fabrication Outputs -&gt; Test PointReport</li></ol><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps7.jpg" /></p><ol start="8" type="1"><li>生成SMT贴片零件位置表，Files -&gt; Assembly Outputs -&gt; Generatespick and place files</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps8.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="9" type="1"><li>生成SMT贴片零件PCB组装图，Files -&gt; Smart PDF</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps9.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps10.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps11.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>将前面7个步骤生成的文件打包发送给pcb板厂就可以制造PCB了，如果还需要贴片，就需要第8步和第9步生成的组装文件了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;pcb
layout完成后，然后就可以发送到PCB板厂进行生产制造了，一般为了保密性质，发送给厂商的是GerberFiles文件，所以，就需要生成GerberFiles。以下说一下Altium
Designer生成GerberFiles的具体的操作步骤：&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="pcb" scheme="http://example.com/tags/pcb/"/>
    
  </entry>
  
</feed>
