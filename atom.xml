<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-28T03:50:19.627Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>结构体struct详解</title>
    <link href="http://example.com/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93struct%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93struct%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-28T03:41:37.000Z</published>
    <updated>2023-08-28T03:50:19.627Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>共用体union详解</title>
    <link href="http://example.com/2023/08/28/%E5%85%B1%E7%94%A8%E4%BD%93union%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/28/%E5%85%B1%E7%94%A8%E4%BD%93union%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-28T03:41:03.000Z</published>
    <updated>2023-08-28T03:41:03.696Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>十大排序算法</title>
    <link href="http://example.com/2023/08/26/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/08/26/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-08-26T14:31:43.000Z</published>
    <updated>2023-08-28T03:37:53.355Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法是《数据结构与算法》中最基本的算法之一，常见的共有十种：</p><ol type="1"><li><a href="http://www.codebaoku.com/algorithm-sort/bubble-sort.html">冒泡排序（Bubble Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/selection-sort.html">选择排序（Selection Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/insertion-sort.html">插入排序（Insertion Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/shell-sort.html">希尔排序（Shell Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/merge-sort.html">归并排序（Merge Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/quick-sort.html">快速排序（Quick Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/heap-sort.html">堆排序（Heap Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/counting-sort.html">计数排序（Counting Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/bucket-sort.html">桶排序（Bucket Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/radix-sort.html">基数排序（Radix Sort）</a></li></ol><p>其中，前面七种属于比较排序，即通过比较来决定元素的相对次序。后面三种则属于非比较排序。</p><p>这十种排序方式的复杂度如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230827112203238.png" alt="" /><figcaption>image-20230827112203238</figcaption></figure><p>下面分别来看看这十种排序方式：</p><h2 id="冒泡排序bubble-sort">冒泡排序（Bubble Sort）</h2><p>冒泡排序的基本思想是，从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻元素大小比较进行交换，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9a152a7e13500cf688efd8e5297f9f6e.gif" alt="" /><figcaption>冒泡排序的动图演示</figcaption></figure><p>在数据完全有序的时候展现出最优时间复杂度，为O(n)。其他情况下，几乎总是O( n2 )。因此，算法在数据基本有序的情况下，性能最好。 要使算法在最佳情况下有O(n)复杂度，需要做一些改进，增加一个<code>swap</code>的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> i, j, temp;    <span class="hljs-type">bool</span> swap;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)    &#123;        swap = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)        &#123;            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])             &#123;                temp = arr[j];                arr[j] = arr[j + <span class="hljs-number">1</span>];                arr[j + <span class="hljs-number">1</span>] = temp;                swap = <span class="hljs-literal">true</span>;            &#125;                    &#125;         <span class="hljs-keyword">if</span>(swap == <span class="hljs-literal">false</span>) <span class="hljs-comment">//有序</span>            <span class="hljs-keyword">break</span>;    &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">22</span>, <span class="hljs-number">34</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">82</span>, <span class="hljs-number">55</span>, <span class="hljs-number">89</span>, <span class="hljs-number">50</span>, <span class="hljs-number">37</span>, <span class="hljs-number">5</span>, <span class="hljs-number">64</span>, <span class="hljs-number">35</span>, <span class="hljs-number">9</span>, <span class="hljs-number">70</span> &#125;;    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);    bubble_sort(arr, len);    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高,基本为O(n2)，在数据量大的时候不适合使用。</p><h2 id="选择排序selection-sort">选择排序（Selection Sort）</h2><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p><p>它的排序思想是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/c7322fccb46e3cc0ea3c107781d1e880.gif" alt="" /><figcaption>选择排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span> <span class="hljs-comment">//交互两个变量</span>&#123;    <span class="hljs-type">int</span> temp = *a;    *a = *b;    *b = temp;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">selection_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>&#123;    <span class="hljs-type">int</span> i,j;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; len - <span class="hljs-number">1</span> ; i++)    &#123;<span class="hljs-type">int</span> min = i;<span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; len; j++) <span class="hljs-comment">//遍历未排序的元素</span>        &#123;    <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min])    <span class="hljs-comment">//找到目前最小值</span>        min = j;      <span class="hljs-comment">//记录最小值序号            </span>        &#125;swap(&amp;arr[min], &amp;arr[i]);     <span class="hljs-comment">//做交換</span>     &#125;&#125;</code></pre></div><p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。</p><h2 id="插入排序insertion-sort">插入排序（Insertion Sort）</h2><p>插入排序的基本方法是：从待排序的n个元素中的第二个元素开始，依次与前面的元素比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6d867acd56e40fb32975f9e91d041fa9.gif" alt="" /><figcaption>插入排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertion_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>&#123;    <span class="hljs-type">int</span> i,j,key;    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;len;i++)    &#123;        key = arr[i];        j=i<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>((j&gt;=<span class="hljs-number">0</span>) &amp;&amp; (arr[j]&gt;key))         &#123;            arr[j+<span class="hljs-number">1</span>] = arr[j];            j--;        &#125;        arr[j+<span class="hljs-number">1</span>] = key;    &#125;&#125;</code></pre></div><p>插入排序由于O( n2 )的复杂度，在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。</p><h2 id="希尔排序shell-sort">希尔排序（Shell Sort）</h2><p>希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p>希尔排序基本思想是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/e250b339f4595451ca75ba3b83c83704.gif" alt="" /><figcaption>十大经典排序算法动画与解析，看我就够了！（配代码完全版）</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> gap, i, j;    <span class="hljs-type">int</span> temp;        <span class="hljs-keyword">for</span> (gap = len &gt;&gt; <span class="hljs-number">1</span>; gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>)    &#123;    <span class="hljs-keyword">for</span> (i = gap; i &lt; len; i++)         &#123;            temp = arr[i];            <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)            &#123;                arr[j + gap] = arr[j];            &#125;            arr[j + gap] = temp;    &#125;            &#125;&#125;</code></pre></div><p>Shell排序虽然快，但是毕竟是插入排序，其数量级并没有后起之秀--快速排序O(n㏒n)快。在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。</p><h2 id="归并排序merge-sort">归并排序（Merge Sort）</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p>它的基本思路是：</p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2f9f62d486be19b87a3f37f13eb75786.gif" alt="" /><figcaption>归并排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;    <span class="hljs-keyword">return</span> x &lt; y ? x : y;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> *a = arr;    <span class="hljs-type">int</span> *b = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));    <span class="hljs-type">int</span> seg, start;        <span class="hljs-keyword">for</span> (seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg)     &#123;        <span class="hljs-keyword">for</span> (start = <span class="hljs-number">0</span>; start &lt; len; start += seg * <span class="hljs-number">2</span>)         &#123;            <span class="hljs-type">int</span> low = start, mid = min(start + seg, len), high = min(start + seg * <span class="hljs-number">2</span>, len);            <span class="hljs-type">int</span> k = low;            <span class="hljs-type">int</span> start1 = low, end1 = mid;            <span class="hljs-type">int</span> start2 = mid, end2 = high;                        <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            <span class="hljs-keyword">while</span> (start1 &lt; end1)                b[k++] = a[start1++];            <span class="hljs-keyword">while</span> (start2 &lt; end2)                b[k++] = a[start2++];        &#125;        <span class="hljs-type">int</span> *temp = a;        a = b;        b = temp;    &#125;    <span class="hljs-keyword">if</span> (a != arr)     &#123;        <span class="hljs-type">int</span> i;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        &#123;            b[i] = a[i];                    &#125;        b = a;    &#125;    <span class="hljs-built_in">free</span>(b);&#125;</code></pre></div><p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。</p><h2 id="快速排序quick-sort">快速排序（Quick Sort）</h2><p>冒泡排序总的比较与移动次数较多，快速排序又称分区交换排序，是对冒泡排序的改进，快速排序采用的思想是分治思想。</p><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/eaca66d26efe27519e8c462d3a7d4593.gif" alt="" /><figcaption>快速排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//a：待排序数组，low：最低位的下标，high：最高位的下标</span><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span>&#123;    <span class="hljs-keyword">if</span>(low&gt;=high)    &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">int</span> left=low;    <span class="hljs-type">int</span> right=high;    <span class="hljs-type">int</span> key=a[left];    <span class="hljs-comment">/*用数组的第一个记录作为分区元素*/</span>    <span class="hljs-keyword">while</span>(left!=right)    &#123;        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[right]&gt;=key)    <span class="hljs-comment">/*从右向左扫描，找第一个码值小于key的记录，并交换到key*/</span>            --right;        a[left]=a[right];        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[left]&lt;=key)            ++left;        a[right]=a[left];    <span class="hljs-comment">/*从左向右扫描，找第一个码值大于key的记录，并交换到右边*/</span>    &#125;    a[left]=key;    <span class="hljs-comment">/*分区元素放到正确位置*/</span>    quickSort(a,low,left<span class="hljs-number">-1</span>);    quickSort(a,left+<span class="hljs-number">1</span>,high);&#125;</code></pre></div><p>快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。</p><h2 id="堆排序heap-sort">堆排序（Heap Sort）</h2><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序原理就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</p><figure><img src="https://ask.qcloudimg.com/http-save/yehe-8223537/2c40662fc38e7e7ba7882786f1ee19e2.gif" alt="" /><figcaption>十大经典排序算法动画与解析，看我就够了！（配代码完全版）</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> &#123;    <span class="hljs-type">int</span> temp = *b;    *b = *a;    *a = temp;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;    <span class="hljs-comment">// 建立父節點指標和子節點指標</span>    <span class="hljs-type">int</span> dad = start;    <span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (son &lt;= end)     &#123; <span class="hljs-comment">// 若子節點指標在範圍內才做比較</span>        <span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 先比較兩個子節點大小，選擇最大的</span>            son++;        <span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">//如果父節點大於子節點代表調整完畢，直接跳出函數</span>            <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">else</span>         &#123; <span class="hljs-comment">// 否則交換父子內容再繼續子節點和孫節點比較</span>            swap(&amp;arr[dad], &amp;arr[son]);            dad = son;            son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        &#125;    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> i;    <span class="hljs-comment">// 初始化，i從最後一個父節點開始調整</span>    <span class="hljs-keyword">for</span> (i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)        max_heapify(arr, i, len - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢</span>    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);        max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, \                 <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);    heap_sort(arr, len);    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p><hr /><h2 id="计数排序counting-sort">计数排序（Counting Sort）</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>它的基本方法是：</p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/25fdb31acd81f931cd443cb932140ab9.gif" alt="" /><figcaption>冒泡排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">print_arr</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-type">int</span> i;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, arr[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">counting_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *ini_arr, <span class="hljs-type">int</span> *sorted_arr, <span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-type">int</span> *count_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100</span>);    <span class="hljs-type">int</span> i, j, k;    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">100</span>; k++)        count_arr[k] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)        count_arr[ini_arr[i]]++;    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">100</span>; k++)        count_arr[k] += count_arr[k - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (j = n; j &gt; <span class="hljs-number">0</span>; j--)        sorted_arr[--count_arr[ini_arr[j - <span class="hljs-number">1</span>]]] = ini_arr[j - <span class="hljs-number">1</span>];    <span class="hljs-built_in">free</span>(count_arr);&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> i;    <span class="hljs-type">int</span> *arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * n);    <span class="hljs-type">int</span> *sorted_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * n);    srand(time(<span class="hljs-number">0</span>));    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)        arr[i] = rand() % <span class="hljs-number">100</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ini_array: &quot;</span>);    print_arr(arr, n);    counting_sort(arr, sorted_arr, n);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sorted_array: &quot;</span>);    print_arr(sorted_arr, n);    <span class="hljs-built_in">free</span>(arr);    <span class="hljs-built_in">free</span>(sorted_arr);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>排序目标要能够映射到整数域，其最大值最小值应当容易辨别。例如高中生考试的总分数，显然用0-750就OK啦；又比如一群人的年龄，用个0-150应该就可以了，再不济就用0-200喽。另外，计数排序需要占用大量空间，它比较适用于数据比较集中的情况。</p><h2 id="桶排序bucket-sort">桶排序（Bucket Sort）</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9095a2947d144f4b960369dbc1d259d7.gif" alt="" /><figcaption>img</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 使用桶排序法对数列 [5，2，30，98，20，1，45，80] 从小到大排序 */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> m[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">30</span>,<span class="hljs-number">98</span>,<span class="hljs-number">20</span>,<span class="hljs-number">1</span>,<span class="hljs-number">45</span>,<span class="hljs-number">80</span>&#125;;    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组a存放[1,10]的数,将数组a赋值为零*/</span>    <span class="hljs-type">int</span> b[<span class="hljs-number">40</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组b存放[11,50]的数,将数组b赋值为零*/</span>    <span class="hljs-type">int</span> c[<span class="hljs-number">50</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组c存放[51,100]的数,将数组c赋值为零*/</span>    <span class="hljs-type">int</span> i;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)    &#123;        <span class="hljs-comment">/* 定义三个桶 */</span>        <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">0</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">11</span>))             a[m[i]<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;               <span class="hljs-comment">/*假如i=0,那么m[i]=5;将5放在数组a的第5个位置，即a[4]中,所以是a[m[i]-1] */</span>        <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">10</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">51</span>))             b[m[i]<span class="hljs-number">-10</span><span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;           <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">51</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">101</span>))             c[m[i]<span class="hljs-number">-50</span><span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;        &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)                         <span class="hljs-comment">/*输出数组a的结果*/</span>      <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)                         <span class="hljs-comment">/*输出数组b的结果*/</span>      <span class="hljs-keyword">if</span>(b[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">11</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">50</span>;i++)                         <span class="hljs-comment">/*输出数组c的结果*/</span>      <span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">51</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;</code></pre></div><p>桶排序可用于最大最小值相差较大的数据情况，但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。</p><h2 id="基数排序radix-sort">基数排序（Radix Sort）</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/88cb17eb223c8838182dcaff3dfcde17.gif" alt="" /><figcaption>基数排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 20</span><span class="hljs-comment">//#define SHOWPASS</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> BASE 10</span><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-type">int</span> i;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)   &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, a[i]);  &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">radixsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-type">int</span> i, b[MAX], m = a[<span class="hljs-number">0</span>], <span class="hljs-built_in">exp</span> = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)   &#123;    <span class="hljs-keyword">if</span> (a[i] &gt; m)       m = a[i];  &#125;  <span class="hljs-keyword">while</span> (m / <span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">0</span>)   &#123;    <span class="hljs-type">int</span> bucket[BASE] = &#123; <span class="hljs-number">0</span> &#125;;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)     &#123;      bucket[(a[i] / <span class="hljs-built_in">exp</span>) % BASE]++;    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; BASE; i++)     &#123;      bucket[i] += bucket[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)     &#123;      b[--bucket[(a[i] / <span class="hljs-built_in">exp</span>) % BASE]] = a[i];    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)     &#123;      a[i] = b[i];    &#125;    <span class="hljs-built_in">exp</span> *= BASE;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SHOWPASS</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nPASS   : &quot;</span>);    print(a, n);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>  &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <span class="hljs-type">int</span> arr[MAX];  <span class="hljs-type">int</span> i, n;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter total elements (n &lt;= %d) : &quot;</span>, MAX);  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  n = n &lt; MAX ? n : MAX;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter %d Elements : &quot;</span>, n);  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)   &#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);  &#125;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nARRAY  : &quot;</span>);  print(&amp;arr[<span class="hljs-number">0</span>], n);  radixsort(&amp;arr[<span class="hljs-number">0</span>], n);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nSORTED : &quot;</span>);  print(&amp;arr[<span class="hljs-number">0</span>], n);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>基数排序要求较高，元素必须是整数，整数时长度10W以上，最大值100W以下效率较好，但是基数排序比其他排序好在可以适用字符串，或者其他需要根据多个条件进行排序的场景，例如日期，先排序日，再排序月，最后排序年 ，其它排序算法可是做不了的。</p><p>参考链接：</p><p>https://zhuanlan.zhihu.com/p/42586566</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;排序算法是《数据结构与算法》中最基本的算法之一，常见的共有十种：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codebaoku.com/algorithm-sort/bubble-sort.html&quot;&gt;冒泡排序（Bubble S</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>常见的开发概念及开源资源</title>
    <link href="http://example.com/2023/08/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E5%8F%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BC%80%E6%BA%90%E8%B5%84%E6%BA%90/"/>
    <id>http://example.com/2023/08/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E5%8F%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BC%80%E6%BA%90%E8%B5%84%E6%BA%90/</id>
    <published>2023-08-20T04:09:58.000Z</published>
    <updated>2023-08-28T03:37:53.395Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/gnu-100-b98545.png"><p align="center"><b style="font-size:25px">GNU</b></p></p><p>GNU是一个开源组织，同时也是一个100%自由软件的操作系统，包含了所有的官方GNU软件包，也包括非GNU自由软件。</p><p><a href="https://www.gnu.org/">官网</a>：https://www.gnu.org/</p><ul><li><p><strong>GCC/G++</strong>：GNU工具链中的编译器。</p></li><li><p><strong><a href="https://www.gnu.org/software/make/">Make</a></strong>：GNU工具链中的构建生成器，搭配makefile文件使用。</p></li><li><p><strong><a href="https://www.sourceware.org/gdb/">GDB（GNU Debuger）</a></strong>：GNU 开源组织发布的一个强大的UNIX 下的程序调试工具。</p></li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6ac65d24163b5b6e0.jpeg"><p align="center"><b style="font-size:25px">LLVM</b></p></p><p>LLVM是编译器和工具链技术的集合。</p><p><a href="https://clang.llvm.org/">官网</a>： https://clang.llvm.org/</p><p><strong>clang/clang++</strong> ：LLVM工具链中C/C++/Objective-C 编译器。</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/weq.png"><p align="center"><b style="font-size:25px">Cygwin</b></p></p><p>Cygwin是GNU编译器和大量开源工具的集合，能够在Windows系统上提供类似于Linux系统的功能。它提供了大量的POSIX API功能。</p><p><a href="https://www.cygwin.com/index.html">官网</a>：https://www.cygwin.com/index.html</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/%EF%BC%ADinGW-w64-long.png"><p align="center"><b style="font-size:25px">MinGw</b></p></p><p>MinGW(Minimalist GNU for Windows)是一个开源的基于GNU的编译器套件，允许你在Windows平台生成本地的Windows程序而不需要系统运行库(C Runtime library，静态库lib或动态库dll)。</p><p><a href="https://www.mingw-w64.org/">官网</a>：https://www.mingw-w64.org/</p><p><a href="https://zhuanlan.zhihu.com/p/76613134?utm_source=QQ_article_bottom">MinGW-w64安装教程——著名C/C++编译器GCC的Windows版本</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/RE1Mu3b.png"><p align="center"><b style="font-size:25px">MSVC</b></p></p><p>MSVC(Microsoft Visual C/C++)是微软公司开发的Windows下编译器工具链，已经集成到Microsoft Visual Studio环境中。</p><p><a href="https://learn.microsoft.com/zh-cn/cpp/build/projects-and-build-systems-cpp?view=msvc-170">官网</a>：https://learn.microsoft.com/zh-cn/cpp/build/projects-and-build-systems-cpp?view=msvc-170</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/Cmake-logo-header.png"><p align="center"><b style="font-size:25px">CMake</b></p></p><p>CMake(Cross platform make)是比Make更高一层的工具,搭配CmakeList.txt文件，产生标准的建构档，再依一般的建构方式进行项目构建。</p><p><a href="https://cmake.org/">官网</a>：https://cmake.org/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/Qt-logo-neon-small.png" alt="img" style="zoom:33%;" /><p align="center"><b style="font-size:25px">qmake</b></p></p><p>qmake 是QT工程的项目构建生成器。</p><p><a href="https://www.qt.io/product/development-tools">官网</a>：https://www.qt.io/product/development-tools</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825103236069.png"><p align="center"><b style="font-size:25px">QCustomPlot</b></p></p><p>QCustomPlot 是用于Qt中绘图和数据可视化的一个开源C++库。该绘图库专注于制作精美、可打印的高质量2D图形表，并在应用程序内显示实时数据。</p><p><a href="https://www.qcustomplot.com/">官网</a>：https://www.qcustomplot.com/</p><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/SCons-Bricks.png"><p align="center"><b style="font-size:25px">SCons</b></p></p><p>SCons 是项目构建工具，使用 SConstruct 和 SConscript 文件来替代复杂规则的makefile文件，像RT-thread系统构建中有使用。</p><p><a href="https://www.scons.org/">官网</a>：https://www.scons.org/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/tux.png"><p align="center"><b style="font-size:25px">Linux</b></p></p><ul><li><p><strong>Linux Kernel</strong> ：Linux内核 ，Linux系统核心。</p><p><a href="https://kernel.org/">官网</a>：https://kernel.org/</p></li><li><p><strong>U-Boot</strong>：Linux系统启动引导代码。全称 Universal Boot Loader。</p><p><a href="https://u-boot.readthedocs.io/en/latest/">官网</a>：https://u-boot.readthedocs.io/en/latest/</p><p>源码网址：</p><ul><li>https://source.denx.de/u-boot/u-boot</li><li>https://ftp.denx.de/pub/u-boot/ （或 ftp://ftp.denx.de/pub/u-boot/）</li></ul></li><li><p><strong>BusyBox</strong>：BusyBox 是一个集成了众多最常用 linux 命令和工具的精简工具箱。它提供了一个比较完善的环境，可用于构建轻量级的根文件系统。</p><p><a href="https://busybox.net/">官网</a>：https://busybox.net/</p><p><a href="http://www.taodudu.cc/news/show-318004.html?action=onClick">busybox详解</a></p></li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818231609048.png" alt="image-20230818231609048" style="zoom:50%;" /><p align="center"><b style="font-size:25px">OpenOCD</b></p></p><p><strong>OpenOCD(Open On-Chip Debugger)</strong>是一个开源片上调试器，用于嵌入式系统的开发和调试。</p><p><a href="https://www.openocd.org/">官网</a>：https://www.openocd.org/</p><p>下载地址：https://sourceforge.net/projects/openocd/files/</p><p>Windows下openocd：https://gnutoolchains.com/arm-eabi/openocd/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818232211015.png" alt="image-20230818232211015" style="zoom:67%;" /><p align="center"><b style="font-size:25px">FatFs</b></p></p><p>FatFs 是用于小型嵌入式系统的通用 FAT/exFAT 文件系统开源项目。</p><p><a href="http://elm-chan.org/fsw/ff/00index_e.html">官网</a>：http://elm-chan.org/fsw/ff/00index_e.html</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/floating.png" alt="Back to Savannah Homepage" style="zoom:80%;" /><p align="center"><b style="font-size:25px">lwIP</b></p></p><p><strong>lwIP(light weight IP)</strong>是一个开源的小型轻量级的 TCP/IP 协议栈。</p><p><a href="http://savannah.nongnu.org/projects/lwip/">官网</a>：http://savannah.nongnu.org/projects/lwip/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/logo_lvgl.png" alt="logo" style="zoom: 67%;" /><p align="center"><b style="font-size:25px">LVGL</b></p></p><p><strong>LVGL(Light and Versatile Graphics Library )</strong>,是一个开源的轻量级嵌入式图形库，可为任何 MCU、MPU 和显示类型创建漂亮的 UI。</p><p><a href="https://lvgl.io/">官网</a>：https://lvgl.io/</p><p>源码：https://github.com/lvgl/lvgl/releases</p><p>百问网LVGL：http://lvgl.100ask.net/8.2/index.html</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230819001230032.png"><p align="center"><b style="font-size:25px">MQTT</b></p></p><p>MQTT(Message Queuing Telemetry Transport,消息队列遥测传输协议)是一种基于发布/订阅(PUBLISH/SUBSCRIBE)模式的轻量级的物联网通信协议。</p><p><a href="https://mqtt.org/">官网</a>：https://mqtt.org/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/logo.png"><p align="center"><b style="font-size:25px">OpenCV</b></p></p><p>OpenCV是一个开源跨平台的计算机视觉库，被用于各种各样的计算机视觉应用程序中，包括人脸检测、目标识别、图像分割、机器人视觉、运动跟踪、手势识别等。OpenCV提供了许多用于图像处理和计算机视觉的功能，包括图像滤波、特征检测、特征匹配、图像分割、摄像机校准、三维重建等。它还提供了C++、Python和Java等编程语言的接口，方便用户在各种平台上进行开发。</p><p><a href="https://opencv.org/">官网</a>：https://opencv.org/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230821084024530.png"><p align="center"><b style="font-size:25px">CMSIS</b></p></p><p><strong>CMSIS(Common Microcontroller Software Interface Standard)</strong> : ARM Cortex™通用微控制器软件接口标准，由ARM公司跟芯片软件厂商共同提出的，开源。它提供了一种内核与外设、实时操作系统和中间件接口的通用方法。参考：<a href="https://blog.csdn.net/m0_54929728/article/details/128695058?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-128695058-blog-126438165.235%5Ev38%5Epc_relevant_sort&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-128695058-blog-126438165.235%5Ev38%5Epc_relevant_sort&amp;utm_relevant_index=11">CMSIS到底是个什么东西</a></p><p><a href="https://www.arm.com/technologies/cmsis">官网</a>：https://www.arm.com/technologies/cmsis</p><p>CMSIS资源包含：</p><ul><li><a href="http://arm-software.github.io/CMSIS_5/RTOS2/html/index.html">CMSIS-RTOS</a> ：一个 API，能够使中间件和库组件实现一致的软件层</li><li><a href="http://arm-software.github.io/CMSIS_5/DSP/html/index.html">CMSIS-DSP</a> ：DSP库是Arm针对各种Cortex-M处理器内核优化的DSP功能的丰富集合</li><li><a href="http://arm-software.github.io/CMSIS_5/Driver/html/index.html">CMSIS-Driver</a>：CMSIS驱动程序接口可用于许多微控制器系列</li><li><a href="http://arm-software.github.io/CMSIS_5/Pack/html/index.html">CMSIS-Pack</a>：定义了包含软件组件的软件包结构</li><li><a href="http://arm-software.github.io/CMSIS_5/SVD/html/index.html">CMSIS-SVD</a>：该文件允许查看具有当前寄存器状态的设备外设的详细视图</li><li><a href="http://arm-software.github.io/CMSIS_5/DAP/html/index.html">CMSIS-DAP</a>：它是 Cortex 调试访问端口（DAP）的标准化接口</li><li><a href="http://arm-software.github.io/CMSIS_5/NN/html/index.html">CMSIS-NN</a>：这是高效神经网络内核的集合</li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230823133444089.png"><p align="center"><b style="font-size:25px">MIPI Alliance</b></p></p><p><strong>MIPI(Mobile Industry Processor Interface)移动行业处理器接口</strong>，MIPI联盟是一个全球协作组织，制定和推进移动设备接口技术标准，提供一个世界性，全面性的接口规范生态系统，有效地互连各种移动组件和受移动影响的设备。这些规范标准涵盖了设备所需的所有接口应用，包括调制解调器、应用处理器、相机、显示器、音频、存储、天线、调谐器、功率放大器、滤波器、开关、电池等的接口。</p><p><a href="https://www.mipi.org/">官网</a>：https://www.mipi.org/</p><p>MIPI联盟各接口规格及开发工作组主要有（非MIPI联盟成员只能查看接口公开版规格书）：</p><ul><li><strong>Audio</strong><ul><li><a href="https://www.mipi.org/groups/audio"><strong>Audio Working Group</strong></a></li></ul></li><li><strong>Camera &amp; Imaging</strong><ul><li><strong><a href="https://www.mipi.org/groups/camera">Camera Working Group</a></strong></li></ul></li><li><strong>Chip-to-chip/IPC</strong><ul><li><strong><a href="https://www.mipi.org/groups/unipro-working-group">UniPro Working Group</a></strong></li></ul></li><li><strong>Control &amp; Data</strong><ul><li><strong><a href="https://www.mipi.org/groups/i3c">I3C Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/rf-front-end">RF Front-End Control Working Group</a></strong></li></ul></li><li><strong>Debug &amp; Trace</strong><ul><li><strong><a href="https://www.mipi.org/groups/debug">Debug Working Group</a></strong></li></ul></li><li><strong>Display &amp; Touch</strong><ul><li><strong><a href="https://www.mipi.org/groups/display">Display Working Group</a></strong></li></ul></li><li><strong>Physical Layers</strong><ul><li><strong><a href="https://www.mipi.org/groups/phy">PHY Steering Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/a-phy">A-PHY Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/c-phy">C-PHY Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/d-phy">D-PHY Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/m-phy">M-PHY Working Group</a></strong></li></ul></li><li><strong>Software Integration</strong><ul><li><strong><a href="https://www.mipi.org/groups/software">Software Working Group</a></strong></li></ul></li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/sqlite370_banner.gif"><p align="center"><b style="font-size:25px">SQLite</b></p></p><p>SQLite 是一款开源的嵌入式轻型C语言数据库，它实现了一个独立的、无服务器的、零配置的事务性 SQL 数据库引擎，且是世界上使用最多的数据库引擎，占用资源非常低，处理速度快。参考教程：<a href="http://www.codebaoku.com/sqlite/sqlite-index.html">SQLite教程</a></p><p><a href="https://www.sqlite.org">官网</a>：https://www.sqlite.org</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825161343265.png"><p align="center"><b style="font-size:25px">Lua</b></p></p><p><a href="https://www.leixue.com/so/Lua">Lua</a> 是一个简洁、轻量、可扩展的脚本语言，由标准 C 编写而成，并以源代码形式开放，几乎在所有操作系统和平台上都可以编译，运行，主要用于嵌入式系统、游戏开发、网络编程、科学计算等领域。Lua 在葡萄牙语中的意思是月亮。参考：<a href="http://www.codebaoku.com/lua/lua-index.html">Lua 教程</a></p><p><a href="http://www.lua.org">官网</a>：http://www.lua.org</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825163324396.png"><p align="center"><b style="font-size:25px">Docker</b></p></p><p>Docker 是一个开源的应用容器引擎，可以轻松地为任何应用创建一个轻量级、可移植的、安全的容器。它可以让开发者打包他们的应用和依赖包到一个轻量级、可移植的容器中，然后发布到其它机器上，也可以实现虚拟化。、</p><p>容器和虚拟机具有类似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。</p><p>容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台计算机上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为隔离进程运行。容器占用的空间比 VM 少（容器映像大小通常为 数十 MB），可以处理更多应用程序，并且需要更少的 VM 和操作系统。</p><p>虚拟机 （VM） 是将一台服务器转换为多台服务器的物理硬件的抽象。虚拟机监控程序允许多个 VM 在一台计算机上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本，占用数十 GB。 VM 的启动速度也可能很慢。<strong>参考</strong>：<a href="https://baijiahao.baidu.com/s?id=1675253978950340809&amp;wfr=spider&amp;for=pc">什么是Docker？看这一篇干货文章就够了！</a></p><p><a href="https://www.docker.com/">官网</a>：https://www.docker.com/</p><p><a href="http://www.codebaoku.com/docker/docker-index.html">Docker 教程</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825164813557.png"><p align="center"><b style="font-size:25px">POSTMAN</b></p></p><p>Postman 是一个用于API测试的最流行的软件测试工具。借助该工具，开发人员可以轻松地创建，测试，共享和文档化API。这是一个简单的图形用户界面，用于发送和查看HTTP请求和响应。 使用Postman进行测试时，不需要编写任何HTTP客户端网络代码。在此工具中，几乎嵌入了任何开发人员可能需要的所有功能。</p><p><a href="https://www.postman.com/">官网</a>：https://www.postman.com/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825165153458.png"><p align="center"><b style="font-size:25px">Nginx</b></p></p><p>Nginx（engine x) 是一款免费开源的高性能、轻量级的 HTTP 和 反向代理 Web 服务器，Nginx 的功能可以分为：基本 HTTP 服务、高级 HTTP 服务和邮件服务等三大类。它以运行的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而闻名，其主要特点是占用内存少，并发能力强。Nginx 的并发能力在同类型的网页服务器中表现最好。在中国，所有大中型的网站几乎都在使用 Nginx：包括阿里、腾讯、百度、京东、新浪、网易等。</p><p><a href="http://www.nginx.org">官网</a>：http://www.nginx.org</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/vue-js_UzKKG.png"><p align="center"><b style="font-size:25px">Vue.js</b></p></p><p>Vue 是一个用于构建Web用户界面的渐进式JavaScript框架，需要了解关于 HTML、CSS 和 JavaScript 的相关知识，Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。对浏览器提供的修改 Dom 结构API进行封装，只需要对数据对象进行操作，由 Vue 负责调用底层浏览器 API。数据和视图双向绑定，当一方发生变化，另一方同时也会发生变化。</p><p>参考：<a href="http://www.codebaoku.com/vue3/vue3-index.html">Vue3 教程</a></p><p><a href="https://vuejs.org/">官网</a>：https://vuejs.org/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/circle_screenshot_1_Node.js.png"><p align="center"><b style="font-size:25px">Node.js</b></p></p><p>Node.js® 是一个开源、跨平台的 JavaScript 运行时环境。</p><p><a href="https://nodejs.org/">官网</a>：https://nodejs.org/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/circle_screenshot_1_About%20the%20Django%20Software%20Foundation%20Django.png"><p align="center"><b style="font-size:25px">Django</b></p></p><p>Python 目前主要流行的web框架：flask、Django、Tornado。Django 是使用 Python 开发的免费开源 MVC 风格的 Web 应用程序框架，自带大量常用工具和框架，可轻松、迅速开发出一个功能齐全的Web应用。强大的数据库访问组件，灵活的URL映射，丰富的模板语言，健全的后台管理系统，完整的错误信息提示和强大的缓存支持，并支持多种语言。使用这种架构，程序员可以方便、快捷地创建高品质、易维护、数据库驱动的应用程序。</p><p>参考：<a href="http://www.codebaoku.com/django/django-index.html">Django 教程</a></p><p><a href="https://www.djangoproject.com/">官网</a>：https://www.djangoproject.com/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230826175843615.png"><p align="center"><b style="font-size:25px">Flask</b></p></p><p>Flask 是一个 Python 实现的基于 WSGI 的 Web 开发微框架， 自由、灵活、可扩展性很强，很适用于开发小型应用。</p><p>参考：<a href="http://www.codebaoku.com/flask/flask-index.html">Flask 教程</a></p><p><a href="https://flask.palletsprojects.com">官网</a>：https://flask.palletsprojects.com</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/tornado.png"><p align="center"><b style="font-size:25px">Tornado</b></p></p><p>Tornado 是一个开源的 Python Web非阻塞轻量级服务器框架，速度相当快，其用于异步非阻塞IO的处理方式，具有实现高并发、高性能的特点。</p><p><a href="https://www.tornadoweb.org">官网</a>：https://www.tornadoweb.org</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/scrapylogo.png"><p align="center"><b style="font-size:25px">Scrapy</b></p></p><p>Scrapy 是一套用Python实现的基于 Twisted 异步处理网络爬虫和网络抓取框架，它应用广泛，从数据挖掘，到监控数据，及自动化测试。使用者只需要定制开发几个简单的模块，就能够轻松的实现一个爬虫，用来抓取网页内容以及各种图片，使用非常简单方便。</p><p>参考：<a href="http://www.codebaoku.com/scrapy/scrapy-index.html">Scrapy 教程</a></p><p><a href="https://scrapy.org/">官网</a>：https://scrapy.org/</p><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://gitee.com/kayoungzhang/picgo_res/raw/master/img/gnu-100-b98545.png&quot;&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;b style=&quot;fo</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="开源" scheme="http://example.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>编译工具链</title>
    <link href="http://example.com/2023/08/18/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>http://example.com/2023/08/18/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/</id>
    <published>2023-08-18T06:40:47.000Z</published>
    <updated>2023-08-18T06:54:23.796Z</updated>
    
    <content type="html"><![CDATA[<p>在编写程序后，一般需要进行编译处理，生成可执行的程序文件，才能下载到芯片中运行，在IDE集成开发环境中，编译的过程都是由其内部的编译工具链进行处理。但在Linux开发过程中，一般需要自己进行编译器的配置等操作，下面简单了解下编译工具链的相关知识。</p><h2 id="编译工具链简介">编译工具链简介</h2><p>编译程序是一个由多个步骤组成的过程，每个步骤都需要使用不同的工具进行处理。这些工具紧密协作，前一个工具的输出会成为后一个工具的输入，故称之为工具链，习惯称为编译工具链。这个工具链中包含多种工具和相关C库，如预编译器，编译器，汇编器，链接器，调试器等等。</p><h2 id="编译工具链分类">编译工具链分类</h2><p>针对不同的应用平台和芯片架构，编译工具链种类有很多，有免费开源授权版和付费授权版。</p><p><strong>免费版工具链</strong> 主要有两大主流：</p><ul><li><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/gnu-100-b98545-16923412898262.png" alt="gnu-100-b98545" /> <a href="https://www.gnu.org/">GNU Toolchain</a></p></li><li><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6ac54669f4b30cb07094375cbd65d24163b5b6e0.jpeg" alt="6ac54669f4b30cb07094375cbd65d24163b5b6e0" /> <a href="https://llvm.org/">LLVM Toolchain</a></p></li></ul><p>对于开源的这两大工具链，主要是ARM和Linaro开发社区提供：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818145258689.png" alt="image-20230818145258689" /> <a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain">arm Developer</a></p><p>arm主要提供GNU工具链。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818131408554.png" alt="image-20230818131408554" /> <a href="https://www.linaro.org/">Linaro</a></p><p>Linaro两种都有提供。</p><p><strong>收费版工具链</strong> 主要是一些大公司开发的专用工具链，必须购买获取授权，才能使用，像ARM原厂提供的armcc、IAR EWARM，微软的MSVC等等。</p><h2 id="编译工具链一般命名规则">编译工具链一般命名规则</h2><p>编译工具链的命名规则为： <strong>arch [-vendor] [-os] [-(gnu)eabi]</strong></p><p><strong>arch</strong> - 芯片体系架构，如arm，mips，aarch64等。</p><p><strong>vendor</strong> - 工具链提供商，可以是none、unknow或者省略。</p><p><strong>os</strong> - 目标操作系统，这个字段一般是linux或者none。</p><p><strong>eabi</strong> - 嵌入式应用二进制接口（Embedded Application Binary Interface)，它指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。</p><p>如：</p><p>arm-none-eabi</p><p>aarch64-none-linux-gnu</p><p>arm-none-linux-gnueabihf</p><h2 id="gnu编译工具链">GNU编译工具链</h2><h4 id="arm-gnu-toolchain">Arm GNU Toolchain</h4><p>下载地址：https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain</p><p>由ARM公司开发用于Arm架构的GNU开源编译工具链（称作“Arm GNU Toolchain”），可以让合作伙伴，开发人员和社区能够使用新功能，这些功能来自最新Arm架构和GCC，Binutils，glibc，Newlib和GDB的开源项目。</p><ul><li><a href="https://gcc.gnu.org/"><strong>GNU C/C++ Compiler (GCC)</strong></a> ： 编译工具，把源程序编译为可执行文件。</li><li><a href="https://www.gnu.org/software/binutils/"><strong>Binutils</strong></a> ：一组二进制工具程序集合。</li><li><a href="https://www.sourceware.org/gdb/"><strong>GDB</strong></a>：GNU本地调试器，可以用来调试C、C++和其他语言编写的程序。<br /></li><li><a href="https://sourceware.org/newlib/"><strong>Newlib</strong></a>：C库</li><li><a href="https://www.gnu.org/software/libc/libc.html"><strong>Glibc</strong></a>：C库</li></ul><p><strong>注意</strong>： Arm发布的旧版GNU工具链有两种：一种针对A系列芯片，另一种是针对M系列和R系列芯片(<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads">GNU Toolchain for A-profile processors</a> 和 <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">GNU Arm Embedded Toolchain</a>)。现在已经合二为一。</p><h3 id="gnu-toolchain">GNU Toolchain</h3><p>其他开源组织开发的GNU编译工具链</p><p>https://gnutoolchains.com/download/</p><h3 id="llvm-toolchain">LLVM Toolchain</h3><p>下载地址：https://github.com/llvm/llvm-project/releases/</p><p>LLVM项目是一个模块化和可重用的编译器和工具链技术的集合。LLVM 核心库提供了一个独立的代码优化器，且支持大多数流行的CPU的代码生成。</p><ul><li><strong><a href="https://clang.llvm.org/">Clang compiler</a></strong>：LLVM工具链中的编译器。</li><li><a href="https://lldb.llvm.org/"><strong>LLDB debugger</strong></a>：本机调试器。</li><li><strong><a href="https://libcxx.llvm.org/">libc++</a></strong> :C++标准库</li><li><a href="https://compiler-rt.llvm.org/"><strong>Compiler-RT runtime libraries</strong></a>：编译运行库</li><li><strong><a href="https://lld.llvm.org/">LLD linker</a></strong>：链接器</li></ul><p>以上是关于编译器的一些介绍，如果不是做编译器底层开发的话，不建议深入学习，毕竟还是有点复杂，对于我们一般开发者而言，了解它的一般原理，知道在哪下载，怎么使用，这些已足够了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在编写程序后，一般需要进行编译处理，生成可执行的程序文件，才能下载到芯片中运行，在IDE集成开发环境中，编译的过程都是由其内部的编译工具链进行处理。但在Linux开发过程中，一般需要自己进行编译器的配置等操作，下面简单了解下编译工具链的相关知识。&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="编译" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>内存的分区(栈区、堆区、全局区、常量区和代码区)</title>
    <link href="http://example.com/2023/08/13/%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E5%8C%BA-%E6%A0%88%E5%8C%BA%E3%80%81%E5%A0%86%E5%8C%BA%E3%80%81%E5%85%A8%E5%B1%80%E5%8C%BA%E3%80%81%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8C%BA/"/>
    <id>http://example.com/2023/08/13/%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E5%8C%BA-%E6%A0%88%E5%8C%BA%E3%80%81%E5%A0%86%E5%8C%BA%E3%80%81%E5%85%A8%E5%B1%80%E5%8C%BA%E3%80%81%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8C%BA/</id>
    <published>2023-08-13T14:30:12.000Z</published>
    <updated>2023-08-28T05:39:44.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存分区简介">内存分区简介</h2><p>内存一般分为四个区域：<strong>堆区、栈区、全局区（静态区）、代码区</strong>。而编译程序占用的内存分为以下五个部分：<strong>堆区、栈区、全局区（静态区）、常量区、代码区</strong> 。</p><p>C、C++程序在编译链接后生成的映像（image）中，将只包含 <strong>代码段(.Text)</strong>、<strong>只读数据段(.rodata)</strong> 和 <strong>读写数据段(.data)</strong> 。在程序运行之前，将生成 <strong>未初始化数据段(.bss)</strong>，在程序的运行时还将动态生成 <strong>堆(Heap)区域</strong> 和 <strong>栈(Stack)区域</strong> 。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230821192124971.png" alt="" /><figcaption>image-20230821192124971</figcaption></figure><h2 id="内存各分区功能">内存各分区功能</h2><ul><li><p><strong>栈区（Read and Write）</strong></p><ul><li>临时创建的局部变量和const定义的局部变量及函数形参、返回值存放在栈上。</li><li>栈区按内存地址由高到低方向生长，先进后出原则。</li><li>栈区由编译器自动分配释放，无须手动管理。栈上内容在函数运行结束就会自动销毁。</li></ul></li><li><p><strong>堆区（Read and Write）</strong></p><ul><li>由程序员分别调用malloc()和free()函数分配和释放内存。若申请了内存，忘记释放会造成内存泄漏。</li><li>堆区按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。</li></ul></li><li><p><strong>全局区(静态区)（Read and Write）</strong></p><ul><li><strong>.data段</strong>：存放初始化的全局变量和静态(static)变量。编译期间其大小及数据被确定，这些变量<strong>需要占用内存空间</strong>。</li><li><strong>.bss段(Block Started by Symbol)</strong>：存放未初始化的全局变量和静态(static)变量。程序运行之前被内核初始化为 0 或者空（NULL）。这些变量<strong>在程序运行之前不占内存空间</strong>。</li></ul></li><li><p><strong>常量区（Read Only）</strong></p><ul><li>存放 <strong>字符串</strong>、<strong>数字</strong> 等常量。</li><li>存放 <strong>const修饰的全局变量</strong>。</li></ul></li><li><p><strong>代码区（Read Only）</strong></p><ul><li><p>存放程序的编译后的可执行二进制代码，CPU执行的机器指令。</p></li><li><p>代码区的地址:函数的地址,程序的入口地址，函数的名称也是一个指针，可以通过查询函数名称所处的内存地址，查询函数存放的区域。</p></li><li><p>字符串常量和define定义的常量也有可能存放在代码区。</p></li></ul></li></ul><h2 id="举例">举例</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> a;   <span class="hljs-comment">//存放在全局未初始化区 .bss段</span><span class="hljs-type">char</span>* p1;   <span class="hljs-comment">//存放在全局未初始化区</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> b;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span>* p2;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span>* p3 = <span class="hljs-string">&quot;123456&quot;</span>;<span class="hljs-comment">//123456\0在常量区，p3在栈区。</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>；<span class="hljs-comment">//全局(静态)初始化区 .data段</span>p1 = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);p2 = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);<span class="hljs-comment">//使用malloc分配得来得10和20字节的区域就在堆区。</span><span class="hljs-built_in">strcpy</span>(p1, <span class="hljs-string">&quot;123456&quot;</span>);<span class="hljs-comment">//123456\0在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span>&#125;</code></pre></div><p><strong>参考:</strong></p><p><a href="https://blog.csdn.net/u014470361/article/details/79297601?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%2279297601%22%2C%22source%22%3A%22zky0830%22%7D&amp;fromshare=blogdetail">什么是代码区、常量区、静态区（全局区）、堆区、栈区？</a></p><p><a href="https://blog.csdn.net/weixin_44364057/article/details/126541545">五大内存分区</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存分区简介&quot;&gt;内存分区简介&lt;/h2&gt;
&lt;p&gt;内存一般分为四个区域：&lt;strong&gt;堆区、栈区、全局区（静态区）、代码区&lt;/strong&gt;。而编译程序占用的内存分为以下五个部分：&lt;strong&gt;堆区、栈区、全局区（静态区）、常量区、代码区&lt;/strong&gt; 。&lt;</summary>
      
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="内存" scheme="http://example.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>计算机结构</title>
    <link href="http://example.com/2023/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/</id>
    <published>2023-08-13T11:42:45.000Z</published>
    <updated>2023-08-28T05:25:52.532Z</updated>
    
    <content type="html"><![CDATA[<p>计算机的五个基本组成部分：<strong>运算器、控制器、存储器、输入设备、输出设备</strong> 。</p><p>计算机常见的两种结构，<strong>哈佛结构（Harvard Architecture）</strong>和 <strong>冯·诺依曼结构（Von Neumann Architecture）</strong>：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230813204135256.png" /></p><p>从这两种结构图上可以看出，它们的主要区别是内存存在方式的不同。</p><h3 id="哈佛结构">哈佛结构</h3><p>哈佛结构是一种将程序指令储存和数据储存分开的存储器结构。每个存储器独立编址，使用两条独立的总线传输，中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作(通常是执行)。程序指令储存和数据储存分开，<strong>数据和指令的储存可以同时进行</strong>，可以使指令和数据有不同的数据宽度。</p><p>哈佛结构的微处理器执行时可以预先读取下一条指令，因此具有较高的执行效率。</p><h3 id="冯诺依曼结构">冯诺依曼结构</h3><p>冯诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的结构。指令和数据统一编址，使用同一条总线传输，节约了资源。</p><p>冯.诺依曼结构中，将程序和数据一样看待，<strong>将程序编码为数据，然后与数据一同存放在存储器中</strong>，无论什么程序，最终都是会转换为数据的形式存储在存储器中，要执行相应的程序只需要从存储器中依次取出指令、执行，这样减少了硬件的连接。</p><h3 id="改进型哈佛结构">改进型哈佛结构</h3><p>现在的计算机，其实是这两种结构的混合体。对于一台计算机的整体来说，我们可以认为是冯·诺依曼结构，计算机中的内存是统一的，并没有明确分为指令内存还是数据内存。</p><p>相对于CPU的速度来说，从内存读取数据和写入数据都很慢的，因此CPU内部有另外一种速度更快的存储介质来存放数据和指令，我们称之为缓存（Cache），分为D-Cache和l-Cache，分别用于存储数据和程序指令。在CPU外部则使用RAM存储数据和指令。只有需要改变数据时，缓存才会到RAM中加载新的数据。现代计算机中缓存通常有多层，每一层都比下一层快，但比下一层可以存放的数据少。</p><p>实际上，这种结构从内部看属于哈佛结构，从外部看则属于冯诺依曼结构， 这是一种混合式结构，而现在的计算机CPU大多采用这样的结构， 已经不再是纯粹的冯诺依曼结构或者哈佛结构了。</p><h4 id="参考链接">参考链接</h4><p>https://zhuanlan.zhihu.com/p/63322067</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机的五个基本组成部分：&lt;strong&gt;运算器、控制器、存储器、输入设备、输出设备&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;计算机常见的两种结构，&lt;strong&gt;哈佛结构（Harvard Architecture）&lt;/strong&gt;和 &lt;strong&gt;冯·诺依曼结构（Von</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>stm32 sct分散加载文件详解</title>
    <link href="http://example.com/2023/08/09/stm32-sct%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/09/stm32-sct%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-09T10:28:31.000Z</published>
    <updated>2023-08-10T11:32:50.678Z</updated>
    
    <content type="html"><![CDATA[<p>keil软件在编译过程中会生成分散加载文件（Scatter-Loading Description File），它可以用来描述链接器生成映像文件时需要的信息，通过这些信息分配 Code、RO-Data，RW-Data，ZI-Data 等数据的存放地址。</p><p>一个sct文件主要由一个<strong>加载区（load region）</strong>和多个<strong>执行区（execution region）</strong>构成。</p><p>加载区是用来保存永久性数据（程序和只读变量）的区域；执行区是程序执行时，从加载区域将数据复制到相应执行区后才能被正确执行。</p><p>sct文件一般格式：</p><div class="code-wrapper"><pre><code class="hljs assembly">LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region  ER_IROM1 0x08000000 0x00080000  &#123;  ; load address = execution address   *.o (RESET, +First)    *(InRoot$$Sections)    .ANY (+RO)   &#125;  RW_IRAM1 0x20000000 0x00010000  &#123;  ; RW data   .ANY (+RW +ZI)   &#125;&#125;</code></pre></div><p>下面分别通过三个方面详细了解一下其格式语法：</p><h4 id="加载区域语法">1. 加载区域语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">加载区名(基地址|&quot;+&quot;偏移地址)[属性][大小]&#123;执行区操作+    ;+号表示可以有一个或者多个运行区&#125;</code></pre></div><p>属性列表：</p><ul><li>ABSOLUTE：绝对地址；</li><li>PI：与位置无关；</li><li>RELOC：可重定位；</li><li>OVERLAY：覆盖；</li><li>NOCOMPRESS：不能进行压缩。</li></ul><h4 id="执行区语法">2. 执行区语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">执行区名(基地址|&quot;+&quot;偏移地址)[属性][大小|&quot; &quot;长度]&#123;输入段内容&#125;</code></pre></div><p>属性列表：</p><ul><li><p>ABSOLUTE：绝对地址；</p></li><li><p>PI：与位置无关；</p></li><li><p>RELOC：可重定位；</p></li><li><p>OVERLAY：覆盖；</p></li><li><p>FIXED：固定地址。</p></li><li><p>ALIGNalignment：将执行区的对齐约束从 4 增加到 alignment。alignment 必须为 2 的正数幂。如果执行区具有 base_address，则它必须为 alignment 对齐。如果执行区具有 offset，则链接器将计算的区基址与 alignment 边界对齐；</p></li><li><p>EMPTY：在执行区中保留一个给定长度的空白内存块，通常供堆或堆栈使用。</p></li><li><p>ZEROPAD：零初始化的段作为零填充块写入 ELF 文件，因此，运行时无需使用零进行填充；</p></li><li><p>PADVALUE：定义任何填充的值。如果指定 PADVALUE，则必须为其赋值；</p></li><li><p>NOCOMPRESS：不能进行压缩；</p></li><li><p>UNINIT：未初始化的数据。</p></li></ul><h4 id="输入段内容语法">3. 输入段内容语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">module_select_pattern [ &quot;(&quot; input_section_selector ( &quot;,&quot; input_section_selector )* &quot;)&quot; ](&quot;+&quot; input_section_attr | input_section_pattern | input_symbol_pattern)</code></pre></div><ul><li>module_select_pattern：目标文件滤波器，支持通配符“*”与“?”。字符不区分大小写。</li><li>input_section_selector: 模块选择器模式,有以下几种：<ul><li>包含段和目标文件的名称；</li><li>库成员名称（不带前导路径名）；</li><li>库的完整名称（包括路径名）。如果名称包含空格，则可以使用通配符简化。例如，使用*libname.lib 匹配 C:dir.lib。</li></ul></li><li>nput_section_attr：属性选择器与输入段属性相匹配。每个 input_section_attr 的前面有“+”号。如果指定一个模式以匹配输入段名称，名称前面必须有一个“+”号。可以省略紧靠“+”号前面的任何逗号。选择器不区分大小写。可以识别以下选择器：<ul><li>RO-CODE，RO-DATA，RO（RO-CODE 和 RO-DATA），CODE（RO-CODE）、CONST（RO-DATA），TEXT（RO）</li><li>RW-DATA，RW-CODE，RW（RW-CODE 和 RW-DATA），DATA（RW）</li><li>ZI，BSS（ZI）</li><li>ENTRY（即包含 ENTRY 点的段），FIRST，LAST</li></ul></li></ul><p>通过使用特殊模块选择器模式.ANY 可以将输入段分配给执行区，而无需考虑其父模块。可以使用一个或多个.ANY 模式以任意分配方式填充运行区。在大多数情况下，使用单个.ANY 等效于使用*模块选择器。</p><p>由以上语法分析，查看具体实例，如下所示：</p><div class="code-wrapper"><pre><code class="hljs assembly">; IROM1加载区，地址：0x08000000，大小：0x00080000LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region  ; ER_IROM1执行区，地址：0x08000000，大小：0x00080000  ER_IROM1 0x08000000 0x00080000    &#123;  ; load address = execution address   *.o (RESET, +First) ;将REST段最先放到本区，+First表示强制放到首地址   *(InRoot$$Sections) ;将ARM相关库放进来，InRoot$$Sections即ARM库的链接器标号，主要作用COPY RW区到RAM，然后再RW区后面创建ZI区。   .ANY (+RO) ;执行所有目标文件的只读属性数据  &#125;    ; RW_IRAM1执行区，地址：0x20000000，大小：0x00010000  RW_IRAM1 0x20000000 0x00010000    &#123;  ; RW data   .ANY (+RW +ZI) ;执行所有目标文件的可读可写属性及初始化为零的数据  &#125;&#125;</code></pre></div><p>以上就是sct分散加载文件的简要介绍，一般作为了解内存的分布情况，若想尝试修改区域数据存放的内存位置，可参考附件内周立功老师关于其具体使用的介绍。</p><p><a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/stm32%20sct%20file%20.zip">附件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;keil软件在编译过程中会生成分散加载文件（Scatter-Loading Description File），它可以用来描述链接器生成映像文件时需要的信息，通过这些信息分配 Code、RO-Data，RW-Data，ZI-Data 等数据的存放地址。&lt;/p&gt;
&lt;p&gt;一个</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sct" scheme="http://example.com/tags/sct/"/>
    
  </entry>
  
  <entry>
    <title>stm32 map文件详解</title>
    <link href="http://example.com/2023/08/09/stm32-map%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/09/stm32-map%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-09T10:25:35.000Z</published>
    <updated>2023-08-14T10:54:30.924Z</updated>
    
    <content type="html"><![CDATA[<p>MDK-ARM在编译时会生成很多类型的中间文件，最终通过这些中间文件生成可下载到MCU的hex文件。.map 文件就是其中编译器链接时生成的一个文件，主要包含了交叉链接信息。</p><p>通过 .map 文件，可以知晓工程中函数的大小，入口地址，变量、调用关系、FLASH 和 RAM 占用空间大小等信息，根据这些信息，可以对代码进行优化。</p><p>要生成 .map 文件，需要在keil软件中进行如下相应设置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809191148933.png" alt="image-20230809191148933" style="zoom: 80%;" /></p><p>为了更好的分析 map 文件，需要了解一些基础概念：</p><ul><li>Section：描述映像文件的代码或数据块，我们简称程序段</li><li>RO：包括只读数据（RO data）和代码（RO code）两部分内容，占用 FLASH 空间</li><li>RW：包含可读写数据（RW data，有初值，且不为 0），占用 FLASH（存储初值）和 RAM（读写操作）</li><li>ZI：Zero initialized 的缩写，包含初始化为 0 的数据（ZI data），占用 RAM 空间。</li><li>.text：相当于 RO code</li><li>.constdata：相当于 RO data</li><li>.bss：相当于 ZI data</li><li>.data：相当于 RW data</li></ul><p>使用notepad打开map文件，会发现map文件主要有 5 个组成部分：</p><ul><li><strong>程序段交叉引用关系（Section Cross References）</strong></li><li><strong>删除映像未使用的程序段（Removing Unused input sections from the image）</strong></li><li><strong>映像符号表（Image Symbol Table）</strong></li><li><strong>映像内存分布图（Memory Map of the image）</strong></li><li><strong>映像组件大小（Image component sizes）</strong></li></ul><p>下面分别进行介绍：</p><h4 id="程序段交叉引用关系section-cross-references">1.程序段交叉引用关系（Section Cross References）</h4><p>这部分内容描述了各个文件（.c/.s 等）之间函数（程序段）的调用关系。</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 1.程序段交叉引用关系</span><span class="hljs-comment"> * .o文件是.c源文件生成的中间文件，括号内是文件或函数入口地址，每句末尾表示被调用的函数或内容</span><span class="hljs-comment"> */</span>Section Cross References     startup_stm32f103xe.o(RESET) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    startup_stm32f103xe.o(RESET) refers to startup_stm32f103xe.o(.text) <span class="hljs-keyword">for</span> Reset_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.NMI_Handler) <span class="hljs-keyword">for</span> NMI_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.HardFault_Handler) <span class="hljs-keyword">for</span> HardFault_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.MemManage_Handler) <span class="hljs-keyword">for</span> MemManage_Handler    省略......    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash_ex.o(i.FLASH_OB_RDP_LevelConfig) <span class="hljs-keyword">for</span> FLASH_OB_RDP_LevelConfig    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash.o(i.FLASH_WaitForLastOperation) <span class="hljs-keyword">for</span> FLASH_WaitForLastOperation    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash.o(.bss) <span class="hljs-keyword">for</span> pFlash    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry10a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>D) <span class="hljs-keyword">for</span> __rt_final_cpp    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry11a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>F) <span class="hljs-keyword">for</span> __rt_final_exit    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry7b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000008</span>) <span class="hljs-keyword">for</span> _main_clock    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry8b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>A) <span class="hljs-keyword">for</span> _main_cpp_init    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry9a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>B) <span class="hljs-keyword">for</span> _main_init    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) <span class="hljs-keyword">for</span> _main_scatterload    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000001</span>) <span class="hljs-keyword">for</span> _main_stk    entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000001</span>) refers to entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00002712</span>) <span class="hljs-keyword">for</span> __lit__00000000    entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00002712</span>) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    entry2.o(__vectab_stack_and_reset_area) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    entry2.o(__vectab_stack_and_reset_area) refers to entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) <span class="hljs-keyword">for</span> __main    entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) refers to init.o(.text) <span class="hljs-keyword">for</span> __scatterload    entry9a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>B) refers to main.o(i.main) <span class="hljs-keyword">for</span> main    entry9b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>C) refers to main.o(i.main) <span class="hljs-keyword">for</span> main    init.o(.text) refers to entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) <span class="hljs-keyword">for</span> __main_after_scatterload</code></pre></div><h4 id="删除映像未使用的程序段removing-unused-input-sections-from-the-image">2.删除映像未使用的程序段（Removing Unused input sections from the image）</h4><p>这部分内容描述了工程中由于未被调用而被删除的冗余程序段（函数/数据）。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 2. 删除映像未使用的程序段</span><span class="hljs-comment"> * 每行显示删除的文件，位置及大小</span><span class="hljs-comment"> * 这部分最末显示删除的汇总信息。</span><span class="hljs-comment"> */</span>Removing Unused <span class="hljs-selector-tag">input</span> sections from the image.    Removing startup_stm32f103xe<span class="hljs-selector-class">.o</span>(HEAP), (<span class="hljs-number">512</span> bytes).    Removing <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>(.rev16_text), (<span class="hljs-number">4</span> bytes).    Removing <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>(.revsh_text), (<span class="hljs-number">4</span> bytes).    省略......    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_ClearConfigLine), (<span class="hljs-number">104</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_ClearPending), (<span class="hljs-number">20</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GenerateSWI), (<span class="hljs-number">20</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetConfigLine), (<span class="hljs-number">140</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetHandle), (<span class="hljs-number">12</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetPending), (<span class="hljs-number">24</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_IRQHandler), (<span class="hljs-number">36</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_RegisterCallback), (<span class="hljs-number">14</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_SetConfigLine), (<span class="hljs-number">164</span> bytes).<span class="hljs-number">226</span> unused <span class="hljs-selector-tag">section</span>(s) (total <span class="hljs-number">11022</span> bytes) removed from the image.</code></pre></div><h4 id="映像符号表image-symbol-table">3.映像符号表（Image Symbol Table）</h4><p>映像符号表（Image Symbol Table）描述了被引用的各个符号（程序段/数据）在存储器中的存储地址、类型、大小等信息。映像符号表分为两类：本地符号（Local Symbols）和全局符号（Global Symbols）。</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 3. 映像符号表</span><span class="hljs-comment"> * 映像符号包括Local Symbols（本地符号）和Global Symbols（全局符号）</span><span class="hljs-comment"> * 每行描述映像符号的名称、地址、类型、大小及生成目标。</span><span class="hljs-comment"> */</span>Image Symbol Table    Local Symbols    Symbol Name                              Value     Ov Type        Size  <span class="hljs-built_in">Object</span>(Section)    ../Core/Src/dma<span class="hljs-selector-class">.c</span>                        <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  dma<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/gpio<span class="hljs-selector-class">.c</span>                       <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  gpio<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>                       <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/stm32f1xx_hal_msp<span class="hljs-selector-class">.c</span>          <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_msp<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/stm32f1xx_it<span class="hljs-selector-class">.c</span>               <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_it<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/system_stm32f1xx<span class="hljs-selector-class">.c</span>           <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  system_stm32f1xx<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/usart<span class="hljs-selector-class">.c</span>                      <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  usart<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_cortex<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_cortex<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_dma<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_dma<span class="hljs-selector-class">.o</span> ABSOLUTE    省略......    Global Symbols    Symbol Name                              Value     Ov Type        Size  <span class="hljs-built_in">Object</span>(Section)    BuildAttributes$<span class="hljs-variable">$THM_ISAv4</span><span class="hljs-variable">$P</span><span class="hljs-variable">$D</span><span class="hljs-variable">$K</span><span class="hljs-variable">$B</span><span class="hljs-variable">$S</span><span class="hljs-variable">$PE</span><span class="hljs-variable">$A</span>:L22UL41UL21<span class="hljs-variable">$X</span>:L11<span class="hljs-variable">$S22US41US21</span><span class="hljs-variable">$IEEE1</span><span class="hljs-variable">$IW</span><span class="hljs-variable">$USESV6</span>$~STKCKD<span class="hljs-variable">$USESV7</span>$~SHL<span class="hljs-variable">$OSPACE</span><span class="hljs-variable">$EBA8</span><span class="hljs-variable">$MICROLIB</span><span class="hljs-variable">$REQ8</span><span class="hljs-variable">$PRES8</span><span class="hljs-variable">$EABIv2</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  anon$<span class="hljs-variable">$obj</span><span class="hljs-selector-class">.o</span> ABSOLUTE    __ARM_use_no_argv                        <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> ABSOLUTE    __cpp_initialize__aeabi_                  - Undefined Weak Reference    __cxa_finalize                            - Undefined Weak Reference    __decompress                              - Undefined Weak Reference    _clock_init                               - Undefined Weak Reference    _microlib_exit                            - Undefined Weak Reference    __Vectors_Size                           <span class="hljs-number">0</span>x00000130   Number         <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span> ABSOLUTE    __Vectors                                <span class="hljs-number">0</span>x08000000   Data           <span class="hljs-number">4</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(RESET)    __Vectors_End                            <span class="hljs-number">0</span>x08000130   Data           <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(RESET)    __main                                   <span class="hljs-number">0</span>x08000131   Thumb Code     <span class="hljs-number">0</span>  entry<span class="hljs-selector-class">.o</span>(<span class="hljs-selector-class">.ARM</span>.Collect$$$$<span class="hljs-number">00000000</span>)    _main_stk                                <span class="hljs-number">0</span>x08000131   Thumb Code     <span class="hljs-number">0</span>  entry2<span class="hljs-selector-class">.o</span>(<span class="hljs-selector-class">.ARM</span>.Collect$$$$<span class="hljs-number">00000001</span>)    省略......    SystemCoreClock                          <span class="hljs-number">0</span>x20000030   Data           <span class="hljs-number">4</span>  system_stm32f1xx<span class="hljs-selector-class">.o</span>(.data)    uwTickFreq                               <span class="hljs-number">0</span>x20000034   Data           <span class="hljs-number">1</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    uwTickPrio                               <span class="hljs-number">0</span>x20000038   Data           <span class="hljs-number">4</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    uwTick                                   <span class="hljs-number">0</span>x2000003c   Data           <span class="hljs-number">4</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    huart1                                   <span class="hljs-number">0</span>x20000040   Data          <span class="hljs-number">72</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    hdma_usart1_rx                           <span class="hljs-number">0</span>x20000088   Data          <span class="hljs-number">68</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    hdma_usart1_tx                           <span class="hljs-number">0</span>x200000cc   Data          <span class="hljs-number">68</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    __initial_sp                             <span class="hljs-number">0</span>x20000510   Data           <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(STACK)</code></pre></div><h4 id="映像内存分布图memory-map-of-the-image">4.映像内存分布图（Memory Map of the image）</h4><p>映像文件分为加载域（Load Region）和运行域（Execution Region），一个加载域必须有至少一个运行域（可以有多个运行域），而一个程序又可以有多个加载域。加载域为映像程序的实际存储区域，而运行域则是 MCU 上电后的运行状态。加载域和运行域的简化关系（这里仅表示一个加载域的情况）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809213411201.png" alt="image-20230809213411201" style="zoom:80%;" /></p><div class="code-wrapper"><pre><code class="hljs dns">/* * <span class="hljs-number">4</span>. 映像内存分布图 * 映像文件分为加载域（Load Region）和运行域（Execution Region）。 */Memory Map of the image  /* 映象入口地址 */  Image Entry point : <span class="hljs-number">0x08000131</span>     /* LR_IROM1加载域地址及大小 */  Load Region LR_IROM1 (Base: <span class="hljs-number">0x08000000</span>, Size: <span class="hljs-number">0</span>x<span class="hljs-number">000017c8</span>, Max: <span class="hljs-number">0x00080000</span>, ABSOLUTE)     /* ER_IROM1运行域地址及大小 */  Execution Region ER_IROM1 (Base: <span class="hljs-number">0x08000000</span>, Size: <span class="hljs-number">0x00001788</span>, Max: <span class="hljs-number">0x00080000</span>, ABSOLUTE)     Base Addr    Size         Type   Attr      Idx    E Section Name        Object    <span class="hljs-number">0x08000000</span>   <span class="hljs-number">0x00000130</span>   Data   RO            <span class="hljs-number">3</span>    RESET               startup_stm32f103xe.o    <span class="hljs-number">0x08000130</span>   <span class="hljs-number">0x00000000</span>   Code   RO         <span class="hljs-number">1809</span>  * .ARM.Collect$$$$<span class="hljs-number">00000000</span>  mc_w.l(entry.o)    <span class="hljs-number">0x08000130</span>   <span class="hljs-number">0x00000004</span>   Code   RO         <span class="hljs-number">1816</span>    .ARM.Collect$$$$<span class="hljs-number">00000001</span>  mc_w.l(entry2.o)    <span class="hljs-number">0x08000134</span>   <span class="hljs-number">0x00000004</span>   Code   RO         <span class="hljs-number">1819</span>    .ARM.Collect$$$$<span class="hljs-number">00000004</span>  mc_w.l(entry5.o)    省略......    <span class="hljs-number">0x08001708</span>   <span class="hljs-number">0x00000034</span>   Code   RO           <span class="hljs-number">15</span>    i.main              main.o    <span class="hljs-number">0</span>x0800173c   <span class="hljs-number">0x00000010</span>   Data   RO          <span class="hljs-number">364</span>    .constdata          system_stm32f1xx.o    <span class="hljs-number">0</span>x0800174c   <span class="hljs-number">0x00000008</span>   Data   RO          <span class="hljs-number">365</span>    .constdata          system_stm32f1xx.o    <span class="hljs-number">0x08001754</span>   <span class="hljs-number">0x00000012</span>   Data   RO         <span class="hljs-number">1023</span>    .constdata          stm32f1xx_hal_rcc.o    <span class="hljs-number">0x08001766</span>   <span class="hljs-number">0x00000002</span>   PAD    <span class="hljs-number">0x08001768</span>   <span class="hljs-number">0x00000020</span>   Data   RO         <span class="hljs-number">1832</span>    Region$$Table       anon$$obj.o    /* RW_IRAM1运行域，地址，大小 */    Execution Region RW_IRAM1 (Base: <span class="hljs-number">0x20000000</span>, Size: <span class="hljs-number">0x00000510</span>, Max: <span class="hljs-number">0x00010000</span>, ABSOLUTE)     Base Addr    Size         Type   Attr      Idx    E Section Name        Object    <span class="hljs-number">0x20000000</span>   <span class="hljs-number">0</span>x0000002f   Data   RW           <span class="hljs-number">16</span>    .data               main.o    <span class="hljs-number">0</span>x2000002f   <span class="hljs-number">0x00000001</span>   PAD    <span class="hljs-number">0x20000030</span>   <span class="hljs-number">0x00000004</span>   Data   RW          <span class="hljs-number">366</span>    .data               system_stm32f1xx.o    <span class="hljs-number">0x20000034</span>   <span class="hljs-number">0</span>x0000000c   Data   RW          <span class="hljs-number">860</span>    .data               stm32f1xx_hal.o    <span class="hljs-number">0x20000040</span>   <span class="hljs-number">0</span>x<span class="hljs-number">000000d0</span>   Zero   RW          <span class="hljs-number">200</span>    .bss                usart.o    <span class="hljs-number">0x20000110</span>   <span class="hljs-number">0x00000400</span>   Zero   RW            <span class="hljs-number">1</span>    STACK               startup_stm32f103xe.o</code></pre></div><h4 id="映像组件大小image-component-sizes">5.映像组件大小（Image component sizes）</h4><p>各文件编译后所占代码空间的大小，keil IDE编译后输出框显示的文件占用空间大小与此部分一致。</p><div class="code-wrapper"><pre><code class="hljs tap">/* * 5. 映像组件大小 * 文件编译后所占代码空间的大小。 */Image component sizes/* 代码大小(内联函数大小) 只读大小  读写大小  零初始化大小  调试大小  文件名 */      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name       <span class="hljs-number"> 60 </span>        <span class="hljs-number"> 4 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 682 </span>  dma.o       <span class="hljs-number"> 28 </span>        <span class="hljs-number"> 6 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 663 </span>  gpio.o      <span class="hljs-number"> 150 </span>       <span class="hljs-number"> 10 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 47 </span>        <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 455148 </span>  main.o       <span class="hljs-number"> 36 </span>        <span class="hljs-number"> 8 </span>      <span class="hljs-number"> 304 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1024 </span>      <span class="hljs-number"> 760 </span>  startup_stm32f103xe.o      <span class="hljs-number"> 164 </span>       <span class="hljs-number"> 28 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 12 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 6105 </span>  stm32f1xx_hal.o      <span class="hljs-number"> 198 </span>       <span class="hljs-number"> 14 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 28331 </span>  stm32f1xx_hal_cortex.o     <span class="hljs-number"> 1236 </span>       <span class="hljs-number"> 52 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4358 </span>  stm32f1xx_hal_dma.o      <span class="hljs-number"> 504 </span>       <span class="hljs-number"> 42 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1928 </span>  stm32f1xx_hal_gpio.o       <span class="hljs-number"> 60 </span>        <span class="hljs-number"> 8 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 786 </span>  stm32f1xx_hal_msp.o     <span class="hljs-number"> 1240 </span>       <span class="hljs-number"> 84 </span>       <span class="hljs-number"> 18 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4604 </span>  stm32f1xx_hal_rcc.o     <span class="hljs-number"> 1500 </span>       <span class="hljs-number"> 24 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 10186 </span>  stm32f1xx_hal_uart.o       <span class="hljs-number"> 56 </span>       <span class="hljs-number"> 18 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4700 </span>  stm32f1xx_it.o        <span class="hljs-number"> 2 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 24 </span>        <span class="hljs-number"> 4 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 987 </span>  system_stm32f1xx.o      <span class="hljs-number"> 276 </span>       <span class="hljs-number"> 30 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 208 </span>     <span class="hljs-number"> 1728 </span>  usart.o    -------------------------------------------------------------------<span class="language-yaml"><span class="hljs-meta">---</span></span><span class="language-yaml">      <span class="hljs-number">5522        </span><span class="hljs-number">328</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">520966</span>   <span class="hljs-string">Object</span> <span class="hljs-string">Totals</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>         <span class="hljs-number">32</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Generated)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器生成的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">        <span class="hljs-number">12</span>          <span class="hljs-number">0</span>          <span class="hljs-number">2</span>          <span class="hljs-number">1</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Padding)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器填充的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span>  <span class="hljs-string">库文件名</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Member</span> <span class="hljs-string">Name</span></span><span class="language-yaml"></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry10a.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry11a.o</span></span><span class="language-yaml">         <span class="hljs-number">8</span>          <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry2.o</span></span><span class="language-yaml">         <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry5.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry7b.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry8b.o</span></span><span class="language-yaml">         <span class="hljs-number">8</span>          <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry9a.o</span></span><span class="language-yaml">        <span class="hljs-number">30</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">handlers.o</span></span><span class="language-yaml">        <span class="hljs-number">36</span>          <span class="hljs-number">8</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>         <span class="hljs-number">68</span>   <span class="hljs-string">init.o</span></span><span class="language-yaml">        <span class="hljs-number">36</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">108</span>   <span class="hljs-string">memseta.o</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Totals</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Padding)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器填充的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span>  <span class="hljs-string">库文件名</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Name</span></span><span class="language-yaml"></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">mc_w.l</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Totals</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   </span><span class="language-yaml"></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">518434</span>   <span class="hljs-string">Grand</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">整个映像大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">518434</span>   <span class="hljs-string">ELF</span> <span class="hljs-string">Image</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">ELF可执行格式映像大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">ROM</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">整个ROM大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">RO</span>  <span class="hljs-string">Size</span> <span class="hljs-string">(Code</span> <span class="hljs-string">+</span> <span class="hljs-string">RO</span> <span class="hljs-string">Data)</span>                 <span class="hljs-number">6024</span> <span class="hljs-string">(</span>   <span class="hljs-number">5.</span><span class="hljs-string">88kB)</span></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">RW</span>  <span class="hljs-string">Size</span> <span class="hljs-string">(RW</span> <span class="hljs-string">Data</span> <span class="hljs-string">+</span> <span class="hljs-string">ZI</span> <span class="hljs-string">Data)</span>              <span class="hljs-number">1296</span> <span class="hljs-string">(</span>   <span class="hljs-number">1.</span><span class="hljs-string">27kB)</span></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">ROM</span> <span class="hljs-string">Size</span> <span class="hljs-string">(Code</span> <span class="hljs-string">+</span> <span class="hljs-string">RO</span> <span class="hljs-string">Data</span> <span class="hljs-string">+</span> <span class="hljs-string">RW</span> <span class="hljs-string">Data)</span>       <span class="hljs-number">6088</span> <span class="hljs-string">(</span>   <span class="hljs-number">5.</span><span class="hljs-string">95kB)</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span></code></pre></div><p>Code是代码区，RO-data 代表常量区，RW-data 代表已初始化的全局变量和静态变量，属于静态区（全局区），ZI-data 代表未初始化但被编译器初始化为0的全局变量和静态变量，属于静态区（全局区）。</p><p><a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/stm32_map_file.zip">hal uart map文件与正点原子详解附件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MDK-ARM在编译时会生成很多类型的中间文件，最终通过这些中间文件生成可下载到MCU的hex文件。.map 文件就是其中编译器链接时生成的一个文件，主要包含了交叉链接信息。&lt;/p&gt;
&lt;p&gt;通过 .map 文件，可以知晓工程中函数的大小，入口地址，变量、调用关系、FLAS</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="map" scheme="http://example.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>stm32启动文件详解</title>
    <link href="http://example.com/2023/08/08/stm32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/08/stm32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-08T04:30:03.000Z</published>
    <updated>2023-08-09T10:00:07.283Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道程序一般是从<code>main</code>函数开始运行的，但在<code>main</code>函数运行之前，程序已经做了一些准备工作，对于STM32F1芯片，这些准备工作是通过启动文件来完成的。下面来详细看看stm32库中的启动代码文件（STM32Cube_FW_F1_V1.8.532F1xx_stm32f103xe.s）。</p><p>启动文件是由汇编语言编写，是系统上电复位后第一个执行的程序。首先我们来看看启动文件使用的ARM汇编指令：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809173349258.png" alt="" /><figcaption>image-20230809173349258</figcaption></figure><p>整个启动文件主要做了以下操作：</p><ul><li>**设置初始化堆栈指针SP = _initial_sp**</li><li><strong>设置初始化计数器指针PC = Reset_Handler</strong></li><li><strong>设置堆栈大小</strong></li><li><strong>初始化中断向量表</strong></li><li><strong>调用 SystemInit() 函数初始化系统时钟</strong></li><li>**跳转到C库中的 __main 函数初始化用户堆栈（最终调用main()函数）**</li></ul><div class="code-wrapper"><pre><code class="hljs assembly">;1-栈 ######;开辟栈的大小为 0X00000400（1K字节），名字为 STACK， NOINIT 即不初始化，可读可写， 8（2^3）字节对齐。;标号__initial_sp 表示栈的结束地址，即栈顶地址，栈是由高向低生长的。; Amount of memory (in bytes) allocated for Stack  ; Tailor this value to your application needs    ; &lt;h&gt; Stack Configuration   ;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;   ; &lt;/h&gt;Stack_Size      EQU     0x00000400                    AREA    STACK, NOINIT, READWRITE, ALIGN=3  Stack_Mem       SPACE   Stack_Size   __initial_sp</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;2-堆 ######;开辟堆的大小为 0X00000200（512字节），名字为 HEAP， 不初始化，可读可写， 8（2^3）字节对齐。;标号__heap_base 表示堆的起始地址， __heap_limit 表示堆的结束地址。堆是由低向高生长的，跟栈的生长方向相反。                                                  ; &lt;h&gt; Heap Configuration  ;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;  ; &lt;/h&gt;Heap_Size       EQU     0x00000200                  AREA    HEAP, NOINIT, READWRITE, ALIGN=3 __heap_baseHeap_Mem        SPACE   Heap_Size__heap_limit</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;3-向量表; 定义一个名为RESET的数据段，只读，并声明三个全局属性的标号 __Vectors、 __Vectors_End 和__Vectors_Size; Vector Table Mapped to Address 0 at Reset                AREA    RESET, DATA, READONLY                EXPORT  __Vectors                EXPORT  __Vectors_End                EXPORT  __Vectors_Size__Vectors       DCD     __initial_sp               ; Top of Stack #栈顶                DCD     Reset_Handler              ; Reset Handler                DCD     NMI_Handler                ; NMI Handler                DCD     HardFault_Handler          ; Hard Fault Handler                DCD     MemManage_Handler          ; MPU Fault Handler                DCD     BusFault_Handler           ; Bus Fault Handler                DCD     UsageFault_Handler         ; Usage Fault Handler                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     SVC_Handler                ; SVCall Handler                DCD     DebugMon_Handler           ; Debug Monitor Handler                DCD     0                          ; Reserved                DCD     PendSV_Handler             ; PendSV Handler                DCD     SysTick_Handler            ; SysTick Handler                ; External Interrupts #外部中断                DCD     WWDG_IRQHandler            ; Window Watchdog                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect                DCD     TAMPER_IRQHandler          ; Tamper                DCD     RTC_IRQHandler             ; RTC                DCD     FLASH_IRQHandler           ; Flash                DCD     RCC_IRQHandler             ; RCC                DCD     EXTI0_IRQHandler           ; EXTI Line 0                DCD     EXTI1_IRQHandler           ; EXTI Line 1                DCD     EXTI2_IRQHandler           ; EXTI Line 2                DCD     EXTI3_IRQHandler           ; EXTI Line 3                DCD     EXTI4_IRQHandler           ; EXTI Line 4                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7                DCD     ADC1_2_IRQHandler          ; ADC1 &amp; ADC2                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break                DCD     TIM1_UP_IRQHandler         ; TIM1 Update                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare                DCD     TIM2_IRQHandler            ; TIM2                DCD     TIM3_IRQHandler            ; TIM3                DCD     TIM4_IRQHandler            ; TIM4                DCD     I2C1_EV_IRQHandler         ; I2C1 Event                DCD     I2C1_ER_IRQHandler         ; I2C1 Error                DCD     I2C2_EV_IRQHandler         ; I2C2 Event                DCD     I2C2_ER_IRQHandler         ; I2C2 Error                DCD     SPI1_IRQHandler            ; SPI1                DCD     SPI2_IRQHandler            ; SPI2                DCD     USART1_IRQHandler          ; USART1                DCD     USART2_IRQHandler          ; USART2                DCD     USART3_IRQHandler          ; USART3                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10                DCD     RTC_Alarm_IRQHandler        ; RTC Alarm through EXTI Line                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break                DCD     TIM8_UP_IRQHandler         ; TIM8 Update                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare                DCD     ADC3_IRQHandler            ; ADC3                DCD     FSMC_IRQHandler            ; FSMC                DCD     SDIO_IRQHandler            ; SDIO                DCD     TIM5_IRQHandler            ; TIM5                DCD     SPI3_IRQHandler            ; SPI3                DCD     UART4_IRQHandler           ; UART4                DCD     UART5_IRQHandler           ; UART5                DCD     TIM6_IRQHandler            ; TIM6                DCD     TIM7_IRQHandler            ; TIM7                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5__Vectors_End__Vectors_Size  EQU  __Vectors_End - __Vectors</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;4-复位中断程序，系统上电后第一个要执行的程序;调用外部 SystemInit() 函数初始化系统时钟，然后调用 C 库函数_mian()，最终调用 main()函数去到 C 的世界。               ; Reset handlerReset_Handler   PROC                EXPORT  Reset_Handler             [WEAK]                IMPORT  __main                IMPORT  SystemInit                LDR     R0, =SystemInit                BLX     R0                               LDR     R0, =__main                BX      R0                ENDP</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;5-空的中断服务函数，[WEAK]弱声明无限循环函数，用户可以对其进行重定义。             ; Dummy Exception Handlers (infinite loops which can be modified)NMI_Handler     PROC                EXPORT  NMI_Handler                [WEAK]                B       .                ENDPHardFault_Handler\                PROC                EXPORT  HardFault_Handler          [WEAK]                B       .                ENDPMemManage_Handler\                PROC                EXPORT  MemManage_Handler          [WEAK]                B       .                ENDPBusFault_Handler\                PROC                EXPORT  BusFault_Handler           [WEAK]                B       .                ENDPUsageFault_Handler\                PROC                EXPORT  UsageFault_Handler         [WEAK]                B       .                ENDPSVC_Handler     PROC                EXPORT  SVC_Handler                [WEAK]                B       .                ENDPDebugMon_Handler\                PROC                EXPORT  DebugMon_Handler           [WEAK]                B       .                ENDPPendSV_Handler  PROC                EXPORT  PendSV_Handler             [WEAK]                B       .                ENDPSysTick_Handler PROC                EXPORT  SysTick_Handler            [WEAK]                B       .                ENDPDefault_Handler PROC                EXPORT  WWDG_IRQHandler            [WEAK]                EXPORT  PVD_IRQHandler             [WEAK]                EXPORT  TAMPER_IRQHandler          [WEAK]                EXPORT  RTC_IRQHandler             [WEAK]                EXPORT  FLASH_IRQHandler           [WEAK]                EXPORT  RCC_IRQHandler             [WEAK]                EXPORT  EXTI0_IRQHandler           [WEAK]                EXPORT  EXTI1_IRQHandler           [WEAK]                EXPORT  EXTI2_IRQHandler           [WEAK]                EXPORT  EXTI3_IRQHandler           [WEAK]                EXPORT  EXTI4_IRQHandler           [WEAK]                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]                EXPORT  ADC1_2_IRQHandler          [WEAK]                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]                EXPORT  CAN1_RX1_IRQHandler        [WEAK]                EXPORT  CAN1_SCE_IRQHandler        [WEAK]                EXPORT  EXTI9_5_IRQHandler         [WEAK]                EXPORT  TIM1_BRK_IRQHandler        [WEAK]                EXPORT  TIM1_UP_IRQHandler         [WEAK]                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]                EXPORT  TIM1_CC_IRQHandler         [WEAK]                EXPORT  TIM2_IRQHandler            [WEAK]                EXPORT  TIM3_IRQHandler            [WEAK]                EXPORT  TIM4_IRQHandler            [WEAK]                EXPORT  I2C1_EV_IRQHandler         [WEAK]                EXPORT  I2C1_ER_IRQHandler         [WEAK]                EXPORT  I2C2_EV_IRQHandler         [WEAK]                EXPORT  I2C2_ER_IRQHandler         [WEAK]                EXPORT  SPI1_IRQHandler            [WEAK]                EXPORT  SPI2_IRQHandler            [WEAK]                EXPORT  USART1_IRQHandler          [WEAK]                EXPORT  USART2_IRQHandler          [WEAK]                EXPORT  USART3_IRQHandler          [WEAK]                EXPORT  EXTI15_10_IRQHandler       [WEAK]                EXPORT  RTC_Alarm_IRQHandler        [WEAK]                EXPORT  USBWakeUp_IRQHandler       [WEAK]                EXPORT  TIM8_BRK_IRQHandler        [WEAK]                EXPORT  TIM8_UP_IRQHandler         [WEAK]                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]                EXPORT  TIM8_CC_IRQHandler         [WEAK]                EXPORT  ADC3_IRQHandler            [WEAK]                EXPORT  FSMC_IRQHandler            [WEAK]                EXPORT  SDIO_IRQHandler            [WEAK]                EXPORT  TIM5_IRQHandler            [WEAK]                EXPORT  SPI3_IRQHandler            [WEAK]                EXPORT  UART4_IRQHandler           [WEAK]                EXPORT  UART5_IRQHandler           [WEAK]                EXPORT  TIM6_IRQHandler            [WEAK]                EXPORT  TIM7_IRQHandler            [WEAK]                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]WWDG_IRQHandlerPVD_IRQHandlerTAMPER_IRQHandlerRTC_IRQHandlerFLASH_IRQHandlerRCC_IRQHandlerEXTI0_IRQHandlerEXTI1_IRQHandlerEXTI2_IRQHandlerEXTI3_IRQHandlerEXTI4_IRQHandlerDMA1_Channel1_IRQHandlerDMA1_Channel2_IRQHandlerDMA1_Channel3_IRQHandlerDMA1_Channel4_IRQHandlerDMA1_Channel5_IRQHandlerDMA1_Channel6_IRQHandlerDMA1_Channel7_IRQHandlerADC1_2_IRQHandlerUSB_HP_CAN1_TX_IRQHandlerUSB_LP_CAN1_RX0_IRQHandlerCAN1_RX1_IRQHandlerCAN1_SCE_IRQHandlerEXTI9_5_IRQHandlerTIM1_BRK_IRQHandlerTIM1_UP_IRQHandlerTIM1_TRG_COM_IRQHandlerTIM1_CC_IRQHandlerTIM2_IRQHandlerTIM3_IRQHandlerTIM4_IRQHandlerI2C1_EV_IRQHandlerI2C1_ER_IRQHandlerI2C2_EV_IRQHandlerI2C2_ER_IRQHandlerSPI1_IRQHandlerSPI2_IRQHandlerUSART1_IRQHandlerUSART2_IRQHandlerUSART3_IRQHandlerEXTI15_10_IRQHandlerRTC_Alarm_IRQHandlerUSBWakeUp_IRQHandlerTIM8_BRK_IRQHandlerTIM8_UP_IRQHandlerTIM8_TRG_COM_IRQHandlerTIM8_CC_IRQHandlerADC3_IRQHandlerFSMC_IRQHandlerSDIO_IRQHandlerTIM5_IRQHandlerSPI3_IRQHandlerUART4_IRQHandlerUART5_IRQHandlerTIM6_IRQHandlerTIM7_IRQHandlerDMA2_Channel1_IRQHandlerDMA2_Channel2_IRQHandlerDMA2_Channel3_IRQHandlerDMA2_Channel4_5_IRQHandler                B       .                ENDP                ALIGN</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;6-将堆栈地址传递给C库函数_main()，利用C库函数初始化堆栈或由用户自己初始化堆栈。;*******************************************************************************; User Stack and Heap initialization;*******************************************************************************                 IF      :DEF:__MICROLIB  ;#keil-MDK IDE勾选MicroLIB宏                ;#赋予以下三个标号全局属性                 EXPORT  __initial_sp                 EXPORT  __heap_base                 EXPORT  __heap_limit                                 ELSE        ;#keil-MDK IDE没有勾选MicroLIB宏                                 IMPORT  __use_two_region_memory ;#导入双段存储器模式，需要用户自己实现。                 EXPORT  __user_initial_stackheap ;#赋予标号__user_initial_stackheap全局属性                 __user_initial_stackheap                 LDR     R0, =  Heap_Mem                 LDR     R1, =(Stack_Mem + Stack_Size)                 LDR     R2, = (Heap_Mem +  Heap_Size)                 LDR     R3, = Stack_Mem                 BX      LR                 ALIGN</code></pre></div><p><a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/startup_stm32f103xe.zip">启动文件与正点原子详解附件</a></p><p>参考链接：</p><p>https://www.elecfans.com/news/1802838.html</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道程序一般是从&lt;code&gt;main&lt;/code&gt;函数开始运行的，但在&lt;code&gt;main&lt;/code&gt;函数运行之前，程序已经做了一些准备工作，对于STM32F1芯片，这些准备工作是通过启动文件来完成的。下面来详细看看stm32库中的启动代码文件（STM32Cube_F</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="startup" scheme="http://example.com/tags/startup/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_sd库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T10:30:31.000Z</published>
    <updated>2023-08-14T00:03:33.381Z</updated>
    
    <content type="html"><![CDATA[<p>Secure Digital,简称SD,SD内存卡是一种使用非常广泛的存储设备，以下来看看HAL库关于SD卡的使用方法。</p><h3 id="sd外设库的使用">SD外设库的使用</h3><p>这是一个通用分层的SDIO存储驱动，它使用HAL SDIO驱动函数来连接SD内存卡。</p><p><strong>1. 初始化SDIO底层。HAL_SD_MspInit()</strong></p><ul><li>使能SDIO接口时钟。__HAL_RCC_SDIO_CLK_ENABLE()</li><li>配置SDIO引脚<ul><li>使能SDIO GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置SDIO引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_SD_ReadBlocks_DMA() ， HAL_SD_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDIO和DMA中断优先级，DMA优先级高于SDIO。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code> ， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code> ，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_SD_ReadBlocks_IT()，HAL_SD_WriteBlocks_IT()<ul><li>配置SDIO中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code> ， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code> ，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. SD卡的初始化和配置</strong></p><p>使用HAL_SD_Init()函数来初始化SD卡，并进入睡眠状态（已准备好数据传输）。SD卡初始化后，就可以执行SD卡的读、写、擦除操作。</p><ul><li><p>以400KHz的频率配置初始化SD卡。</p><p>SD卡频率：SDIO_CK = SDIOCLK / (ClockDiv + 2)；</p><p>初始化时，根据SD卡标准，确保SDIO_CK频率不要超过400KHz，通过SDIO底层函数 SDIO_Init()和SDIO_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化SD卡。HAL_SD_InitCard()</p><p>这个函数用于初始化和识别SDIO及检查SD卡的类型（标准容量或高容量），此初始化流程与SD卡标准兼容。这个函数也可以在插拔时重新初始化SD卡。</p></li><li><p>配置SD卡数据传输频率，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据SD卡标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDIO外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的SD卡。</p></li><li><p>配置SD卡宽总线模式：4位数据。</p></li></ul><p><strong>3. SD卡的读操作</strong></p><ul><li><p>轮询模式下读取SD卡。HAL_SD_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态。</p></li><li><p>DMA模式下读取SD卡。HAL_SD_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Rx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取SD卡。HAL_SD_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Rx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. SD卡的写操作</strong></p><ul><li><p>轮询模式下向SD卡写操作。HAL_SD_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD卡的状态。</p></li><li><p>DMA模式下向SD卡写操作。HAL_SD_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Tx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向SD卡写操作。HAL_SD_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Tx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取SD卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取SD卡信息。HAL_SDIO_GetCardInfo()</p><p>它会返回关于SD卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_SDIO_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_SDIO_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="sd-hal常用宏定义列表">SD HAL常用宏定义列表</h3><ul><li><p>__HAL_SD_ENABLE : 使能 SD设备</p></li><li><p>__HAL_SD_DISABLE : 禁止 SD 设备</p></li><li><p>__HAL_SD_DMA_ENABLE: 使能 SD DMA 传输</p></li><li><p>__HAL_SD_DMA_DISABLE: 禁止 SD DMA 传输</p></li><li><p>__HAL_SD_ENABLE_IT: 使能 SD 设备中断</p></li><li><p>__HAL_SD_DISABLE_IT: 禁止 SD 设备中断</p></li><li><p>__HAL_SD_GET_FLAG:检查 SD 标志是否设置</p></li><li><p>__HAL_SD_CLEAR_FLAG: 清除 SD 的挂起标志</p></li></ul><h3 id="sd回调函数的注册">SD回调函数的注册</h3><p>当 USE_HAL_SD_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_SD_RegisterCallback(), HAL_SD_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>ErrorCallback : 发生错误回调函数</li><li>AbortCpltCallback : 中止完成回调函数</li><li>MspInitCallback : SD 相关MCU初始化回调函数</li><li>MspDeInitCallback : SD 相关MCU去初始化回调函数</li></ul><p>默认情况下, SD 初始化（HAL_SD_Init()）后，当状态是 HAL_SD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SD_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Secure Digital,简称SD,SD内存卡是一种使用非常广泛的存储设备，以下来看看HAL库关于SD卡的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;sd外设库的使用&quot;&gt;SD外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用分层的SDIO存储驱动，它使用HAL SDIO驱动函数来连</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sd" scheme="http://example.com/tags/sd/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_mmc库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T09:30:31.000Z</published>
    <updated>2023-08-14T00:03:33.327Z</updated>
    
    <content type="html"><![CDATA[<p>MultiMediaCard,简称MMC,它属于SD卡的一种，是一种一体化、可拆卸、多功能的内存卡,以下来看看HAL库关于MMC的使用方法。</p><h3 id="mmc外设库的使用">MMC外设库的使用</h3><p>这是一个通用分层的MMC存储器驱动，它使用HAL SDMMC 驱动函数来连接MMC和eMMC卡。</p><p><strong>1. 初始化MMC底层。HAL_MMC_MspInit()</strong></p><ul><li>使能MMC接口时钟。__HAL_RCC_SDMMC_CLK_ENABLE()</li><li>配置MMC引脚<ul><li>使能MMC GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置MMC引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_MMC_ReadBlocks_DMA() ， HAL_MMC_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDMMC和DMA中断优先级，DMA优先级高于SDMMC。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code> ， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code> ，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_MMC_ReadBlocks_IT()，HAL_MMC_WriteBlocks_IT()<ul><li>配置SDMMC中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code> ， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code> ，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. MMC的初始化和配置</strong></p><p>使用HAL_MMC_Init()函数来初始化SDMMC，并进入睡眠状态（已准备好数据传输）。MMC卡初始化后，就可以执行MMC 读、写、擦除操作。</p><ul><li><p>使用默认配置初始化SDMMC外设接口。默认频率：400KHz。</p><p>MMC频率：SDMMC_CK = SDMMCCLK / (ClockDiv + 2)；</p><p>初始化时，根据MMC标准，确保SDMMC_CK频率不要超过400KHz，通过SDMMC底层函数 SDMMC_Init()和SDMMC_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化MMC卡。HAL_MMC_InitCard()</p><p>这个函数用于初始化和识别MMC及检查MMC卡的类型（标准容量或高容量），此初始化流程与MMC标准兼容。这个函数也可以在插拔时重新初始化MMC卡。</p></li><li><p>配置MMC卡数据传输频率，默认传输频率是24MHz，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据MMC标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDMMC外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的MMC卡。</p></li><li><p>配置MMC宽总线模式：4位数据。</p></li></ul><p><strong>3. MMC的读操作</strong></p><ul><li><p>轮询模式下读取MMC卡。HAL_MMC_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下读取MMC卡。HAL_MMC_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Rx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取MMC卡。HAL_MMC_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Rx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. MMC的写操作</strong></p><ul><li><p>轮询模式下向MMC卡写操作。HAL_MMC_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下向MMC卡写操作。HAL_MMC_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Tx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向MMC卡写操作。HAL_MMC_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Tx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取MMC卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取MMC卡信息。HAL_MMC_GetCardInfo()</p><p>它会返回关于MMC卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_MMC_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_MMC_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="mmc-hal常用宏定义列表">MMC HAL常用宏定义列表</h3><ul><li><p>__HAL_MMC_ENABLE : 使能 MMC设备</p></li><li><p>__HAL_MMC_DISABLE : 禁止 MMC 设备</p></li><li><p>__HAL_MMC_DMA_ENABLE: 使能 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_DMA_DISABLE: 禁止 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_ENABLE_IT: 使能 MMC 设备中断</p></li><li><p>__HAL_MMC_DISABLE_IT: 禁止 MMC 设备中断</p></li><li><p>__HAL_MMC_GET_FLAG:检查 MMC 标志是否设置</p></li><li><p>__HAL_MMC_CLEAR_FLAG: 清除 MMC 的挂起标志</p></li></ul><h3 id="mmc回调函数的注册">MMC回调函数的注册</h3><p>当 USE_HAL_MMC_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_MMC_RegisterCallback(), HAL_MMC_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>ErrorCallback : 发生错误回调函数</li><li>AbortCpltCallback : 中止完成回调函数</li><li>MspInitCallback : MMC 相关MCU初始化回调函数</li><li>MspDeInitCallback : MMC 相关MCU去初始化回调函数</li></ul><p>默认情况下, MMC 初始化（HAL_MMC_Init()）后，当状态是 HAL_MMC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_MMC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_MMC_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MultiMediaCard,简称MMC,它属于SD卡的一种，是一种一体化、可拆卸、多功能的内存卡,以下来看看HAL库关于MMC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;mmc外设库的使用&quot;&gt;MMC外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用分层的MMC存储器驱动，它使用HA</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="mmc" scheme="http://example.com/tags/mmc/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_nor库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T04:15:11.000Z</published>
    <updated>2023-08-14T00:03:33.347Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于Nor flash存储器的使用方法。</p><h3 id="nor存储器外设库的使用">NOR存储器外设库的使用</h3><p>此驱动是一个通用的分层驱动程序，包含一组用于控制NOR闪存的API。它使用FSMC层函数来连接NOR 闪存。</p><ol type="1"><li><p>配置NOR flash 存储器的控制和时序参数。HAL_NOR_Init()</p></li><li><p>读取NOR flash 存储器制造商和设备ID。HAL_NOR_Read_ID()</p><p>读取的信息存储在函数调用的NOR_ID_TypeDef类型结构体中。</p></li><li><p>对NOR flash存储器进行读写操作。HAL_NOR_Read(), HAL_NOR_Program()</p></li><li><p>执行NOR flash块擦除或芯片擦除操作。 HAL_NOR_Erase_Block() , HAL_NOR_Erase_Chip()</p></li><li><p>读取NOR flash的通用闪存接口ID（CFI IDs）。HAL_NOR_Read_CFI()</p><p>读取的信息存储在被上述函数调用的已声明NOR_CFI_TypeDef结构体中。</p></li><li><p>可分别通过调用 HAL_NOR_WriteOperation_Enable() / HAL_NOR_WriteOperation_Disable()函数来使能/禁止 NOR Flash的写操作，从而控制NOR Flash设备。</p></li><li><p>监测NOR设备状态。 HAL_NOR_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通NOR flash操作APIs。如果NOR flash设备包含不同的操作和方法，应该单独实施。</p><h3 id="nor存储器外设常用宏定义">NOR存储器外设常用宏定义</h3><ul><li>NOR_WRITE : NOR 存储器向指定的地址写入数据。</li></ul><h3 id="nor存储器回调函数的注册">NOR存储器回调函数的注册</h3><p>当 USE_HAL_NOR_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_NOR_RegisterCallback(), HAL_NOR_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : NOR 相关MCU初始化回调函数</li><li>MspDeInitCallback : NOR 相关MCU去初始化回调函数</li></ul><p>默认情况下, NOR 初始化（HAL_NOR_Init()）后，当状态是 HAL_NOR_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_NOR_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_NOR_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于Nor flash存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;nor存储器外设库的使用&quot;&gt;NOR存储器外设库的使用&lt;/h3&gt;
&lt;p&gt;此驱动是一个通用的分层驱动程序，包含一组用于控制NOR闪存的API。它使用FSMC层函数来连接NOR 闪存。&lt;/p&gt;</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="nor" scheme="http://example.com/tags/nor/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_pccard库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-pccard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-pccard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T04:15:11.000Z</published>
    <updated>2023-08-14T00:03:33.356Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于PCCARD存储器的使用方法。</p><h3 id="pccard存储器外设库的使用">PCCARD存储器外设库的使用</h3><p>此驱动是一个通用的分层驱动程序，包含一组用于控制PCCARD/小型闪存的API。它使用FSMC层函数来连接PCCARD存储器。</p><ol type="1"><li><p>配置PCCARD/小型闪存的控制和时序参数。HAL_PCCARD_Init()/HAL_CF_Init()</p></li><li><p>读取PCCARD/小型闪存制造商和设备ID。HAL_PCCARD_Read_ID()/HAL_CF_Read_ID()</p><p>读取的信息存储在函数调用的CompactFlash_ID结构体中。</p></li><li><p>对PCCARD/小型闪存进行扇区读写操作：</p><ul><li><p>HAL_PCCARD_Read_Sector()/ HAL_PCCARD_Write_Sector()</p></li><li><p>HAL_CF_Read_Sector()/HAL_CF_Write_Sector()</p></li></ul></li><li><p>执行PCCARD/小型闪存复位操作。HAL_PCCARD_Reset()/HAL_CF_Reset()</p></li><li><p>执行PCCARD/小型闪存扇区擦除操作。 HAL_PCCARD_Erase_Sector()/HAL_CF_Erase_Sector()</p></li><li><p>读取PCCARD/小型闪存的状态。HAL_PCCARD_ReadStatus()/HAL_CF_ReadStatus()</p></li><li><p>监测PCCARD/小型闪存的状态。 HAL_PCCARD_GetState()/HAL_CF_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通PCCARD/小型闪存操作API。如果PCCARD/小型闪存设备包含不同的操作和方法，应该单独实施。</p><h3 id="pccard存储器回调函数的注册">PCCARD存储器回调函数的注册</h3><p>当 USE_HAL_PCCARD_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_PCCARD_RegisterCallback(), HAL_PCCARD_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : PCCARD 相关MCU初始化回调</li><li>MspDeInitCallback : PCCARD 相关MCU去初始化回调</li></ul><p>默认情况下, PCCARD 初始化（HAL_PCCARD_Init()）后，当状态是 HAL_PCCARD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_PCCARD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_PCCARD_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于PCCARD存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;pccard存储器外设库的使用&quot;&gt;PCCARD存储器外设库的使用&lt;/h3&gt;
&lt;p&gt;此驱动是一个通用的分层驱动程序，包含一组用于控制PCCARD/小型闪存的API。它使用FSMC层函数来连接PC</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="pccard" scheme="http://example.com/tags/pccard/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_nand库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-nand%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-nand%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T14:32:31.000Z</published>
    <updated>2023-08-14T00:03:33.336Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于NAND flash存储器的使用方法。</p><h3 id="nand外设库的使用">NAND外设库的使用</h3><ol type="1"><li><p>配置NAND flash 存储器。HAL_NAND_Init()</p></li><li><p>读取NAND flash 存储器制造商和设备ID。HAL_NAND_Read_ID()</p><p>读取的信息存储在函数调用的NAND_ID_TypeDef类型结构体中。</p></li><li><p>对NAND flash存储器进行读写操作：</p><ul><li>HAL_NAND_Read_Page_8b()/HAL_NAND_Read_SpareArea_8b()</li><li>HAL_NAND_Write_Page_8b()/HAL_NAND_Write_SpareArea_8b()</li><li>HAL_NAND_Read_Page_16b()/HAL_NAND_Read_SpareArea_16b()</li><li>HAL_NAND_Write_Page_16b()/HAL_NAND_Write_SpareArea_16b()</li></ul><p>这些函数使用用户在 NAND_DeviceConfigTypeDef 结构体中预定义的设备信息(块、页面大小等)，结构体中包含读写地址信息。</p></li><li><p>执行NAND flash复位操作。HAL_NAND_Reset()</p></li><li><p>执行NAND flash块擦除操作。HAL_NAND_Erase_Block()</p><p>块擦除信息作为参数传入Nand_Address_Typedef结构体。</p></li><li><p>读取NAND flash的状态操作。HAL_NAND_Read_Status()</p></li><li><p>分别通过调用 HAL_NAND_ECC_Enable() / HAL_NAND_ECC_Disable()函数来使能/禁止 ECC码更正特性，或通过 HAL_NAND_GetECC() 函数获取 ECC更正码，从而控制NAND 设备。</p></li><li><p>监测NAND设备状态。 HAL_NAND_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通NAND flash操作APIs。如果NAND flash设备包含不同的操作和方法，应该单独实施。</p><h3 id="nand回调函数的注册">NAND回调函数的注册</h3><p>当 USE_HAL_NAND_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_NAND_RegisterCallback(), HAL_NAND_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : NAND 相关MCU初始化回调函数</li><li>MspDeInitCallback : NAND 相关MCU去初始化回调函数</li></ul><p>默认情况下, NAND 初始化（HAL_NAND_Init()）后，当状态是 HAL_NAND_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_NAND_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_NAND_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于NAND flash存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;nand外设库的使用&quot;&gt;NAND外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;配置NAND flash 存储器。HAL_NAND_Init()&lt;/p&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="nand" scheme="http://example.com/tags/nand/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_rtc库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-rtc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-rtc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T13:10:31.000Z</published>
    <updated>2023-08-14T00:03:33.377Z</updated>
    
    <content type="html"><![CDATA[<p>Real Time Clock，简称RTC，实时时钟，以下来看看HAL库关于RTC的使用方法。</p><h3 id="rtc外设库的使用">RTC外设库的使用</h3><ol type="1"><li>使能RTC域。</li><li>配置RTC预分频系数(异步预分频器生成RTC 1Hz时基)。 HAL_RTC_Init()</li><li>配置时间和日期。<ul><li>配置RTC日历(时间和日期)。HAL_RTC_SetTime()，HAL_RTC_SetDate()</li><li>读RTC日历。HAL_RTC_GetTime() ，HAL_RTC_GetDate()</li></ul></li><li>闹钟配置。<ul><li>配置RTC闹钟。HAL_RTC_SetAlarm() ，HAL_RTC_SetAlarm_IT()</li><li>读RTC闹钟。HAL_RTC_GetAlarm()</li></ul></li><li>RTC 入侵检测配置。RTC Tamper<ul><li>使能RTC Tamper，配置Tamper电平。HAL_RTCEx_SetTamper()，HAL_RTCEx_SetTamper_IT()</li><li>TAMPER1 复用功能映射到PC13 。</li></ul></li><li>配置备份数据寄存器（Backup Data Registers）<ul><li>向RTC备份数据寄存器写数据。HAL_RTCEx_BKUPWrite()</li><li>读RTC备份数据寄存器。HAL_RTCEx_BKUPRead()</li></ul></li></ol><h3 id="提示-hal-rtc驱动的限制">==提示: HAL RTC驱动的限制==</h3><ul><li>STM32F1系列芯片上的RTC版本是V1，F1系列芯片不支持V2版本（其它系列）的所有特性。</li><li>对于V2版本，RTC主要的特性是通过硬件控制的。但在F1芯片，日期特性完全由软件控制。</li><li>跟其它系列芯片相比，F1系列芯片有一些限制：<ul><li>HAL库只支持24小时格式（不支持12小时）。</li><li>日期保存在SRAM中，当MCU处于停止或待机模式时，日期就会丢失。用户应该在进入低功耗模式之前保存日期。（基于备份寄存器的固件包提供了一个示例）</li><li>每次调用时间和日期函数时，日期就会自动更新。HAL_RTC_GetTime() ，HAL_RTC_GetDate()</li><li>闹钟检测被限制在一天内，它只会过期一次（无重复闹钟，需要编一个新的闹钟）。</li></ul></li></ul><h3 id="备用域操作条件">备用域操作条件</h3><ul><li>当主电源关闭时，可通过VBAT电源来给RTC和RTC备份寄存器供电。当VDD关闭，为了维持RTC备份寄存器的内容和给RTC供电，VBAT引脚连接到一个电池或其它电源的备用电源。</li><li>当主数字电源（VDD）关闭，为了RTC的操作，VBAT引脚需为以下模块供电：<ul><li>RTC</li><li>LSE振荡器</li><li>使能低功耗备用稳压器时的备用SRAM</li><li>PC13 ~ PC15 I/O引脚，加上 PI8引脚 (当可使用时)</li></ul></li><li>当备用域通过VDD（模拟开关连接到VDD）供电，可使用PC13引脚，用作入侵检测引脚。</li><li>当备用域通过VBAT（模拟开关连接到VBAT，因为VDD不存在）供电，可使用PC13引脚，用作入侵检测引脚。</li></ul><h3 id="备用域复位">备用域复位</h3><ul><li>备用域复位将所有的RTC寄存器和RCC_BDCR寄存器设为复位值。</li><li>当发生以下任一事件，就会产生备用域复位：<ul><li>设置RCC备用域控制寄存器（RCC_BDCR）中的BDRST位触发软件复位。</li><li>如果两个供电之前都关闭了，那么VDD或VBAT电压就会打开。</li><li>入侵检测事件复位所有的数据备份寄存器。</li></ul></li></ul><h3 id="访问备用域">访问备用域</h3><ul><li>复位后, 备用域 (RTC寄存器, RTC备份数据寄存器和备份SRAM)就会被保护，不能进行写操作。</li><li>为了访问RTC域和RTC寄存器，可通过以下方式：<ul><li>调用 HAL_RCCEx_PeriphCLKConfig()函数，其中PeriphClockSelection为RCC_PERIPHCLK_RTC，并选择RTCClockSelection (LSE, LSI 或 HSE)。</li><li>使能备用域时钟。__HAL_RCC_BKP_CLK_ENABLE()</li></ul></li></ul><h3 id="rtc和低功耗模式">RTC和低功耗模式</h3><ul><li>通过RTC复用函数可把MCU从低功耗模式中唤醒。</li><li>RTC复用函数是RTC闹钟（闹钟A）和检测RTC入侵事件。这些复用函数可将系统从停止和待机低功耗模式下唤醒。</li><li>系统还可以通过RTC闹钟从低功耗模式下唤醒，而无需依赖外部中断（自动唤醒模式）</li></ul><h3 id="rtc回调函数的注册">RTC回调函数的注册</h3><p>当 USE_HAL_RTC_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_RTC_RegisterCallback(), HAL_RTC_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>AlarmAEventCallback : RTC闹钟A 事件回调函数</p></li><li><p>Tamper1EventCallback : RTC入侵检测1事件回调函数</p></li><li><p>MspInitCallback : RTC相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : RTC相关MCU去初始化回调函数</p></li></ul><p>默认情况下, RTC 初始化（HAL_RTC_Init()）后，当状态是 HAL_RTC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_RTC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_RTC_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Real Time Clock，简称RTC，实时时钟，以下来看看HAL库关于RTC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;rtc外设库的使用&quot;&gt;RTC外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;使能RTC域。&lt;/li&gt;
&lt;li&gt;配置RTC预分频系数(异</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="rtc" scheme="http://example.com/tags/rtc/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_spi库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-spi%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-spi%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:50:31.000Z</published>
    <updated>2023-08-14T00:03:33.426Z</updated>
    
    <content type="html"><![CDATA[<p>Serial Peripheral Interface，简称SPI，串行外设接口。以下来看看HAL库关于SPI的使用方法。</p><h3 id="spi外设库的使用">SPI外设库的使用</h3><ol type="1"><li><p>声明一个 SPI_HandleTypeDef 结构体,如：SPI_HandleTypeDef hspi;</p></li><li><p>初始化SPI底层。HAL_SPI_MspInit()</p></li></ol><ul><li>使能SPIx 接口时钟。</li><li>配置SPI引脚<ul><li>使能SPI GPIO 时钟</li><li>配置SPI引脚为复用推挽模式</li></ul></li><li>如果使用到中断，则配置NVIC。<ul><li>配置SPIx 中断优先级</li><li>使能NVIC SPI IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体参数。</li><li>配置DMA Tx或Rx通道。</li><li>将hdma_tx 或hdma_rx 跟 hspi DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置hspi初始化结构体中各参数。</li><li>调用 HAL_SPI_Init() 函数初始化 SPI寄存器。</li></ol><h3 id="循环模式规则">循环模式规则</h3><ul><li>当SPI配置在以下模式时，就不能使用DMA循环模式：<ul><li>主机2线只接收 (Master 2Lines RxOnly)</li><li>主机1线接收 (Master 1Line Rx)</li></ul></li><li>当使能DMA循环模式时，就不能使用CRC功能。</li><li>当使用了SPI DMA 暂停/停止功能时，必须只能在SPI回调函数中使用HAL_SPI_DMAPause()/ HAL_SPI_DMAStop()函数。</li></ul><h3 id="主机接收模式规则">主机接收模式规则</h3><p>在主机单向接收模式 (MSTR =1, BIDIMODE=0, RXONLY=1) 或 双向接收模式(MSTR=1, BIDIMODE=1, BIDIOE=0)，为了确保SPI没有发起新的数据传输，需要重视以下函数：</p><ul><li><p>HAL_SPI_DeInit()</p></li><li><p>HAL_SPI_Init()</p></li></ul><h3 id="spi回调函数的注册">SPI回调函数的注册</h3><p>当 USE_HAL_SPI_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_SPI_RegisterCallback(), HAL_SPI_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxCpltCallback : SPI 发送完成回调函数</p></li><li><p>RxCpltCallback : SPI 接收完成回调函数</p></li><li><p>TxRxCpltCallback : SPI 发送接收完成回调函数</p></li><li><p>TxHalfCpltCallback : SPI 发送过半回调函数</p></li><li><p>RxHalfCpltCallback : SPI 接收过半回调函数</p></li><li><p>TxRxHalfCpltCallback : SPI 发送接收过半回调函数</p></li><li><p>ErrorCallback : SPI 错误回调函数</p></li><li><p>AbortCpltCallback : SPI 中止回调函数</p></li><li><p>MspInitCallback : SPI 相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : SPI 相关MCU去初始化回调函数</p></li></ul><p>默认情况下, SPI 初始化（HAL_SPI_Init()）后，当状态是 HAL_SPI_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SPI_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SPI_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Serial Peripheral Interface，简称SPI，串行外设接口。以下来看看HAL库关于SPI的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;spi外设库的使用&quot;&gt;SPI外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;声明一个 SPI_Hand</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="spi" scheme="http://example.com/tags/spi/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_smartcard库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-smartcard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-smartcard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:32:31.000Z</published>
    <updated>2023-08-14T00:03:33.416Z</updated>
    
    <content type="html"><![CDATA[<p>Smart Card，智能卡，以下来看看HAL库关于SMARTCARD的使用方法。</p><h3 id="smartcard外设库的使用">SMARTCARD外设库的使用</h3><ol type="1"><li><p>声明一个 SMARTCARD_HandleTypeDef 结构体。</p></li><li><p>初始化SMARTCARD底层。HAL_SMARTCARD_MSMARTCARDnit()</p></li></ol><ul><li>使能SMARTCARDx关联到USARTx 的接口时钟。</li><li>配置SMARTCARD引脚<ul><li>使能SMARTCARD GPIO 时钟</li><li>配置SMARTCARD引脚为复用上拉模式</li></ul></li><li>如果使用到中断（HAL_SMARTCARD_Transmit_IT()，HAL_SMARTCARD_Receive_IT() ），则配置NVIC。<ul><li>配置USARTx中断优先级</li><li>使能NVIC USART IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_SMARTCARD_Transmit_DMA()，HAL_SMARTCARD_Receive_DMA()<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体Tx/Rx参数。</li><li>配置DMA Tx或Rx通道。</li><li>将DMA 跟 SMARTCARD DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置SMARTCARD初始化结构体中各参数。</li><li>调用 HAL_SMARTCARD_Init() 函数初始化 SMARTCARD寄存器。</li></ol><p>在发送和接收过程中，使用宏定义 __HAL_SMARTCARD_ENABLE_IT() 和 __HAL_SMARTCARD_DISABLE_IT() 来管理SMARTCARD 的中断(发送完成中断，接收非空中断，错误中断)。</p><h3 id="smartcard轮询模式io操作">SMARTCARD轮询模式IO操作</h3><ul><li>阻塞方式下，发送一定数量的数据。HAL_SMARTCARD_Transmit()</li><li>阻塞方式下，接收一定数量的数据。HAL_SMARTCARD_Receive()</li></ul><h3 id="smartcard中断模式io操作">SMARTCARD中断模式IO操作</h3><ul><li><p>非阻塞方式下，发送一定数量的数据。HAL_SMARTCARD_Transmit_IT()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_SMARTCARD_TxCpltCallback()</p></li><li><p>非阻塞方式下，接收一定数量的数据。HAL_SMARTCARD_Receive_IT()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_SMARTCARD_RxCpltCallback()</p></li><li><p>传输出错时，执行出错回调函数，用户自行添加代码。HAL_SMARTCARD_ErrorCallback()</p></li></ul><h3 id="smartcard-dma-模式io操作">SMARTCARD DMA 模式IO操作</h3><ul><li><p>非阻塞方式(DMA)下，发送一定数量的数据。HAL_SMARTCARD_Transmit_DMA()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_SMARTCARD_TxCpltCallback()</p></li><li><p>非阻塞方式(DMA)下，接收一定数量的数据。HAL_SMARTCARD_Receive_DMA()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_SMARTCARD_RxCpltCallback()</p></li><li><p>传输出错时，执行出错回调函数，用户自行添加代码。HAL_SMARTCARD_ErrorCallback()</p></li></ul><h3 id="smartcard-常用宏定义">SMARTCARD 常用宏定义</h3><ul><li><p>__HAL_SMARTCARD_ENABLE: 使能SMARTCARD 外设</p></li><li><p>__HAL_SMARTCARD_DISABLE: 禁止SMARTCARD 外设</p></li><li><p>__HAL_SMARTCARD_GET_FLAG : 检查SMARTCARD 标志是否设置</p></li><li><p>__HAL_SMARTCARD_CLEAR_FLAG : 清除 SMARTCARD 挂起标志</p></li><li><p>__HAL_SMARTCARD_ENABLE_IT: 使能 SMARTCARD 中断</p></li><li><p>__HAL_SMARTCARD_DISABLE_IT: 禁止 SMARTCARD 中断</p></li></ul><h3 id="smartcard回调函数的注册">SMARTCARD回调函数的注册</h3><p>当 USE_HAL_SMARTCARD_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_SMARTCARD_RegisterCallback(), HAL_SMARTCARD_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxCpltCallback : 发送完成回调函数</p></li><li><p>RxCpltCallback : 接收完成回调函数</p></li><li><p>ErrorCallback : 错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>AbortTransmitCpltCallback : 中止发送完成回调函数</p></li><li><p>AbortReceiveCpltCallback : 中止接收完成回调函数</p></li><li><p>MspInitCallback : SMARTCARD 相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : SMARTCARD 相关MCU去初始化回调函数</p></li></ul><p>默认情况下, SMARTCARD 初始化（HAL_SMARTCARD_Init()）后，当状态是 HAL_SMARTCARD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SMARTCARD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SMARTCARD_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Smart Card，智能卡，以下来看看HAL库关于SMARTCARD的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;smartcard外设库的使用&quot;&gt;SMARTCARD外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;声明一个 SMARTCARD_Handle</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="smartcard" scheme="http://example.com/tags/smartcard/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_tim库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-tim%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-tim%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:20:30.000Z</published>
    <updated>2023-08-14T00:03:33.496Z</updated>
    
    <content type="html"><![CDATA[<p>timer, 简称TIM，定时器是MCU控制中使用最广泛的外设，STM32中有多个TIM，下面来看看HAL库关于TIM的介绍和使用方法。</p><h3 id="tim外设库的一般特性">TIM外设库的一般特性</h3><ul><li>16位向上，向下，向上向下自动重装载计数器</li><li>16位可编程预分频系数，允许对计数器时钟进行 1 ~ 65536 的分频。</li><li>多达4各独立的通道：<ul><li>输入捕获 Input Capture</li><li>输出比较 Output Compare</li><li>产生PWM（边沿和中心对齐模式）</li><li>单脉冲模式输出 One-pulse mode output</li></ul></li><li>用外部信号的同步电路来控制定时器，并将多个定时器互连在一起。</li><li>支持增量编码器的定位目的</li></ul><h3 id="tim外设库的使用">TIM外设库的使用</h3><ol type="1"><li><p>根据所选的功能特性，初始化TIM底层：</p><ul><li>Time Base : HAL_TIM_Base_MspInit()</li><li>Input Capture : HAL_TIM_IC_MspInit()</li><li>Output Compare : HAL_TIM_OC_MspInit()</li><li>PWM generation : HAL_TIM_PWM_MspInit()</li><li>One-pulse mode output : HAL_TIM_OnePulse_MspInit()</li><li>Encoder mode output : HAL_TIM_Encoder_MspInit()</li><li>Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()</li></ul></li><li><p>使能TIM接口时钟。__HAL_RCC_TIMx_CLK_ENABLE()</p></li><li><p>配置TIM引脚。</p><ul><li>使能TIM GPIOs时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置TIM引脚复用功能。HAL_GPIO_Init()</li></ul></li><li><p>默认时钟是来自APBx的内部时钟，如果有需要，可配置外部时钟。HAL_TIM_ConfigClockSource()</p><p>该配置需在任何启动函数之前完成。</p></li><li><p>在所需的功能模式下配置TIM：</p><ul><li><p>使用定时器产生时基（time base）。HAL_TIM_Base_Init()</p></li><li><p>使用定时器产生输出比较信号。 HAL_TIM_OC_Init() , HAL_TIM_OC_ConfigChannel()</p></li><li><p>使用定时器产生PWM信号。HAL_TIM_PWM_Init() , HAL_TIM_PWM_ConfigChannel()</p></li><li><p>使用定时器测量外部信号。HAL_TIM_IC_Init() , HAL_TIM_IC_ConfigChannel()</p></li><li><p>单脉冲模式下使用定时器。HAL_TIM_OnePulse_Init() , HAL_TIM_OnePulse_ConfigChannel()</p></li><li><p>使用定时器编码接口。HAL_TIM_Encoder_Init()</p></li><li><p>使用定时器 Hall Sensor接口，如果有需要中断和DMA请求，则配置通信事件。HAL_TIMEx_HallSensor_Init() ， HAL_TIMEx_ConfigCommutEvent()</p><p><strong>注意</strong>：一个定时器用于与Hall sensor接口连接，另一个定时器用于通信事件。</p></li></ul></li><li><p>根据功能特性开启TIM外设：</p><ul><li>Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()</li><li>Input Capture : HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()</li><li>Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()</li><li>PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()</li><li>One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()</li><li>Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT()</li><li>Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OCN_Start_IT()</li><li>Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()</li><li>Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()</li><li>Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().</li></ul></li><li><p>管理控制DMA Busrt功能。HAL_TIM_DMABurst_WriteStart()， HAL_TIM_DMABurst_ReadStart()</p></li></ol><h3 id="tim回调函数的注册">TIM回调函数的注册</h3><p>当 USE_HAL_TIM_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_TIM_RegisterCallback(), HAL_TIM_UnRegisterCallback()</p><p>回调函数：</p><ul><li>Base_MspDeInitCallback : TIM 时基相关MCU去初始化回调函数</li><li>IC_MspInitCallback : TIM 输入捕获相关MCU初始化回调函数</li><li>IC_MspDeInitCallback : TIM 输入捕获相关MCU去初始化回调函数</li><li>OC_MspInitCallback : TIM 输出比较相关MCU初始化回调函数</li><li>OC_MspDeInitCallback : TIM 输出比较相关MCU去初始化回调函数</li><li>PWM_MspInitCallback : TIM PWM 相关MCU初始化回调函数</li><li>PWM_MspDeInitCallback : TIM PWM 相关MCU去初始化回调函数</li><li>OnePulse_MspInitCallback : TIM 单脉冲相关MCU初始化回调函数</li><li>OnePulse_MspDeInitCallback : TIM 单脉冲相关MCU去初始化回调函数</li><li>Encoder_MspInitCallback : TIM 编码器相关MCU初始化回调函数</li><li>Encoder_MspDeInitCallback : TIM 编码器相关MCU去初始化回调函数</li><li>HallSensor_MspInitCallback : TIM Hall Sensor 相关MCU初始化回调函数</li><li>HallSensor_MspDeInitCallback : TIM Hall Sensor 相关MCU去初始化回调函数</li><li>PeriodElapsedCallback : TIM 周期时间结束回调函数</li><li>PeriodElapsedHalfCpltCallback : TIM 半周期时间结束回调函数</li><li>TriggerCallback : TIM 触发回调函数</li><li>TriggerHalfCpltCallback : TIM 半触发回调函数</li><li>IC_CaptureCallback : TIM 输入捕获回调函数</li><li>IC_CaptureHalfCpltCallback : TIM 半输入捕获回调函数</li><li>OC_DelayElapsedCallback : TIM 输出比较延时回调函数</li><li>PWM_PulseFinishedCallback : TIM PWM 脉冲结束回调函数</li><li>PWM_PulseFinishedHalfCpltCallback : TIM PWM 半脉冲结束回调函数</li><li>ErrorCallback : TIM 错误回调函数</li><li>CommutationCallback : TIM 通信回调函数</li><li>CommutationHalfCpltCallback : TIM 半通信回调函数</li><li>BreakCallback : TIM 打断回调函数</li></ul><p>默认情况下, TIM初始化（HAL_TIM_Init()）后，当状态是 HAL_TIM_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_TIM_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_TIM_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;timer, 简称TIM，定时器是MCU控制中使用最广泛的外设，STM32中有多个TIM，下面来看看HAL库关于TIM的介绍和使用方法。&lt;/p&gt;
&lt;h3 id=&quot;tim外设库的一般特性&quot;&gt;TIM外设库的一般特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;16位向上，向下，向上向下自</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="tim" scheme="http://example.com/tags/tim/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_sram库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-sram%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-sram%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T11:20:30.000Z</published>
    <updated>2023-08-14T00:03:33.439Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于SRAM 内存的使用方法。</p><h3 id="sram外设库的使用">SRAM外设库的使用</h3><p>这是一个通用的分层驱动，包含一套控制SRAM内存的API。它使用FSMC层函数与SRAM设备进行连接。要配置FSMC与SRAM/PSRAM的连接，应遵循以下顺序：</p><ol type="1"><li><p>声明一个SRAM_HandleTypeDef类型结构体。如：SRAM_HandleTypeDef hsram;</p><ul><li>对SRAM_HandleTypeDef 句柄中“Init”中成员赋值。</li><li>对SRAM_HandleTypeDef 句柄中“Instance”填入预先定义的NOR或SRAM设备基地址寄存器实例。</li><li>对SRAM_HandleTypeDef 句柄中“Extended”填入预先定义的NOR或SRAM扩展模式基地址寄存器实例。</li></ul></li><li><p>为正常模式和扩展模式声明两个 FSMC_NORSRAM_TimingTypeDef 类型结构体，并进行赋值。如：</p><p>​ FSMC_NORSRAM_TimingTypeDef Timing ， FSMC_NORSRAM_TimingTypeDef ExTiming;</p></li><li><p>初始化 SRAM 控制器。HAL_SRAM_Init()</p><ul><li>配置底层硬件。HAL_SRAM_MspInit()</li><li>使用 FSMC NORSRAM 接口配置控制寄存器。FSMC_NORSRAM_Init()</li><li>使用 FSMC NORSRAM 接口配置时序寄存器。FSMC_NORSRAM_Timing_Init()</li><li>使用 FSMC NORSRAM 接口配置扩展模式时序寄存器。FSMC_NORSRAM_Extended_Timing_Init()</li><li>使能SRAM设备。__FSMC_NORSRAM_ENABLE()</li></ul></li><li><p>在这个阶段，你就可以执行内存与NOR/SRAM Bank之间的读、写操作。</p><ul><li>轮询模式下的读写：HAL_SRAM_Read()/HAL_SRAM_Write()</li><li>DMA模式下的读写：HAL_SRAM_Read_DMA()/HAL_SRAM_Write_DMA()</li></ul></li><li><p>你也可以通过调用HAL_SRAM_WriteOperation_Enable() / HAL_SRAM_WriteOperation_Disable() 函数来控制SRAM设备的写操作。</p></li><li><p>你可以持续监测SRAM设备的状态。HAL_SRAM_GetState()</p></li></ol><h3 id="sram回调函数的注册">SRAM回调函数的注册</h3><p>当 USE_HAL_SRAM_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_SRAM_RegisterCallback(), HAL_SRAM_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : SRAM 相关MCU初始化回调函数</li><li>MspDeInitCallback : SRAM 相关MCU去初始化回调函数</li></ul><p>默认情况下, SRAM 初始化（HAL_SRAM_Init()）后，当状态是 HAL_SRAM_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SRAM_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SRAM_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于SRAM 内存的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;sram外设库的使用&quot;&gt;SRAM外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用的分层驱动，包含一套控制SRAM内存的API。它使用FSMC层函数与SRAM设备进行连接。要配置FSMC与SRAM/PSR</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sram" scheme="http://example.com/tags/sram/"/>
    
  </entry>
  
</feed>
