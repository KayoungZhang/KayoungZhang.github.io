<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-09T10:28:31.721Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>stm32 sct分散加载文件详解</title>
    <link href="http://example.com/2023/08/09/stm32-sct%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/09/stm32-sct%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-09T10:28:31.000Z</published>
    <updated>2023-08-09T10:28:31.721Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>stm32 map文件详解</title>
    <link href="http://example.com/2023/08/09/stm32-map%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/09/stm32-map%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-09T10:25:35.000Z</published>
    <updated>2023-08-09T14:34:18.709Z</updated>
    
    <content type="html"><![CDATA[<p>MDK-ARM在编译时会生成很多类型的中间文件，最终通过这些中间文件生成可下载到MCU的hex文件。.map文件就是其中编译器链接时生成的一个文件，主要包含了交叉链接信息。</p><p>通过 .map文件，可以知晓工程中函数的大小，入口地址，变量、调用关系、FLASH 和 RAM占用空间大小等信息，根据这些信息，可以对代码进行优化。</p><p>要生成 .map 文件，需要在keil软件中进行如下相应设置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809191148933.png" alt="image-20230809191148933" style="zoom: 80%;" /></p><p>为了更好的分析 map 文件，需要了解一些基础概念：</p><ul><li>Section：描述映像文件的代码或数据块，我们简称程序段</li><li>RO：包括只读数据（RO data）和代码（RO code）两部分内容，占用 FLASH空间</li><li>RW：包含可读写数据（RW data，有初值，且不为 0），占用FLASH（存储初值）和 RAM（读写操作）</li><li>ZI：Zero initialized 的缩写，包含初始化为 0 的数据（ZI data），占用RAM 空间。</li><li>.text：相当于 RO code</li><li>.constdata：相当于 RO data</li><li>.bss：相当于 ZI data</li><li>.data：相当于 RW data</li></ul><p>使用notepad打开map文件，会发现map文件主要有 5 个组成部分：</p><ul><li><strong>程序段交叉引用关系（Section Cross References）</strong></li><li><strong>删除映像未使用的程序段（Removing Unused input sections fromthe image）</strong></li><li><strong>映像符号表（Image Symbol Table）</strong></li><li><strong>映像内存分布图（Memory Map of the image）</strong></li><li><strong>映像组件大小（Image component sizes）</strong></li></ul><p>下面分别进行介绍：</p><h4id="程序段交叉引用关系section-cross-references">1.程序段交叉引用关系（SectionCross References）</h4><p>这部分内容描述了各个文件（.c/.s等）之间函数（程序段）的调用关系。</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 1.程序段交叉引用关系</span><span class="hljs-comment"> * .o文件是.c源文件生成的中间文件，括号内是文件或函数入口地址，每句末尾表示被调用的函数或内容</span><span class="hljs-comment"> */</span>Section Cross References     startup_stm32f103xe.o(RESET) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    startup_stm32f103xe.o(RESET) refers to startup_stm32f103xe.o(.text) <span class="hljs-keyword">for</span> Reset_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.NMI_Handler) <span class="hljs-keyword">for</span> NMI_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.HardFault_Handler) <span class="hljs-keyword">for</span> HardFault_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.MemManage_Handler) <span class="hljs-keyword">for</span> MemManage_Handler    省略......    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash_ex.o(i.FLASH_OB_RDP_LevelConfig) <span class="hljs-keyword">for</span> FLASH_OB_RDP_LevelConfig    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash.o(i.FLASH_WaitForLastOperation) <span class="hljs-keyword">for</span> FLASH_WaitForLastOperation    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash.o(.bss) <span class="hljs-keyword">for</span> pFlash    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry10a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>D) <span class="hljs-keyword">for</span> __rt_final_cpp    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry11a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>F) <span class="hljs-keyword">for</span> __rt_final_exit    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry7b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000008</span>) <span class="hljs-keyword">for</span> _main_clock    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry8b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>A) <span class="hljs-keyword">for</span> _main_cpp_init    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry9a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>B) <span class="hljs-keyword">for</span> _main_init    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) <span class="hljs-keyword">for</span> _main_scatterload    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000001</span>) <span class="hljs-keyword">for</span> _main_stk    entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000001</span>) refers to entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00002712</span>) <span class="hljs-keyword">for</span> __lit__00000000    entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00002712</span>) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    entry2.o(__vectab_stack_and_reset_area) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    entry2.o(__vectab_stack_and_reset_area) refers to entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) <span class="hljs-keyword">for</span> __main    entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) refers to init.o(.text) <span class="hljs-keyword">for</span> __scatterload    entry9a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>B) refers to main.o(i.main) <span class="hljs-keyword">for</span> main    entry9b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>C) refers to main.o(i.main) <span class="hljs-keyword">for</span> main    init.o(.text) refers to entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) <span class="hljs-keyword">for</span> __main_after_scatterload</code></pre></div><h4id="删除映像未使用的程序段removing-unused-input-sections-from-the-image">2.删除映像未使用的程序段（RemovingUnused input sections from the image）</h4><p>这部分内容描述了工程中由于未被调用而被删除的冗余程序段（函数/数据）。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 2. 删除映像未使用的程序段</span><span class="hljs-comment"> * 每行显示删除的文件，位置及大小</span><span class="hljs-comment"> * 这部分最末显示删除的汇总信息。</span><span class="hljs-comment"> */</span>Removing Unused <span class="hljs-selector-tag">input</span> sections from the image.    Removing startup_stm32f103xe<span class="hljs-selector-class">.o</span>(HEAP), (<span class="hljs-number">512</span> bytes).    Removing <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>(.rev16_text), (<span class="hljs-number">4</span> bytes).    Removing <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>(.revsh_text), (<span class="hljs-number">4</span> bytes).    省略......    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_ClearConfigLine), (<span class="hljs-number">104</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_ClearPending), (<span class="hljs-number">20</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GenerateSWI), (<span class="hljs-number">20</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetConfigLine), (<span class="hljs-number">140</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetHandle), (<span class="hljs-number">12</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetPending), (<span class="hljs-number">24</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_IRQHandler), (<span class="hljs-number">36</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_RegisterCallback), (<span class="hljs-number">14</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_SetConfigLine), (<span class="hljs-number">164</span> bytes).<span class="hljs-number">226</span> unused <span class="hljs-selector-tag">section</span>(s) (total <span class="hljs-number">11022</span> bytes) removed from the image.</code></pre></div><h4 id="映像符号表image-symbol-table">3.映像符号表（Image SymbolTable）</h4><p>映像符号表（Image SymbolTable）描述了被引用的各个符号（程序段/数据）在存储器中的存储地址、类型、大小等信息。映像符号表分为两类：本地符号（LocalSymbols）和全局符号（Global Symbols）。</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 3. 映像符号表</span><span class="hljs-comment"> * 映像符号包括Local Symbols（本地符号）和Global Symbols（全局符号）</span><span class="hljs-comment"> * 每行描述映像符号的名称、地址、类型、大小及生成目标。</span><span class="hljs-comment"> */</span>Image Symbol Table    Local Symbols    Symbol Name                              Value     Ov Type        Size  <span class="hljs-built_in">Object</span>(Section)    ../Core/Src/dma<span class="hljs-selector-class">.c</span>                        <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  dma<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/gpio<span class="hljs-selector-class">.c</span>                       <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  gpio<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>                       <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/stm32f1xx_hal_msp<span class="hljs-selector-class">.c</span>          <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_msp<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/stm32f1xx_it<span class="hljs-selector-class">.c</span>               <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_it<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/system_stm32f1xx<span class="hljs-selector-class">.c</span>           <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  system_stm32f1xx<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/usart<span class="hljs-selector-class">.c</span>                      <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  usart<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_cortex<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_cortex<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_dma<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_dma<span class="hljs-selector-class">.o</span> ABSOLUTE    省略......    Global Symbols    Symbol Name                              Value     Ov Type        Size  <span class="hljs-built_in">Object</span>(Section)    BuildAttributes$<span class="hljs-variable">$THM_ISAv4</span><span class="hljs-variable">$P</span><span class="hljs-variable">$D</span><span class="hljs-variable">$K</span><span class="hljs-variable">$B</span><span class="hljs-variable">$S</span><span class="hljs-variable">$PE</span><span class="hljs-variable">$A</span>:L22UL41UL21<span class="hljs-variable">$X</span>:L11<span class="hljs-variable">$S22US41US21</span><span class="hljs-variable">$IEEE1</span><span class="hljs-variable">$IW</span><span class="hljs-variable">$USESV6</span>$~STKCKD<span class="hljs-variable">$USESV7</span>$~SHL<span class="hljs-variable">$OSPACE</span><span class="hljs-variable">$EBA8</span><span class="hljs-variable">$MICROLIB</span><span class="hljs-variable">$REQ8</span><span class="hljs-variable">$PRES8</span><span class="hljs-variable">$EABIv2</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  anon$<span class="hljs-variable">$obj</span><span class="hljs-selector-class">.o</span> ABSOLUTE    __ARM_use_no_argv                        <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> ABSOLUTE    __cpp_initialize__aeabi_                  - Undefined Weak Reference    __cxa_finalize                            - Undefined Weak Reference    __decompress                              - Undefined Weak Reference    _clock_init                               - Undefined Weak Reference    _microlib_exit                            - Undefined Weak Reference    __Vectors_Size                           <span class="hljs-number">0</span>x00000130   Number         <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span> ABSOLUTE    __Vectors                                <span class="hljs-number">0</span>x08000000   Data           <span class="hljs-number">4</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(RESET)    __Vectors_End                            <span class="hljs-number">0</span>x08000130   Data           <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(RESET)    __main                                   <span class="hljs-number">0</span>x08000131   Thumb Code     <span class="hljs-number">0</span>  entry<span class="hljs-selector-class">.o</span>(<span class="hljs-selector-class">.ARM</span>.Collect$$$$<span class="hljs-number">00000000</span>)    _main_stk                                <span class="hljs-number">0</span>x08000131   Thumb Code     <span class="hljs-number">0</span>  entry2<span class="hljs-selector-class">.o</span>(<span class="hljs-selector-class">.ARM</span>.Collect$$$$<span class="hljs-number">00000001</span>)    省略......    SystemCoreClock                          <span class="hljs-number">0</span>x20000030   Data           <span class="hljs-number">4</span>  system_stm32f1xx<span class="hljs-selector-class">.o</span>(.data)    uwTickFreq                               <span class="hljs-number">0</span>x20000034   Data           <span class="hljs-number">1</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    uwTickPrio                               <span class="hljs-number">0</span>x20000038   Data           <span class="hljs-number">4</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    uwTick                                   <span class="hljs-number">0</span>x2000003c   Data           <span class="hljs-number">4</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    huart1                                   <span class="hljs-number">0</span>x20000040   Data          <span class="hljs-number">72</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    hdma_usart1_rx                           <span class="hljs-number">0</span>x20000088   Data          <span class="hljs-number">68</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    hdma_usart1_tx                           <span class="hljs-number">0</span>x200000cc   Data          <span class="hljs-number">68</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    __initial_sp                             <span class="hljs-number">0</span>x20000510   Data           <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(STACK)</code></pre></div><h4 id="映像内存分布图memory-map-of-the-image">4.映像内存分布图（MemoryMap of the image）</h4><p>映像文件分为加载域（Load Region）和运行域（ExecutionRegion），一个加载域必须有至少一个运行域（可以有多个运行域），而一个程序又可以有多个加载域。加载域为映像程序的实际存储区域，而运行域则是MCU上电后的运行状态。加载域和运行域的简化关系（这里仅表示一个加载域的情况）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809213411201.png" alt="image-20230809213411201" style="zoom:80%;" /></p><div class="code-wrapper"><pre><code class="hljs dns">/* * <span class="hljs-number">4</span>. 映像内存分布图 * 映像文件分为加载域（Load Region）和运行域（Execution Region）。 */Memory Map of the image  /* 映象入口地址 */  Image Entry point : <span class="hljs-number">0x08000131</span>     /* LR_IROM1加载域地址及大小 */  Load Region LR_IROM1 (Base: <span class="hljs-number">0x08000000</span>, Size: <span class="hljs-number">0</span>x<span class="hljs-number">000017c8</span>, Max: <span class="hljs-number">0x00080000</span>, ABSOLUTE)     /* ER_IROM1运行域地址及大小 */  Execution Region ER_IROM1 (Base: <span class="hljs-number">0x08000000</span>, Size: <span class="hljs-number">0x00001788</span>, Max: <span class="hljs-number">0x00080000</span>, ABSOLUTE)     Base Addr    Size         Type   Attr      Idx    E Section Name        Object    <span class="hljs-number">0x08000000</span>   <span class="hljs-number">0x00000130</span>   Data   RO            <span class="hljs-number">3</span>    RESET               startup_stm32f103xe.o    <span class="hljs-number">0x08000130</span>   <span class="hljs-number">0x00000000</span>   Code   RO         <span class="hljs-number">1809</span>  * .ARM.Collect$$$$<span class="hljs-number">00000000</span>  mc_w.l(entry.o)    <span class="hljs-number">0x08000130</span>   <span class="hljs-number">0x00000004</span>   Code   RO         <span class="hljs-number">1816</span>    .ARM.Collect$$$$<span class="hljs-number">00000001</span>  mc_w.l(entry2.o)    <span class="hljs-number">0x08000134</span>   <span class="hljs-number">0x00000004</span>   Code   RO         <span class="hljs-number">1819</span>    .ARM.Collect$$$$<span class="hljs-number">00000004</span>  mc_w.l(entry5.o)    省略......    <span class="hljs-number">0x08001708</span>   <span class="hljs-number">0x00000034</span>   Code   RO           <span class="hljs-number">15</span>    i.main              main.o    <span class="hljs-number">0</span>x0800173c   <span class="hljs-number">0x00000010</span>   Data   RO          <span class="hljs-number">364</span>    .constdata          system_stm32f1xx.o    <span class="hljs-number">0</span>x0800174c   <span class="hljs-number">0x00000008</span>   Data   RO          <span class="hljs-number">365</span>    .constdata          system_stm32f1xx.o    <span class="hljs-number">0x08001754</span>   <span class="hljs-number">0x00000012</span>   Data   RO         <span class="hljs-number">1023</span>    .constdata          stm32f1xx_hal_rcc.o    <span class="hljs-number">0x08001766</span>   <span class="hljs-number">0x00000002</span>   PAD    <span class="hljs-number">0x08001768</span>   <span class="hljs-number">0x00000020</span>   Data   RO         <span class="hljs-number">1832</span>    Region$$Table       anon$$obj.o    /* RW_IRAM1运行域，地址，大小 */    Execution Region RW_IRAM1 (Base: <span class="hljs-number">0x20000000</span>, Size: <span class="hljs-number">0x00000510</span>, Max: <span class="hljs-number">0x00010000</span>, ABSOLUTE)     Base Addr    Size         Type   Attr      Idx    E Section Name        Object    <span class="hljs-number">0x20000000</span>   <span class="hljs-number">0</span>x0000002f   Data   RW           <span class="hljs-number">16</span>    .data               main.o    <span class="hljs-number">0</span>x2000002f   <span class="hljs-number">0x00000001</span>   PAD    <span class="hljs-number">0x20000030</span>   <span class="hljs-number">0x00000004</span>   Data   RW          <span class="hljs-number">366</span>    .data               system_stm32f1xx.o    <span class="hljs-number">0x20000034</span>   <span class="hljs-number">0</span>x0000000c   Data   RW          <span class="hljs-number">860</span>    .data               stm32f1xx_hal.o    <span class="hljs-number">0x20000040</span>   <span class="hljs-number">0</span>x<span class="hljs-number">000000d0</span>   Zero   RW          <span class="hljs-number">200</span>    .bss                usart.o    <span class="hljs-number">0x20000110</span>   <span class="hljs-number">0x00000400</span>   Zero   RW            <span class="hljs-number">1</span>    STACK               startup_stm32f103xe.o</code></pre></div><h4 id="映像组件大小image-component-sizes">5.映像组件大小（Imagecomponent sizes）</h4><p>各文件编译后所占代码空间的大小，keilIDE编译后输出框显示的文件占用空间大小与此部分一致。</p><div class="code-wrapper"><pre><code class="hljs tap">/* * 5. 映像组件大小 * 文件编译后所占代码空间的大小。 */Image component sizes/* 代码大小(内联函数大小) 只读大小  读写大小  零初始化大小  调试大小  文件名 */      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name       <span class="hljs-number"> 60 </span>        <span class="hljs-number"> 4 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 682 </span>  dma.o       <span class="hljs-number"> 28 </span>        <span class="hljs-number"> 6 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 663 </span>  gpio.o      <span class="hljs-number"> 150 </span>       <span class="hljs-number"> 10 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 47 </span>        <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 455148 </span>  main.o       <span class="hljs-number"> 36 </span>        <span class="hljs-number"> 8 </span>      <span class="hljs-number"> 304 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1024 </span>      <span class="hljs-number"> 760 </span>  startup_stm32f103xe.o      <span class="hljs-number"> 164 </span>       <span class="hljs-number"> 28 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 12 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 6105 </span>  stm32f1xx_hal.o      <span class="hljs-number"> 198 </span>       <span class="hljs-number"> 14 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 28331 </span>  stm32f1xx_hal_cortex.o     <span class="hljs-number"> 1236 </span>       <span class="hljs-number"> 52 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4358 </span>  stm32f1xx_hal_dma.o      <span class="hljs-number"> 504 </span>       <span class="hljs-number"> 42 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1928 </span>  stm32f1xx_hal_gpio.o       <span class="hljs-number"> 60 </span>        <span class="hljs-number"> 8 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 786 </span>  stm32f1xx_hal_msp.o     <span class="hljs-number"> 1240 </span>       <span class="hljs-number"> 84 </span>       <span class="hljs-number"> 18 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4604 </span>  stm32f1xx_hal_rcc.o     <span class="hljs-number"> 1500 </span>       <span class="hljs-number"> 24 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 10186 </span>  stm32f1xx_hal_uart.o       <span class="hljs-number"> 56 </span>       <span class="hljs-number"> 18 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4700 </span>  stm32f1xx_it.o        <span class="hljs-number"> 2 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 24 </span>        <span class="hljs-number"> 4 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 987 </span>  system_stm32f1xx.o      <span class="hljs-number"> 276 </span>       <span class="hljs-number"> 30 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 208 </span>     <span class="hljs-number"> 1728 </span>  usart.o    -------------------------------------------------------------------<span class="language-yaml"><span class="hljs-meta">---</span></span><span class="language-yaml">      <span class="hljs-number">5522        </span><span class="hljs-number">328</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">520966</span>   <span class="hljs-string">Object</span> <span class="hljs-string">Totals</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>         <span class="hljs-number">32</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Generated)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器生成的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">        <span class="hljs-number">12</span>          <span class="hljs-number">0</span>          <span class="hljs-number">2</span>          <span class="hljs-number">1</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Padding)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器填充的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span>  <span class="hljs-string">库文件名</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Member</span> <span class="hljs-string">Name</span></span><span class="language-yaml"></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry10a.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry11a.o</span></span><span class="language-yaml">         <span class="hljs-number">8</span>          <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry2.o</span></span><span class="language-yaml">         <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry5.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry7b.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry8b.o</span></span><span class="language-yaml">         <span class="hljs-number">8</span>          <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry9a.o</span></span><span class="language-yaml">        <span class="hljs-number">30</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">handlers.o</span></span><span class="language-yaml">        <span class="hljs-number">36</span>          <span class="hljs-number">8</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>         <span class="hljs-number">68</span>   <span class="hljs-string">init.o</span></span><span class="language-yaml">        <span class="hljs-number">36</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">108</span>   <span class="hljs-string">memseta.o</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Totals</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Padding)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器填充的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span>  <span class="hljs-string">库文件名</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Name</span></span><span class="language-yaml"></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">mc_w.l</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Totals</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   </span><span class="language-yaml"></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">518434</span>   <span class="hljs-string">Grand</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">整个映像大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">518434</span>   <span class="hljs-string">ELF</span> <span class="hljs-string">Image</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">ELF可执行格式映像大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">ROM</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">整个ROM大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">RO</span>  <span class="hljs-string">Size</span> <span class="hljs-string">(Code</span> <span class="hljs-string">+</span> <span class="hljs-string">RO</span> <span class="hljs-string">Data)</span>                 <span class="hljs-number">6024</span> <span class="hljs-string">(</span>   <span class="hljs-number">5.</span><span class="hljs-string">88kB)</span></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">RW</span>  <span class="hljs-string">Size</span> <span class="hljs-string">(RW</span> <span class="hljs-string">Data</span> <span class="hljs-string">+</span> <span class="hljs-string">ZI</span> <span class="hljs-string">Data)</span>              <span class="hljs-number">1296</span> <span class="hljs-string">(</span>   <span class="hljs-number">1.</span><span class="hljs-string">27kB)</span></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">ROM</span> <span class="hljs-string">Size</span> <span class="hljs-string">(Code</span> <span class="hljs-string">+</span> <span class="hljs-string">RO</span> <span class="hljs-string">Data</span> <span class="hljs-string">+</span> <span class="hljs-string">RW</span> <span class="hljs-string">Data)</span>       <span class="hljs-number">6088</span> <span class="hljs-string">(</span>   <span class="hljs-number">5.</span><span class="hljs-string">95kB)</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span></code></pre></div><p><ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/stm32_map_file.zip">haluart map文件与正点原子详解附件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MDK-ARM在编译时会生成很多类型的中间文件，最终通过这些中间文件生成可下载到MCU的hex文件。.map
文件就是其中编译器链接时生成的一个文件，主要包含了交叉链接信息。&lt;/p&gt;
&lt;p&gt;通过 .map
文件，可以知晓工程中函数的大小，入口地址，变量、调用关系、FL</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="map" scheme="http://example.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>stm32启动文件详解</title>
    <link href="http://example.com/2023/08/08/stm32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/08/stm32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-08T04:30:03.000Z</published>
    <updated>2023-08-09T10:00:07.283Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道程序一般是从<code>main</code>函数开始运行的，但在<code>main</code>函数运行之前，程序已经做了一些准备工作，对于STM32F1芯片，这些准备工作是通过启动文件来完成的。下面来详细看看stm32库中的启动代码文件（STM32Cube_FW_F1_V1.8.532F1xx_stm32f103xe.s）。</p><p>启动文件是由汇编语言编写，是系统上电复位后第一个执行的程序。首先我们来看看启动文件使用的ARM汇编指令：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809173349258.png"alt="image-20230809173349258" /><figcaption aria-hidden="true">image-20230809173349258</figcaption></figure><p>整个启动文件主要做了以下操作：</p><ul><li>**设置初始化堆栈指针SP = _initial_sp**</li><li><strong>设置初始化计数器指针PC = Reset_Handler</strong></li><li><strong>设置堆栈大小</strong></li><li><strong>初始化中断向量表</strong></li><li><strong>调用 SystemInit() 函数初始化系统时钟</strong></li><li>**跳转到C库中的 __main函数初始化用户堆栈（最终调用main()函数）**</li></ul><div class="code-wrapper"><pre><code class="hljs assembly">;1-栈 ######;开辟栈的大小为 0X00000400（1K字节），名字为 STACK， NOINIT 即不初始化，可读可写， 8（2^3）字节对齐。;标号__initial_sp 表示栈的结束地址，即栈顶地址，栈是由高向低生长的。; Amount of memory (in bytes) allocated for Stack  ; Tailor this value to your application needs    ; &lt;h&gt; Stack Configuration   ;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;   ; &lt;/h&gt;Stack_Size      EQU     0x00000400                    AREA    STACK, NOINIT, READWRITE, ALIGN=3  Stack_Mem       SPACE   Stack_Size   __initial_sp</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;2-堆 ######;开辟堆的大小为 0X00000200（512字节），名字为 HEAP， 不初始化，可读可写， 8（2^3）字节对齐。;标号__heap_base 表示堆的起始地址， __heap_limit 表示堆的结束地址。堆是由低向高生长的，跟栈的生长方向相反。                                                  ; &lt;h&gt; Heap Configuration  ;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;  ; &lt;/h&gt;Heap_Size       EQU     0x00000200                  AREA    HEAP, NOINIT, READWRITE, ALIGN=3 __heap_baseHeap_Mem        SPACE   Heap_Size__heap_limit</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;3-向量表; 定义一个名为RESET的数据段，只读，并声明三个全局属性的标号 __Vectors、 __Vectors_End 和__Vectors_Size; Vector Table Mapped to Address 0 at Reset                AREA    RESET, DATA, READONLY                EXPORT  __Vectors                EXPORT  __Vectors_End                EXPORT  __Vectors_Size__Vectors       DCD     __initial_sp               ; Top of Stack #栈顶                DCD     Reset_Handler              ; Reset Handler                DCD     NMI_Handler                ; NMI Handler                DCD     HardFault_Handler          ; Hard Fault Handler                DCD     MemManage_Handler          ; MPU Fault Handler                DCD     BusFault_Handler           ; Bus Fault Handler                DCD     UsageFault_Handler         ; Usage Fault Handler                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     SVC_Handler                ; SVCall Handler                DCD     DebugMon_Handler           ; Debug Monitor Handler                DCD     0                          ; Reserved                DCD     PendSV_Handler             ; PendSV Handler                DCD     SysTick_Handler            ; SysTick Handler                ; External Interrupts #外部中断                DCD     WWDG_IRQHandler            ; Window Watchdog                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect                DCD     TAMPER_IRQHandler          ; Tamper                DCD     RTC_IRQHandler             ; RTC                DCD     FLASH_IRQHandler           ; Flash                DCD     RCC_IRQHandler             ; RCC                DCD     EXTI0_IRQHandler           ; EXTI Line 0                DCD     EXTI1_IRQHandler           ; EXTI Line 1                DCD     EXTI2_IRQHandler           ; EXTI Line 2                DCD     EXTI3_IRQHandler           ; EXTI Line 3                DCD     EXTI4_IRQHandler           ; EXTI Line 4                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7                DCD     ADC1_2_IRQHandler          ; ADC1 &amp; ADC2                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break                DCD     TIM1_UP_IRQHandler         ; TIM1 Update                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare                DCD     TIM2_IRQHandler            ; TIM2                DCD     TIM3_IRQHandler            ; TIM3                DCD     TIM4_IRQHandler            ; TIM4                DCD     I2C1_EV_IRQHandler         ; I2C1 Event                DCD     I2C1_ER_IRQHandler         ; I2C1 Error                DCD     I2C2_EV_IRQHandler         ; I2C2 Event                DCD     I2C2_ER_IRQHandler         ; I2C2 Error                DCD     SPI1_IRQHandler            ; SPI1                DCD     SPI2_IRQHandler            ; SPI2                DCD     USART1_IRQHandler          ; USART1                DCD     USART2_IRQHandler          ; USART2                DCD     USART3_IRQHandler          ; USART3                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10                DCD     RTC_Alarm_IRQHandler        ; RTC Alarm through EXTI Line                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break                DCD     TIM8_UP_IRQHandler         ; TIM8 Update                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare                DCD     ADC3_IRQHandler            ; ADC3                DCD     FSMC_IRQHandler            ; FSMC                DCD     SDIO_IRQHandler            ; SDIO                DCD     TIM5_IRQHandler            ; TIM5                DCD     SPI3_IRQHandler            ; SPI3                DCD     UART4_IRQHandler           ; UART4                DCD     UART5_IRQHandler           ; UART5                DCD     TIM6_IRQHandler            ; TIM6                DCD     TIM7_IRQHandler            ; TIM7                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5__Vectors_End__Vectors_Size  EQU  __Vectors_End - __Vectors</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;4-复位中断程序，系统上电后第一个要执行的程序;调用外部 SystemInit() 函数初始化系统时钟，然后调用 C 库函数_mian()，最终调用 main()函数去到 C 的世界。               ; Reset handlerReset_Handler   PROC                EXPORT  Reset_Handler             [WEAK]                IMPORT  __main                IMPORT  SystemInit                LDR     R0, =SystemInit                BLX     R0                               LDR     R0, =__main                BX      R0                ENDP</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;5-空的中断服务函数，[WEAK]弱声明无限循环函数，用户可以对其进行重定义。             ; Dummy Exception Handlers (infinite loops which can be modified)NMI_Handler     PROC                EXPORT  NMI_Handler                [WEAK]                B       .                ENDPHardFault_Handler\                PROC                EXPORT  HardFault_Handler          [WEAK]                B       .                ENDPMemManage_Handler\                PROC                EXPORT  MemManage_Handler          [WEAK]                B       .                ENDPBusFault_Handler\                PROC                EXPORT  BusFault_Handler           [WEAK]                B       .                ENDPUsageFault_Handler\                PROC                EXPORT  UsageFault_Handler         [WEAK]                B       .                ENDPSVC_Handler     PROC                EXPORT  SVC_Handler                [WEAK]                B       .                ENDPDebugMon_Handler\                PROC                EXPORT  DebugMon_Handler           [WEAK]                B       .                ENDPPendSV_Handler  PROC                EXPORT  PendSV_Handler             [WEAK]                B       .                ENDPSysTick_Handler PROC                EXPORT  SysTick_Handler            [WEAK]                B       .                ENDPDefault_Handler PROC                EXPORT  WWDG_IRQHandler            [WEAK]                EXPORT  PVD_IRQHandler             [WEAK]                EXPORT  TAMPER_IRQHandler          [WEAK]                EXPORT  RTC_IRQHandler             [WEAK]                EXPORT  FLASH_IRQHandler           [WEAK]                EXPORT  RCC_IRQHandler             [WEAK]                EXPORT  EXTI0_IRQHandler           [WEAK]                EXPORT  EXTI1_IRQHandler           [WEAK]                EXPORT  EXTI2_IRQHandler           [WEAK]                EXPORT  EXTI3_IRQHandler           [WEAK]                EXPORT  EXTI4_IRQHandler           [WEAK]                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]                EXPORT  ADC1_2_IRQHandler          [WEAK]                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]                EXPORT  CAN1_RX1_IRQHandler        [WEAK]                EXPORT  CAN1_SCE_IRQHandler        [WEAK]                EXPORT  EXTI9_5_IRQHandler         [WEAK]                EXPORT  TIM1_BRK_IRQHandler        [WEAK]                EXPORT  TIM1_UP_IRQHandler         [WEAK]                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]                EXPORT  TIM1_CC_IRQHandler         [WEAK]                EXPORT  TIM2_IRQHandler            [WEAK]                EXPORT  TIM3_IRQHandler            [WEAK]                EXPORT  TIM4_IRQHandler            [WEAK]                EXPORT  I2C1_EV_IRQHandler         [WEAK]                EXPORT  I2C1_ER_IRQHandler         [WEAK]                EXPORT  I2C2_EV_IRQHandler         [WEAK]                EXPORT  I2C2_ER_IRQHandler         [WEAK]                EXPORT  SPI1_IRQHandler            [WEAK]                EXPORT  SPI2_IRQHandler            [WEAK]                EXPORT  USART1_IRQHandler          [WEAK]                EXPORT  USART2_IRQHandler          [WEAK]                EXPORT  USART3_IRQHandler          [WEAK]                EXPORT  EXTI15_10_IRQHandler       [WEAK]                EXPORT  RTC_Alarm_IRQHandler        [WEAK]                EXPORT  USBWakeUp_IRQHandler       [WEAK]                EXPORT  TIM8_BRK_IRQHandler        [WEAK]                EXPORT  TIM8_UP_IRQHandler         [WEAK]                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]                EXPORT  TIM8_CC_IRQHandler         [WEAK]                EXPORT  ADC3_IRQHandler            [WEAK]                EXPORT  FSMC_IRQHandler            [WEAK]                EXPORT  SDIO_IRQHandler            [WEAK]                EXPORT  TIM5_IRQHandler            [WEAK]                EXPORT  SPI3_IRQHandler            [WEAK]                EXPORT  UART4_IRQHandler           [WEAK]                EXPORT  UART5_IRQHandler           [WEAK]                EXPORT  TIM6_IRQHandler            [WEAK]                EXPORT  TIM7_IRQHandler            [WEAK]                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]WWDG_IRQHandlerPVD_IRQHandlerTAMPER_IRQHandlerRTC_IRQHandlerFLASH_IRQHandlerRCC_IRQHandlerEXTI0_IRQHandlerEXTI1_IRQHandlerEXTI2_IRQHandlerEXTI3_IRQHandlerEXTI4_IRQHandlerDMA1_Channel1_IRQHandlerDMA1_Channel2_IRQHandlerDMA1_Channel3_IRQHandlerDMA1_Channel4_IRQHandlerDMA1_Channel5_IRQHandlerDMA1_Channel6_IRQHandlerDMA1_Channel7_IRQHandlerADC1_2_IRQHandlerUSB_HP_CAN1_TX_IRQHandlerUSB_LP_CAN1_RX0_IRQHandlerCAN1_RX1_IRQHandlerCAN1_SCE_IRQHandlerEXTI9_5_IRQHandlerTIM1_BRK_IRQHandlerTIM1_UP_IRQHandlerTIM1_TRG_COM_IRQHandlerTIM1_CC_IRQHandlerTIM2_IRQHandlerTIM3_IRQHandlerTIM4_IRQHandlerI2C1_EV_IRQHandlerI2C1_ER_IRQHandlerI2C2_EV_IRQHandlerI2C2_ER_IRQHandlerSPI1_IRQHandlerSPI2_IRQHandlerUSART1_IRQHandlerUSART2_IRQHandlerUSART3_IRQHandlerEXTI15_10_IRQHandlerRTC_Alarm_IRQHandlerUSBWakeUp_IRQHandlerTIM8_BRK_IRQHandlerTIM8_UP_IRQHandlerTIM8_TRG_COM_IRQHandlerTIM8_CC_IRQHandlerADC3_IRQHandlerFSMC_IRQHandlerSDIO_IRQHandlerTIM5_IRQHandlerSPI3_IRQHandlerUART4_IRQHandlerUART5_IRQHandlerTIM6_IRQHandlerTIM7_IRQHandlerDMA2_Channel1_IRQHandlerDMA2_Channel2_IRQHandlerDMA2_Channel3_IRQHandlerDMA2_Channel4_5_IRQHandler                B       .                ENDP                ALIGN</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;6-将堆栈地址传递给C库函数_main()，利用C库函数初始化堆栈或由用户自己初始化堆栈。;*******************************************************************************; User Stack and Heap initialization;*******************************************************************************                 IF      :DEF:__MICROLIB  ;#keil-MDK IDE勾选MicroLIB宏                ;#赋予以下三个标号全局属性                 EXPORT  __initial_sp                 EXPORT  __heap_base                 EXPORT  __heap_limit                                 ELSE        ;#keil-MDK IDE没有勾选MicroLIB宏                                 IMPORT  __use_two_region_memory ;#导入双段存储器模式，需要用户自己实现。                 EXPORT  __user_initial_stackheap ;#赋予标号__user_initial_stackheap全局属性                 __user_initial_stackheap                 LDR     R0, =  Heap_Mem                 LDR     R1, =(Stack_Mem + Stack_Size)                 LDR     R2, = (Heap_Mem +  Heap_Size)                 LDR     R3, = Stack_Mem                 BX      LR                 ALIGN</code></pre></div><p><ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/startup_stm32f103xe.zip">启动文件与正点原子详解附件</a></p><p>参考链接：</p><p>https://www.elecfans.com/news/1802838.html</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道程序一般是从&lt;code&gt;main&lt;/code&gt;函数开始运行的，但在&lt;code&gt;main&lt;/code&gt;函数运行之前，程序已经做了一些准备工作，对于STM32F1芯片，这些准备工作是通过启动文件来完成的。下面来详细看看stm32库中的启动代码文件（STM32Cube_F</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="startup" scheme="http://example.com/tags/startup/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_sd库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T10:30:31.000Z</published>
    <updated>2023-08-07T13:00:33.830Z</updated>
    
    <content type="html"><![CDATA[<p>SecureDigital,简称SD,SD内存卡是一种使用非常广泛的存储设备，以下来看看HAL库关于SD卡的使用方法。</p><h3 id="sd外设库的使用">SD外设库的使用</h3><p>这是一个通用分层的SDIO存储驱动，它使用HALSDIO驱动函数来连接SD内存卡。</p><p><strong>1. 初始化SDIO底层。HAL_SD_MspInit()</strong></p><ul><li>使能SDIO接口时钟。__HAL_RCC_SDIO_CLK_ENABLE()</li><li>配置SDIO引脚<ul><li>使能SDIO GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置SDIO引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_SD_ReadBlocks_DMA() ，HAL_SD_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDIO和DMA中断优先级，DMA优先级高于SDIO。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code>， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code>，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_SD_ReadBlocks_IT()，HAL_SD_WriteBlocks_IT()<ul><li>配置SDIO中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code>， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code>，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. SD卡的初始化和配置</strong></p><p>使用HAL_SD_Init()函数来初始化SD卡，并进入睡眠状态（已准备好数据传输）。SD卡初始化后，就可以执行SD卡的读、写、擦除操作。</p><ul><li><p>以400KHz的频率配置初始化SD卡。</p><p>SD卡频率：SDIO_CK = SDIOCLK / (ClockDiv + 2)；</p><p>初始化时，根据SD卡标准，确保SDIO_CK频率不要超过400KHz，通过SDIO底层函数SDIO_Init()和SDIO_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化SD卡。HAL_SD_InitCard()</p><p>这个函数用于初始化和识别SDIO及检查SD卡的类型（标准容量或高容量），此初始化流程与SD卡标准兼容。这个函数也可以在插拔时重新初始化SD卡。</p></li><li><p>配置SD卡数据传输频率，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据SD卡标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDIO外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的SD卡。</p></li><li><p>配置SD卡宽总线模式：4位数据。</p></li></ul><p><strong>3. SD卡的读操作</strong></p><ul><li><p>轮询模式下读取SD卡。HAL_SD_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态。</p></li><li><p>DMA模式下读取SD卡。HAL_SD_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDRx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取SD卡。HAL_SD_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDRx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. SD卡的写操作</strong></p><ul><li><p>轮询模式下向SD卡写操作。HAL_SD_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD卡的状态。</p></li><li><p>DMA模式下向SD卡写操作。HAL_SD_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDTx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向SD卡写操作。HAL_SD_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDTx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取SD卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取SD卡信息。HAL_SDIO_GetCardInfo()</p><p>它会返回关于SD卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_SDIO_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_SDIO_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="sd-hal常用宏定义列表">SD HAL常用宏定义列表</h3><ul><li><p>__HAL_SD_ENABLE : 使能 SD设备</p></li><li><p>__HAL_SD_DISABLE : 禁止 SD 设备</p></li><li><p>__HAL_SD_DMA_ENABLE: 使能 SD DMA 传输</p></li><li><p>__HAL_SD_DMA_DISABLE: 禁止 SD DMA 传输</p></li><li><p>__HAL_SD_ENABLE_IT: 使能 SD 设备中断</p></li><li><p>__HAL_SD_DISABLE_IT: 禁止 SD 设备中断</p></li><li><p>__HAL_SD_GET_FLAG:检查 SD 标志是否设置</p></li><li><p>__HAL_SD_CLEAR_FLAG: 清除 SD 的挂起标志</p></li></ul><h3 id="sd回调函数的注册">SD回调函数的注册</h3><p>当 USE_HAL_SD_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SD_RegisterCallback(),HAL_SD_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>ErrorCallback : 发生错误回调函数</li><li>AbortCpltCallback : 中止完成回调函数</li><li>MspInitCallback : SD 底层初始化回调函数</li><li>MspDeInitCallback : SD 底层析构回调函数</li></ul><p>默认情况下, SD 初始化（HAL_SD_Init()）后，当状态是HAL_SD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SD_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Secure
Digital,简称SD,SD内存卡是一种使用非常广泛的存储设备，以下来看看HAL库关于SD卡的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;sd外设库的使用&quot;&gt;SD外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用分层的SDIO存储驱动，它使用HAL
SDIO驱动函数</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sd" scheme="http://example.com/tags/sd/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_mmc库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T09:30:31.000Z</published>
    <updated>2023-08-08T00:18:21.207Z</updated>
    
    <content type="html"><![CDATA[<p>MultiMediaCard,简称MMC,它属于SD卡的一种，是一种一体化、可拆卸、多功能的内存卡,以下来看看HAL库关于MMC的使用方法。</p><h3 id="mmc外设库的使用">MMC外设库的使用</h3><p>这是一个通用分层的MMC存储器驱动，它使用HAL SDMMC驱动函数来连接MMC和eMMC卡。</p><p><strong>1. 初始化MMC底层。HAL_MMC_MspInit()</strong></p><ul><li>使能MMC接口时钟。__HAL_RCC_SDMMC_CLK_ENABLE()</li><li>配置MMC引脚<ul><li>使能MMC GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置MMC引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_MMC_ReadBlocks_DMA() ，HAL_MMC_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDMMC和DMA中断优先级，DMA优先级高于SDMMC。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code>， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code>，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_MMC_ReadBlocks_IT()，HAL_MMC_WriteBlocks_IT()<ul><li>配置SDMMC中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code>， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code>，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. MMC的初始化和配置</strong></p><p>使用HAL_MMC_Init()函数来初始化SDMMC，并进入睡眠状态（已准备好数据传输）。MMC卡初始化后，就可以执行MMC读、写、擦除操作。</p><ul><li><p>使用默认配置初始化SDMMC外设接口。默认频率：400KHz。</p><p>MMC频率：SDMMC_CK = SDMMCCLK / (ClockDiv + 2)；</p><p>初始化时，根据MMC标准，确保SDMMC_CK频率不要超过400KHz，通过SDMMC底层函数SDMMC_Init()和SDMMC_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化MMC卡。HAL_MMC_InitCard()</p><p>这个函数用于初始化和识别MMC及检查MMC卡的类型（标准容量或高容量），此初始化流程与MMC标准兼容。这个函数也可以在插拔时重新初始化MMC卡。</p></li><li><p>配置MMC卡数据传输频率，默认传输频率是24MHz，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据MMC标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDMMC外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的MMC卡。</p></li><li><p>配置MMC宽总线模式：4位数据。</p></li></ul><p><strong>3. MMC的读操作</strong></p><ul><li><p>轮询模式下读取MMC卡。HAL_MMC_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下读取MMC卡。HAL_MMC_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCRx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取MMC卡。HAL_MMC_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCRx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. MMC的写操作</strong></p><ul><li><p>轮询模式下向MMC卡写操作。HAL_MMC_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下向MMC卡写操作。HAL_MMC_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCTx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向MMC卡写操作。HAL_MMC_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCTx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取MMC卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取MMC卡信息。HAL_MMC_GetCardInfo()</p><p>它会返回关于MMC卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_MMC_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_MMC_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="mmc-hal常用宏定义列表">MMC HAL常用宏定义列表</h3><ul><li><p>__HAL_MMC_ENABLE : 使能 MMC设备</p></li><li><p>__HAL_MMC_DISABLE : 禁止 MMC 设备</p></li><li><p>__HAL_MMC_DMA_ENABLE: 使能 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_DMA_DISABLE: 禁止 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_ENABLE_IT: 使能 MMC 设备中断</p></li><li><p>__HAL_MMC_DISABLE_IT: 禁止 MMC 设备中断</p></li><li><p>__HAL_MMC_GET_FLAG:检查 MMC 标志是否设置</p></li><li><p>__HAL_MMC_CLEAR_FLAG: 清除 MMC 的挂起标志</p></li></ul><h3 id="mmc回调函数的注册">MMC回调函数的注册</h3><p>当 USE_HAL_MMC_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_MMC_RegisterCallback(),HAL_MMC_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>ErrorCallback : 发生错误回调函数</li><li>AbortCpltCallback : 中止完成回调函数</li><li>MspInitCallback : MMC 底层初始化回调函数</li><li>MspDeInitCallback : MMC 底层析构回调函数</li></ul><p>默认情况下, MMC 初始化（HAL_MMC_Init()）后，当状态是HAL_MMC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_MMC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_MMC_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MultiMediaCard,简称MMC,它属于SD卡的一种，是一种一体化、可拆卸、多功能的内存卡,以下来看看HAL库关于MMC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;mmc外设库的使用&quot;&gt;MMC外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用分层的MMC存储器驱动，它使用HA</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="mmc" scheme="http://example.com/tags/mmc/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_nor库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T04:15:11.000Z</published>
    <updated>2023-08-07T05:34:38.718Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于Nor flash存储器的使用方法。</p><h3 id="nor存储器外设库的使用">NOR存储器外设库的使用</h3><p>此驱动是一个通用的分层驱动程序，包含一组用于控制NOR闪存的API。它使用FSMC层函数来连接NOR闪存。</p><ol type="1"><li><p>配置NOR flash 存储器的控制和时序参数。HAL_NOR_Init()</p></li><li><p>读取NOR flash 存储器制造商和设备ID。HAL_NOR_Read_ID()</p><p>读取的信息存储在函数调用的NOR_ID_TypeDef类型结构体中。</p></li><li><p>对NOR flash存储器进行读写操作。HAL_NOR_Read(),HAL_NOR_Program()</p></li><li><p>执行NOR flash块擦除或芯片擦除操作。 HAL_NOR_Erase_Block() ,HAL_NOR_Erase_Chip()</p></li><li><p>读取NOR flash的通用闪存接口ID（CFI IDs）。HAL_NOR_Read_CFI()</p><p>读取的信息存储在被上述函数调用的已声明NOR_CFI_TypeDef结构体中。</p></li><li><p>可分别通过调用 HAL_NOR_WriteOperation_Enable() /HAL_NOR_WriteOperation_Disable()函数来使能/禁止 NORFlash的写操作，从而控制NOR Flash设备。</p></li><li><p>监测NOR设备状态。 HAL_NOR_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通NOR flash操作APIs。如果NORflash设备包含不同的操作和方法，应该单独实施。</p><h3 id="nor存储器外设常用宏定义">NOR存储器外设常用宏定义</h3><ul><li>NOR_WRITE : NOR 存储器向指定的地址写入数据。</li></ul><h3 id="nor存储器回调函数的注册">NOR存储器回调函数的注册</h3><p>当 USE_HAL_NOR_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_NOR_RegisterCallback(),HAL_NOR_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : NOR 底层初始化回调函数</li><li>MspDeInitCallback : NOR 底层析构回调函数</li></ul><p>默认情况下, NOR 初始化（HAL_NOR_Init()）后，当状态是HAL_NOR_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_NOR_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_NOR_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于Nor flash存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;nor存储器外设库的使用&quot;&gt;NOR存储器外设库的使用&lt;/h3&gt;
&lt;p&gt;此驱动是一个通用的分层驱动程序，包含一组用于控制NOR闪存的API。它使用FSMC层函数来连接NOR
闪存。&lt;/p</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="nor" scheme="http://example.com/tags/nor/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_pccard库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-pccard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-pccard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T04:15:11.000Z</published>
    <updated>2023-08-07T05:42:50.629Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于PCCARD存储器的使用方法。</p><h3 id="pccard存储器外设库的使用">PCCARD存储器外设库的使用</h3><p>此驱动是一个通用的分层驱动程序，包含一组用于控制PCCARD/小型闪存的API。它使用FSMC层函数来连接PCCARD存储器。</p><ol type="1"><li><p>配置PCCARD/小型闪存的控制和时序参数。HAL_PCCARD_Init()/HAL_CF_Init()</p></li><li><p>读取PCCARD/小型闪存制造商和设备ID。HAL_PCCARD_Read_ID()/HAL_CF_Read_ID()</p><p>读取的信息存储在函数调用的CompactFlash_ID结构体中。</p></li><li><p>对PCCARD/小型闪存进行扇区读写操作：</p><ul><li><p>HAL_PCCARD_Read_Sector()/ HAL_PCCARD_Write_Sector()</p></li><li><p>HAL_CF_Read_Sector()/HAL_CF_Write_Sector()</p></li></ul></li><li><p>执行PCCARD/小型闪存复位操作。HAL_PCCARD_Reset()/HAL_CF_Reset()</p></li><li><p>执行PCCARD/小型闪存扇区擦除操作。HAL_PCCARD_Erase_Sector()/HAL_CF_Erase_Sector()</p></li><li><p>读取PCCARD/小型闪存的状态。HAL_PCCARD_ReadStatus()/HAL_CF_ReadStatus()</p></li><li><p>监测PCCARD/小型闪存的状态。HAL_PCCARD_GetState()/HAL_CF_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通PCCARD/小型闪存操作API。如果PCCARD/小型闪存设备包含不同的操作和方法，应该单独实施。</p><h3 id="pccard存储器回调函数的注册">PCCARD存储器回调函数的注册</h3><p>当 USE_HAL_PCCARD_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_PCCARD_RegisterCallback(),HAL_PCCARD_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : PCCARD 底层初始化回调函数</li><li>MspDeInitCallback : PCCARD 底层析构回调函数</li></ul><p>默认情况下, PCCARD 初始化（HAL_PCCARD_Init()）后，当状态是HAL_PCCARD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_PCCARD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_PCCARD_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于PCCARD存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;pccard存储器外设库的使用&quot;&gt;PCCARD存储器外设库的使用&lt;/h3&gt;
&lt;p&gt;此驱动是一个通用的分层驱动程序，包含一组用于控制PCCARD/小型闪存的API。它使用FSMC层函数来连接PC</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="pccard" scheme="http://example.com/tags/pccard/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_nand库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-nand%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-nand%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T14:32:31.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于NAND flash存储器的使用方法。</p><h3 id="nand外设库的使用">NAND外设库的使用</h3><ol type="1"><li><p>配置NAND flash 存储器。HAL_NAND_Init()</p></li><li><p>读取NAND flash 存储器制造商和设备ID。HAL_NAND_Read_ID()</p><p>读取的信息存储在函数调用的NAND_ID_TypeDef类型结构体中。</p></li><li><p>对NAND flash存储器进行读写操作：</p><ul><li>HAL_NAND_Read_Page_8b()/HAL_NAND_Read_SpareArea_8b()</li><li>HAL_NAND_Write_Page_8b()/HAL_NAND_Write_SpareArea_8b()</li><li>HAL_NAND_Read_Page_16b()/HAL_NAND_Read_SpareArea_16b()</li><li>HAL_NAND_Write_Page_16b()/HAL_NAND_Write_SpareArea_16b()</li></ul><p>这些函数使用用户在 NAND_DeviceConfigTypeDef结构体中预定义的设备信息(块、页面大小等)，结构体中包含读写地址信息。</p></li><li><p>执行NAND flash复位操作。HAL_NAND_Reset()</p></li><li><p>执行NAND flash块擦除操作。HAL_NAND_Erase_Block()</p><p>块擦除信息作为参数传入Nand_Address_Typedef结构体。</p></li><li><p>读取NAND flash的状态操作。HAL_NAND_Read_Status()</p></li><li><p>分别通过调用 HAL_NAND_ECC_Enable() /HAL_NAND_ECC_Disable()函数来使能/禁止 ECC码更正特性，或通过HAL_NAND_GetECC() 函数获取 ECC更正码，从而控制NAND 设备。</p></li><li><p>监测NAND设备状态。 HAL_NAND_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通NAND flash操作APIs。如果NANDflash设备包含不同的操作和方法，应该单独实施。</p><h3 id="nand回调函数的注册">NAND回调函数的注册</h3><p>当 USE_HAL_NAND_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_NAND_RegisterCallback(),HAL_NAND_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : NAND 底层初始化回调函数</li><li>MspDeInitCallback : NAND 底层析构回调函数</li></ul><p>默认情况下, NAND 初始化（HAL_NAND_Init()）后，当状态是HAL_NAND_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_NAND_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_NAND_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于NAND flash存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;nand外设库的使用&quot;&gt;NAND外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;配置NAND flash 存储器。HAL_NAND_Init()&lt;/p&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="nand" scheme="http://example.com/tags/nand/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_rtc库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-rtc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-rtc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T13:10:31.000Z</published>
    <updated>2023-08-08T00:21:20.813Z</updated>
    
    <content type="html"><![CDATA[<p>Real TimeClock，简称RTC，实时时钟，以下来看看HAL库关于RTC的使用方法。</p><h3 id="rtc外设库的使用">RTC外设库的使用</h3><ol type="1"><li>使能RTC域。</li><li>配置RTC预分频系数(异步预分频器生成RTC 1Hz时基)。 HAL_RTC_Init()</li><li>配置时间和日期。<ul><li>配置RTC日历(时间和日期)。HAL_RTC_SetTime()，HAL_RTC_SetDate()</li><li>读RTC日历。HAL_RTC_GetTime() ，HAL_RTC_GetDate()</li></ul></li><li>闹钟配置。<ul><li>配置RTC闹钟。HAL_RTC_SetAlarm() ，HAL_RTC_SetAlarm_IT()</li><li>读RTC闹钟。HAL_RTC_GetAlarm()</li></ul></li><li>RTC 入侵检测配置。RTC Tamper<ul><li>使能RTCTamper，配置Tamper电平。HAL_RTCEx_SetTamper()，HAL_RTCEx_SetTamper_IT()</li><li>TAMPER1 复用功能映射到PC13 。</li></ul></li><li>配置备份数据寄存器（Backup Data Registers）<ul><li>向RTC备份数据寄存器写数据。HAL_RTCEx_BKUPWrite()</li><li>读RTC备份数据寄存器。HAL_RTCEx_BKUPRead()</li></ul></li></ol><h3 id="提示-hal-rtc驱动的限制">==提示: HAL RTC驱动的限制==</h3><ul><li>STM32F1系列芯片上的RTC版本是V1，F1系列芯片不支持V2版本（其它系列）的所有特性。</li><li>对于V2版本，RTC主要的特性是通过硬件控制的。但在F1芯片，日期特性完全由软件控制。</li><li>跟其它系列芯片相比，F1系列芯片有一些限制：<ul><li>HAL库只支持24小时格式（不支持12小时）。</li><li>日期保存在SRAM中，当MCU处于停止或待机模式时，日期就会丢失。用户应该在进入低功耗模式之前保存日期。（基于备份寄存器的固件包提供了一个示例）</li><li>每次调用时间和日期函数时，日期就会自动更新。HAL_RTC_GetTime()，HAL_RTC_GetDate()</li><li>闹钟检测被限制在一天内，它只会过期一次（无重复闹钟，需要编一个新的闹钟）。</li></ul></li></ul><h3 id="备用域操作条件">备用域操作条件</h3><ul><li>当主电源关闭时，可通过VBAT电源来给RTC和RTC备份寄存器供电。当VDD关闭，为了维持RTC备份寄存器的内容和给RTC供电，VBAT引脚连接到一个电池或其它电源的备用电源。</li><li>当主数字电源（VDD）关闭，为了RTC的操作，VBAT引脚需为以下模块供电：<ul><li>RTC</li><li>LSE振荡器</li><li>使能低功耗备用稳压器时的备用SRAM</li><li>PC13 ~ PC15 I/O引脚，加上 PI8引脚 (当可使用时)</li></ul></li><li>当备用域通过VDD（模拟开关连接到VDD）供电，可使用PC13引脚，用作入侵检测引脚。</li><li>当备用域通过VBAT（模拟开关连接到VBAT，因为VDD不存在）供电，可使用PC13引脚，用作入侵检测引脚。</li></ul><h3 id="备用域复位">备用域复位</h3><ul><li>备用域复位将所有的RTC寄存器和RCC_BDCR寄存器设为复位值。</li><li>当发生以下任一事件，就会产生备用域复位：<ul><li>设置RCC备用域控制寄存器（RCC_BDCR）中的BDRST位触发软件复位。</li><li>如果两个供电之前都关闭了，那么VDD或VBAT电压就会打开。</li><li>入侵检测事件复位所有的数据备份寄存器。</li></ul></li></ul><h3 id="访问备用域">访问备用域</h3><ul><li>复位后, 备用域 (RTC寄存器,RTC备份数据寄存器和备份SRAM)就会被保护，不能进行写操作。</li><li>为了访问RTC域和RTC寄存器，可通过以下方式：<ul><li>调用HAL_RCCEx_PeriphCLKConfig()函数，其中PeriphClockSelection为RCC_PERIPHCLK_RTC，并选择RTCClockSelection(LSE, LSI 或 HSE)。</li><li>使能备用域时钟。__HAL_RCC_BKP_CLK_ENABLE()</li></ul></li></ul><h3 id="rtc和低功耗模式">RTC和低功耗模式</h3><ul><li>通过RTC复用函数可把MCU从低功耗模式中唤醒。</li><li>RTC复用函数是RTC闹钟（闹钟A）和检测RTC入侵事件。这些复用函数可将系统从停止和待机低功耗模式下唤醒。</li><li>系统还可以通过RTC闹钟从低功耗模式下唤醒，而无需依赖外部中断（自动唤醒模式）</li></ul><h3 id="rtc回调函数的注册">RTC回调函数的注册</h3><p>当 USE_HAL_RTC_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_RTC_RegisterCallback(),HAL_RTC_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>AlarmAEventCallback : RTC闹钟A 事件回调函数</p></li><li><p>Tamper1EventCallback : RTC入侵检测1事件回调函数</p></li><li><p>MspInitCallback : RTC底层初始化回调函数</p></li><li><p>MspDeInitCallback : RTC底层析构回调函数</p></li></ul><p>默认情况下, RTC 初始化（HAL_RTC_Init()）后，当状态是HAL_RTC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_RTC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_RTC_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Real Time
Clock，简称RTC，实时时钟，以下来看看HAL库关于RTC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;rtc外设库的使用&quot;&gt;RTC外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;使能RTC域。&lt;/li&gt;
&lt;li&gt;配置RTC预分频系数(</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="rtc" scheme="http://example.com/tags/rtc/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_spi库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-spi%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-spi%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:50:31.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>Serial PeripheralInterface，简称SPI，串行外设接口。以下来看看HAL库关于SPI的使用方法。</p><h3 id="spi外设库的使用">SPI外设库的使用</h3><ol type="1"><li><p>声明一个 SPI_HandleTypeDef 结构体,如：SPI_HandleTypeDefhspi;</p></li><li><p>初始化SPI底层。HAL_SPI_MspInit()</p></li></ol><ul><li>使能SPIx 接口时钟。</li><li>配置SPI引脚<ul><li>使能SPI GPIO 时钟</li><li>配置SPI引脚为复用推挽模式</li></ul></li><li>如果使用到中断，则配置NVIC。<ul><li>配置SPIx 中断优先级</li><li>使能NVIC SPI IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体参数。</li><li>配置DMA Tx或Rx通道。</li><li>将hdma_tx 或hdma_rx 跟 hspi DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置hspi初始化结构体中各参数。</li><li>调用 HAL_SPI_Init() 函数初始化 SPI寄存器。</li></ol><h3 id="循环模式规则">循环模式规则</h3><ul><li>当SPI配置在以下模式时，就不能使用DMA循环模式：<ul><li>主机2线只接收 (Master 2Lines RxOnly)</li><li>主机1线接收 (Master 1Line Rx)</li></ul></li><li>当使能DMA循环模式时，就不能使用CRC功能。</li><li>当使用了SPI DMA暂停/停止功能时，必须只能在SPI回调函数中使用HAL_SPI_DMAPause()/HAL_SPI_DMAStop()函数。</li></ul><h3 id="主机接收模式规则">主机接收模式规则</h3><p>在主机单向接收模式 (MSTR =1, BIDIMODE=0, RXONLY=1) 或双向接收模式(MSTR=1, BIDIMODE=1,BIDIOE=0)，为了确保SPI没有发起新的数据传输，需要重视以下函数：</p><ul><li><p>HAL_SPI_DeInit()</p></li><li><p>HAL_SPI_Init()</p></li></ul><h3 id="spi回调函数的注册">SPI回调函数的注册</h3><p>当 USE_HAL_SPI_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SPI_RegisterCallback(),HAL_SPI_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxCpltCallback : SPI 发送完成回调函数</p></li><li><p>RxCpltCallback : SPI 接收完成回调函数</p></li><li><p>TxRxCpltCallback : SPI 发送接收完成回调函数</p></li><li><p>TxHalfCpltCallback : SPI 发送过半回调函数</p></li><li><p>RxHalfCpltCallback : SPI 接收过半回调函数</p></li><li><p>TxRxHalfCpltCallback : SPI 发送接收过半回调函数</p></li><li><p>ErrorCallback : SPI 错误回调函数</p></li><li><p>AbortCpltCallback : SPI 中止回调函数</p></li><li><p>MspInitCallback : SPI 底层初始化回调函数</p></li><li><p>MspDeInitCallback : SPI 底层析构回调函数</p></li></ul><p>默认情况下, SPI 初始化（HAL_SPI_Init()）后，当状态是HAL_SPI_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SPI_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SPI_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Serial Peripheral
Interface，简称SPI，串行外设接口。以下来看看HAL库关于SPI的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;spi外设库的使用&quot;&gt;SPI外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;声明一个 SPI_Han</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="spi" scheme="http://example.com/tags/spi/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_smartcard库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-smartcard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-smartcard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:32:31.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>Smart Card，智能卡，以下来看看HAL库关于SMARTCARD的使用方法。</p><h3 id="smartcard外设库的使用">SMARTCARD外设库的使用</h3><ol type="1"><li><p>声明一个 SMARTCARD_HandleTypeDef 结构体。</p></li><li><p>初始化SMARTCARD底层。HAL_SMARTCARD_MSMARTCARDnit()</p></li></ol><ul><li>使能SMARTCARDx关联到USARTx 的接口时钟。</li><li>配置SMARTCARD引脚<ul><li>使能SMARTCARD GPIO 时钟</li><li>配置SMARTCARD引脚为复用上拉模式</li></ul></li><li>如果使用到中断（HAL_SMARTCARD_Transmit_IT()，HAL_SMARTCARD_Receive_IT()），则配置NVIC。<ul><li>配置USARTx中断优先级</li><li>使能NVIC USART IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_SMARTCARD_Transmit_DMA()，HAL_SMARTCARD_Receive_DMA()<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体Tx/Rx参数。</li><li>配置DMA Tx或Rx通道。</li><li>将DMA 跟 SMARTCARD DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置SMARTCARD初始化结构体中各参数。</li><li>调用 HAL_SMARTCARD_Init() 函数初始化 SMARTCARD寄存器。</li></ol><p>在发送和接收过程中，使用宏定义 __HAL_SMARTCARD_ENABLE_IT() 和__HAL_SMARTCARD_DISABLE_IT() 来管理SMARTCARD的中断(发送完成中断，接收非空中断，错误中断)。</p><h3 id="smartcard轮询模式io操作">SMARTCARD轮询模式IO操作</h3><ul><li>阻塞方式下，发送一定数量的数据。HAL_SMARTCARD_Transmit()</li><li>阻塞方式下，接收一定数量的数据。HAL_SMARTCARD_Receive()</li></ul><h3 id="smartcard中断模式io操作">SMARTCARD中断模式IO操作</h3><ul><li><p>非阻塞方式下，发送一定数量的数据。HAL_SMARTCARD_Transmit_IT()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_SMARTCARD_TxCpltCallback()</p></li><li><p>非阻塞方式下，接收一定数量的数据。HAL_SMARTCARD_Receive_IT()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_SMARTCARD_RxCpltCallback()</p></li><li><p>传输出错时，执行出错回调函数，用户自行添加代码。HAL_SMARTCARD_ErrorCallback()</p></li></ul><h3 id="smartcard-dma-模式io操作">SMARTCARD DMA 模式IO操作</h3><ul><li><p>非阻塞方式(DMA)下，发送一定数量的数据。HAL_SMARTCARD_Transmit_DMA()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_SMARTCARD_TxCpltCallback()</p></li><li><p>非阻塞方式(DMA)下，接收一定数量的数据。HAL_SMARTCARD_Receive_DMA()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_SMARTCARD_RxCpltCallback()</p></li><li><p>传输出错时，执行出错回调函数，用户自行添加代码。HAL_SMARTCARD_ErrorCallback()</p></li></ul><h3 id="smartcard-常用宏定义">SMARTCARD 常用宏定义</h3><ul><li><p>__HAL_SMARTCARD_ENABLE: 使能SMARTCARD 外设</p></li><li><p>__HAL_SMARTCARD_DISABLE: 禁止SMARTCARD 外设</p></li><li><p>__HAL_SMARTCARD_GET_FLAG : 检查SMARTCARD 标志是否设置</p></li><li><p>__HAL_SMARTCARD_CLEAR_FLAG : 清除 SMARTCARD 挂起标志</p></li><li><p>__HAL_SMARTCARD_ENABLE_IT: 使能 SMARTCARD 中断</p></li><li><p>__HAL_SMARTCARD_DISABLE_IT: 禁止 SMARTCARD 中断</p></li></ul><h3 id="smartcard回调函数的注册">SMARTCARD回调函数的注册</h3><p>当 USE_HAL_SMARTCARD_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SMARTCARD_RegisterCallback(),HAL_SMARTCARD_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxCpltCallback : 发送完成回调函数</p></li><li><p>RxCpltCallback : 接收完成回调函数</p></li><li><p>ErrorCallback : 错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>AbortTransmitCpltCallback : 中止发送完成回调函数</p></li><li><p>AbortReceiveCpltCallback : 中止接收完成回调函数</p></li><li><p>MspInitCallback : SMARTCARD 底层初始化回调函数</p></li><li><p>MspDeInitCallback : SMARTCARD 底层析构回调函数</p></li></ul><p>默认情况下, SMARTCARD 初始化（HAL_SMARTCARD_Init()）后，当状态是HAL_SMARTCARD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SMARTCARD_STATE_READY状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SMARTCARD_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Smart Card，智能卡，以下来看看HAL库关于SMARTCARD的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;smartcard外设库的使用&quot;&gt;SMARTCARD外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;声明一个 SMARTCARD_Handle</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="smartcard" scheme="http://example.com/tags/smartcard/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_tim库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-tim%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-tim%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:20:30.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>timer,简称TIM，定时器是MCU控制中使用最广泛的外设，STM32中有多个TIM，下面来看看HAL库关于TIM的介绍和使用方法。</p><h3 id="tim外设库的一般特性">TIM外设库的一般特性</h3><ul><li>16位向上，向下，向上向下自动重装载计数器</li><li>16位可编程预分频系数，允许对计数器时钟进行 1 ~ 65536 的分频。</li><li>多达4各独立的通道：<ul><li>输入捕获 Input Capture</li><li>输出比较 Output Compare</li><li>产生PWM（边沿和中心对齐模式）</li><li>单脉冲模式输出 One-pulse mode output</li></ul></li><li>用外部信号的同步电路来控制定时器，并将多个定时器互连在一起。</li><li>支持增量编码器的定位目的</li></ul><h3 id="tim外设库的使用">TIM外设库的使用</h3><ol type="1"><li><p>根据所选的功能特性，初始化TIM底层：</p><ul><li>Time Base : HAL_TIM_Base_MspInit()</li><li>Input Capture : HAL_TIM_IC_MspInit()</li><li>Output Compare : HAL_TIM_OC_MspInit()</li><li>PWM generation : HAL_TIM_PWM_MspInit()</li><li>One-pulse mode output : HAL_TIM_OnePulse_MspInit()</li><li>Encoder mode output : HAL_TIM_Encoder_MspInit()</li><li>Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()</li></ul></li><li><p>使能TIM接口时钟。__HAL_RCC_TIMx_CLK_ENABLE()</p></li><li><p>配置TIM引脚。</p><ul><li>使能TIM GPIOs时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置TIM引脚复用功能。HAL_GPIO_Init()</li></ul></li><li><p>默认时钟是来自APBx的内部时钟，如果有需要，可配置外部时钟。HAL_TIM_ConfigClockSource()</p><p>该配置需在任何启动函数之前完成。</p></li><li><p>在所需的功能模式下配置TIM：</p><ul><li><p>使用定时器产生时基（time base）。HAL_TIM_Base_Init()</p></li><li><p>使用定时器产生输出比较信号。 HAL_TIM_OC_Init() ,HAL_TIM_OC_ConfigChannel()</p></li><li><p>使用定时器产生PWM信号。HAL_TIM_PWM_Init() ,HAL_TIM_PWM_ConfigChannel()</p></li><li><p>使用定时器测量外部信号。HAL_TIM_IC_Init() ,HAL_TIM_IC_ConfigChannel()</p></li><li><p>单脉冲模式下使用定时器。HAL_TIM_OnePulse_Init() ,HAL_TIM_OnePulse_ConfigChannel()</p></li><li><p>使用定时器编码接口。HAL_TIM_Encoder_Init()</p></li><li><p>使用定时器 HallSensor接口，如果有需要中断和DMA请求，则配置通信事件。HAL_TIMEx_HallSensor_Init()， HAL_TIMEx_ConfigCommutEvent()</p><p><strong>注意</strong>：一个定时器用于与Hallsensor接口连接，另一个定时器用于通信事件。</p></li></ul></li><li><p>根据功能特性开启TIM外设：</p><ul><li>Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(),HAL_TIM_Base_Start_IT()</li><li>Input Capture : HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(),HAL_TIM_IC_Start_IT()</li><li>Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(),HAL_TIM_OC_Start_IT()</li><li>PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(),HAL_TIM_PWM_Start_IT()</li><li>One-pulse mode output : HAL_TIM_OnePulse_Start(),HAL_TIM_OnePulse_Start_IT()</li><li>Encoder mode output : HAL_TIM_Encoder_Start(),HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT()</li><li>Complementary Output Compare : HAL_TIMEx_OCN_Start(),HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OCN_Start_IT()</li><li>Complementary PWM generation : HAL_TIMEx_PWMN_Start(),HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()</li><li>Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(),HAL_TIMEx_OnePulseN_Start_IT()</li><li>Hall Sensor output : HAL_TIMEx_HallSensor_Start(),HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().</li></ul></li><li><p>管理控制DMA Busrt功能。HAL_TIM_DMABurst_WriteStart()，HAL_TIM_DMABurst_ReadStart()</p></li></ol><h3 id="tim回调函数的注册">TIM回调函数的注册</h3><p>当 USE_HAL_TIM_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_TIM_RegisterCallback(),HAL_TIM_UnRegisterCallback()</p><p>回调函数：</p><ul><li>Base_MspDeInitCallback : TIM 时基底层析构回调函数</li><li>IC_MspInitCallback : TIM 输入捕获底层初始化回调函数</li><li>IC_MspDeInitCallback : TIM 输入捕获底层析构回调函数</li><li>OC_MspInitCallback : TIM 输出比较底层初始化回调函数</li><li>OC_MspDeInitCallback : TIM 输出比较底层析构回调函数</li><li>PWM_MspInitCallback : TIM PWM 底层初始化回调函数</li><li>PWM_MspDeInitCallback : TIM PWM 底层析构回调函数</li><li>OnePulse_MspInitCallback : TIM 单脉冲底层初始化回调函数</li><li>OnePulse_MspDeInitCallback : TIM 单脉冲底层析构回调函数</li><li>Encoder_MspInitCallback : TIM 编码器底层初始化回调函数</li><li>Encoder_MspDeInitCallback : TIM 编码器底层析构回调函数</li><li>HallSensor_MspInitCallback : TIM Hall Sensor 底层初始化回调函数</li><li>HallSensor_MspDeInitCallback : TIM Hall Sensor 析构回调函数</li><li>PeriodElapsedCallback : TIM 周期时间结束回调函数</li><li>PeriodElapsedHalfCpltCallback : TIM 半周期时间结束回调函数</li><li>TriggerCallback : TIM 触发回调函数</li><li>TriggerHalfCpltCallback : TIM 半触发回调函数</li><li>IC_CaptureCallback : TIM 输入捕获回调函数</li><li>IC_CaptureHalfCpltCallback : TIM 半输入捕获回调函数</li><li>OC_DelayElapsedCallback : TIM 输出比较延时回调函数</li><li>PWM_PulseFinishedCallback : TIM PWM 脉冲结束回调函数</li><li>PWM_PulseFinishedHalfCpltCallback : TIM PWM 半脉冲结束回调函数</li><li>ErrorCallback : TIM 错误回调函数</li><li>CommutationCallback : TIM 通信回调函数</li><li>CommutationHalfCpltCallback : TIM 半通信回调函数</li><li>BreakCallback : TIM 打断回调函数</li></ul><p>默认情况下, TIM初始化（HAL_TIM_Init()）后，当状态是HAL_TIM_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_TIM_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_TIM_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;timer,
简称TIM，定时器是MCU控制中使用最广泛的外设，STM32中有多个TIM，下面来看看HAL库关于TIM的介绍和使用方法。&lt;/p&gt;
&lt;h3 id=&quot;tim外设库的一般特性&quot;&gt;TIM外设库的一般特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;16位向上，向下，向上向下</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="tim" scheme="http://example.com/tags/tim/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_sram库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-sram%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-sram%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T11:20:30.000Z</published>
    <updated>2023-08-07T05:07:43.030Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于SRAM 内存的使用方法。</p><h3 id="sram外设库的使用">SRAM外设库的使用</h3><p>这是一个通用的分层驱动，包含一套控制SRAM内存的API。它使用FSMC层函数与SRAM设备进行连接。要配置FSMC与SRAM/PSRAM的连接，应遵循以下顺序：</p><ol type="1"><li><p>声明一个SRAM_HandleTypeDef类型结构体。如：SRAM_HandleTypeDefhsram;</p><ul><li>对SRAM_HandleTypeDef 句柄中“Init”中成员赋值。</li><li>对SRAM_HandleTypeDef句柄中“Instance”填入预先定义的NOR或SRAM设备基地址寄存器实例。</li><li>对SRAM_HandleTypeDef句柄中“Extended”填入预先定义的NOR或SRAM扩展模式基地址寄存器实例。</li></ul></li><li><p>为正常模式和扩展模式声明两个 FSMC_NORSRAM_TimingTypeDef类型结构体，并进行赋值。如：</p><p>​ FSMC_NORSRAM_TimingTypeDef Timing ， FSMC_NORSRAM_TimingTypeDefExTiming;</p></li><li><p>初始化 SRAM 控制器。HAL_SRAM_Init()</p><ul><li>配置底层硬件。HAL_SRAM_MspInit()</li><li>使用 FSMC NORSRAM 接口配置控制寄存器。FSMC_NORSRAM_Init()</li><li>使用 FSMC NORSRAM接口配置时序寄存器。FSMC_NORSRAM_Timing_Init()</li><li>使用 FSMC NORSRAM接口配置扩展模式时序寄存器。FSMC_NORSRAM_Extended_Timing_Init()</li><li>使能SRAM设备。__FSMC_NORSRAM_ENABLE()</li></ul></li><li><p>在这个阶段，你就可以执行内存与NOR/SRAM Bank之间的读、写操作。</p><ul><li>轮询模式下的读写：HAL_SRAM_Read()/HAL_SRAM_Write()</li><li>DMA模式下的读写：HAL_SRAM_Read_DMA()/HAL_SRAM_Write_DMA()</li></ul></li><li><p>你也可以通过调用HAL_SRAM_WriteOperation_Enable() /HAL_SRAM_WriteOperation_Disable() 函数来控制SRAM设备的写操作。</p></li><li><p>你可以持续监测SRAM设备的状态。HAL_SRAM_GetState()</p></li></ol><h3 id="sram回调函数的注册">SRAM回调函数的注册</h3><p>当 USE_HAL_SRAM_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SRAM_RegisterCallback(),HAL_SRAM_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : SRAM 底层初始化回调函数</li><li>MspDeInitCallback : SRAM 底层析构回调函数</li></ul><p>默认情况下, SRAM 初始化（HAL_SRAM_Init()）后，当状态是HAL_SRAM_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SRAM_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SRAM_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于SRAM 内存的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;sram外设库的使用&quot;&gt;SRAM外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用的分层驱动，包含一套控制SRAM内存的API。它使用FSMC层函数与SRAM设备进行连接。要配置FSMC与SRAM/PSR</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sram" scheme="http://example.com/tags/sram/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_hcd库和pcd的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-hcd%E5%BA%93%E5%92%8Cpcd%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-hcd%E5%BA%93%E5%92%8Cpcd%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T10:30:31.000Z</published>
    <updated>2023-08-07T14:49:16.982Z</updated>
    
    <content type="html"><![CDATA[<p>Host Controller Driver 和 Peripheral ControllerDriver，分别简称HCD，PCD，它们是USB外设控制器相关驱动，下面来看看HAL库关于HCD和PCD的使用方法介绍。</p><h3 id="hcd外设库的使用">HCD外设库的使用</h3><ol type="1"><li>声明一个 HCD_HandleTypeDef 类型结构体。如：HCD_HandleTypeDefhhcd;</li><li>对hhcd结构体的各参数进行赋值。</li><li>初始化 HCD外设。HAL_HCD_Init();</li><li>初始化HCD底层。HAL_HCD_MspInit();<ul><li>使能 HCD/USB 底层接口时钟。__HAL_RCC_USB_OTG_FS_CLK_ENABLE();</li><li>初始化相关GPIO时钟</li><li>配置HCD引脚为输出模式</li><li>配置HCD NVIC中断</li></ul></li><li>将上层USB主机栈关联到HAL HCD驱动。hhcd.pData = phost;</li><li>使能HCD发送和接收。HAL_HCD_Start();</li></ol><h3 id="pcd外设库的使用">PCD外设库的使用</h3><ol type="1"><li>声明一个 PCD_HandleTypeDef 类型结构体。如：PCD_HandleTypeDefhpcd;</li><li>对hpcd结构体的各参数进行赋值。</li><li>初始化 PCD外设。HAL_PCD_Init();</li><li>初始化PCD底层。HAL_PCD_MspInit();<ul><li>使能 PCD/USB 底层接口时钟。<ul><li>对于一般USB设备：__HAL_RCC_USB_CLK_ENABLE();</li><li>对于USB全速设备：__HAL_RCC_USB_OTG_FS_CLK_ENABLE();</li></ul></li><li>初始化相关GPIO时钟</li><li>配置PCD引脚为输出模式</li><li>配置PCD NVIC中断</li></ul></li><li>将上层USB设备栈关联到HAL PCD驱动。hpcd.pData = pdev;</li><li>使能PCD发送和接收。HAL_PCD_Start();</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Host Controller Driver 和 Peripheral Controller
Driver，分别简称HCD，PCD，它们是USB外设控制器相关驱动，下面来看看HAL库关于HCD和PCD的使用方法介绍。&lt;/p&gt;
&lt;h3 id=&quot;hcd外设库的使用&quot;&gt;HCD</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="hcd" scheme="http://example.com/tags/hcd/"/>
    
    <category term="pcd" scheme="http://example.com/tags/pcd/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_eth库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-eth%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-eth%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T09:30:31.000Z</published>
    <updated>2023-08-07T05:07:43.020Z</updated>
    
    <content type="html"><![CDATA[<p>Ethernet，简称ETH，以太网，以下来看看HAL库关于ETH的使用方法。</p><h3 id="eth外设库的使用">ETH外设库的使用</h3><ol type="1"><li><p>声明一个ETH_HandleTypeDef 类型结构体，如：ETH_HandleTypeDefheth;</p></li><li><p>对初始化结构体heth中参数进行赋值。</p></li><li><p>初始化ETH。Call HAL_ETH_Init()</p></li><li><p>初始化ETH底层。HAL_ETH_MspInit()</p><ul><li><p>使能ETH接口时钟。<code>__HAL_RCC_ETHMAC_CLK_ENABLE()</code>，<code>__HAL_RCC_ETHMACTX_CLK_ENABLE()</code>，<code>__HAL_RCC_ETHMACRX_CLK_ENABLE()</code></p></li><li><p>初始化相关GPIO时钟。</p></li><li><p>配置ETH引脚为输出</p></li><li><p>配置ETH NVIC中断（中断模式）</p></li></ul></li><li><p>以链模式（chain mode ）初始化ETHDMA描述符并指向已分配的缓冲区：</p></li></ol><ul><li>发送过程：HAL_ETH_DMATxDescListInit()</li><li>接收过程：HAL_ETH_DMARxDescListInit()</li></ul><ol start="6" type="1"><li><p>使能MAC并进行DMA发送和接收。HAL_ETH_Start()</p></li><li><p>准备好 ETH DMA 发送描述符，助力于ETH DMA传输数据帧到 MAC TXFIFO。HAL_ETH_TransmitFrame()</p></li><li><p>轮询接收ETHDMA接收描述符中的数据帧，并获取数据帧参数。HAL_ETH_GetReceivedFrame()(在无限循环中调用)</p></li><li><p>当ETH接收中断发生时，获取一帧接收数据。HAL_ETH_GetReceivedFrame_IT()(仅在中断模式中调用)</p></li><li><p>与外部PHY通信:</p><ul><li>从PHY中读取指定寄存器。HAL_ETH_ReadPHYRegister();</li><li>向指定的PHY寄存器中写入数据。HAL_ETH_WritePHYRegister();</li></ul></li><li><p>当 ETH 外设初始化后配置MAC。HAL_ETH_ConfigMAC()</p><p>所有的MAC参数都应该赋值。</p></li><li><p>当 ETH 外设初始化后配置DMA 。HAL_ETH_ConfigDMA()</p><p>所有的DMA参数都应该赋值。</p></li></ol><p><strong>注意</strong>：本驱动不支持PTP 协议和DMA描述符环状模式（DMAdescriptors ring mode）。</p><h3 id="eth回调函数的注册">ETH回调函数的注册</h3><p>当 USE_HAL_ETH_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_ETH_RegisterCallback(),HAL_ETH_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>DMAErrorCallback : DMA 错误回调函数</li><li>MspInitCallback : 底层初始化回调函数</li><li>MspDeInitCallback: 底层析构回调函数</li></ul><p>默认情况下, ETH 初始化（HAL_ETH_Init()）后，当状态是HAL_ETH_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_ETH_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_ETH_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Ethernet，简称ETH，以太网，以下来看看HAL库关于ETH的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;eth外设库的使用&quot;&gt;ETH外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;声明一个ETH_HandleTypeDef 类型结构体，如：ETH_H</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="eth" scheme="http://example.com/tags/eth/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_cec库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-cec%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-cec%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T08:30:31.000Z</published>
    <updated>2023-08-07T05:07:43.010Z</updated>
    
    <content type="html"><![CDATA[<p>Consumer Electronics Control，简称CEC，消费电子控制，是一种允许用户通过一个遥控器控制多个电子设备的技术，通常用于家庭娱乐系统。以下来看看HAL库关于CEC的使用方法。</p><h3 id="cec外设库的使用">CEC外设库的使用</h3><ol type="1"><li><p>声明一个CEC_HandleTypeDef 类型结构体。</p></li><li><p>初始化CEC底层。HAL_CEC_MspInit()</p></li></ol><ul><li>使能CEC接口时钟。</li><li>配置CEC引脚<ul><li><p>使能CEC GPIO 时钟</p></li><li><p>配置CEC引脚为复用上拉模式</p></li><li><p>如果使用到中断，如：HAL_CEC_Transmit_IT() ，HAL_CEC_Receive_IT()</p><ul><li>配置CEC 中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC CEC IRQ。HAL_NVIC_EnableIRQ()</li><li>在发送和接收过程中使用宏定义 __HAL_CEC_ENABLE_IT() 和__HAL_CEC_DISABLE_IT()来控制CEC的中断（发送完成中断，接收非空中断，错误中断）。</li></ul></li></ul></li></ul><ol start="3" type="1"><li>在hcec初始化结构体中设置位定时错误模式和位周期错误模式。Bit TimingError Mode / Bit Period Error Mode</li><li>初始化CEC寄存器。HAL_CEC_Init()</li></ol><h3 id="cec回调函数的注册">CEC回调函数的注册</h3><p>当 USE_HAL_CEC_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_CEC_RegisterCallback(),HAL_CEC_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>ErrorCallback : 错误回调函数</li><li>MspInitCallback : CEC 底层初始化回调函数</li><li>MspDeInitCallback : CEC 底层析构回调函数</li></ul><p>默认情况下, CEC 初始化（HAL_CEC_Init()）后，当状态是HAL_CEC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_CEC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_CEC_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Consumer Electronics Control
，简称CEC，消费电子控制，是一种允许用户通过一个遥控器控制多个电子设备的技术，通常用于家庭娱乐系统。以下来看看HAL库关于CEC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;cec外设库的使用&quot;&gt;CEC外设库的使用&lt;/</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="cec" scheme="http://example.com/tags/cec/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_can库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-can%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-can%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T07:50:31.000Z</published>
    <updated>2023-08-07T05:07:43.010Z</updated>
    
    <content type="html"><![CDATA[<p>Controller AreaNetwork，简称CAN，控制器局域网，是一种用于实现设备间通信的网络技术，广泛应用于汽车、工业自动化等领域。以下来看看HAL库关于CAN的使用方法。</p><h3 id="can外设库的使用">CAN外设库的使用</h3><ol type="1"><li><p>初始化CAN底层。HAL_CAN_MspInit()</p><ul><li>使能CAN接口时钟。__HAL_RCC_CANx_CLK_ENABLE()</li><li>配置CAN引脚<ul><li>使能CAN GPIO 时钟</li><li>配置CAN引脚为复用开漏模式</li></ul></li><li>如果使用到中断，如：HAL_CAN_ActivateNotification()<ul><li>配置CAN 中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC CAN IRQ。HAL_NVIC_EnableIRQ()</li><li>调用HAL_CAN_IRQHandler()</li></ul></li></ul></li><li><p>初始化CAN外设。HAL_CAN_Init()</p><p>此初始化函数会使用HAL_CAN_MspInit() 为底层进行初始化。</p></li><li><p>配置接收过滤器。HAL_CAN_ConfigFilter()</p></li><li><p>开启CAN模组。HAL_CAN_Start()</p><p>此时CAN总线被激活，可以接收信息，也能发送信息。</p></li><li><p>为了管理信息发送，可以使用以下发送控制函数：</p><ul><li>请求发送新信息。HAL_CAN_AddTxMessage()</li><li>中止挂起信息的发送。HAL_CAN_AbortTxRequest()</li><li>获取空闲发送邮箱的数量 。HAL_CAN_GetTxMailboxesFreeLevel()</li><li>检查发送邮箱信息是否挂起。HAL_CAN_IsTxMessagePending()</li><li>当使能时间触发通信模式时，获取发送信息的时间戳。HAL_CAN_GetTxTimestamp()</li></ul></li><li><p>当CAN Rx FIFOs接收到一条信息时，可使用HAL_CAN_GetRxMessage()函数获取信息。HAL_CAN_GetRxFifoFillLevel()函数允许知道RxFIFO接收到多少信息。</p></li><li><p>停止CAN模组。HAL_CAN_Stop()</p></li><li><p>CAN的析构函数：HAL_CAN_DeInit()</p></li></ol><h3 id="can-轮询模式操作">CAN 轮询模式操作</h3><ul><li><p>接收</p><ul><li>监测信息的接收，直到至少接收到一条信息。HAL_CAN_GetRxFifoFillLevel()</li><li>获取信息。HAL_CAN_GetRxMessage()</li></ul></li><li><p>发送</p><ul><li>监测可用的发送邮箱，直到至少有一个发送邮箱是空闲的。HAL_CAN_GetTxMailboxesFreeLevel()</li><li>请求发送信息。HAL_CAN_AddTxMessage()</li></ul></li></ul><h3 id="can-中断模式操作">CAN 中断模式操作</h3><ul><li>使用HAL_CAN_ActivateNotification()函数激活通知提示，然后通过HAL_CAN_xxxCallback()回调函数来控制，使用同样的APIs：HAL_CAN_GetRxMessage() 和 HAL_CAN_AddTxMessage()</li><li>可使用 HAL_CAN_DeactivateNotification()函数使通知提示失效。</li><li>需要特别留心 <strong>CAN_IT_RX_FIFO0_MSG_PENDING</strong> 和<strong>CAN_IT_RX_FIFO1_MSG_PENDING</strong> 的通知提示，它们会触发HAL_CAN_RxFIFO0MsgPendingCallback() 和HAL_CAN_RxFIFO1MsgPendingCallback() 回调函数。这里有两种做法：<ul><li><ol type="1"><li>在回调函数中直接获取接收的信息。HAL_CAN_GetRxMessage()</li></ol></li><li><ol start="2" type="1"><li>在回调函数中让通知提示失效，而不获取接收的信息。之后使用HAL_CAN_GetRxMessage()函数获取接收的信息，一旦读取接收的信息，通知提示就会被再次激活。</li></ol></li></ul></li></ul><h3 id="can-睡眠模式">CAN 睡眠模式</h3><ul><li><p>CAN 外设可进入睡眠模式（低功耗）。HAL_CAN_RequestSleep()</p><p>只要当前CAN完成发送或接收过程就能进入睡眠模式。</p></li><li><p>当进入睡眠模式时，可激活一个通知用来提示。</p></li><li><p>HAL_CAN_IsSleepActive()函数可用来检查CAN是否进入睡眠模式。<strong>注意</strong>：只要发送了睡眠模式请求（还没进入睡眠模式），CAN的状态（用HAL_CAN_GetState()函数获取）是HAL_CAN_STATE_SLEEP_PENDING，当睡眠模式生效，它的状态就是HAL_CAN_STATE_SLEEP_ACTIVE</p></li><li><p>从睡眠模式中唤醒有两种方式：</p><ul><li><p>使用函数： HAL_CAN_WakeUp()</p><p>当从此函数返回，就会退出睡眠模式（返回状态是 HAL_OK）。</p></li><li><p>如果激活自动唤醒模式，当CAN外设检测到RxCAN数据帧的开启。</p></li></ul></li></ul><h3 id="can回调函数的注册">CAN回调函数的注册</h3><p>当 USE_HAL_CAN_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_CAN_RegisterCallback(),HAL_CAN_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxMailbox0CompleteCallback : 邮箱0发送完成回调函数</li><li>TxMailbox1CompleteCallback : 邮箱1发送完成回调函数</li><li>TxMailbox2CompleteCallback : 邮箱2发送完成回调函数</li><li>TxMailbox0AbortCallback : 中止邮箱0的发送回调函数</li><li>TxMailbox1AbortCallback : 中止邮箱1的发送回调函数</li><li>TxMailbox2AbortCallback : 中止邮箱2的发送回调函数</li><li>RxFifo0MsgPendingCallback : Rx FIFO0 信息挂起回调函数</li><li>RxFifo0FullCallback : Rx FIFO0 已满回调函数</li><li>RxFifo1MsgPendingCallback : Rx FIFO1 信息挂起回调函数</li><li>RxFifo1FullCallback : Rx FIFO1 已满回调函数</li><li>SleepCallback : 睡眠回调函数</li><li>WakeUpFromRxMsgCallback : 从接收到信息唤醒回调函数</li><li>ErrorCallback : 错误回调函数</li><li>MspInitCallback : CAN 底层初始化回调函数</li><li>MspDeInitCallback : CAN 底层析构回调函数</li></ul><p>默认情况下, CAN 初始化（HAL_CAN_Init()）后，当状态是HAL_CAN_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_CAN_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_CAN_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Controller Area
Network，简称CAN，控制器局域网，是一种用于实现设备间通信的网络技术，广泛应用于汽车、工业自动化等领域。以下来看看HAL库关于CAN的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;can外设库的使用&quot;&gt;CAN外设库的使用&lt;/h3&gt;
&lt;ol</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="can" scheme="http://example.com/tags/can/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_i2s库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-i2s%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-i2s%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T05:50:31.000Z</published>
    <updated>2023-08-07T05:07:43.020Z</updated>
    
    <content type="html"><![CDATA[<p>Integrated InterchipSound，简称I2S，是关于音频相关的驱动，下面来看看HAL库关于I2S的使用方法。</p><h3 id="i2s外设库的使用">I2S外设库的使用</h3><ol type="1"><li>声明一个 I2S_HandleTypeDef 结构体,如：I2S_HandleTypeDef hi2s;</li><li>初始化I2S底层。HAL_I2S_MspInit()</li></ol><ul><li>使能SPIx 接口时钟。</li><li>配置I2S引脚<ul><li>使能I2S GPIO 时钟</li><li>配置I2S引脚为复用上拉模式</li></ul></li><li>如果使用到中断，则配置NVIC。HAL_I2S_Transmit_IT() 和HAL_I2S_Receive_IT()<ul><li>配置I2Sx 中断优先级</li><li>使能NVIC I2S IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_I2S_Transmit_DMA() 和HAL_I2S_Receive_DMA()<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体Tx、Rx参数。</li><li>配置DMA Tx或Rx通道。</li><li>将DMA句柄和hi2s DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置hi2s初始化结构体中各参数。</li><li>I2S中断模式（发送完成中断，接收非空中断，错误中断）下发送和接收过程中，使用宏定义__HAL_I2S_ENABLE_IT() 和 __HAL_I2S_DISABLE_IT()来控制。</li><li>I2SxCLK 时钟源是系统时钟（由HSI、HSE或PLL提供，产生 AHB时钟源）。对于互联型芯片，为了获得最大的精确度，I2SxCLK时钟源可以由SYSCLK 时钟或 PLL3 VCO (2 x PLL3CLK)时钟提供。</li></ol><h3 id="i2s-io操作的三种模式">I2S IO操作的三种模式：</h3><ul><li><p>轮询模式IO操作</p><ul><li>阻塞模式下发送一定数量的数据。HAL_I2S_Transmit()</li><li>阻塞模式下接收一定数量的数据。HAL_I2S_Receive()</li></ul></li><li><p>中断模式IO操作</p><ul><li><p>非阻塞模式下发送一定数量的数据。HAL_I2S_Transmit_IT()</p><p>发送过半，执行发送过半回调函数，用户自行添加代码。HAL_I2S_TxHalfCpltCallback()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_I2S_TxCpltCallback()</p></li><li><p>非阻塞模式下接收一定数量的数据。HAL_I2S_Receive_IT()</p><p>接收过半，执行接收过半回调函数，用户自行添加代码。HAL_I2S_RxHalfCpltCallback()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_I2S_RxCpltCallback()</p></li><li><p>当传输发生错误时，执行错误回调函数，用户自行添加代码。HAL_I2S_ErrorCallback()</p></li></ul></li><li><p>DMA模式IO操作</p><ul><li><p>非阻塞模式下(DMA)发送一定数量的数据。HAL_I2S_Transmit_DMA()</p><p>发送过半，执行发送过半回调函数，用户自行添加代码。HAL_I2S_TxHalfCpltCallback()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_I2S_TxCpltCallback()</p></li><li><p>非阻塞模式下(DMA)接收一定数量的数据。HAL_I2S_Receive_DMA()</p><p>接收过半，执行接收过半回调函数，用户自行添加代码。HAL_I2S_RxHalfCpltCallback()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_I2S_RxCpltCallback()</p></li><li><p>当传输发生错误时，执行错误回调函数，用户自行添加代码。HAL_I2S_ErrorCallback()</p></li><li><p>暂停DMA传输。HAL_I2S_DMAPause()</p></li><li><p>恢复DMA传输。HAL_I2S_DMAResume()</p></li><li><p>停止DMA传输。HAL_I2S_DMAStop()</p><p>在从模式下，如果HAL_I2S_DMAStop()用来停止通信，当主机继续传输数据时，HAL_I2S_ERROR_BUSY_LINE_RX就会产生错误。当__HAL_I2S_FLUSH_RX_DR宏用来刷新数据寄存器中的剩余值时，要避免在下次传输时使用DeInit/Init进程。</p></li></ul></li></ul><h3 id="i2s-hal常用宏定义">I2S HAL常用宏定义</h3><ul><li>__HAL_I2S_ENABLE: 使能SPI外设 (I2S 模式)</li><li>__HAL_I2S_DISABLE: 禁止SPI外设 (I2S 模式)</li><li>__HAL_I2S_ENABLE_IT : 使能I2S中断</li><li>__HAL_I2S_DISABLE_IT : 禁止I2S中断</li><li>__HAL_I2S_GET_FLAG: 检查I2S标志是否设置</li><li>__HAL_I2S_FLUSH_RX_DR: 读取数据寄存器的值来刷新接收的数据</li></ul><h3 id="i2s回调函数的注册">I2S回调函数的注册</h3><p>当 USE_HAL_I2S_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_I2S_RegisterCallback(),HAL_I2S_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : I2S 发送完成回调函数</li><li>RxCpltCallback : I2S 接收完成回调函数</li><li>TxHalfCpltCallback : I2S 发送过半回调函数</li><li>RxHalfCpltCallback : I2S 接收过半回调函数</li><li>ErrorCallback : I2S 错误回调函数</li><li>MspInitCallback : I2S 底层初始化回调函数</li><li>MspDeInitCallback : I2S 底层析构回调函数</li></ul><p>默认情况下, I2S 初始化（HAL_I2S_Init()）后，当状态是HAL_I2S_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_I2S_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_I2S_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p><h3 id="i2s勘误">I2S勘误</h3><p>主机模式时，I2S仅支持无数据扩展的16位模式，和使用PCM长同步模式（PCMlong synchronization mode）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Integrated Interchip
Sound，简称I2S，是关于音频相关的驱动，下面来看看HAL库关于I2S的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;i2s外设库的使用&quot;&gt;I2S外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;声明一个 I2S_Han</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="i2s" scheme="http://example.com/tags/i2s/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_i2c库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-i2c%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-i2c%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T01:10:31.000Z</published>
    <updated>2023-08-07T05:07:43.020Z</updated>
    
    <content type="html"><![CDATA[<p>Inter Integrated Circuit，简称I2C，下面来看看 I2CHAL库关于I2C的使用方法。</p><h3 id="i2c外设库的使用">I2C外设库的使用</h3><ol type="1"><li>声明一个 I2C_HandleTypeDef 结构体,如：I2C_HandleTypeDef hi2c;</li><li>初始化I2C底层。HAL_I2C_MspInit()</li></ol><ul><li><p>使能I2Cx 接口时钟。</p></li><li><p>配置I2C引脚</p><ul><li>使能I2C GPIO 时钟</li><li>配置I2C引脚为复用开漏模式</li></ul></li><li><p>如果使用到中断，则配置NVIC</p><ul><li>配置I2Cx 中断优先级</li><li>使能NVIC I2C IRQ通道</li></ul></li><li><p>如果使用到DMA，则配置DMA</p><ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA句柄参数。</li><li>配置DMA Tx或Rx通道。</li><li>将DMA句柄和hi2c DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置hi2c初始化结构体中各参数。</li><li>初始化I2C寄存器，HAL_I2C_Init()，同时配置底层硬件（GPIO，CLOCK，NVIC等等）HAL_I2C_MspInit()。</li><li>检查目标设备是否已经准备好通信。HAL_I2C_IsDeviceReady()</li></ol><h3 id="i2c-io操作的三种模式">I2C IO操作的三种模式：</h3><ul><li><p>轮询模式IO操作</p><ul><li>主模式下，以阻塞方式发送一定数量的数据。HAL_I2C_Master_Transmit()</li><li>主模式下，以阻塞方式接收一定数量的数据。HAL_I2C_Master_Receive()</li><li>从模式下，以阻塞方式发送一定数量的数据。HAL_I2C_Slave_Transmit()</li><li>从模式下，以阻塞方式接收一定数量的数据。HAL_I2C_Slave_Receive()</li></ul></li><li><p>中断模式IO操作</p><ul><li><p>主模式下，以非阻塞方式发送一定数量的数据。HAL_I2C_Master_Transmit_IT()</p><p>发送完成后，执行回调函数，用户自行添加代码。HAL_I2C_MasterTxCpltCallback()</p></li><li><p>主模式下，以非阻塞方式接收一定数量的数据。HAL_I2C_Master_Receive_IT()</p><p>接收完成后，执行回调函数，用户自行添加代码。HAL_I2C_MasterRxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式发送一定数量的数据。HAL_I2C_Slave_Transmit_IT()</p><p>发送完成后，执行回调函数，用户自行添加代码。HAL_I2C_SlaveTxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式接收一定数量的数据。HAL_I2C_Slave_Receive_IT()</p><p>接收完成后，执行回调函数，用户自行添加代码。HAL_I2C_SlaveRxCpltCallback()</p></li><li><p>如果传输出错，则执行错误回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li><li><p>主模式下，使用中断中止通信。HAL_I2C_Master_Abort_IT()</p></li><li><p>中止通信后执行中止回调函数，用户自行添加代码。HAL_I2C_AbortCpltCallback()</p></li></ul></li><li><p>DMA模式IO操作</p><ul><li><p>主模式下，以非阻塞方式（DMA）传输一定数量的数据。HAL_I2C_Master_Transmit_DMA()</p><p>传输完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterTxCpltCallback()</p></li><li><p>主模式下，以非阻塞方式（DMA）接收一定数量的数据。HAL_I2C_Master_Receive_DMA()</p><p>接收完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterRxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式（DMA）传输一定数量的数据。HAL_I2C_Slave_Transmit_DMA()</p><p>传输完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveTxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式（DMA）接收一定数量的数据。HAL_I2C_Slave_Receive_DMA()</p><p>接收完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveRxCpltCallback()</p></li><li><p>当传输出错时，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li><li><p>中止主模式下的传输。HAL_I2C_Master_Abort_IT()</p><p>中止的末尾，执行回调函数，用户自行添加代码。HAL_I2C_AbortCpltCallback()</p></li></ul></li></ul><h3 id="i2c-io-内存操作的三种模式">I2C IO 内存操作的三种模式</h3><ul><li><p>轮询模式IO内存操作</p><ul><li>以阻塞方式向指定的内存地址写入一定数量的数据。HAL_I2C_Mem_Write()</li><li>以阻塞方式从指定的内存地址读出一定数量的数据。HAL_I2C_Mem_Read()</li></ul></li><li><p>中断模式下IO内存操作</p><ul><li><p>非阻塞方式下，向指定的内存地址写入一定数量的数据。HAL_I2C_Mem_Write_IT()</p><p>在内存写传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemTxCpltCallback()</p></li><li><p>非阻塞方式下，从指定的内存地址读出一定数量的数据。HAL_I2C_Mem_Read_IT()</p><p>在内存读传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemRxCpltCallback()</p></li><li><p>传输出错时，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li></ul></li><li><p>DMA模式IO内存操作</p><ul><li><p>以非阻塞方式（DMA）向指定的内存地址写入一定数量的数据。HAL_I2C_Mem_Write_DMA()</p><p>在内存写传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemTxCpltCallback()</p></li><li><p>以非阻塞方式（DMA）从指定的内存地址读出一定数量的数据。HAL_I2C_Mem_Read_DMA()</p><p>在内存读传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemRxCpltCallback()</p></li><li><p>当传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li></ul></li></ul><h3id="i2c中断或dma模式下-io-顺序操作-sequential-operation">I2C中断或DMA模式下IO 顺序操作 （sequential operation）</h3><p>在传输过程中方向改变时，这些接口允许通过重复启动来控制传输顺序。</p><ul><li><p>通过一个指定的可选域（Optionfield）来控制顺序传输的步骤。</p></li><li><p>可选域的值通过 <strong>I2C_XferOptions_definition</strong>来定义：</p><ol type="1"><li><p>I2C_FIRST_AND_LAST_FRAME：用于非顺序传输，功能与非顺序模式下的关联接口相同。</p></li><li><p>I2C_FIRST_FRAME：用于顺序传输，此选项允许控制传输有开启条件，地址和传输的数据而没有停止条件。</p></li><li><p>I2C_FIRST_AND_NEXT_FRAME：仅主模式下用于顺序传输，此选项允许控制传输有开启条件，地址和传输的数据而没有停止条件，然后允许多次调用主模式下顺序传输接口函数（如：HAL_I2C_Master_Seq_Transmit_IT()或 HAL_I2C_Master_Seq_Transmit_DMA()）。</p></li><li><p>I2C_NEXT_FRAME：用于顺序传输，此选项允许控制传输有重新开启条件，地址以及当方向改变时新的传输数据或方向未改变时仅控制传输的新数据而没有停止条件。</p></li><li><p>I2C_LAST_FRAME：用于顺序传输，此选项允许控制传输有重新开启条件，地址以及当方向改变时新的传输数据或方向未改变时仅控制传输的新数据，最后加上停止条件。</p></li><li><p>I2C_LAST_FRAME_NO_STOP：仅主模式下用于顺序传输，当多次调用同一个主模式顺序接口（类同于I2C_FIRST_AND_NEXT_FRAME）后，此选项允许控制一个重新开启条件。用法是逐个传输多个字节：HAL_I2C_Master_Seq_Transmit_IT、HAL_I2C_Master_Seq_Receive_IT、HAL_I2C_Master_Seq_Transmit_DMA、HAL_I2C_Master_Seq_Receive_DMA(可选I2C_FIRST_AND_NEXT_FRAME 然后I2C_NEXT_FRAME)。 I2C_LAST_FRAME_NO_STOP的用途是在最后一个顺序传输或接收，允许调用相反的接口来接收或传输，而不需要停止通信和产生重新开启条件。</p></li><li><p>I2C_OTHER_FRAME:仅主模式下用于顺序传输，当每次调用同一个主模式顺序接口后，此选项允许控制一个重新开启条件。用法是逐个传输多个字节，每个字节之间重新启动从设备地址：HAL_I2C_Master_Seq_Transmit_IT、HAL_I2C_Master_Seq_Receive_IT、HAL_I2C_Master_Seq_Transmit_DMA、HAL_I2C_Master_Seq_Receive_DMA（可选I2C_FIRST_FRAME然后 I2C_OTHER_FRAME）。I2C_OTHER_AND_LAST_FRAME的用途是在最后一个传输时帮助自动产生停止条件。</p></li></ol></li><li><p>不同顺序的I2C接口如下：</p><ol type="1"><li><p>主模式下,以非阻塞方式顺序发送一定数量的数据。HAL_I2C_Master_Seq_Transmit_IT()或HAL_I2C_Master_Seq_Transmit_DMA()</p><p>当前帧传输完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterTxCpltCallback()</p></li><li><p>主模式下,以非阻塞方式顺序接收一定数量的数据。HAL_I2C_Master_Seq_Receive_IT()或HAL_I2C_Master_Seq_Receive_DMA()</p><p>当前帧接收完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterRxCpltCallback()</p></li><li><p>主模式下，以中断方式中止中断或DMA通信。HAL_I2C_Master_Abort_IT()</p><p>中止后，执行回调函数，用户自行添加代码。HAL_I2C_AbortCpltCallback()</p></li><li><p>从模式下，使能、禁止地址监听模式(Address listenmode)。HAL_I2C_EnableListen_IT() ，HAL_I2C_DisableListen_IT()</p><p>当从设备地址匹配，执行回调函数，用户自行添加地址匹配的检查代码和主设备请求的传输方向（写、读）代码。HAL_I2C_AddrCallback()</p><p>在监听模式末尾，执行回调函数，用户自行添加代码。HAL_I2C_ListenCpltCallback()</p></li><li><p>从模式下，以非阻塞方式顺序发送一定数量的数据。HAL_I2C_Slave_Seq_Transmit_IT()或HAL_I2C_Slave_Seq_Transmit_DMA()</p><p>当前帧发送完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveTxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式顺序接收一定数量的数据。HAL_I2C_Slave_Seq_Receive_IT()或HAL_I2C_Slave_Seq_Receive_DMA()</p><p>当前帧接收完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveRxCpltCallback()</p></li><li><p>当传输出错时，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li></ol></li></ul><h3 id="i2c-hal常用宏定义">I2C HAL常用宏定义</h3><ul><li>__HAL_I2C_ENABLE: 使能I2C外设</li><li>__HAL_I2C_DISABLE: 禁止 I2C 外设</li><li>__HAL_I2C_GET_FLAG: 检查I2C标志是否设置</li><li>__HAL_I2C_CLEAR_FLAG: 清除I2C挂起标志</li><li>__HAL_I2C_ENABLE_IT: 使能I2C中断</li><li>__HAL_I2C_DISABLE_IT: 禁止I2C中断</li></ul><h3 id="i2c回调函数的注册">I2C回调函数的注册</h3><p>当 USE_HAL_I2C_REGISTER_CALLBACKS 为1时，允许用户注册或注销回调函数。HAL_I2C_RegisterCallback()或HAL_I2C_RegisterAddrCallback()，HAL_I2C_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>MasterTxCpltCallback : 主机发送完成回调函数</p></li><li><p>MasterRxCpltCallback : 主机接收完成回调函数</p></li><li><p>SlaveTxCpltCallback : 从机发送完成回调函数</p></li><li><p>SlaveRxCpltCallback : 从机接收完成回调函数</p></li><li><p>ListenCpltCallback : 监听模式完成回调函数</p></li><li><p>MemTxCpltCallback : 内存发送完成回调函数</p></li><li><p>MemRxCpltCallback : 内存接收完成回调函数</p></li><li><p>ErrorCallback : 错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>MspInitCallback : 底层初始化回调函数</p></li><li><p>MspDeInitCallback : 底层析构回调函数</p></li></ul><p>默认情况下, I2C 初始化（HAL_I2C_Init()）后，当状态是HAL_I2C_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_I2C_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_I2C_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p><h3 id="i2c勘误">I2C勘误</h3><p>i2c因为硅限制，会发生以下错误，所以对于 STM32F1xx 芯片，官方对 I2CHAL Driver给出了临时措施，详细内容查看 ErrataSheet：</p><ol type="1"><li><p>将错误的数据读到数据寄存器 (轮询和中断模式)</p></li><li><p>错位的停止条件后，不能产生开启条件。</p></li><li><p>在传输当前字节之前，必须管理一些软件事件。</p><p>临时措施：一般使用DMA，除了当主机正在接收一个字节。对于中断模式，I2C应该有最高优先级。</p></li><li><p>重启条件的Setup时间参数不匹配。</p><p>临时措施：减少频率到88kHz或当从机支持I2C快速模式，则使用快速模式。</p></li><li><p>数据有效时间 (tVD;DAT) 违反而没有设置OVR标志。</p><p>临时措施：如果从机允许，使用时钟扩展机制，在 HAL_I2C_Init()中将NoStretchMode = I2C_NOSTRETCH_DISABLE 。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Inter Integrated Circuit，简称I2C，下面来看看 I2C
HAL库关于I2C的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;i2c外设库的使用&quot;&gt;I2C外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;声明一个 I2C_HandleTypeD</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="i2c" scheme="http://example.com/tags/i2c/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_irda库的使用</title>
    <link href="http://example.com/2023/08/05/stm32f1xx-hal-irda%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/05/stm32f1xx-hal-irda%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-05T14:19:31.000Z</published>
    <updated>2023-08-08T00:27:17.356Z</updated>
    
    <content type="html"><![CDATA[<p>infrared data association, 红外通信技术，简称IRDA，通过USART同步串口进行数据传输。HAL库中关于IRDA外设库的使用方法如下：</p><h3 id="irda外设库的使用">IRDA外设库的使用</h3><ol type="1"><li>声明一个 IRDA_HandleTypeDef结构体句柄。如： IRDA_HandleTypeDefhirda。</li><li>初始化IRDA底层配置。HAL_IRDA_MspInit()<ul><li>使能串口 USARTx 时钟。</li><li>IRDA引脚的配置。<ul><li>使能IRDA GPIO时钟。</li><li>配置 IRDA 引脚为复用功能，上拉。</li></ul></li><li>如果需要使用中断，则配置NVIC。HAL_IRDA_Transmit_IT()，HAL_IRDA_Receive_IT()<ul><li>配置串口 USARTx 中断优先级</li><li>使能NVIC USART IRQ中断。</li></ul></li><li>如果需要使用DMA，则配置DMA。HAL_IRDA_Transmit_DMA()，HAL_IRDA_Receive_DMA()<ul><li>为串口Tx和Rx通道声明一个DMA结构体句柄。</li><li>使能DMAx接口时钟。</li><li>配置刚声明的DMA结构体中所需要的Tx/Rx参数。</li><li>配置DMA Tx/Rx 通道。</li><li>将DMA句柄和串口Tx/Rx句柄进行关联。</li><li>当DMATx/Rx通道数据传输完成产生中断时，则配置NVIC的优先级并使能。</li><li>配置USART中断优先级并使能NVIC USARTIRQ中断。（用于DMA非循环模式下的最后一个字节发送完成的检测）</li></ul></li></ul></li><li>在串口hirda初始化结构体中配置串口的波特率、字节长度，停止位，奇偶校验位，硬件流控和模式（接收/发送）。</li><li>初始化IRDA寄存器。HAL_IRDA_Init()</li></ol><p>指定的IRDA中断(传输完成中断，接收非空中断和错误中断）可使用宏定义控制。__HAL_IRDA_ENABLE_IT(), __HAL_IRDA_DISABLE_IT()</p><p>HAL_IRDA_Init()底层硬件初始化都会调用 HAL_IRDA_MspInit()。</p><h3 id="irda的操作模式">IRDA的操作模式</h3><ul><li>轮询模式IO的操作<ul><li>以阻塞模式发送一定数量的数据。HAL_IRDA_Transmit()</li><li>以阻塞模式接收一定数量的数据。HAL_IRDA_Receive()</li></ul></li><li>中断模式IO的操作<ul><li>非阻塞模式发送一定数量的数据。HAL_IRDA_Transmit_IT()</li><li>传输完成，执行HAL_IRDA_TxCpltCallback()回调函数，用户自行添加代码。</li><li>非阻塞模式接收一定数量的数据。HAL_IRDA_Receive_IT()</li><li>接收完成，执行HAL_IRDA_RxCpltCallback()回调函数，用户自行添加代码。</li><li>当传输出错时，执行HAL_IRDA_ErrorCallback()回调函数，用户自行添加代码。</li></ul></li><li>DMA模式IO的操作<ul><li>非阻塞DMA模式发送一定数量的数据。HAL_IRDA_Transmit_DMA()</li><li>传输过半，执行 HAL_IRDA_TxHalfCpltCallback()回调函数，用户自行添加代码。</li><li>传输完成，执行 HAL_IRDA_TxCpltCallback()回调函数，用户自行添加代码。</li><li>非阻塞DMA模式接收一定数量的数据。HAL_IRDA_Receive_DMA()</li><li>接收过半，执行HAL_IRDA_RxHalfCpltCallback()回调函数，用户自行添加代码。</li><li>接收完成，执行HAL_IRDA_RxCpltCallback()回调函数，用户自行添加代码。</li><li>当传输出错时，执行HAL_IRDA_ErrorCallback()回调函数，用户自行添加代码。</li><li>DMA传输暂停。 HAL_IRDA_DMAPause()</li><li>重新开始串口DMA传输。HAL_IRDA_DMAResume()</li><li>停止串口DMA传输。HAL_IRDA_DMAStop()</li></ul></li></ul><h3 id="irda-hal常用宏定义列表">IRDA HAL常用宏定义列表</h3><ul><li>__HAL_IRDA_ENABLE: 使能IRDA</li><li>__HAL_IRDA_DISABLE: 关闭IRDA</li><li>__HAL_IRDA_GET_FLAG : 获取IRDA标志是否设置</li><li>__HAL_IRDA_CLEAR_FLAG : 清除IRDA挂起标志</li><li>__HAL_IRDA_ENABLE_IT: 使能IRDA中断</li><li>__HAL_IRDA_DISABLE_IT: 关闭IRDA中断</li><li>__HAL_IRDA_GET_IT_SOURCE: 检查IRDA是否发生中断</li></ul><h3 id="回调函数的注册">回调函数的注册</h3><ol type="1"><li>USE_HAL_IRDA_REGISTER_CALLBACKS设置为1，用户就可以使用回调函数了。回调函数的注册和注销函数分别是：HAL_IRDA_RegisterCallback()、HAL_IRDA_UnRegisterCallback()</li></ol><p>​ 回调函数ID：</p><ul><li><p>TxHalfCpltCallback : 发送过半回调函数</p></li><li><p>TxCpltCallback : 发送完成回调函数</p></li><li><p>RxHalfCpltCallback : 接收过半回调函数</p></li><li><p>RxCpltCallback : 接收完成回调函数</p></li><li><p>ErrorCallback : 发生错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>AbortTransmitCpltCallback : 中止发生完成回调函数</p></li><li><p>AbortReceiveCpltCallback : 中止接收完成回调函数</p></li><li><p>MspInitCallback : IRDA底层初始化回调函数</p></li><li><p>MspDeInitCallback : IRDA析构回调函数</p></li></ul><ol start="2" type="1"><li>默认情况下，IRDA初始化之后，当它的状态是<strong>HAL_IRDA_STATE_RESET</strong>，所有的回调函数被设置为相应的弱函数。如：HAL_IRDA_TxCpltCallback(),HAL_IRDA_RxHalfCpltCallback()。</li><li>只有在IRDA状态HAL_IRDA_STATE_READY 时，回调函数才能注册或注销。</li><li>当USE_HAL_IRDA_REGISTER_CALLBACKS设置为0，注册的回调函数特性就不能使用，回调函数就当作一个弱函数使用。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;infrared data association, 红外通信技术，简称
IRDA，通过USART同步串口进行数据传输。HAL库中关于IRDA外设库的使用方法如下：&lt;/p&gt;
&lt;h3 id=&quot;irda外设库的使用&quot;&gt;IRDA外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="irda" scheme="http://example.com/tags/irda/"/>
    
  </entry>
  
</feed>
