<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-02T05:15:53.875Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tkinter widgets 窗口管理</title>
    <link href="http://example.com/2024/01/02/tkinter-widgets-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2024/01/02/tkinter-widgets-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86/</id>
    <published>2024-01-02T02:36:14.000Z</published>
    <updated>2024-01-02T05:15:53.875Z</updated>
    
    <content type="html"><![CDATA[<p>Tkinter 多个控件被摆放到父窗口时，就需要进行布局管理（<font color="#0000FF">geometry management</font>），tkinter中提供了三种管理方法，分别如下：</p><ul><li>pack()</li></ul><p>按照控件的添加顺序从上到下依次排列，通过代码可以直观知道摆放情况。</p><ul><li>grid()</li></ul><p>以行列网格形式进行排列。</p><ul><li>pace()</li></ul><p>精确指定控件的摆放位置。</p><h1 id="pack方法">pack()方法</h1><p>属性参数有：</p><table><thead><tr class="header"><th>属性</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>anchor</td><td>控件在窗口中的对齐方位："n"/"w"/"s"/"e"/"ne"/"nw"/"sw"/"se"/"center"</td></tr><tr class="even"><td><strong>expand</strong></td><td>控件是否随着窗口扩展，参数值： True / False，默认为 False</td></tr><tr class="odd"><td><strong>fill</strong></td><td>控件可在水平/垂直/同时在两个方向上进行拉伸，参数值： X/Y/BOTH/NONE</td></tr><tr class="even"><td>ipadx,ipady</td><td>控件边框与内容的距离（内边距），单位为像素</td></tr><tr class="odd"><td>padx,pady</td><td>控件之间的上下、左右的距离（外边距），单位为像素</td></tr><tr class="even"><td><strong>side</strong></td><td>控件在窗口的位置，参数值： 'top','bottom','left','right'。</td></tr></tbody></table><h1 id="grid方法">grid()方法</h1><p>属性参数有：</p><table><thead><tr class="header"><th>属性</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><strong>column</strong></td><td>控件位于表格中列数，默认为第 0 列</td></tr><tr class="even"><td><strong>columnspan</strong></td><td>控件所跨的列数，默认为 1 列，通过该参数可以合并一行中多个单元格。</td></tr><tr class="odd"><td>ipadx,ipady</td><td>用于控制内边距，在单元格内部，左右、上下方向上填充指定大小的空间。</td></tr><tr class="even"><td>padx,pady</td><td>用于控制外边距，在单元格外部，左右、上下方向上填充指定大小的空间。</td></tr><tr class="odd"><td><strong>row</strong></td><td>控件位于表格中行数，默认为第 0 行</td></tr><tr class="even"><td><strong>rowspan</strong></td><td>控件所跨的行数，默认为 1 行，通过该参数可以合并一列中多个单元格。</td></tr><tr class="odd"><td><strong>sticky</strong></td><td>功能类似于 anchor，参数：N/S/W/E,即上下左右对齐，或组合使用，默认居中对齐。</td></tr></tbody></table><h1 id="place方法">place()方法</h1><p>属性参数有：</p><table><thead><tr class="header"><th>属性</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>anchor</td><td>控件在窗口中的对齐方位："n"/"w"/"s"/"e"/"ne"/"nw"/"sw"/"se"/"center"</td></tr><tr class="even"><td><strong>x,y</strong></td><td>定义控件在窗体中左上方位置</td></tr><tr class="odd"><td><strong>relx,rely</strong></td><td>相对于父窗口的位置比例，取值范围： 0.0~1.0</td></tr><tr class="even"><td>height,width</td><td>控件的高度和宽度（单位为像素）</td></tr><tr class="odd"><td><strong>relheight,relwidth</strong></td><td>相对于父窗口的大小比例，取值范围： 0.0~1.0</td></tr></tbody></table><p><span style="color:red"><strong>注意：</strong></span>在一个父窗口中，place()可以和grid()或pack()方法混合使用，但grid()和pack()方法不能混合使用。</p><p>一般在应用中使用pack()和grid()方法比较多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Tkinter 多个控件被摆放到父窗口时，就需要进行布局管理（&lt;font color=&quot;#0000FF&quot;&gt;geometry management&lt;/font&gt;），tkinter中提供了三种管理方法，分别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pack()&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="layout" scheme="http://example.com/tags/layout/"/>
    
  </entry>
  
  <entry>
    <title>Python tkinter 主窗口与控件</title>
    <link href="http://example.com/2024/01/01/Python-tkinter-%E4%B8%BB%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%8E%A7%E4%BB%B6/"/>
    <id>http://example.com/2024/01/01/Python-tkinter-%E4%B8%BB%E7%AA%97%E5%8F%A3%E4%B8%8E%E6%8E%A7%E4%BB%B6/</id>
    <published>2024-01-01T12:54:24.000Z</published>
    <updated>2024-01-02T02:29:24.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tkinter-主窗口">Tkinter 主窗口</h1><p>Hardware --&gt; OS --&gt; Tcl/Tk --&gt; tkinter --&gt; Python</p><p><font color="#FF33FF">tkinter module(Python 3.x --&gt; tkinter, Python 2.x --&gt; Tkinter)</font></p><p>导入 tkinter module： <code>from tkinter import *</code> or <code>import tkinter</code></p><p>创建主窗口,如: <code>window = Tk()</code> or <code>window = tkinter.Tk()</code></p><div class="code-wrapper"><pre><code class="hljs python">Tk(screenName=<span class="hljs-literal">None</span>, baseName=<span class="hljs-literal">None</span>, className=<span class="hljs-string">&#x27;Tk’, useTk=1)</span></code></pre></div><p>窗口的相关方法：</p><table><thead><tr class="header"><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>window.title("my title")</td><td>接受一个字符串参数，为窗口起一个标题</td></tr><tr class="even"><td>window.resizable()</td><td>是否允许用户拉伸主窗口大小，默认为可更改，当设置为 resizable(0,0)或者resizable(False,False)时不可更改,help(tkinter.Tk().resizable)</td></tr><tr class="odd"><td>window.geometry("widthxheight+x+y")</td><td>设定主窗口的大小以及位置，当参数值为 None 时表示获取窗口的大小和位置信息。</td></tr><tr class="even"><td>window.quit()</td><td>关闭当前窗口</td></tr><tr class="odd"><td>window.update()</td><td>刷新当前窗口</td></tr><tr class="even"><td>window.mainloop()</td><td>设置窗口主循环，使窗口循环显示（一直显示，指导窗口被关闭）</td></tr><tr class="odd"><td>window.iconbitmap('xx.ico')</td><td>设置窗口左上角的图标（图标是.ico文件类型）</td></tr><tr class="even"><td>window.config(background ="red")</td><td>设置窗口的背景色为红色，也可以接受 16 进制的颜色值</td></tr><tr class="odd"><td>window.minsize(50,50)</td><td>设置窗口被允许调整的最小范围，即宽和高各50</td></tr><tr class="even"><td>window.maxsize(400,400)</td><td>设置窗口被允许调整的最大范围，即宽和高各400</td></tr><tr class="odd"><td>window.attributes("-alpha",0.5)</td><td>用来设置窗口的一些属性，比如透明度（-alpha）、是否置顶（-topmost）即将主屏置于其他图标之上、是否全屏（-fullscreen）全屏显示等</td></tr><tr class="even"><td>window.state("normal")</td><td>用来设置窗口的显示状态，参数值 normal（正常显示），icon（最小化），zoomed（最大化），</td></tr><tr class="odd"><td>window.withdraw()</td><td>用来隐藏主窗口，但不会销毁窗口。</td></tr><tr class="even"><td>window.iconify()</td><td>设置窗口最小化</td></tr><tr class="odd"><td>window.deiconify()</td><td>将窗口从隐藏状态还原</td></tr><tr class="even"><td>window.winfo_screenwidth() window.winfo_screenheight()</td><td>获取电脑屏幕的分辨率（尺寸）</td></tr><tr class="odd"><td>window.winfo_width() window.winfo_height()</td><td>获取窗口的大小，同样也适用于其他控件，但是使用前需要使用 window.update() 刷新屏幕，否则返回值为1</td></tr><tr class="even"><td>window.protocol("协议名",回调函数)</td><td>启用协议处理机制，常用协议有 WN_DELETE_WINDOW，当用户点击关闭窗口时，窗口不会关闭，而是触发回调函数。</td></tr></tbody></table><h1 id="tkinter常用widgets">Tkinter常用widgets</h1><table><thead><tr class="header"><th>序号</th><th>控件类型</th><th>控件名称</th><th>控件作用</th></tr></thead><tbody><tr class="odd"><td>1</td><td>Button</td><td>按钮</td><td>点击按钮时触发/执行一些事件（函数）</td></tr><tr class="even"><td>2</td><td>Canvas</td><td>画布</td><td>提供绘制图，比如直线、矩形、多边形等</td></tr><tr class="odd"><td>3</td><td>Checkbutton</td><td>复选框</td><td>多项选择按钮，用于在程序中提供多项选择框</td></tr><tr class="even"><td>4</td><td>Entry</td><td>文本框输入框</td><td>用于接收单行文本输入</td></tr><tr class="odd"><td>5</td><td>Frame</td><td>框架（容器）</td><td>定义一个窗体（根窗口也是一个窗体），用于承载其他控件，作为其他控件的容器</td></tr><tr class="even"><td>6</td><td>Label</td><td>标签</td><td>用于显示单行文本或者图片</td></tr><tr class="odd"><td>7</td><td>LabelFrame</td><td>便签框架</td><td><font color="#FFCCE5">一个简单的容器控件，常用于复杂的窗口布局。？</font></td></tr><tr class="even"><td>8</td><td>Listbox</td><td>列表框</td><td>以列表的形式显示文本</td></tr><tr class="odd"><td>9</td><td>Menu</td><td>菜单</td><td>菜单组件（下拉菜单和弹出菜单）</td></tr><tr class="even"><td>10</td><td>MenuButton</td><td>菜单按钮</td><td>用于显示菜单项</td></tr><tr class="odd"><td>11</td><td>Message</td><td>信息</td><td>用于显示多行不可编辑的文本，与 Label控件类似，增加了自动分行的功能</td></tr><tr class="even"><td>12</td><td>MessageBox</td><td>消息框</td><td>定义与用户交互的消息对话框</td></tr><tr class="odd"><td>13</td><td>OptionMenu</td><td>选项菜单</td><td>下拉菜单</td></tr><tr class="even"><td>14</td><td>PanedWindow</td><td>面板</td><td>为组件提供一个框架，允许用户自己划分窗口空间</td></tr><tr class="odd"><td>15</td><td>Radiobutton</td><td>单选框</td><td>单项选择按钮，只允许从多个选项中选择一项</td></tr><tr class="even"><td>16</td><td>Scale</td><td>进度条</td><td>定义一个线性“滑块”用来控制范围，可以设定起始值和结束值，并显示当前位置的精确值</td></tr><tr class="odd"><td>17</td><td>Spinbox</td><td>微调输入框</td><td>Entry 控件的升级版，可以通过该组件的上、下箭头选择不同的值</td></tr><tr class="even"><td>18</td><td>Scrollbar</td><td>滚动条</td><td>默认垂直方向，鼠标拖动改变数值，可以和 Text、Listbox、Canvas等控件配合使用</td></tr><tr class="odd"><td>19</td><td>Text</td><td>多行文本框</td><td>接收或输出多行文本内容</td></tr><tr class="even"><td>20</td><td>Toplevel</td><td>上层窗口</td><td>在创建一个独立于主窗口之外的子窗口，位于主窗口的上一层，可作为其他控件的容器</td></tr></tbody></table><h1 id="widgets共同属性与方法">widgets共同属性与方法</h1><table><thead><tr class="header"><th>属性名称</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>anchor</td><td>定义控件或者文字信息在窗口内的位置("n" 、"ne" 、"e" 、"se" 、"s" 、"sw" 、"w" 、"nw" 和 "center")</td></tr><tr class="even"><td>bg</td><td>bg 是 background 的缩写，用来定义控件的背景颜色，参数值可以颜色的十六进制数，或者颜色英文单词</td></tr><tr class="odd"><td>bitmap</td><td>定义显示在控件内的位图文件</td></tr><tr class="even"><td>borderwidth (bd)</td><td>定于控件的边框宽度，单位是像素</td></tr><tr class="odd"><td>command</td><td>该参数用于执行事件函数，比如单击按钮时执行特定的动作，可将执行用户自定义的函数</td></tr><tr class="even"><td>cursor</td><td>当鼠标指针移动到控件上时，定义鼠标指针的类型，字符换格式，参数值有 crosshair（十字光标）watch（待加载圆圈）plus（加号）arrow（箭头）等</td></tr><tr class="odd"><td>font</td><td>若控件支持设置标题文字，就可以使用此属性来定义，它是一个数组格式的参数 (字体,大小，字体样式)</td></tr><tr class="even"><td>fg</td><td>fg 是 foreground 的缩写，用来定义控件的前景色，也就是字体的颜色</td></tr><tr class="odd"><td>height</td><td>该参数值用来设置控件的高度，文本控件以字符的数目为高度（px），其他控件则以像素为单位</td></tr><tr class="even"><td>image</td><td>定义显示在控件内的图片文件</td></tr><tr class="odd"><td>justify</td><td>定义多行文字的排列方式，此属性可以是 LEFT/CENTER/RIGHT</td></tr><tr class="even"><td>padx/pady</td><td>定义控件内的文字或者图片与控件边框之间的水平/垂直距离</td></tr><tr class="odd"><td>relief</td><td>定义控件的边框样式，参数值为FLAT（平的）/RAISED（凸起的）/SUNKEN（凹陷的）/GROOVE（沟槽桩边缘）/RIDGE（脊状边缘）</td></tr><tr class="even"><td>text 文本</td><td>定义控件的标题文字</td></tr><tr class="odd"><td>state 状态</td><td>控制控件是否处于可用状态，参数值默认为 NORMAL/DISABLED，默认为 NORMAL（正常的）</td></tr><tr class="even"><td>width</td><td>用于设置控件的宽度，使用方法与 height 相同</td></tr><tr class="odd"><td>config(option=value)</td><td>设置属性</td></tr><tr class="even"><td>cget(''option')</td><td>取得option参数值</td></tr><tr class="odd"><td>keys()</td><td>获取该widget参数</td></tr><tr class="even"><td>quit()</td><td>python shell窗口结束，但所建窗口继续执行</td></tr><tr class="odd"><td>update()</td><td>更新窗口画面</td></tr><tr class="even"><td>bind(event, callback)</td><td>事件绑定</td></tr><tr class="odd"><td>unbind(event)</td><td>解除事件绑定</td></tr><tr class="even"><td>after(time, callback)</td><td>间隔指定时间后，调用callback()方法</td></tr></tbody></table><h1 id="tkinter.ttk模块增加的widgets">tkinter.ttk模块增加的widgets</h1><table><thead><tr class="header"><th>序号</th><th>控件类型</th><th>控件名称</th><th>控件作用</th></tr></thead><tbody><tr class="odd"><td>1</td><td>Combobox</td><td>组合框</td><td>Entry与下拉菜单组合的控件</td></tr><tr class="even"><td>2</td><td>Notebook</td><td>选项卡容器</td><td>可有多个选项卡，承载不同的子控件内容</td></tr><tr class="odd"><td>3</td><td>Progressbar</td><td>进度条</td><td>通过进度指针显示当前阶段</td></tr><tr class="even"><td>4</td><td>Separator</td><td>分割线</td><td>增加视觉效果</td></tr><tr class="odd"><td>5</td><td>Sizegrip</td><td>大小控制</td><td>拖拽更改窗口大小</td></tr><tr class="even"><td>6</td><td>Treeview</td><td>树状表格视图</td><td>将内容分层隐藏与显示</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tkinter-主窗口&quot;&gt;Tkinter 主窗口&lt;/h1&gt;
&lt;p&gt;Hardware --&amp;gt; OS --&amp;gt; Tcl/Tk --&amp;gt; tkinter --&amp;gt; Python&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#FF33FF&quot;&gt;tkinte</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="tkinter" scheme="http://example.com/tags/tkinter/"/>
    
  </entry>
  
  <entry>
    <title>关于Python的基本知识点</title>
    <link href="http://example.com/2024/01/01/%E5%85%B3%E4%BA%8EPython%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2024/01/01/%E5%85%B3%E4%BA%8EPython%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2024-01-01T09:44:15.000Z</published>
    <updated>2024-01-02T02:38:25.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python的基本知识点">Python的基本知识点</h1><ul><li><p>Python Shell环境输入<code>import this</code> 可看到经典名句，代表研读Python的意境。</p></li><li><p>注释符：</p><ul><li>单行注释：<code>#</code></li><li>多行注释：<code>'''</code> or <code>"""</code></li></ul></li><li><p>```python help('modules') # 查看python所有modules help('topics') # 查看python常见的topics <div class="code-wrapper"><pre><code class="hljs python">- ```python  <span class="hljs-keyword">import</span> os.path  <span class="hljs-built_in">help</span>(<span class="hljs-string">&#x27;os.path&#x27;</span>)    <span class="hljs-comment"># 查看python标准库中的modules</span></code></pre></div></p></li><li><div class="sourceCode" id="cb1"><div class="code-wrapper"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>  <span class="bu">dir</span>(__builtins__)  <span class="co"># 列出Python内置函数</span></span><span id="cb1-2"><a href="#cb1-2"></a>  <span class="bu">dir</span>(<span class="st">&#39;&#39;</span>) <span class="co"># 列出字符串对象方法</span></span><span id="cb1-3"><a href="#cb1-3"></a>  <span class="bu">dir</span>(<span class="dv">0</span>) <span class="co"># 列出整数对象方法</span></span><span id="cb1-4"><a href="#cb1-4"></a>  <span class="bu">dir</span>([]) <span class="co">#列出列表的方法</span></span><span id="cb1-5"><a href="#cb1-5"></a>  <span class="bu">dir</span>(()) <span class="co"># 列出元组的方法</span></span><span id="cb1-6"><a href="#cb1-6"></a>  <span class="bu">dir</span>(&#123;&#125;) <span class="co"># 列出字典的方法</span></span><span id="cb1-7"><a href="#cb1-7"></a>  <span class="bu">dir</span>(<span class="bu">set</span>()) <span class="co"># 列出集合的方法</span></span></code></pre></div></div></li><li><p>Python运算优先级：次方(**) &gt; 乘除，求余(%)，求整(//) &gt; 加减</p></li><li><p><code>divmod()</code> 函数可以一次获得商和余数</p></li><li><p><code>id()</code> 可查看变量十进制地址。</p></li><li><p><code>type()</code> 函数可列出变量的数据类型</p></li><li><p>字符串前加 <code>r</code> ,可取消转义字符含义</p></li><li><p><code>chr()</code> # 回传ASCII字符</p></li><li><p><code>ord()</code> # 回传Unicode码</p></li><li><p><code>bytes()</code> # 回传bytes数据，内容不可变</p></li><li><p><code>bytearray()</code> # 回传bytearray数据，内容可变</p></li><li><p>字符串格式输出</p><ul><li><code>print('%s - %d - %f' % (str1, num, score))</code></li><li><code>print('&#123;&#125; - &#123;&#125; - &#123;&#125;'.format(str1, num, score))</code></li><li><code>print(f'&#123;score&#125;')</code> # v3.6版本后</li></ul></li><li><p><code>eval(input(''))</code> 可处理字符串中数学表达式</p></li><li><p><code>enumerate(iterable, start = 0)</code> # 可迭代对象更改索引值</p></li><li><p><code>新列表 = [表达式 for 项目 in 可迭代对象]</code> # 生成式列表</p></li><li><p>元组内只有一个元素，在定义时要在右边加上逗号</p></li><li><p><code>zip()</code> # 对多个可迭代对象打包</p></li><li><p><code>zip(*)</code> # unzip</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python的基本知识点&quot;&gt;Python的基本知识点&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Python Shell环境输入&lt;code&gt;import this&lt;/code&gt; 可看到经典名句，代表研读Python的意境。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注释符：&lt;</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX+VScode搭建STM32开发环境</title>
    <link href="http://example.com/2023/11/18/STM32CubeMX-VScode%E6%90%AD%E5%BB%BASTM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/2023/11/18/STM32CubeMX-VScode%E6%90%AD%E5%BB%BASTM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</id>
    <published>2023-11-18T07:19:27.000Z</published>
    <updated>2023-11-20T08:51:45.735Z</updated>
    
    <content type="html"><![CDATA[<p>市面上开发STM32使用的IDE软件有很多，像常用的 <strong>Keil</strong> 和 <strong>IAR</strong>，国外比较流行的 <strong>mikroC PRO</strong> ，以及ST公司自己推出的免费 <strong>STM32CubeIDE</strong> ，前面三款软件牵涉到版权收费问题，虽说 <strong>STM32CubeIDE</strong> 是免费的，但体积比较大，启动比较慢，所以，很多开发人员选择微软的 <strong>VSCode</strong> 来进行开发，而开发环境需要自己来进行配置，具体配置如下：</p><h2 id="下载开发软件">下载开发软件</h2><p>现在很多软件和插件对windows电脑的<font color="#FF007F"><strong>最低要求是Win10</strong></font>，所以这里以我的电脑Win10 64位来进行操作。</p><p>下载的软件有：</p><ul><li><a href="https://code.visualstudio.com/">Visual Studio Code</a></li></ul><p>主要的文本编辑软件，官网下载比较慢，可以进入 <strong><a href="https://code.visualstudio.com/updates/">Updates</a></strong> 栏进行下载。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118160017135.png" alt="image-20231118160017135" style="zoom:50%;" /></p><ul><li><a href="https://www.st.com/zh/development-tools/stm32cubemx.html">STM32cubeMX</a></li></ul><p>ST推出的图形化配置工具，注册后即可下载。操作说明：<a href="https://www.stmcu.com.cn/ecosystem/Cube/STM32cubemx">生态系统 | STMCU中文官网</a></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118155902022.png" alt="image-20231118155902022" style="zoom:50%;" /></p><ul><li><a href="%5BArm%20GNU%20Toolchain%20Downloads%20–%20Arm%20Developer%5D(https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)">arm-gnu-toolchain</a></li></ul><p>Windows (mingw-w64-i686)下交叉编译工具链，主要使用里面的gcc工具链。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118155746858.png" alt="image-20231118155746858" style="zoom:50%;" /></p><ul><li><a href="https://www.gnutoolchains.com/arm-eabi/openocd/">OpenOCD</a></li></ul><p>开源的GDB调试软件。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118160350697.png" alt="image-20231118160350697" style="zoom:50%;" /></p><ul><li><a href="https://gnuwin32.sourceforge.net/packages/make.htm">GNU make</a></li></ul><p>工程的构建工具，通过 <strong>makefile</strong> 脚本文件，自动进行编译处理过程。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118160902580.png" alt="image-20231118160902580" style="zoom:50%;" /></p><h1 id="软件安装与环境变量配置">软件安装与环境变量配置</h1><p><strong>VS Code</strong> 和 <strong>STM32CubeMX</strong> 及 <strong>GNU make</strong> 按照正常方式安装即可，<strong>arm-gnu-toolchain</strong> 和 <strong>OpenOCD</strong> 是压缩包，将它们解压到某个盘（如：<strong>D:\Program Files (x86)文件夹下</strong>）， 然后将它们的<font color="#FF00FF"><strong>bin文件夹路径</strong></font>添加到环境变量的<strong>PATH</strong>中。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118161850553.png" alt="" /><figcaption>image-20231118161850553</figcaption></figure><h1 id="vs-code插件安装">VS Code插件安装</h1><p>打开 <strong>VS code</strong> ，安装以下插件：</p><ul><li><strong>C/C++</strong></li></ul><p>VS code中对C和C++的支持</p><ul><li><strong>Cortex-Debug</strong></li></ul><p>调试功能，支持寄存器查看、内存查看、断点调试、变量观察等功能。</p><ul><li><strong>stm32-for-vscode</strong></li></ul><p>编译、调试和烧录STM32项目的扩展，自动完成 <strong>.vscode文件夹</strong> json文件的编写。</p><ul><li><strong>aiXcoder Code Completer 或 Tabnine</strong></li></ul><p>代码提示扩展</p><h1 id="创建stm32-hal工程">创建STM32 HAL工程</h1><p>通过STM32CubeMX新建一个工程，正常创建即可，只需要注意选择工具链为 <strong><font color="#FF3333">Makefile</font></strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118163633024.png" alt="image-20231118163633024" style="zoom:67%;" /></p><h1 id="vs-code编译下载">VS Code编译下载</h1><p>进入刚刚创建的STM32工程文件夹，使用VS Code打开文件夹。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118164336856.png" alt="image-20231118164336856" style="zoom:67%;" /></p><p>工程打开后，左侧会出现 <strong>stm32-for-vscode</strong> 插件，如果环境变量配置OK，它会自动进行适配，如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118165358844.png" alt="image-20231118165358844" style="zoom:50%;" /></p><p>如果没有出现以上画面，则需要自己进入插件设置，进行路径的配置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118165049806.png" alt="image-20231118165049806" style="zoom:50%;" /></p><p>点击 <strong>Build</strong> ，即可看到 <strong>TERMINAL</strong> 栏的编译过程，如果一切正常，最终会生成hex和bin文件。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118165612525.png" alt="image-20231118165612525" style="zoom:80%;" /></p><p>需要烧录程序时，因为默认的烧录器是 <strong>stlink</strong>， 我这里是 <strong>daplink</strong> ，点击 <strong>Change Programmer</strong> ，选择 <strong>daplink</strong> ，插上烧录器，上电，然后点击 <strong>Flash STM32</strong> 即可完成程序的下载。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231118170208735.png" alt="image-20231118170208735" style="zoom:67%;" /></p><p>至于调试，点击 <strong>Debug STM32</strong> ，弹出调试界面，进行openocd的调试即可， 好了，以上就是 VS code 开发STM32环境的搭建过程。</p><p>另外，在keil中调用printf 需要重载<code>putc</code>函数，这里因为使用的是gcc编译器，所以需要重载 <code>_write</code> 函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> _write(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *ch, <span class="hljs-type">int</span> len)&#123;  HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span>*)ch, len, <span class="hljs-number">0xFFFF</span>);  <span class="hljs-keyword">return</span> len;&#125;</code></pre></div><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/gorgeousa/article/details/129525234">vscode stm32cubemx 优雅开发stm32，最简单步骤教程_vscode怎么开发stm32_合理说明的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;市面上开发STM32使用的IDE软件有很多，像常用的 &lt;strong&gt;Keil&lt;/strong&gt; 和 &lt;strong&gt;IAR&lt;/strong&gt;，国外比较流行的 &lt;strong&gt;mikroC PRO&lt;/strong&gt; ，以及ST公司自己推出的免费 &lt;strong&gt;STM32C</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>锂电池充放电方案</title>
    <link href="http://example.com/2023/11/16/%E9%94%82%E7%94%B5%E6%B1%A0%E5%85%85%E6%94%BE%E7%94%B5%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2023/11/16/%E9%94%82%E7%94%B5%E6%B1%A0%E5%85%85%E6%94%BE%E7%94%B5%E6%96%B9%E6%A1%88/</id>
    <published>2023-11-16T12:55:49.000Z</published>
    <updated>2023-11-16T14:34:12.990Z</updated>
    
    <content type="html"><![CDATA[<p>对于便携式设备来讲，锂电池作为电源，在应用中必不可少，一般锂电池标称电压3.7V,充满电后4.2V，我们在设计锂电池充放电功能的时候需要考虑其保护电路、充电电路、电量检测电路、电源转换电路。</p><h1 id="保护电路的设计">保护电路的设计</h1><p>锂电池保护电路主要过充和过放保护，使用集成芯片对锂电池进行保护，如深圳富满的 <strong>DW03D芯片</strong>，它具有过充，过放，过流，短路等所有电池所需保护功能，采用TSSOP-8封装，面积占用小，外围电路也非常简单。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116211206743.png" alt="" /><figcaption>image-20231116211206743</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116211127222.png" alt="" /><figcaption>image-20231116211127222</figcaption></figure><p>这是消费电子产品中常用的锂电池保护芯片，还有其它保护芯片，一般电池都自带有保护电路，为了方便，选用时可选带有保护电路的锂电池。</p><h1 id="充电电路的设计">充电电路的设计</h1><p>锂电池充电芯片非常多，有TI、ADI、MPS这些大厂的充电芯片，国内也有很多充电芯片，像南京拓品微、上海贝岭、深圳富满电子、英集芯等。这些充电芯片有的也包含有保护电路的部分。</p><ul><li><strong>充电电流小</strong></li></ul><p>如果充电电流较小，可以选用 <strong>线性充电芯片</strong>，比如 <strong>TP4056、TC4056、TC4054</strong> 等，这类充电芯片最大电流1A，外围电路简单，但发热比较大。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116213108065.png" alt="" /><figcaption>image-20231116213108065</figcaption></figure><ul><li><strong>充电电流大</strong></li></ul><p>如果充电电流较大，就必须要用 <strong>开关降压型芯片</strong>，这类芯片充电电流大，可达2A或更高，但发热量小，典型的有 <strong>TP5000、IP5306</strong> 等。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116213150850.png" alt="" /><figcaption>image-20231116213150850</figcaption></figure><h1 id="电量检测电路设计">电量检测电路设计</h1><p>在使用的时候需要对电池的电量做检测，防止设备欠压，出现故障。</p><ul><li><strong>电阻分压的方案</strong></li></ul><p>对电池电压使用分压电阻分压，然后直接使用AD进行检测，根据其一个周期的放电曲线和AD值计算出简单的电量，这种方法成本低。（<a href="https://blog.csdn.net/switch_love_case/article/details/113553837">低功耗产品ADC精确测量电池电压（电量）_adc电池电量采集</a>）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116215139377.png" alt="image-20231116215139377" style="zoom: 67%;" /></p><ul><li><strong>芯片方案</strong></li></ul><p>使用专业的库仑计IC检测电量，这类芯片通过I2C总线来传输电量信息，检测比较准确，如<strong>TI的BQ27541</strong>、<strong>美信的MAX17043</strong>、还有<strong>凌特的LTC2644</strong>，国内的如大疆和智能手机都在使用的 <strong>CW2015</strong> 。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116220010964.png" alt="" /><figcaption>image-20231116220010964</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116220316629.png" alt="" /><figcaption>image-20231116220316629</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116220534950.png" alt="" /><figcaption>image-20231116220534950</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116220550595.png" alt="" /><figcaption>image-20231116220550595</figcaption></figure><h1 id="电源转换电路的设计">电源转换电路的设计</h1><p>电池供电一般都比较小，要给后端设备提供稳定的电压，就需要进行转换处理。</p><ul><li><strong>PMIC电池电源管理</strong></li></ul><p>在一些复杂的设备中，一般会有一颗PMIC电池电源管理芯片，这类芯片集成了多路DCDC、多路LDO、电源路径管理、锂电池充放电管理，锂电池电量检测等。一般多数情况下使用不到。如ST的 <strong>STPMIC1</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116221514278.png" alt="" /><figcaption>image-20231116221514278</figcaption></figure><ul><li><strong>升降压转换</strong></li></ul><p>使用升压或降压芯片对锂电池电压进行处理。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116221733398.png" alt="" /><figcaption>image-20231116221733398</figcaption></figure><ul><li><strong>充电升压一体集成芯片</strong></li></ul><p>用集成的充电和升压一体IC进行升压，然后使用DCDC进行降压，如 <strong>TP5400、IP5109、IP5318、IP5306</strong> 等。这类IC有放电保护，一般放电截止电压在3V左右。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116222607678.png" alt="" /><figcaption>image-20231116222607678</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116222628162.png" alt="" /><figcaption>image-20231116222628162</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116222937890.png" alt="" /><figcaption>image-20231116222937890</figcaption></figure><p>锂电池相关的芯片有很多，对于产品不同的需求，可根据应用进行不同的取舍，有的芯片在使用过程中，也会出现各种问题，所以，在选择时也需要认真考虑。</p><p><strong>参考链接：</strong></p><p><a href="https://mp.weixin.qq.com/s/WkLsDG0sdHt2pWuwGOsb6g">折腾一下锂电池供电方案 (qq.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于便携式设备来讲，锂电池作为电源，在应用中必不可少，一般锂电池标称电压3.7V,充满电后4.2V，我们在设计锂电池充放电功能的时候需要考虑其保护电路、充电电路、电量检测电路、电源转换电路。&lt;/p&gt;
&lt;h1 id=&quot;保护电路的设计&quot;&gt;保护电路的设计&lt;/h1&gt;
&lt;p&gt;锂电</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="锂电池" scheme="http://example.com/tags/%E9%94%82%E7%94%B5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>批量获取微信公众号的历史消息</title>
    <link href="http://example.com/2023/11/16/%E6%89%B9%E9%87%8F%E8%8E%B7%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9A%84%E5%8E%86%E5%8F%B2%E6%B6%88%E6%81%AF/"/>
    <id>http://example.com/2023/11/16/%E6%89%B9%E9%87%8F%E8%8E%B7%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9A%84%E5%8E%86%E5%8F%B2%E6%B6%88%E6%81%AF/</id>
    <published>2023-11-16T06:43:13.000Z</published>
    <updated>2023-11-16T08:11:10.395Z</updated>
    
    <content type="html"><![CDATA[<p>微信公众号历史文章有很多，不想总是不停一篇一篇滑动浏览，然后在网上找到了一种提取方法：<strong>Python爬虫+Fiddler抓取</strong> 。具体操作如下：</p><h2 id="下载项目源码">下载项目源码</h2><p>项目地址：</p><div class="code-wrapper"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/LeLe86/</span>vWeChatCrawl.git</code></pre></div><p><font color="#FF0000">前提是电脑安装有<strong>python软件</strong></font>，打开 <code>git bash</code> 下载项目源码：</p><div class="code-wrapper"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/LeLe86/</span>vWeChatCrawl.git</code></pre></div><h2 id="安装python包">安装python包</h2><p>在 <code>git bash</code> 中，输入</p><div class="code-wrapper"><pre><code class="hljs c">cd vWeChatCrawlpython setupPackage.py</code></pre></div><p>等待安装完成。</p><h2 id="安装fiddler抓包工具">安装Fiddler抓包工具</h2><p><a href="https://www.telerik.com/fiddler/fiddler-classic">Fiddler的官网</a>有时会连不上，可去 <strong>pc.qq.com</strong> 搜索 <strong>Fiddler4</strong> 下载并安装。</p><h2 id="fiddler软件设置">Fiddler软件设置</h2><p>打开Fiddler软件，设置如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116152054397.png" alt="" /><figcaption>image-20231116152054397</figcaption></figure><p>然后在主窗口右侧选择 <strong>Filters</strong>，在需要填的URL为：<code>mp.weixin.qq.com/mp/profile_ext?action=getmsg</code> ,如下图所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116152400300.png" alt="" /><figcaption>image-20231116152400300</figcaption></figure><p>点软件左下角的方块，会显示 <strong>Capturing</strong> ，表示它此时处在抓取数据的状态，再点一下会停止抓取。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116152722265.png" alt="" /><figcaption>image-20231116152722265</figcaption></figure><h2 id="获取公众号历史消息">获取公众号历史消息</h2><p>登录电脑端微信，我这里版本（<strong>V2.9.5.41</strong>），选择一个公众号，查看历史消息，如：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116152851584.png" alt="" /><figcaption>image-20231116152851584</figcaption></figure><p>进入后缓慢向下滑动，页面显示 <strong>正在加载</strong> ，即可看到抓包软件捕捉到信息。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116153410980.png" alt="" /><figcaption>image-20231116153410980</figcaption></figure><p>把这些json文件保存下来，</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116154034375.png" alt="" /><figcaption>image-20231116154034375</figcaption></figure><h2 id="下载文章html或pdf文档">下载文章html或pdf文档</h2><p>打开项目中的 <strong>config.json</strong> 文件，进行设置并保存。</p><ul><li><strong>jsonDir</strong>：上面在Fiddler中保存的文件目录<br /></li><li><strong>htmlDir</strong>：保存html的目录，路径中不能有空格<br /></li><li><strong>pdfDir</strong>：保存pdf的目录，路径中不能有空格</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116154743433.png" alt="" /><figcaption>image-20231116154743433</figcaption></figure><p>一般只需要设置 <strong>jsonDir</strong> ，另外两个默认即可。</p><p>设置完成后，在 <code>git bash</code> 中， 运行 <code>python start.py</code> ,即可下载html文件，等待下载完成，可看到html文件夹下的html文件和imsges文件夹，但这种html文件都是以数字命名的，查看不方便，所以，可以运行 <code>python start.py pdf</code> ,等待全部转化成pdf文件即可，后面就可以离线查看各个文章了。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116160112140.png" alt="" /><figcaption>image-20231116160112140</figcaption></figure><p>以上就是分享的全部内容，这中间试了很多爬虫方式，找了很多第三方工具，都没法提取，在本项目实施过程中也并非一帆风顺，碰到了各种莫名其妙的问题，折腾好久，但最终都一一解决了，在此记录一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微信公众号历史文章有很多，不想总是不停一篇一篇滑动浏览，然后在网上找到了一种提取方法：&lt;strong&gt;Python爬虫+Fiddler抓取&lt;/strong&gt; 。具体操作如下：&lt;/p&gt;
&lt;h2 id=&quot;下载项目源码&quot;&gt;下载项目源码&lt;/h2&gt;
&lt;p&gt;项目地址：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>关于Fiddler系统代理总是被更改的issue</title>
    <link href="http://example.com/2023/11/16/%E5%85%B3%E4%BA%8EFiddler%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E6%80%BB%E6%98%AF%E8%A2%AB%E6%9B%B4%E6%94%B9%E7%9A%84issue/"/>
    <id>http://example.com/2023/11/16/%E5%85%B3%E4%BA%8EFiddler%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E6%80%BB%E6%98%AF%E8%A2%AB%E6%9B%B4%E6%94%B9%E7%9A%84issue/</id>
    <published>2023-11-16T03:31:27.000Z</published>
    <updated>2023-11-16T04:26:03.869Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Fiddler Web Debugger抓取网页内容时，会经常弹出如下错误：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116113625585.png" alt="" /><figcaption>image-20231116113625585</figcaption></figure><p>在网上看到很多人都碰到有这个问题，产生的原因也有多种，我把这些可能得原因都看了看，排除了自己电脑可能的问题，但还是没法解决。</p><p>突然想到一个博主说的：“一定有一个程序在修改系统的代理”，问题的关键就在于其它软件的影响，于是，从网上下载了 <code>Process Monitor(进程监测软件)</code>(<font color="purple">Win7系统无法使用新版本,我这里使用的是V3.2版本</font>)，通过监测软件搜索 <code>ProxyEnable</code> ,说不定就可以揪出作怪的进程。操作如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116121107282.png" alt="" /><figcaption>image-20231116121107282</figcaption></figure><p>明明我多年前都卸载了这个网银助手软件，也完整看了卸载软件列表中，没有网银或VPN的相关信息，但现在系统中还是残留有网银的进程，折腾了许久，原来是这个潜藏进程的影响。</p><p>此时是没法直接删除这个进程的，双击这个网银的软件，打开任务管理器，找到这个网银进程，结束它的进程，再直接删除，OK。</p><p>再次在 <strong>Fiddler</strong> 软件中，开启捕捉，就不会弹出系统代理更改的错误，问题解决。</p><p><strong>参考：</strong></p><p><a href="https://blog.csdn.net/zwyzzz888/article/details/126426761">解决fiddler 系统代理已更改的问题-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用Fiddler Web Debugger抓取网页内容时，会经常弹出如下错误：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231116</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>网页布局调整插件</title>
    <link href="http://example.com/2023/11/13/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E8%B0%83%E6%95%B4%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2023/11/13/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E8%B0%83%E6%95%B4%E6%8F%92%E4%BB%B6/</id>
    <published>2023-11-13T06:49:19.000Z</published>
    <updated>2023-11-13T08:02:22.969Z</updated>
    
    <content type="html"><![CDATA[<p>浏览网页时，一般网页上会出现很多附带花哨的内容，看起来很影响视觉效果，且都是些无用信息，网上看到个博主写了个网页插件，使用后，屏蔽了这些无用信息，整个页面看起来清爽很多。</p><p>插件GitHub地址：</p><div class="code-wrapper"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Camio1945/</span>adjust_website_chrome_extension</code></pre></div><p>插件屏蔽了指定网页上大部分内容，可以根据自己的需要进行相应的修改和调整。虽然插件是用在谷歌浏览器上的，但我的Microsoft Edge浏览器好像也能正常使用，以下是我调整修改后CSDN网页上的显示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231113154847896.png" alt="" /><figcaption>image-20231113154847896</figcaption></figure><p>调整修改后的插件，我已上传：<a href="https://gitee.com/kayoungzhang/my_codehub/blob/master/plugins/adjust_website%E6%8F%92%E4%BB%B6.zip">gitee</a></p><p>具体内容，请查看原插件说明文档，感兴趣的可以下载来使用看看，并根据自己的需要进行修改调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;浏览网页时，一般网页上会出现很多附带花哨的内容，看起来很影响视觉效果，且都是些无用信息，网上看到个博主写了个网页插件，使用后，屏蔽了这些无用信息，整个页面看起来清爽很多。&lt;/p&gt;
&lt;p&gt;插件GitHub地址：&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>typora插件</title>
    <link href="http://example.com/2023/11/10/typora%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2023/11/10/typora%E6%8F%92%E4%BB%B6/</id>
    <published>2023-11-10T07:20:16.000Z</published>
    <updated>2023-11-13T06:42:14.383Z</updated>
    
    <content type="html"><![CDATA[<p>在写 <code>markdown</code> 文档时，有时需要对文档进行格式处理，如字体大小，颜色设置，加粗等等，像在typora软件中，会有部分设置类型，通过鼠标右键或快捷键的方式可以很方便的操作，但有些常用的一些格式设置，软件中就没有。如果你懂些html的语法，也可以进行设置，在之前的文章中有分享，但总归感觉不太方便。</p><p>前段时间，在 <code>github</code> 上看到个typora插件（<a href="https://github.com/obgnail/typora_plugin">https://github.com/obgnail/typora_plugin</a>），在使用软件时，增加了很多功能，有些功能也比较实用。</p><p>使用之后，我发现有些增强功能我使用不到，typora软件的打开速度也变慢了，通过插件里面的配置文档，我删除了插件里面的部分增强功能，对自己经常用到的功能进行了更改和保留。如下所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231113143517868.png" alt="" /><figcaption>image-20231113143517868</figcaption></figure><ul><li><strong>只读模式 Ctrl+Shift+R</strong></li></ul><p>使用鼠标右键或快捷键 <code>Ctrl+Shift+R</code> 可以快速进入或退出<strong>只读模式</strong>，<strong>只读模式</strong>下，无法编辑，且文章右下角显示只读标志。</p><ul><li><strong>表格调整</strong></li></ul><p>创建表格后，使用 <code>ctrl+鼠标拖动</code> 可以修改表格的行高列宽。</p><ul><li><strong>文字颜色 Ctrl+Shift+C</strong></li></ul><p>使用鼠标右键或快捷键 <code>Ctrl+Shift+C</code> 可以弹出或退出文字颜色设置框，选中需要改变颜色的文字，即可进行颜色的设置。</p><ul><li><strong>右键菜单</strong></li></ul><p>这个主要是打开配置文件夹和github上的帮助文档。</p><ul><li><strong>白天/暗夜模式切换</strong></li></ul><p>文档右下角直接有 <strong>白天/暗夜模式切换</strong> 图标，鼠标左键点击即可进行不同模式的切换，比较实用。</p><ul><li><strong>快读返回顶底部</strong></li></ul><p>文档右下角直接有 <strong>快速返回顶/底部</strong> 图标，对于长文档的阅读，比较方便快捷。</p><p>以上就是我写文档会经常使用到的一些功能，已上传到<a href="https://gitee.com/kayoungzhang/my_codehub/blob/master/plugins/typora%E6%8F%92%E4%BB%B6%E7%B2%BE%E7%AE%80%E7%89%88.zip">gitee</a>，至于其它的功能，可以参考<a href="https://github.com/obgnail/typora_plugin">原插件</a>，感兴趣可以下载下来使用看看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在写 &lt;code&gt;markdown&lt;/code&gt; 文档时，有时需要对文档进行格式处理，如字体大小，颜色设置，加粗等等，像在typora软件中，会有部分设置类型，通过鼠标右键或快捷键的方式可以很方便的操作，但有些常用的一些格式设置，软件中就没有。如果你懂些html的语法，也可</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="typora" scheme="http://example.com/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>热敏电阻原理与代码实现</title>
    <link href="http://example.com/2023/10/25/%E7%83%AD%E6%95%8F%E7%94%B5%E9%98%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/10/25/%E7%83%AD%E6%95%8F%E7%94%B5%E9%98%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-10-25T07:29:47.000Z</published>
    <updated>2023-10-26T10:11:18.617Z</updated>
    
    <content type="html"><![CDATA[<p>在嵌入式产品开发中，会经常碰到温度检测的时候，在成本比较敏感而精度要求较低时，可采用热敏电阻来进行温度的检测。</p><h1 id="热敏电阻简介">热敏电阻简介</h1><p>热敏电阻作用有点像电阻器，但对温度比较敏感。它可用于产生随环境温度变化的模拟输出电压，这是因为由于热量变化会导致其电气特性发生变化。随着它的温度变化，它的电阻也会发生变化。</p><p>热敏电阻的主要用途是作为电阻式温度传感器，但它们也可以用作热敏限流器件。</p><p>随着温度的变化增加，电阻值有的是增大，有的是减小。所以对应了两种类型的热敏电阻：<strong>电阻的负温度系数（NTC）和电阻的正温度系数（PTC）。</strong>工程应用中，NTC热敏电阻使用更广泛一些，下面主要来看看NTC的相关内容。</p><h1 id="ntc的功能概述">NTC的功能概述</h1><p>NTC的性性是阻值随温度的升高而降低，变化率极大的半导体电阻器。NTC的电阻与温度存在如下关系曲线：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026113905028.png" alt="" /><figcaption>image-20231026113905027</figcaption></figure><p>对于NTC的这种电阻与温度的关系可以使用近似的公式来表示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026114506698.png" alt="" /><figcaption>image-20231026114506699</figcaption></figure><p>其中：</p><p><strong>R</strong>: 当前温度（K）零负荷电阻</p><p><strong>T：</strong> 当前温度（K）</p><p><strong>R0:</strong> T0(K)温度下标称电阻，一般是25℃。</p><p><strong>B:</strong> 热敏电阻材料常数，标称温度不同，B值也不同</p><p>有的NTC厂商会给出B值公式，只是上面那个公式的不同转换形式而已：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026120408078.png" alt="" /><figcaption>image-20231026120408077</figcaption></figure><p>由以上公式就可以推出温度与电阻的关系（<strong>℃</strong>）：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/72ac09cc4e50c51a63870bf9401d3a51.png" alt="" /><figcaption>img</figcaption></figure><h1 id="电路原理及程序实现">电路原理及程序实现</h1><p>热敏电阻的本质就是一个电阻，我们通过测量电阻的变化即可测量出来温度。最简单的方法是使用热敏电阻作为分压电路的一部分，测量电阻两端的电压变化，就可以得出温度的变化。</p><p>将电压值转变为对应的温度值，一般有两种方法：<strong>查表法</strong>和<strong>公式计算法（如上公式）</strong>，比较常用的是查表法。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026174558208.png" alt="" /><figcaption>image-20231026174558207</figcaption></figure><p>可以看出，只要知道了当前的电阻，就可以得出ADC的值，以<a href="https://atta.szlcsc.com/upload/public/pdf/source/20170728/C123387_1501225826403848951.pdf">南京时恒的MF58-103F3435</a>为例：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026173537979.png" alt="" /><figcaption>image-20231026173537976</figcaption></figure><p>由上图可以看出，每个温度下都有对应的电阻值，通过上面的公式，就可以计算出对应的电阻值下的ADC采集值。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/641.png" alt="" /><figcaption>图片</figcaption></figure><p>将所有AD值转换为HEX格式后，保存到一个一维数组中：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/640-16983137350834.png" alt="" /><figcaption>图片</figcaption></figure><p>然后用单片机采集到的AD值，一个个从头开始去查找对比就能知道温度了。（由于AD值是按照由大到小的顺序排列的，可以采用更高效的二分法查找，这里不再赘述）</p><p>单片机采集到的AD值一般落在了某个区间，所以要处理的数据基本上在两个温度的区间，如果要显示小数，两个温度区间可以看成是线性的，通过局部线性化就可以计算出温度的值。</p><p>什么是局部线性化，有网友解释的很清楚，这里直接搬过来，假如ADC采样的数字量为 0x80C，十进制是2060，对应在数据表的2048(25℃)和2095(24℃)中间，计算方式按照线性处理如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/640-16983137798156.png" alt="" /><figcaption>图片</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">uint16_t</span> ntc_ad;<span class="hljs-type">uint16_t</span> temp_index;<span class="hljs-type">float</span> temperature = <span class="hljs-number">0.0</span>;ntc_ad = GetADCResult();<span class="hljs-comment">//获取ADC值</span>temp_index = NTCADBinarySearch(ntc_ad);<span class="hljs-comment">//搜索NTC_AD温度表（得到数组标号）</span>temp_integer = temp_index - <span class="hljs-number">30</span>; <span class="hljs-comment">//最低温度-30℃</span>temperature = temp_integer+(<span class="hljs-type">float</span>)(NTC_AD[temp]-ntc_ad)/(<span class="hljs-type">float</span>)(NTC_AD[temp]-NTC_AD[temp+<span class="hljs-number">1</span>]);temperature = temperature * <span class="hljs-number">10</span>;</code></pre></div><p><strong>参考链接：</strong></p><p><a href="https://mp.weixin.qq.com/s/9gCKO-IeI86xJqkxHSZyNg">热敏电阻测温：原理讲解（附送电路图和程序） (qq.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在嵌入式产品开发中，会经常碰到温度检测的时候，在成本比较敏感而精度要求较低时，可采用热敏电阻来进行温度的检测。&lt;/p&gt;
&lt;h1 id=&quot;热敏电阻简介&quot;&gt;热敏电阻简介&lt;/h1&gt;
&lt;p&gt;热敏电阻作用有点像电阻器，但对温度比较敏感。它可用于产生随环境温度变化的模拟输出电压，这</summary>
      
    
    
    
    <category term="单片机" scheme="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="NTC" scheme="http://example.com/tags/NTC/"/>
    
  </entry>
  
  <entry>
    <title>RS485总结</title>
    <link href="http://example.com/2023/10/25/RS485%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/10/25/RS485%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-25T07:28:43.000Z</published>
    <updated>2023-10-26T02:51:47.059Z</updated>
    
    <content type="html"><![CDATA[<p>RS485是工业自动化控制上最常用的半双工通信总线之一，它弥补了RS-232通信距离短，速率低的缺点，它的速率可高达<strong>10Mbit/s</strong>，理论通讯距离可达<strong>1200米</strong>；RS-485采用的是<strong>差分传输</strong>，可抑制总线上的共模干扰。RS485通信只需要MCU有串口就可以使用了。</p><h1 id="rs485通信协议">RS485通信协议</h1><p><strong>RS485是硬件层协议</strong>，MCU管脚输出的是TTL电平，经过485通讯转换器芯片转换成差分信号（线A、线B），然后跟RS485相关设备进行通信。可以这样理解，硬件层协议是公路，目的是为了让车辆能够正常通行。如果想让它按照自己的意愿在某个车道运行，就需要交通规则进行约束了，对应RS485上，就需要上层协议的加入，<strong>即软件层协议</strong>，如常用的Modbus协议，而<strong>RS-485标准</strong>并没有规定应用层通信协议。</p><p>RS485协议规定（线A、B间电压差）：</p><p><span style="color:green"><strong>逻辑1：+2V ~ +6V</strong></span></p><p><span style="color:green"><strong>逻辑0：-6V ~ -2V</strong></span></p><p>很多收发器的标准达到甚至超过TIA/EIA-485A规范，在实际使用中，以器件的SPEC参数为主，如下某收发器的负输入阈值最小也是 <code>-200mV</code> 。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/d03c9ce486984b2fa454be8a59606835.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/1d5a4194976244ddbcac880dbe80e8f5.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><h1 id="rs485拓扑结构">RS485拓扑结构</h1><p>RS485主要采用的是两线制接线方式，在同一总线上最多可以挂接32个节点。RS485支持多从机模式，不支持多主机模式。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026093304812.png" alt="" /><figcaption>image-20231026093304812</figcaption></figure><h1 id="rs485常用电路">RS485常用电路</h1><ul><li><strong>RS485一般应用</strong></li></ul><p>这种应用方案有很多，大部分都是类同如下设计：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026094211229.png" alt="image-20231026094211229" style="zoom:80%;" /></p><ul><li><strong>RS485防雷应用</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026095802733.png" alt="" /><figcaption>image-20231026095802733</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/640.jpeg" alt="" /><figcaption>图片</figcaption></figure><ul><li><p><strong>RS485高压隔离应用</strong></p><ul><li><p><strong>光耦</strong> <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026100250702.png" alt="image-20231026100250702" /></p></li><li><p><strong>专用RS485隔离芯片</strong> <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026100648487.png" alt="image-20231026100648487" /></p></li></ul></li><li><p><strong>RS485自动收发应用</strong></p><ul><li><strong>分立器件</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/d9524ee6bf62424f8b56f1989440748d.png" alt="" /><figcaption>img</figcaption></figure><p>原理分析如下：</p><p><span style="color:blue">发送过程：</span><strong>当USART_TX发送0时</strong>，三极管不导通，DE接高电平，进入发送模式，因为DI接地，所以<strong>AB引脚会传输0</strong>。<strong>当USART_TX发送1时</strong>，三极管导通，RE为低电平，进入接收模式，485芯片的AB引脚进入高阻状态，因为有上下拉电阻，所以<strong>AB传输的是1</strong>。一句话：<strong>TXD发1，AB就发1；TXD发0，AB就发0</strong></p><p><span style="color:blue">接收过程：</span>当<strong>USART_TX是高电平</strong>时，三极管导通，RE为低电平，485芯片进入接收状态，然后其RO引脚（也就是接USART_RX的引脚）就会接收AB传输过来的数据了。</p><ul><li><strong>自动切换方向芯片-MAX13487、MAX13488</strong></li></ul></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/087ca55942604e7aa24e9f1db2a7229a.png" alt="" /><figcaption>img</figcaption></figure><h1 id="rs485应用常见问题">RS485应用常见问题</h1><p>RS485在应用中有时会出现问题，如干扰，终端电阻匹配问题等，具体可参考这篇文章：</p><p><a href="https://mp.weixin.qq.com/s/hObz69bggXqIsttAz1Wo2w">485总线应用及常见问题 (qq.com)</a></p><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/weixin_46251230/article/details/126684223?spm=1001.2101.3001.6650.14&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-14-126684223-blog-103917713.235%5Ev38%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-14-126684223-blog-103917713.235%5Ev38%5Epc_relevant_default_base&amp;utm_relevant_index=22">【精选】RS-485接口协议详解_rs485_ONE_Day|的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_39400113/article/details/122387133">【精选】终于讲透了，史上最详细的RS485自动收发电路你一定要掌握-CSDN博客</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3MDQzOTUzMw==&amp;mid=2247510498&amp;idx=1&amp;sn=4cdfb6a6a3785730dc421f4e2d7cd9f7&amp;chksm=ead3ece0dda465f63f3d9d9bebe056fcb71ca380dbc27bfb4c201394675a8996c560c573da42&amp;scene=178&amp;cur_album_id=2499796242684952577#rd">大厂推荐：RS485接口电路如何设计？ (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s/uszrEinELLhIHucudf04kQ">为什么需要485隔离？常见RS485隔离方案介绍 (qq.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RS485是工业自动化控制上最常用的半双工通信总线之一，它弥补了RS-232通信距离短，速率低的缺点，它的速率可高达&lt;strong&gt;10Mbit/s&lt;/strong&gt;，理论通讯距离可达&lt;strong&gt;1200米&lt;/strong&gt;；RS-485采用的是&lt;strong&gt;差分传输</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="RS485" scheme="http://example.com/tags/RS485/"/>
    
  </entry>
  
  <entry>
    <title>关于迪文串口屏驱动</title>
    <link href="http://example.com/2023/10/25/%E5%85%B3%E4%BA%8E%E8%BF%AA%E6%96%87%E4%B8%B2%E5%8F%A3%E5%B1%8F%E9%A9%B1%E5%8A%A8/"/>
    <id>http://example.com/2023/10/25/%E5%85%B3%E4%BA%8E%E8%BF%AA%E6%96%87%E4%B8%B2%E5%8F%A3%E5%B1%8F%E9%A9%B1%E5%8A%A8/</id>
    <published>2023-10-25T07:27:08.000Z</published>
    <updated>2023-10-25T12:47:22.590Z</updated>
    
    <content type="html"><![CDATA[<p>嵌入式系统开发中，我们会经常使用到串口屏，主要是因为串口屏使用起来比较简单，不需要花费大量的时间来编写底层实现逻辑代码，我们只需要根据它的协议通过串口进行数据的传输和显示就好了。串口屏在工业上有很多品牌，这里主要以迪文显示屏为例，来看看它的使用和驱动编写。</p><h1 id="dgus-屏的简介">DGUS 屏的简介</h1><p>迪文串口屏采用的是 <span style="color:blue">DGUS（<strong>D</strong>WIN <strong>G</strong>raphic <strong>U</strong>tilized <strong>S</strong>oftware）开发体系</span>，由 DGUS 屏和 DGUS 开发软件构成，如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025164002877.png" /></p><p>DGUS 把 GUI（用户图形界面）的每一个页面分解成多个控件，用户需要实现某个功能只需要利用 PC 端的开发软件在相应的页面上添加功能控件即可实现。</p><p>使用上位机软件新建一个工程时，会自动生成一系列文件，这些文件包含了<strong>触控配置文件</strong>，<strong>变量配置文件</strong>，<strong>变量初始化文件</strong>，<strong>OS代码</strong>，<strong>图标库</strong>，<strong>屏幕参数配置文件</strong>。另外还需要准备一些界面图片。</p><h1 id="dgus-屏的存储空间">DGUS 屏的存储空间</h1><p>DGUS 屏提供有 <strong>FLASH储存空间、RAM储存空间、配置寄存器空间，以及曲线缓冲区</strong>。</p><ul><li><strong>FLASH储存空间（256MB/1GB/2GB）</strong></li></ul><p>FLASH 储存空间主要用于储存参数配置文件、图片文件、声音文件、字库文件、图标库、触控配置文件、变量配置文件、OS 代码、用户数据等。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025170212747.png" /></p><ul><li><strong>RAM储存空间（56KB）</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025170249644.png" alt="" /><figcaption>image-20231025170249644</figcaption></figure><ul><li><strong>配置寄存器空间（256Byte）</strong></li></ul><p>用来存放寄存器状态的，比如 RTC（实时时间）、背光亮度等实时的状态。通过 DGUS 的串口指令改变各寄存器的值，可实现上位机与 DGUS 屏信息传输及控制。寄存器地址0x00~0xFF，部分寄存器如下所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025172556583.png" alt="" /><figcaption>image-20231025172556583</figcaption></figure><ul><li><strong>曲线缓冲区（16KB）</strong></li></ul><p>缓冲区中可存储 8 条曲线趋势图。将数据按照 DGUS 指令格式发送至缓冲区中，即可快速实现曲线的显示。曲线缓冲区的数据都是 16 位无符号数。</p><h1 id="dgus-屏的串口通信">DGUS 屏的串口通信</h1><p>DGUS 屏采用串口（<strong>1 个起始位，8 个数据位，1 个停止位</strong>）通信，可采用 RS232 或 RS485 两种通信方式。串口波特率可通过 CONFIG 文件来配置。串口的所有指令或数据都是 16 进制（HEX）格式；对于字型（2 字节）数据，<strong>总是采用高字节先传送（MSB）方式</strong>，如 <code>0x1234</code> 先传送 <code>0x12</code>。</p><p>DGUS 屏采用变量驱动模式工作，屏的工作模式和 GUI 的状态完全由数据变量来控制。因此，<strong>串口指令也只需要对变量进行读、写即可</strong>，指令集非常简单，一共只有 <span style="color:green"><strong>5</strong></span> 条指令。如下所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025153443743.png" alt="" /><figcaption>image-20231025153443743</figcaption></figure><p>一条完整的串口指令协议结构如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025172028362.png" alt="" /><figcaption>image-20231025172028362</figcaption></figure><p>编程时遵循这种协议格式进行数据传输，就可以实现屏幕与MCU之间的正常沟通。</p><h1 id="dgus-屏的驱动实现">DGUS 屏的驱动实现</h1><p>根据以上的通信协议，写出如下几个函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DGUS_FRAME_HEAD1 (0x5a)                     <span class="hljs-comment">/* DGUS帧头1 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DGUS_FRAME_HEAD2 (0xa5)                     <span class="hljs-comment">/* DGUS帧头2 */</span></span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">command</span></span><span class="hljs-class">&#123;</span>  CMD_REG_WRITE = <span class="hljs-number">0x80</span>,  <span class="hljs-comment">/* DGUS写寄存器指令 */</span>  CMD_REG_READ,          <span class="hljs-comment">/* DGUS读寄存器指令 */</span>  CMD_DATA_WRITE,        <span class="hljs-comment">/* DGUS写数据指令 */</span>  CMD_DATA_READ,         <span class="hljs-comment">/* DGUS读数据指令 */</span>  CMD_CURVE_WRITE        <span class="hljs-comment">/* DGUS写曲线指令 */</span>&#125;;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_reg_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_reg_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_data_write</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> addr, <span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_data_read</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> addr,<span class="hljs-type">uint8_t</span> length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_curve_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length, <span class="hljs-type">uint8_t</span> ch_mode)</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif dgus通过串口发送数据</span><span class="hljs-comment">  * @param p_tx_data 数据指针</span><span class="hljs-comment">  * @param size 数据长度</span><span class="hljs-comment">  * @retval none</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_send_data</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> size)</span>&#123;  HAL_UART_Transmit(&amp;huart2, p_tx_data, size, <span class="hljs-number">1000</span>);<span class="hljs-keyword">while</span>(HAL_UART_GetState(&amp;huart2， UART_FLAG_TC) != SET);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif CRC16数据校验</span><span class="hljs-comment">  * @param buf 数据缓存指针</span><span class="hljs-comment">  * @param length 数据长度</span><span class="hljs-comment">  * @retval crc16 校验值</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> <span class="hljs-title function_">CalcDwinCRC16</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *buf,<span class="hljs-type">uint16_t</span> length)</span>&#123;  <span class="hljs-type">uint16_t</span> crc16,data,val;   crc16 = <span class="hljs-number">0x0000</span>;   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)  &#123;    <span class="hljs-keyword">if</span>((i % <span class="hljs-number">8</span>) == <span class="hljs-number">0</span>)    &#123;      data = (*buf++)&lt;&lt;<span class="hljs-number">8</span>;     &#125;    val = crc16 ^ data;    crc16 = crc16&lt;&lt;<span class="hljs-number">1</span>;    data = data &lt;&lt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(val&amp;<span class="hljs-number">0x8000</span>)    &#123;      crc16 = crc16 ^ <span class="hljs-number">0x8005</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> crc16;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif 向DGUS屏寄存器写入数据</span><span class="hljs-comment">  * @param reg_addr 寄存器地址</span><span class="hljs-comment">  * @param p_tx_data 写入数据的指针</span><span class="hljs-comment">  * @param length 写入的数据长度</span><span class="hljs-comment">  * @retval none.</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">dgus_reg_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length)</span>&#123;  <span class="hljs-type">uint8_t</span> frame_Reg_Write[<span class="hljs-number">20</span>];  frame_Reg_Write[<span class="hljs-number">0</span>] = DGUS_FRAME_HEAD1;  frame_Reg_Write[<span class="hljs-number">1</span>] = DGUS_FRAME_HEAD2;  frame_Reg_Write[<span class="hljs-number">2</span>] = (<span class="hljs-type">uint8_t</span>)(length+<span class="hljs-number">4</span>);  frame_Reg_Write[<span class="hljs-number">3</span>] = CMD_REG_WRITE;  frame_Reg_Write[<span class="hljs-number">4</span>] = reg_addr;  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)  &#123;    frame_Reg_Write[<span class="hljs-number">5</span>+i] = p_tx_data[i];  &#125;  <span class="hljs-type">uint16_t</span> checkCode=CalcDwinCRC16(&amp;frame_Reg_Write[<span class="hljs-number">3</span>]，length+<span class="hljs-number">2</span>);  frame_Reg_Write[length+<span class="hljs-number">5</span>]=(<span class="hljs-type">uint8_t</span>)checkCode; <span class="hljs-comment">//数组中高字节在后</span>  frame_Reg_Write[length+<span class="hljs-number">6</span>]=(<span class="hljs-type">uint8_t</span>)(checkCode&gt;&gt;<span class="hljs-number">8</span>);      dgus_send_data(frame_Reg_Write，(length+<span class="hljs-number">7</span>));&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif 读DGUS屏寄存器数据</span><span class="hljs-comment">  * @param reg_addr 寄存器地址</span><span class="hljs-comment">  * @param length 读取的数据长度</span><span class="hljs-comment">  * @retval none.</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">dgus_reg_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> length)</span>&#123;  <span class="hljs-type">uint8_t</span> frame_Reg_Read[<span class="hljs-number">20</span>];<span class="hljs-comment">//读数据命令</span>  frame_Reg_Read[<span class="hljs-number">0</span>] = DGUS_FRAME_HEAD1;  frame_Reg_Read[<span class="hljs-number">1</span>] = DGUS_FRAME_HEAD2;  frame_Reg_Read[<span class="hljs-number">2</span>] = (<span class="hljs-type">uint8_t</span>)(length+<span class="hljs-number">5</span>);  frame_Reg_Read[<span class="hljs-number">3</span>] = CMD_REG_READ;  frame_Reg_Read[<span class="hljs-number">4</span>] = reg_addr;  frame_Reg_Read[<span class="hljs-number">5</span>] = length;  <span class="hljs-type">uint16_t</span> checkCode=CalcDwinCRC16(&amp;frame_Reg_Read[<span class="hljs-number">3</span>],<span class="hljs-number">3</span>);  frame_Reg_Read[<span class="hljs-number">6</span>]=(<span class="hljs-type">uint8_t</span>)checkCode;  frame_Reg_Read[<span class="hljs-number">7</span>]=(<span class="hljs-type">uint8_t</span>)(checkCode&gt;&gt;<span class="hljs-number">8</span>);  dgus_send_data(frame_Reg_Read,<span class="hljs-number">0x08</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif 向DGUS屏变量存储器写数据</span><span class="hljs-comment">  * @param addr 变量存储器地址</span><span class="hljs-comment">  * @param p_tx_data 数据指针</span><span class="hljs-comment">  * @param length 写入的数据长度</span><span class="hljs-comment">  * @retval none.</span><span class="hljs-comment">  * @note 一次最多允许写47个字，即length&lt;=94</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">dgus_data_write</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> addr, <span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length)</span>&#123;  <span class="hljs-type">uint8_t</span> frame_data_Write[<span class="hljs-number">102</span>];  frame_data_Write[<span class="hljs-number">0</span>] = DGUS_FRAME_HEAD1;  frame_data_Write[<span class="hljs-number">1</span>] = DGUS_FRAME_HEAD2;  frame_data_Write[<span class="hljs-number">2</span>] = (<span class="hljs-type">uint8_t</span>)(length+<span class="hljs-number">3</span>);  frame_data_Write[<span class="hljs-number">3</span>] = CMD_DATA_WRITE;  frame_data_Write[<span class="hljs-number">4</span>] = (<span class="hljs-type">uint8_t</span>)(addr&gt;&gt;<span class="hljs-number">8</span>);<span class="hljs-comment">//起始地址</span>  frame_data_Write[<span class="hljs-number">5</span>] = (<span class="hljs-type">uint8_t</span>)addr;<span class="hljs-comment">//起始地址</span>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)  &#123;    frame_data_Write[<span class="hljs-number">6</span>+i] = p_tx_data[i];  &#125;  <span class="hljs-type">uint16_t</span> checkCode = CalcDwinCRC16(&amp;frame_data_Write[<span class="hljs-number">3</span>],length+<span class="hljs-number">3</span>);  frame_data_Write[length+<span class="hljs-number">6</span>] = (<span class="hljs-type">uint8_t</span>)checkCode;  frame_data_Write[length+<span class="hljs-number">7</span>] = (<span class="hljs-type">uint8_t</span>)(checkCode&gt;&gt;<span class="hljs-number">8</span>);  dgus_send_data(frame_data_Write,(length+<span class="hljs-number">8</span>));&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif 读DGUS屏变量存储器数据</span><span class="hljs-comment">  * @param addr 变量存储器地址</span><span class="hljs-comment">  * @param length 读取的数据长度</span><span class="hljs-comment">  * @retval none.</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">dgus_data_read</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> addr,<span class="hljs-type">uint8_t</span> length)</span>&#123;  <span class="hljs-type">uint8_t</span> frame_data_read[<span class="hljs-number">20</span>];<span class="hljs-comment">//读数据命令</span>  frame_data_read[<span class="hljs-number">0</span>] = DGUS_FRAME_HEAD1;  frame_data_read[<span class="hljs-number">1</span>] = DGUS_FRAME_HEAD2;  frame_data_read[<span class="hljs-number">2</span>] = <span class="hljs-number">0x04</span>;  frame_data_read[<span class="hljs-number">3</span>] = CMD_DATA_READ;  frame_data_read[<span class="hljs-number">4</span>] = (<span class="hljs-type">uint8_t</span>)(addr&gt;&gt;<span class="hljs-number">8</span>);<span class="hljs-comment">//起始地址</span>  frame_data_read[<span class="hljs-number">5</span>] = (<span class="hljs-type">uint8_t</span>)addr;<span class="hljs-comment">//起始地址</span>  frame_data_read[<span class="hljs-number">6</span>] = length;<span class="hljs-comment">//读取长度</span>    <span class="hljs-type">uint16_t</span> checkCode=CalcDwinCRC16(&amp;frame_data_read[<span class="hljs-number">3</span>],<span class="hljs-number">4</span>);  frame_data_read[<span class="hljs-number">7</span>]=(<span class="hljs-type">uint8_t</span>)checkCode;  frame_data_read[<span class="hljs-number">8</span>]=(<span class="hljs-type">uint8_t</span>)(checkCode&gt;&gt;<span class="hljs-number">8</span>);  dgus_send_data(frame_data_read,<span class="hljs-number">0x09</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif DGUS屏画曲线</span><span class="hljs-comment">  * @param p_tx_data 数据指针</span><span class="hljs-comment">  * @param length 数据长度</span><span class="hljs-comment">  * @param ch_mode 通道模式</span><span class="hljs-comment">  * @retval none.</span><span class="hljs-comment">  * @note 一次最多允许写8个字，即length&lt;=16</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">dgus_curve_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length, <span class="hljs-type">uint8_t</span> ch_mode)</span>&#123;  <span class="hljs-type">uint8_t</span> frame_curve_Write[<span class="hljs-number">23</span>];<span class="hljs-comment">//写曲线缓冲区命令</span>  frame_curve_Write[<span class="hljs-number">0</span>] = DGUS_FRAME_HEAD1;  frame_curve_Write[<span class="hljs-number">1</span>] = DGUS_FRAME_HEAD2;  frame_curve_Write[<span class="hljs-number">2</span>] = (<span class="hljs-type">uint8_t</span>)(length+<span class="hljs-number">2</span>);  frame_curve_Write[<span class="hljs-number">3</span>] = CMD_CURVE_WRITE;  frame_curve_Write[<span class="hljs-number">4</span>] = ch_mode;  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)  &#123;    frame_curve_Write[<span class="hljs-number">5</span>+i] = p_tx_data[i];  &#125;  <span class="hljs-type">uint16_t</span> checkCode=CalcDwinCRC16(&amp;frame_curve_Write[<span class="hljs-number">3</span>],length+<span class="hljs-number">2</span>);  frame_curve_Write[length+<span class="hljs-number">5</span>]=(<span class="hljs-type">uint8_t</span>)checkCode;  frame_curve_Write[length+<span class="hljs-number">6</span>]=(<span class="hljs-type">uint8_t</span>)(checkCode&gt;&gt;<span class="hljs-number">8</span>);  dgus_send_data(frame_curve_Write,length+<span class="hljs-number">7</span>);&#125;</code></pre></div><p>根据需求，在上层应用中调用以上API函数，即可实现屏幕与MCU的通信。</p><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/foxclever/article/details/121734689">【精选】外设驱动库开发笔记35：迪文触摸屏驱动_迪文k600+触摸校准-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;嵌入式系统开发中，我们会经常使用到串口屏，主要是因为串口屏使用起来比较简单，不需要花费大量的时间来编写底层实现逻辑代码，我们只需要根据它的协议通过串口进行数据的传输和显示就好了。串口屏在工业上有很多品牌，这里主要以迪文显示屏为例，来看看它的使用和驱动编写。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="单片机" scheme="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="串口屏" scheme="http://example.com/tags/%E4%B8%B2%E5%8F%A3%E5%B1%8F/"/>
    
  </entry>
  
  <entry>
    <title>阅读摘录</title>
    <link href="http://example.com/2023/10/22/%E9%98%85%E8%AF%BB%E6%91%98%E5%BD%95/"/>
    <id>http://example.com/2023/10/22/%E9%98%85%E8%AF%BB%E6%91%98%E5%BD%95/</id>
    <published>2023-10-22T14:23:41.000Z</published>
    <updated>2023-10-23T08:38:41.109Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在整理之前收录的文章，读到了一篇关于阅读意义的文章，觉得写的挺好，摘录如下：</p><ul><li><p>“<strong>我这辈子遇到的聪明人，来自各行各业的聪明人，没有不每天阅读的。没有，一个都没有。--------查理·芒格</strong>”</p></li><li><p><strong>一个人的成长，一个人的自我突破过程，很大程度上就是他的阅读史。</strong>所以我们才有了这样一句话：你的气质里，藏着你走过的路，读过的书，爱过的人。</p></li><li><p><strong><span style="color:green">几乎所有领导者都是通过读书打开了自我，从而有了自己清晰的人生目标与追求。</span></strong></p></li><li><p>读书的好处，是可以让我们跳出此时此地的限制，穿透一时一地的迷雾，从更大的格局和更长远的眼光来把握眼前的各种扰动，从而把不解和不安化成豁然开朗和淡定从容，最后养成战略上的定力。</p></li><li><p>好的书，提供的是在无数人的经验教训的基础之上总结出来的规律和原则，让人可以更好、更快地理解自己和所处的这个世界，以及背后的行为逻辑。</p></li><li><p><strong>使命是做什么，思想是怎么做。这都是领导力的核心，而这些都离不开读书。</strong></p></li><li><p>读经典，就是在跟大师对话。这是提高自己思维水平的最有效途径。</p></li><li><p><strong>读书一定要带着问题意识。</strong>最好的读书是联系实际来读书，善于把书本中的普遍规律与我们的具体实践结合起来。</p></li><li><p>高管需要的是理念，是思想，而基层需要的是解决具体问题的操作性方法。所以读书一定要分层级。就像共产党那样，从毛泽东的思想，到林彪的战术理念，到士兵的具体打法，一步步落地。</p></li></ul><p><strong>原文</strong>：<a href="https://mp.weixin.qq.com/s/p4OUvyx8edUlc1JyUFQUTA">为什么管理者必须要大量阅读？</a></p><p><strong>管理类书籍推荐：</strong></p><p><span style="color:blue">《乔布斯传》《从优秀到卓越》《创新者的窘境》《影响力》《卓有成效的管理者》《裂变》《穷查理宝典》《大赛车》《傻瓜理财指南》 《创业维艰》《精益创业》《从0到1》 《人性的优势》《献给经理人的一本书》《团队合作的五大障碍》《认识商业》《逃不开的经济周期》《失控》《思考，快与慢》《黑天鹅》《洞见》《基业长青》《滚雪球》吴军的《态度》《见识》《富足》《格局》《原则》</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两天在整理之前收录的文章，读到了一篇关于阅读意义的文章，觉得写的挺好，摘录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;“&lt;strong&gt;我这辈子遇到的聪明人，来自各行各业的聪明人，没有不每天阅读的。没有，一个都没有。--------查理·芒格&lt;/strong&gt;”&lt;/p&gt;&lt;</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>stm32 IAP在线升级详解</title>
    <link href="http://example.com/2023/10/19/stm32-IAP%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/10/19/stm32-IAP%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-10-19T05:01:39.000Z</published>
    <updated>2023-10-26T02:55:44.313Z</updated>
    
    <content type="html"><![CDATA[<p>单片机程序的烧录方式主要有以下三种：</p><ul><li><span style="color:blue">ICP（In Circuit Programming）线路途径烧录</span></li></ul><p>烧录器Jlink、daplink等通过JTAG或SWD线路接口进行烧录。</p><ul><li><span style="color:blue">ISP（In System Programming）系统途径烧录</span></li></ul><p>通过BootLoader引导代码和外围uart或usb等接口引导进入Flash的System Memory区，进行程序的烧录。</p><ul><li><span style="color:blue">IAP（In Application Programming）应用程序途径烧录</span></li></ul><p>通过程序自身运行过程中，对flash进行程序烧录。</p><p>在产品发布后，需要添加新功能或修复bug，而使用预留的通信接口（UART、USB、WIFI、4G、网口、蓝牙等）进行IAP程序的烧录升级，就可避免拆开机器使用下载器烧写程序，方便快捷，所以，IAP方式使用的越来越广泛，下面我们主要来看看IAP的烧录方式具体情况。</p><h1 id="iap程序的组成">IAP程序的组成</h1><p>要实现IAP功能一般要设计两个工程代码：</p><ul><li><strong><span style="color:blue">自定义BootLoader程序</span></strong></li></ul><p>BootLoader主要起引导作用，引导程序从哪一部分映射地址启动。在STM32中有两类，一类是芯片厂商固化到Flash中的自举程序，用作ISP串口下载程序；另一类属于用户自定义BootLoader程序，用于检测APP区代码是否需要更新，以及跳转到APP区执行APP程序。</p><ul><li><strong><span style="color:blue">APP应用程序</span></strong></li></ul><p>这个程序才是真正实现产品功能的程序。APP程序可分成APP1和APP2两部分，即双区模式，APP1用来存储用户程序，APP2用来当更新缓存和备份区域用。</p><p><strong>IAP的实现流程</strong>：</p><p>单片机上电后先运行BootLoader程序，检测程序更新条件是否被触发(如：<strong>上位机是否发生特定的数据、特定的按键是否按下、串口是否接收到特定数据、U盘是否插入</strong>等)，如果有则对APP应用程序进行擦除和重新写入新的用户程序，如果没有则直接跳转到APP应用程序执行应用。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/66e1355f18e349069da43d2785c8237c.png" alt="img" style="zoom:50%;" /></p><h1 id="iap实现原理">IAP实现原理</h1><p>STM32微控制器在硬件上通过<strong>boot0</strong>和<strong>boot1</strong>两个引脚的设置，可进入不同的启动模式，如下所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231020085333996.png" alt="" /><figcaption>image-20231020085333996</figcaption></figure><p>微控制器进入不同的启动模式，就是改变了flash内部中断向量表起始地址的指向，<span style="color:green"><strong>IAP的本质其实是设置存放中断向量表的地址。</strong></span></p><ul><li><strong>正常程序上电执行流程</strong>：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231019184549407.png" /></p><ul><li><strong>加入IAP后上电执行流程</strong>：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231019191454635.png" /></p><p>更新中断向量表的方法：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> APPLICATION_ADDRESS   (uint32_t)0x08008000</span>SCB-&gt;VTOR = APPLICATION_ADDRESS;</code></pre></div><h1 id="iap-flash分区">IAP flash分区</h1><h1 id="程序的实现">程序的实现</h1><p>程序实现主要是BootLoader程序和APP用户程序的编写。</p><h4 id="bootloader程序">BootLoader程序</h4><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>APPLICATION_NORMAL = <span class="hljs-number">0</span>,<span class="hljs-comment">// APP能正常稳定运行</span>APPLICATION_UPDATED,<span class="hljs-comment">// APP刚更新完成，等待测试启动</span>APPLICATION_ERROR,<span class="hljs-comment">// APP错误，不能正常工作</span>&#125;Application_Status_t; <span class="hljs-keyword">typedef</span>__PACKED_STRUCT&#123;<span class="hljs-type">uint32_t</span> Device_id;<span class="hljs-comment">// 设备号</span><span class="hljs-type">uint32_t</span> Hardware_Version;<span class="hljs-comment">// 硬件版本信息</span><span class="hljs-type">uint32_t</span> Application0_Version;<span class="hljs-comment">// APP0软件版本</span><span class="hljs-type">uint32_t</span> Application1_Version;<span class="hljs-comment">// APP1软件版本</span><span class="hljs-type">uint32_t</span> Application0_Status;<span class="hljs-comment">// APP0的状态. @Application_Status_t</span><span class="hljs-type">uint32_t</span> Application1_Status;<span class="hljs-comment">// APP1的状态. @Application_Status_t</span><span class="hljs-type">uint8_t</span>  Server_Address[<span class="hljs-number">64</span>];<span class="hljs-comment">// 服务器的地址</span><span class="hljs-type">uint32_t</span> Server_Port;<span class="hljs-comment">// 服务器的端口号</span><span class="hljs-type">uint8_t</span>  Server_Key[<span class="hljs-number">4</span>];<span class="hljs-comment">// 服务器的登录密钥，随时更新</span><span class="hljs-type">uint32_t</span> SystemParamCRC;&#125;SystemParamTypeDef;<span class="hljs-type">void</span> <span class="hljs-title function_">System_ParamReadCheck</span><span class="hljs-params">(SystemParamTypeDef *pData)</span>&#123;<span class="hljs-type">uint32_t</span> crcdatalen = <span class="hljs-number">0</span>;SystemParamTypeDef sysparam, sysparambackup; <span class="hljs-comment">/* 读取主区和备份区的系统参数 */</span>FLASH_If_Read(SYSTEMPARAM_ADDRESS, (<span class="hljs-type">uint32_t</span>*) &amp;sysparam, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span>);FLASH_If_Read(SYSTEMPARAM_BACKUPADDRESS, (<span class="hljs-type">uint32_t</span>*) &amp;sysparambackup, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span>); <span class="hljs-comment">// 去掉系统参数CRC的数据校验长度</span>crcdatalen = <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span> - <span class="hljs-number">1</span>;<span class="hljs-comment">/* 主系统参数区放的的数据CRC校验  */</span><span class="hljs-keyword">if</span> (HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span>*) &amp;sysparam, crcdatalen)== sysparam.SystemParamCRC)&#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> *  @ 系统参数主存储区的数据校验正确，</span><span class="hljs-comment"> *  @ 开始校验系统参数备份区的数据：</span><span class="hljs-comment"> *    1、如果备份区的数据CRC校验正确，则进行对比数据一致性，不一致则将主区数据写入备份区</span><span class="hljs-comment"> *    2、如果备份区的数据CRC校验错误，则将主区的系统参数据写入备份区；</span><span class="hljs-comment"> * */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter main sector data checked OK\r\n&quot;</span>);<span class="hljs-keyword">if</span> (HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span>*) &amp;sysparambackup, crcdatalen) == sysparambackup.SystemParamCRC)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter backup sector data checked OK\r\n&quot;</span>);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(&amp;sysparam, &amp;sysparambackup, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef)) != <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter main sector and backup sector data are different, update backup sector data\r\n&quot;</span>);<span class="hljs-built_in">memcpy</span>(&amp;sysparambackup, &amp;sysparam, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, &amp;sysparambackup);&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter main sector and backup sector data are the same\r\n&quot;</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter backup sector data checked Fail, update backup sector data\r\n&quot;</span>);<span class="hljs-built_in">memcpy</span>(&amp;sysparambackup, &amp;sysparam, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, &amp;sysparambackup);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> *  @ 系统参数主存储区的数据校验错误</span><span class="hljs-comment"> *  @ 开始校验系统参数备份区的数据：</span><span class="hljs-comment"> *    1、如果备份区的数据CRC校验正确，则将备份区数据写入主区</span><span class="hljs-comment"> *    2、如果备份区的数据CRC校验错误，则将默认系统参数数据写入两个区域，强行启动APP0；</span><span class="hljs-comment"> * */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter main sector data checked Fail\r\n&quot;</span>);<span class="hljs-keyword">if</span> (HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span>*) &amp;sysparambackup, crcdatalen) == sysparambackup.SystemParamCRC)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter backup sector data checked OK, update master sector data\r\n&quot;</span>);<span class="hljs-built_in">memcpy</span>(&amp;sysparam, &amp;sysparambackup, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));System_ParamUpdate(SYSTEMPARAM_ADDRESS, &amp;sysparam);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter main sector and backup sector data checked Fail, Restore defaults\r\n&quot;</span>);SystemParam_default.SystemParamCRC = HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span>*) &amp;SystemParam_default, crcdatalen);<span class="hljs-built_in">memcpy</span>(&amp;sysparam, &amp;SystemParam_default, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));<span class="hljs-built_in">memcpy</span>(&amp;sysparambackup, &amp;SystemParam_default, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));System_ParamUpdate(SYSTEMPARAM_ADDRESS, &amp;sysparam);System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, &amp;sysparambackup);&#125;&#125; <span class="hljs-built_in">memcpy</span>(pData, &amp;sysparam, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hardware_Version = 0x%08lX\r\n&quot;</span>, pData-&gt;Hardware_Version);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Application0_Version = 0x%08lX\r\n&quot;</span>, pData-&gt;Application0_Version);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Application0_Status  = 0x%08lX\r\n&quot;</span>, pData-&gt;Application0_Status);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Application1_Version = 0x%08lX\r\n&quot;</span>, pData-&gt;Application1_Version);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Application1_Status  = 0x%08lX\r\n&quot;</span>, pData-&gt;Application1_Status);&#125;<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">System_SelectBootAddress</span><span class="hljs-params">(SystemParamTypeDef *pData)</span>&#123;<span class="hljs-type">uint32_t</span> BootAddress = <span class="hljs-number">0</span>; <span class="hljs-keyword">if</span> (pData-&gt;Application0_Version &gt;= pData-&gt;Application1_Version)&#123;<span class="hljs-keyword">if</span> (pData-&gt;Application0_Status == APPLICATION_NORMAL)&#123;<span class="hljs-comment">/* 正常启动 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP0 APPLICATION_NORMAL. Run the APP0.\r\n&quot;</span>);BootAddress = APPLICATION0_ADDRESS;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pData-&gt;Application0_Status == APPLICATION_UPDATED)&#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * 刚IAP更新的程序固件，把APP的status改成 错误标志位 @APPLICATION_ERROR，</span><span class="hljs-comment"> * 1、若APP跳转运行正常后会修改成正常启动标志 @APPLICATION_NORMAL。</span><span class="hljs-comment"> * 2、若APP跳转运行失败（跑飞），那么看门狗会复位，重启后该APP是错误标志不会启动。</span><span class="hljs-comment"> * 3、清空版本信息，待启动修正。</span><span class="hljs-comment"> * 4、更新系统参数，写入flash</span><span class="hljs-comment"> * */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP0 APPLICATION_UPDATED. Clear APP0 system parameters, Run the APP0.\r\n&quot;</span>);pData-&gt;Application0_Version = <span class="hljs-number">0</span>;pData-&gt;Application0_Status = APPLICATION_ERROR;System_ParamUpdate(SYSTEMPARAM_ADDRESS, pData);System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, pData);BootAddress = APPLICATION0_ADDRESS;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 由于APP0信息错误，强制启动APP1 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP0 APPLICATION_ERROR. Forced the APP1 to run.\r\n&quot;</span>);BootAddress = APPLICATION1_ADDRESS;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (pData-&gt;Application1_Status == APPLICATION_NORMAL)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP1 APPLICATION_NORMAL. Run the APP1.\r\n&quot;</span>);BootAddress = APPLICATION1_ADDRESS;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pData-&gt;Application1_Status == APPLICATION_UPDATED)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP1 APPLICATION_UPDATED. Clear APP1 system parameters, Run the APP1.\r\n&quot;</span>);pData-&gt;Application1_Version = <span class="hljs-number">0</span>;pData-&gt;Application1_Status = APPLICATION_ERROR;System_ParamUpdate(SYSTEMPARAM_ADDRESS, pData);System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, pData);BootAddress = APPLICATION1_ADDRESS;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 由于APP1信息错误，强制启动APP0 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP1 APPLICATION_ERROR. Forced the APP0 to run.\r\n&quot;</span>);BootAddress = APPLICATION0_ADDRESS;&#125;&#125; <span class="hljs-keyword">return</span> BootAddress;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>   <span class="hljs-comment">/* USER CODE END 1 */</span>   <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>   <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>  HAL_Init();   <span class="hljs-comment">/* USER CODE BEGIN Init */</span>   <span class="hljs-comment">/* USER CODE END Init */</span>   <span class="hljs-comment">/* Configure the system clock */</span>  SystemClock_Config();   <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>   <span class="hljs-comment">/* USER CODE END SysInit */</span>   <span class="hljs-comment">/* Initialize all configured peripherals */</span>  MX_GPIO_Init();  MX_USART1_UART_Init();  MX_CRC_Init();  MX_IWDG_Init();  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nSudaroot, This is a advanced bootloader\r\n&quot;</span>);  <span class="hljs-comment">/* system param read check */</span>  System_ParamReadCheck(&amp;SystemParam);  <span class="hljs-comment">/* execute the new program */</span>  HAL_IWDG_Refresh(&amp;hiwdg);  JumpAddress = System_SelectBootAddress(&amp;SystemParam);  JumpAddress = *(__IO <span class="hljs-type">uint32_t</span>*) (JumpAddress + <span class="hljs-number">4</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Start program execution......\r\n\n\n&quot;</span>);  <span class="hljs-comment">/*</span><span class="hljs-comment">   * 关闭或反初始化前面用到的外设和中断</span><span class="hljs-comment">   * 1、反初始化UART</span><span class="hljs-comment">   * 2、关闭系统滴答定时器中断</span><span class="hljs-comment">   * */</span>  HAL_UART_DeInit(&amp;huart1);  HAL_SuspendTick();  <span class="hljs-comment">/* Refresh the IWDG. */</span>  HAL_IWDG_Refresh(&amp;hiwdg);  <span class="hljs-comment">/* Jump to user application */</span>  JumpToApplication = (pFunction) JumpAddress;  <span class="hljs-comment">/* Initialize user application&#x27;s Stack Pointer */</span>  __set_MSP(*(__IO <span class="hljs-type">uint32_t</span>*) (JumpAddress - <span class="hljs-number">4</span>));  JumpToApplication();  <span class="hljs-comment">/* USER CODE END 2 */</span>   <span class="hljs-comment">/* Infinite loop */</span>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;    <span class="hljs-comment">/* USER CODE END WHILE */</span>     <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>  &#125;  <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><h3 id="app程序">APP程序</h3><p>这部分可使用 <strong>YModem协议</strong>，也可不使用，</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Define APP0 software version */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>APPLICATION0_VERSION0x00000010U</span><span class="hljs-type">void</span> <span class="hljs-title function_">System_ParamReadCheckUpdate</span><span class="hljs-params">(SystemParamTypeDef *pData)</span>&#123;<span class="hljs-type">uint32_t</span> flash_update = <span class="hljs-number">0</span>; FLASH_If_Read(SYSTEMPARAM_ADDRESS, (<span class="hljs-type">uint32_t</span>*)pData, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span>); <span class="hljs-comment">/* APP0的软件版本号与固件内部软件版本号不一致，更新版本号并写入Flash */</span><span class="hljs-keyword">if</span>(pData-&gt;Application0_Version != APPLICATION0_VERSION)&#123;flash_update = <span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Update APP0 Software Version : 0x%08X\r\n&quot;</span>, APPLICATION0_VERSION);pData-&gt;Application0_Version = APPLICATION0_VERSION;&#125; <span class="hljs-comment">/* APP0 启动了，但是APP0的状态是错误标志.</span><span class="hljs-comment"> * 可能是由于更新完成后，第一次启动标记的，</span><span class="hljs-comment"> * 修正为APPLICATION_NORMAL，重新写入flash</span><span class="hljs-comment"> * */</span><span class="hljs-keyword">if</span>(pData-&gt;Application0_Status != APPLICATION_NORMAL)&#123;flash_update = <span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Update APP0 Status, APPLICATION_NORMAL\r\n&quot;</span>);pData-&gt;Application0_Status = APPLICATION_NORMAL;&#125; <span class="hljs-comment">/* 如果flash_update 等于 1， 即flash需要更新主存储区和备份区的系统参数数据</span><span class="hljs-comment"> * 更新数据后，需要重启</span><span class="hljs-comment"> * 注意：更新数据时，必须擦除一个扇区后写入完成后，才能更新另一个区域数据，否则有概率丢失两个扇区数据</span><span class="hljs-comment"> * */</span><span class="hljs-keyword">if</span>(flash_update == <span class="hljs-number">1</span>)&#123;pData-&gt;SystemParamCRC = HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span> *)pData, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span> - <span class="hljs-number">1</span>);System_ParamUpdate(SYSTEMPARAM_ADDRESS, pData);System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, pData);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;device reboot\r\n&quot;</span>);HAL_NVIC_SystemReset();&#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">SystemParam_IAP</span><span class="hljs-params">(SystemParamTypeDef *pData)</span>&#123;<span class="hljs-type">uint32_t</span> temp = <span class="hljs-number">0</span>;<span class="hljs-type">uint32_t</span> file_length= <span class="hljs-number">0</span>;<span class="hljs-type">uint32_t</span> timeout = HAL_MAX_DELAY; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System IAP start, update APP1\r\n&quot;</span>);<span class="hljs-comment">/* Download user application in the Flash */</span><span class="hljs-comment">/* 1. erase user application1 area */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Wait for the internal Flash erase to complete\r\n&quot;</span>);<span class="hljs-keyword">if</span>(FLASH_If_Erase(APPLICATION1_ADDRESS, APPLICATION1_SECTOR_NUM) == <span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Erase the internal Flash is fail\r\n&quot;</span>);Error_Handler();&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Erase the internal Flash is complete\r\n&quot;</span>); <span class="hljs-comment">/* 2. download a file via serial port */</span><span class="hljs-comment">/* Clean the input path */</span>__HAL_UART_FLUSH_DRREGISTER(&amp;huart1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for the file to be sent ... \r\n&quot;</span>); <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(HAL_UART_Receive(&amp;huart1, uart_buf, UART_BUF_SIZE, timeout) != HAL_OK)&#123;temp = UART_BUF_SIZE - (huart1.RxXferCount + <span class="hljs-number">1</span>);FLASH_If_Write(APPLICATION1_ADDRESS + file_length, (<span class="hljs-type">uint32_t</span>*)uart_buf, file_length / <span class="hljs-number">4</span>);file_length = file_length + temp;<span class="hljs-keyword">break</span>;&#125;timeout = <span class="hljs-number">1000</span>;FLASH_If_Write(APPLICATION1_ADDRESS + file_length, (<span class="hljs-type">uint32_t</span>*)uart_buf, UART_BUF_SIZE / <span class="hljs-number">4</span>);file_length = file_length + UART_BUF_SIZE;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Programming Completed Successfully! %ldBtye\r\n&quot;</span>, file_length);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Update system parameters\r\n&quot;</span>);pData-&gt;Application1_Version = <span class="hljs-number">0xFFFFFFFF</span>;pData-&gt;Application1_Status  = APPLICATION_UPDATED;pData-&gt;SystemParamCRC = HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span> *)pData, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span> - <span class="hljs-number">1</span>);System_ParamUpdate(SYSTEMPARAM_ADDRESS, pData);System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, pData); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;device reboot\r\n&quot;</span>);HAL_NVIC_SystemReset();&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> key = <span class="hljs-number">0</span>; SCB-&gt;VTOR = APPLICATION0_ADDRESS;  <span class="hljs-comment">/* USER CODE END 1 */</span>   <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>   <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>  HAL_Init();   <span class="hljs-comment">/* USER CODE BEGIN Init */</span>   <span class="hljs-comment">/* USER CODE END Init */</span>   <span class="hljs-comment">/* Configure the system clock */</span>  SystemClock_Config();   <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>   <span class="hljs-comment">/* USER CODE END SysInit */</span>   <span class="hljs-comment">/* Initialize all configured peripherals */</span>  MX_GPIO_Init();  MX_USART1_UART_Init();  MX_IWDG_Init();  MX_CRC_Init();  MX_TIM2_Init();  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>  HAL_TIM_Base_Start_IT(&amp;htim2);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nSudaroot, This is IAP Application0\r\n&quot;</span>);  System_ParamReadCheckUpdate(&amp;SystemParam);  <span class="hljs-comment">/* USER CODE END 2 */</span>   <span class="hljs-comment">/* Infinite loop */</span>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n=================== Main Menu ============================\r\n\n&quot;</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  IAP:Download user application to the internal Flash ----- 1\r\n\n&quot;</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Current System APP0 Version: 0x%08lX\r\n&quot;</span>, SystemParam.Application0_Version);  <span class="hljs-comment">/* Clean the input path */</span>  __HAL_UART_FLUSH_DRREGISTER(&amp;huart1);  <span class="hljs-keyword">if</span>(HAL_UART_Receive(&amp;huart1, &amp;key, <span class="hljs-number">1</span>, HAL_MAX_DELAY) == HAL_OK)  &#123;  <span class="hljs-keyword">if</span>(key == <span class="hljs-string">&#x27;1&#x27;</span>)  &#123;  SystemParam_IAP(&amp;SystemParam);  &#125;  &#125;    <span class="hljs-comment">/* USER CODE END WHILE */</span>     <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>  &#125;  <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><p><a href="https://blog.csdn.net/xys430381_1/article/details/105409808">stm32-IAP（在线升级程序）_stm32 在线升级-CSDN博客</a></p><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/sudaroot/article/details/106932736">STM32CubeIDE IAP原理讲解，及UART双APP交替升级IAP实现-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_41294615/article/details/104669766">STM32CubeMx开发之路—在线升级OTA_stm32ota升级例程-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单片机程序的烧录方式主要有以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;color:blue&quot;&gt;ICP（In Circuit Programming）线路途径烧录&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;烧录器Jlink、daplink等通过JT</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="IAP" scheme="http://example.com/tags/IAP/"/>
    
  </entry>
  
  <entry>
    <title>关于过零检测电路</title>
    <link href="http://example.com/2023/10/18/%E5%85%B3%E4%BA%8E%E8%BF%87%E9%9B%B6%E6%A3%80%E6%B5%8B%E7%94%B5%E8%B7%AF/"/>
    <id>http://example.com/2023/10/18/%E5%85%B3%E4%BA%8E%E8%BF%87%E9%9B%B6%E6%A3%80%E6%B5%8B%E7%94%B5%E8%B7%AF/</id>
    <published>2023-10-18T10:43:19.000Z</published>
    <updated>2023-10-19T03:23:27.053Z</updated>
    
    <content type="html"><![CDATA[<p>在电力工程中，会经常用到<span style="color:red">过零检测</span>技术，如在智能开关产品中通过零点电压检测技术来实现在零电压时导通，从而抑制了开机时浪涌电流冲击，达到保护继电器触点等器件的目的；在调光开关/调光器、电机调速产品中，通过零点电压检测技术对可控硅从零点开始控制交流电导通角的大小，实现调光灯具亮度、电机速度的调节。</p><h1 id="过零检测的概念">过零检测的概念</h1><p>什么是过零检测呢？在交流回路中，电压随时间成正弦波变化，当波形由正负半周交替转换时，电压为 <span style="color:red">零</span> 的点就是 <span style="color:red">过零点</span>，过零检测就是对 <strong>过零点</strong> 进行检测，如下图所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018221851569.png" /></p><h1 id="过零检测的作用">过零检测的作用</h1><p>过零检测主要有以下几个作用：</p><ul><li><strong>可控硅的控制。</strong>调节可控硅的导通时间，从而进行电压控制等。</li><li><strong>交流线路器件保护。</strong>当控制AC220v电压的器件在峰值附近闭合，会产生很大的浪涌电流和火花，在过零点处闭合，就会减少浪涌影响，从而保护了器件。</li><li><strong>计时。</strong>在我国交流电频率为50Hz，周期为20ms。经过全波整流后，在每个过零点处就是10ms，可通过检测过零点进行计时。</li></ul><h1 id="过零检测电路">过零检测电路</h1><p>过零检测时，其末端输出有如下两种形式，可以利用这种呈现方式设计出可以检测这种变化的电路，然后通过MCU中断接口进行触发判断，从而做出应对控制器件导通或关闭的动作。</p><ul><li><span style="color:blue">过零点时电路末端输出脉冲</span></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018221739979.png" alt="" /><figcaption>image-20231018221739979</figcaption></figure><ul><li><span style="color:blue">过零点时电路末端电平变化</span></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018221957043.png" alt="" /><figcaption>image-20231018221957043</figcaption></figure><p>下面看看工程设计中常见的几种设计思路：</p><ul><li><strong>采用三极管的过零检测电路</strong></li></ul><p>通过分压电阻将交流信号衰减至三极管基极，利用三极管特性进行过零检测来改变输出状态。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018222920964.png" alt="" /><figcaption>image-20231018222920964</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018224755520.png" alt="" /><figcaption>image-20231018224755520</figcaption></figure><ul><li><strong>采用比较器的过零检测电路</strong></li></ul><p>通过分压电阻将交流信号衰减至比较器正端输入，当交流输入超过零基准电压时，过零检测电路会改变比较器的输出状态。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018223535069.png" alt="image-20231018223535069" /><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018225206057.png" alt="image-20231018225206057" /></p><ul><li><strong>采用光耦隔离的过零检测电路</strong></li></ul><p>这是隔离方式中最常用的一种，在设计应用中，使用最广。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018223733354.png" alt="" /><figcaption>image-20231018223733354</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018224951457.png" alt="" /><figcaption>image-20231018224951457</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018225034226.png" alt="" /><figcaption>image-20231018225034226</figcaption></figure><ul><li><strong>采用ADC采集的过零检测电路</strong></li></ul><p>通过分压电阻将交流信号衰减至ADC输入端，通过ADC进行电压采样来检测过零点。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018223927720.png" alt="" /><figcaption>image-20231018223927720</figcaption></figure><ul><li><strong>采用带过零检测功能的芯片</strong></li></ul><p>采用芯片方式，PCB布局占用面积小，可靠性高，但成本也相对要高些。如：</p><p>ROHM半导体公司的BM1ZxxxFJ系列：<a href="https://www.rohm.com.cn/products/power-management/ac-voltage-zero-cross-detection-ics#parametricSearch">过零检测IC罗姆半导体集团(ROHM Semiconductor)</a></p><p>国产的GS1102：<a href="http://www.silandtech.com/prodind.html?prodKey=ic_xp_GS1102">GS1102详情 (silandtech.com)</a></p><p>MOC303x、MOC304x、MOC308x等</p><p><strong>参考链接：</strong></p><p><a href="https://mp.weixin.qq.com/s/U4svW0Oxr6UoI1sYF5k8pg">https://mp.weixin.qq.com/s/U4svW0Oxr6UoI1sYF5k8pg</a></p><p><a href="https://mp.weixin.qq.com/s/oNA8LNU8WL6gEBPcWI3NiQ">https://mp.weixin.qq.com/s/oNA8LNU8WL6gEBPcWI3NiQ</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在电力工程中，会经常用到&lt;span style=&quot;color:red&quot;&gt;过零检测&lt;/span&gt;技术，如在智能开关产品中通过零点电压检测技术来实现在零电压时导通，从而抑制了开机时浪涌电流冲击，达到保护继电器触点等器件的目的；在调光开关/调光器、电机调速产品中，通过零点电压检测</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="过零检测" scheme="http://example.com/tags/%E8%BF%87%E9%9B%B6%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>红外遥控NEC协议详解</title>
    <link href="http://example.com/2023/10/17/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7NEC%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/10/17/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7NEC%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-10-17T02:31:50.000Z</published>
    <updated>2023-10-17T05:15:40.514Z</updated>
    
    <content type="html"><![CDATA[<p>红外遥控（IR）一般由发射和接收两部分组成，发射元件为红外发射管（遥控器），接收一般采用一体化红外接收头，发射载波频率与接收头固定频率需一致才能正确接收数据。</p><h3 id="发射">发射</h3><p>红外遥控是以调制方式发射数据，将数据调制到固定的载波上发送，调制发送抗干扰能力更强，传送距离也更远。常用的红外传输协议有很多，最常见的为NEC协议，红外遥控NEC传输协议采用<strong>脉冲位置调制(pulse distance encoding)</strong>，调制脉冲宽度不变，以发射红外载波的间隔时长代表“0”或“1”，每个脉冲的长度是560us，逻辑位定义如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231017122916998.png" /></p><p>编码过程：在红外输出口输出数据高电平期间，同时输出固定频率载波(一般是38kHz)，低电平期间则直接输出低。解码过程：红外接收头收到载波时输出高电平，没有载波时输出低电平，完成数据解码。</p><p>NEC协议格式如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231017122845611.png" /></p><p><strong>引导码:</strong> 由9ms的脉冲 + 4.5ms的低电平组成。</p><p><strong>4字节的数据:</strong> 8位地址码 + 8位地址反码 + 8位数据码 + 8位数据反码，反码用来校验数据是否传输正确。</p><p><u>记住</u>：一帧消息的末尾必须有一个560us的脉冲，以确定数据的最后一位。</p><p>当用户长时间按下遥控器按钮时，遥控器在发送一次指令码后，就不会再发送指令码了，而是周期性（110ms）发送一段数据码。这段数据码包含 <strong>9ms脉冲+2.25ms低电平+560us脉冲</strong>，如下图:</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231017123104556.png" /></p><h3 id="接收">接收</h3><p>红外接收常采用一体化红外接收头，集红外接收、放大、滤波、比较器输出等功能于一体，输出MCU可识别的TTL信号的。常用的一体化红外接收头有SCR638、HS0038、VS1838等，<strong><u>注意</u></strong>：有些红外接收头为了提高接收的灵敏度，输出的电平会跟正常解码的方式反相，即高低电平反转。</p><h3 id="编程思路">编程思路</h3><p>一般我们都是编写接收端（解码）程序，关于发送端（编码）程序，可参考：</p><p><a href="https://xiaolong.blog.csdn.net/article/details/118313109?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-118313109-blog-97166387.235%5Ev38%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-118313109-blog-97166387.235%5Ev38%5Epc_relevant_default_base&amp;utm_relevant_index=8">STM32入门开发: 制作红外线遥控器(智能居家-万能遥控器)_stm32遥控器程序怎么写-CSDN博客</a></p><p>解码程序的思路，一般是采用外部中断+定时器方式。在STM32中，可使用输入捕获方式，根据不同的条件下设置不同的捕获方式，记录每一段高低电平的持续时间，按照NEC协议进行判断，完成解码。可参考：</p><p><a href="https://xiaolong.blog.csdn.net/article/details/118281124">STM32入门开发: NEC红外线协议解码(超低成本无线传输方案)_nec32协议-CSDN博客</a></p><p><strong>参考链接：</strong></p><p><a href="https://www.sbprojects.net/knowledge/ir/nec.php">SB-Projects - IR - NEC Protocol (sbprojects.net)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;红外遥控（IR）一般由发射和接收两部分组成，发射元件为红外发射管（遥控器），接收一般采用一体化红外接收头，发射载波频率与接收头固定频率需一致才能正确接收数据。&lt;/p&gt;
&lt;h3 id=&quot;发射&quot;&gt;发射&lt;/h3&gt;
&lt;p&gt;红外遥控是以调制方式发射数据，将数据调制到固定的载波上发</summary>
      
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="NEC" scheme="http://example.com/tags/NEC/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xxx项目HAL文件概览</title>
    <link href="http://example.com/2023/10/08/stm32f1xxx%E9%A1%B9%E7%9B%AEHAL%E6%96%87%E4%BB%B6%E6%A6%82%E8%A7%88/"/>
    <id>http://example.com/2023/10/08/stm32f1xxx%E9%A1%B9%E7%9B%AEHAL%E6%96%87%E4%BB%B6%E6%A6%82%E8%A7%88/</id>
    <published>2023-10-08T07:11:36.000Z</published>
    <updated>2023-10-08T07:12:44.334Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cmsis">CMSIS</h3><ul><li><strong>stm32f1xx.h</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c">全局库文件的配置<span class="hljs-number">1.</span> 处理器芯片平台的选择及其头文件包含<span class="hljs-number">2.</span> CMSIS 版本<span class="hljs-number">3.</span> 平台共用宏：<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BIT(REG, BIT)     ((REG) |= (BIT))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BIT(REG, BIT)   ((REG) &amp;= ~(BIT))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_BIT(REG, BIT)    ((REG) &amp; (BIT))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_REG(REG)        ((REG) = (0x0))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITE_REG(REG, VAL)   ((REG) = (VAL))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_REG(REG)         ((REG))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) &amp; (~(CLEARMASK))) | (SETMASK))) </span></code></pre></div><ul><li><strong>stm32f103xe.h</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c">stm32f103xe 芯片外设寄存器定义及位定义和内存映射<span class="hljs-number">1.</span> CMSIS的配置和中断号定义<span class="hljs-number">2.</span> 外设寄存器结构体的定义<span class="hljs-number">3.</span> 外设内存表及外设声明   <span class="hljs-comment">//如：#define GPIOA  ((GPIO_TypeDef *)GPIOA_BASE)</span><span class="hljs-number">4.</span> 外设寄存器位定义</code></pre></div><ul><li><strong>startup_stm32f103xe.s</strong></li></ul><div class="code-wrapper"><pre><code class="hljs armasm">针对MDK-<span class="hljs-meta">ARM</span>工具链STM32F103xE处理器的启动代码</code></pre></div><ul><li><strong>system_stm32f1xx.h/system_stm32f1xx.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c">系统初始化及时钟配置<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">SystemInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">SystemCoreClockUpdate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;</code></pre></div><h3 id="stm32f1xx_hal_driver">STM32F1xx_HAL_Driver</h3><ul><li><strong>stm32f1xx_hal.h/stm32f1xx_hal.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c">HAL库初始化及SysTick时钟相关项和Debug模式下各外设启用和禁用<span class="hljs-comment">/* Peripheral Control functions  ************************************************/</span>HAL_StatusTypeDef <span class="hljs-title function_">HAL_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;HAL_StatusTypeDef <span class="hljs-title function_">HAL_DeInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_MspInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_MspDeInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;HAL_StatusTypeDef <span class="hljs-title function_">HAL_InitTick</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> TickPriority)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_IncTick</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_Delay</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> Delay)</span>;<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">HAL_GetTick</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">HAL_GetTickPrio</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;HAL_StatusTypeDef <span class="hljs-title function_">HAL_SetTickFreq</span><span class="hljs-params">(HAL_TickFreqTypeDef Freq)</span>;HAL_TickFreqTypeDef <span class="hljs-title function_">HAL_GetTickFreq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_SuspendTick</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_ResumeTick</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;</code></pre></div><ul><li><strong>stm32f1xx_hal_cortex.h/stm32f1xx_hal_cortex.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1.</span> CORTEX M3 NVIC和SYSTICK相关项<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">HAL_NVIC_GetPriorityGrouping</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_NVIC_GetPriority</span><span class="hljs-params">(IRQn_Type IRQn, <span class="hljs-type">uint32_t</span> PriorityGroup, <span class="hljs-type">uint32_t</span>* pPreemptPriority, <span class="hljs-type">uint32_t</span>* pSubPriority)</span>;<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">HAL_NVIC_GetPendingIRQ</span><span class="hljs-params">(IRQn_Type IRQn)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_NVIC_SetPendingIRQ</span><span class="hljs-params">(IRQn_Type IRQn)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_NVIC_ClearPendingIRQ</span><span class="hljs-params">(IRQn_Type IRQn)</span>;<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">HAL_NVIC_GetActive</span><span class="hljs-params">(IRQn_Type IRQn)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_SYSTICK_CLKSourceConfig</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> CLKSource)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_SYSTICK_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_SYSTICK_Callback</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-number">2.</span> MPU相关项</code></pre></div><ul><li><strong>stm32f1xx_hal_msp.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c">各外设与mcu相关项的初始化和复位，可在main.h中声明<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_MspInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></code></pre></div><ul><li><strong>stm32f1xx_hal_conf.h </strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1.</span> 外设使能宏，不使用的外设，注释掉。<span class="hljs-number">2.</span> HAL System配置、回调使能配置。<span class="hljs-number">3.</span> Ethernet配置<span class="hljs-number">4.</span> HAL库头文件的配置<span class="hljs-number">5.</span> assert_param 断言宏的配置<span class="hljs-meta">#<span class="hljs-keyword">define</span>  VDD_VALUE           3300U <span class="hljs-comment">/*!&lt; Value of VDD in mv */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  TICK_INT_PRIORITY   15U <span class="hljs-comment">/*!&lt; tick interrupt priority (lowest by default)  */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  USE_RTOS            0U</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  PREFETCH_ENABLE     1U</span></code></pre></div><ul><li><strong>stm32f1xx_it.h/stm32f1xx_it.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs">中断和异常处理函数</code></pre></div><ul><li><strong>stm32f1xx_hal_def.h</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1.</span> HAL库共用项<span class="hljs-meta">#<span class="hljs-keyword">define</span> HAL_MAX_DELAY      0xFFFFFFFFU</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HAL_IS_BIT_SET(REG, BIT)         (((REG) &amp; (BIT)) != 0U)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HAL_IS_BIT_CLR(REG, BIT)         (((REG) &amp; (BIT)) == 0U)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)               \</span><span class="hljs-meta">                        do&#123;                                                      \</span><span class="hljs-meta">                              (__HANDLE__)-&gt;__PPP_DMA_FIELD__ = &amp;(__DMA_HANDLE__); \</span><span class="hljs-meta">                              (__DMA_HANDLE__).Parent = (__HANDLE__);             \</span><span class="hljs-meta">                          &#125; while(0U)</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(UNUSED)    #<span class="hljs-keyword">define</span> UNUSED(X) (void)X  <span class="hljs-comment">/* To avoid gcc/g++ warnings */</span></span><span class="hljs-number">2.</span> 编译器配置项</code></pre></div><ul><li><strong>stm32f1xx_hal_gpio.h/stm32f1xx_hal_gpio.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">gpio</span> hal库操作函数</code></pre></div><ul><li><strong>stm32f1xx_ll_gpio.h/stm32f1xx_ll_gpio.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">gpio</span> ll库寄存器操作函数</code></pre></div><ul><li><strong>main.h/main.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs">主程序，及共用项定义头文件</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;cmsis&quot;&gt;CMSIS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stm32f1xx.h&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs c&quot;&gt;全局库文件的配置
</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
  </entry>
  
  <entry>
    <title>解决Microsoft Edge浏览器关于“根据热门内容向你推荐”的问题</title>
    <link href="http://example.com/2023/10/07/%E8%A7%A3%E5%86%B3Microsoft-Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E4%BA%8E%E2%80%9C%E6%A0%B9%E6%8D%AE%E7%83%AD%E9%97%A8%E5%86%85%E5%AE%B9%E5%90%91%E4%BD%A0%E6%8E%A8%E8%8D%90%E2%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/10/07/%E8%A7%A3%E5%86%B3Microsoft-Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E4%BA%8E%E2%80%9C%E6%A0%B9%E6%8D%AE%E7%83%AD%E9%97%A8%E5%86%85%E5%AE%B9%E5%90%91%E4%BD%A0%E6%8E%A8%E8%8D%90%E2%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-10-07T05:32:42.000Z</published>
    <updated>2023-10-07T06:43:43.429Z</updated>
    
    <content type="html"><![CDATA[<p>在使用微软的Edge浏览器搜索时，当我们点开某个页面后，它会自动在原网页弹出推荐的内容，如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231007135553301.png" alt="image-20231007135553301" style="zoom:80%;" /></p><p>通常情况下，它占用了屏幕大部分空间，且弹出的内容好多并无作用，浪费了浏览时间。在浏览器的设置中，并没有这个设置项。因为这个是点击所触发的情况，所以可以利用广告拦截的方式进行处理，具体操作如下：</p><ol type="1"><li>在浏览器扩展应用商店中搜索“<strong>广告拦截</strong>”,安装一个广告拦截器插件（我这里选择 AdGuard）:</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231007141805618.png" alt="image-20231007141805618" style="zoom:80%;" /></p><ol start="2" type="1"><li>安装完插件后，在搜索页面 <strong>鼠标右键 =&gt; AdGuard广告拦截器 =&gt; 拦截此网站上的广告</strong> ，选择搜索页面弹出的推荐外框，点击拦截即可。</li></ol><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231007143227303.png" alt="" /><figcaption>image-20231007143227303</figcaption></figure><p>这样设置后，就不会再弹出推荐的内容了，完美解决。</p><p><strong>参考：</strong></p><p><a href="https://blog.csdn.net/qq_42920270/article/details/128224356">拦截Edge的“根据热门内容向您推荐”_buding0716的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用微软的Edge浏览器搜索时，当我们点开某个页面后，它会自动在原网页弹出推荐的内容，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-2023100</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="Edge" scheme="http://example.com/tags/Edge/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中内存管理(HeapMemory)</title>
    <link href="http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(HeapMemory)/"/>
    <id>http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(HeapMemory)/</id>
    <published>2023-10-06T13:58:26.000Z</published>
    <updated>2023-10-13T06:53:06.029Z</updated>
    
    <content type="html"><![CDATA[<p>FreeRTOS在每次创建内核对象时分配内存，在每次删除内核对象时释放RAM。此策略减少了设计和规划工作，简化了API，并最大限度地减少了内存占用。</p><p>可以使用标准C库malloc()和free()函数分配内存，但有时它们可能不适用，因为：</p><ul><li><p>在小型嵌入式系统上并不总是可用的。</p></li><li><p>函数实现比较复杂，占用了宝贵的代码空间。</p></li><li><p>并非都是安全线程。</p></li><li><p>运行时间不确定，执行函数所花费的时间因调用而异。</p></li><li><p>内存碎片化。</p></li><li><p>使用不同的编译器时，需要进行复杂的配置。</p></li><li><p>为其他变量使用的堆内存扩展，则可能出现难以调试的错误。</p></li></ul><p>早期版本的FreeRTOS使用内存池分配方案，即在编译时预先分配不同大小的内存块池，然后由内存分配函数返回。因为它不能有效地使用RAM，使其只在非常小的嵌入式系统中可行，因此该方案被放弃了。</p><p>FreeRTOS提供了<code>pvPortMalloc()</code>和<code>vPortFree()</code>内存管理函数，它们具有与标准C库<code>malloc()</code>和<code>free()</code>函数相同的原型。FreeRTOS 提供了五种堆管理方案，其复杂性和功能各不相同，源码分别在<code>heap_1.c、heap_2.c、heap_3.c、heap_4.c、heap_5.c</code>源文件中，它们都位于<code>FreeRTOS/ source /portable/MemMang</code>目录中。</p><p>每次一个项目中，只应包含其中一个源文件，这些可移植层函数定义的堆将由 RTOS 内核使用。</p><p>它们的区别主要是：</p><ul><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00111.html#heap_1">heap_1</a> —— 最简单，不允许释放内存。</li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00111.html#heap_2">heap_2</a> —— 允许释放内存，但不会合并相邻的空闲块。</li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00111.html#heap_3">heap_3</a> —— 简单包装了标准 malloc() 和 free()，以保证线程安全。</li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00111.html#heap_4">heap_4</a> —— 合并相邻的空闲块以避免碎片化，包含绝对地址放置选项。</li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00111.html#heap_5">heap_5</a> —— 如同 heap_4，能够跨越多个不相邻内存区域的堆。</li></ul><p><strong>注意</strong>：</p><ul><li><strong>heap_1 不太有用，因为 FreeRTOS 添加了静态分配支持。</strong></li><li><strong>heap_2 现在被视为旧版，较新的 heap_4 实现是首选。</strong></li></ul><h2 id="heap_1">Heap_1</h2><p><code>heap_1.c</code> 实现了 <code>pvPortMalloc()</code>的一个非常基本的版本，并且没有实现<code>vPortFree()</code>。所以内存一经分配，就不允许释放。尽管如此，它还是适用于大量嵌入式应用程序，这是因为许多小型和深度嵌入的应用程序在系统启动时创建了所需的所有任务、队列、信号量等，并在程序的生命周期内使用所有这些对象（直到应用程序再次关闭或重新启动）。</p><p>当调用<code>pvPortMalloc()</code>时，heap_1分配方案将一个单一数组细分为更小的块，这个数组被称为堆，堆内存空间的总量通过配置文件宏： <strong>configTOTAL_HEAP_SIZE</strong> 设置，堆内存地址设置通过配置文件宏： <strong>configAPPLICATION_ALLOCATED_HEAP</strong> 设置。每个创建的任务需要从堆中分配一个任务控制块(<strong>TCB</strong>)和一个堆栈。</p><p>堆内存空间的总量通过配置文件宏： <strong>configTOTAL_HEAP_SIZE</strong> 设置。 堆内存地址设置通过配置文件宏： <strong>configAPPLICATION_ALLOCATED_HEAP</strong> 设置。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231013133023140.png" alt="" /><figcaption>image-20231013133023140</figcaption></figure><p>Heap_1实现：</p><ul><li>如果您的应用程序不删除任务、队列、信号量、互斥锁等，则可以使用。</li><li>始终具有确定性（总是需要相同的时间来执行）， 不会导致内存碎片化。</li><li>非常简单，且从静态分配的数组分配内存，这意味着它通常适合用于不允许真实动态内存分配的应用程序 。</li></ul><h2 id="heap_2">Heap_2</h2><p><code>heap_2.c</code> 使用最佳匹配算法来分配内存，允许释放内存。最佳匹配算法确保<code>pvPortMalloc()</code>使用大小最接近请求字节数的空闲内存块。Heap_2不会将相邻的空闲块合并，因此它更容易出现碎片。但是，如果分配和随后释放的内存块大小总是相同，那么就不会有碎片问题。</p><p>堆内存空间的总量通过配置文件宏： <strong>configTOTAL_HEAP_SIZE</strong> 设置。 堆内存地址设置通过配置文件宏： <strong>configAPPLICATION_ALLOCATED_HEAP</strong> 设置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231013141830263.png" /></p><p>Heap_2实现：</p><ul><li><p>适用于应用程序重复创建和删除任务、队列、信号量、互斥锁等，前提是分配给已创建任务的堆栈大小不变。</p></li><li><p>如果您应用程序的队列、任务、信号量、互斥锁等的顺序不可预测，可能会导致内存碎片化。</p></li><li><p>非确定性，但比malloc()和free()的大多数标准库实现要快。</p></li></ul><h2 id="heap_3">Heap_3</h2><p><code>heap_3.c</code>使用标准库 <code>malloc()</code>和<code>free()</code>函数，因此堆的大小由链接器配置，需要编译器库提供 <code>malloc()</code> 和 <code>free()</code> 实现,宏 <strong>configTOTAL_HEAP_SIZE</strong> 不起作用。Heap_3通过暂时挂起FreeRTOS调度器使malloc()和free()线程安全。</p><h2 id="heap_4">Heap_4</h2><p><code>heap_4.c</code> 是当前使用最多的方式，它使用第一拟合和内存合并算法,将相邻的空闲块合并(合并)成一个更大的块，从而最大限度地降低了碎片的风险，并使其适用于重复分配和释放不同大小的RAM块的应用程序。</p><p>堆内存空间的总量通过配置文件宏： <strong>configTOTAL_HEAP_SIZE</strong> 设置。 堆内存地址设置通过配置文件宏： <strong>configAPPLICATION_ALLOCATED_HEAP</strong> 设置。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231013142636425.png" alt="" /><figcaption>image-20231013142636425</figcaption></figure><p>heap_4实现：</p><ul><li>适用于应用程序重复创建和删除任务、队列、信号量、互斥锁等情况。</li><li>非确定性，但比malloc()和free()的大多数标准库实现要快。</li></ul><h2 id="heap_5">Heap_5</h2><p><code>heap_5.c</code>用于分配和释放内存的算法与heap_4使用的算法相同，允许堆跨越多个不相邻内存区域，但它并不局限于从单个静态声明的数组中分配内存，而是从多个独立的内存空间中分配内存。</p><p>创建 RTOS 对象（任务、队列、信号量等）将调用 <code>pvPortMalloc()</code>，heap_5必须在调用<code>pvPortMalloc()</code>之前显式初始化，即使用<code>vPortDefineHeapRegions()</code> API函数初始化。</p><p>heap_5实现：</p><p>当运行FreeRTOS的系统提供的内存在系统内存映射中不是单个连续块。</p><h1 id="heap相关api函数">Heap相关API函数</h1><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 分配内存 */</span><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( </span><span class="hljs-params">  <span class="hljs-type">size_t</span> xWantedSize <span class="hljs-comment">/* 分配的内存大小 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 释放内存 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( </span><span class="hljs-params">  <span class="hljs-type">void</span> * pv <span class="hljs-comment">/* 待释放的内存指针 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 获取堆内存大小 */</span><span class="hljs-type">size_t</span> <span class="hljs-title function_">xPortGetFreeHeapSize</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<span class="hljs-comment">/* 获取空闲内存容量的最小值 */</span><span class="hljs-type">size_t</span> <span class="hljs-title function_">xPortGetMinimumEverFreeHeapSize</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<span class="hljs-comment">/* 内存分配失败钩子 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">vApplicationMallocFailedHook</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;FreeRTOS在每次创建内核对象时分配内存，在每次删除内核对象时释放RAM。此策略减少了设计和规划工作，简化了API，并最大限度地减少了内存占用。&lt;/p&gt;
&lt;p&gt;可以使用标准C库malloc()和free()函数分配内存，但有时它们可能不适用，因为：&lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    <category term="RTOS" scheme="http://example.com/categories/RTOS/"/>
    
    
    <category term="RAM" scheme="http://example.com/tags/RAM/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中互斥量(Mutexes)</title>
    <link href="http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E4%BA%92%E6%96%A5%E9%87%8F(Mutexes)/"/>
    <id>http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E4%BA%92%E6%96%A5%E9%87%8F(Mutexes)/</id>
    <published>2023-10-06T13:50:32.000Z</published>
    <updated>2023-10-12T14:35:09.248Z</updated>
    
    <content type="html"><![CDATA[<p>互斥是一种特殊的二进制信号量，用于控制对两个或多个任务之间共享资源的访问。要使用它，需在配置文件中设置 <code>configUSE_MUTEXES</code> 为1。</p><p>用于互斥时，互斥锁就像用于保护资源的令牌。当访问资源时，必须首先获取 ('token') 令牌，使用资源后，必须“返回”令牌，这样其他任务就有机会访问此共享资源。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/mutexes.gif" alt="" /><figcaption>img</figcaption></figure><h1 id="互斥优先级反转">互斥优先级反转</h1><p>高优先级的任务必须等待低优先级的任务放弃对互斥锁的控制，这种方式的延迟，称为“优先级反转”。如果中等优先级任务开始执行，而高优先级任务正在等待信号量，这会导致高优先级任务等待低优先级任务，而低优先级任务甚至无法执行。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231012203208837.png" alt="" /><figcaption>image-20231012203208837</figcaption></figure><p>优先级反转显然是一个严重的问题，但在小型嵌入式系统中，通过考虑如何访问资源，通常可以在系统设计时避免这个问题。</p><h1 id="互斥优先级继承">互斥优先级继承</h1><p>与二进制信号量不同的是互斥锁包含基本的“优先级继承”机制，优先级继承是一种将优先级反转的负面影响降至最低的方案。它并没有“修复”优先级反转，只是通过确保总是有时间限制反转来减少其影响。然而优先级继承使系统时序分析复杂化，并且依赖它来进行正确的系统操作并不是一个好的实践。</p><p>优先级继承的工作原理是临时将互斥锁持有者的优先级提高到最高优先级。持有互斥锁的低优先级任务“继承”等待互斥锁任务的优先级。当互斥锁返回时，互斥锁持有者的优先级自动重置为其原始值。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231012204245838.png" alt="" /><figcaption>image-20231012204245838</figcaption></figure><p>不应在中断中使用互斥锁，因为：</p><ul><li>互斥锁使用的优先级继承机制要求从任务中（而不是从中断中）拿走和放入互斥锁。</li><li>中断无法保持阻塞来等待一个被互斥锁保护的资源 由互斥锁保护的资源变为可用。</li></ul><h1 id="死锁">死锁</h1><p>“死锁”是使用互斥锁进行互斥的另一个潜在陷阱，当两个任务都在等待由另一个任务持有的资源而无法运行时，就会发生死锁。假设任务A和任务B都需要互斥锁X和互斥锁Y来完成操作：</p><ul><li>任务A执行并成功获取互斥锁X</li><li>任务B抢占任务A</li><li>任务B成功地获取了互斥锁Y，在尝试获取互斥锁X，但被任务A持有，所以任务B选择进入阻塞态等待互斥锁X的释放。</li><li>任务A继续运行，它尝试获取互斥锁Y，但被任务B持有，任务A选择进入阻塞态等待互斥锁Y的释放。</li></ul><p>这个场景的最后，任务A等待任务B持有的互斥锁，任务B也在等待任务A持有的互斥锁，这两个任务都无法运行，所以发生死锁。</p><p>与优先级反转一样，避免死锁的最佳方法是设计系统避免发生死锁。让任务无限等待(没有超时)来获取互斥锁通常是不好的做法，相反，使用比期望等待互斥锁的最大时间稍长一点的超时时间，在此时间内未能获得互斥锁将是错误设计的征兆（死锁）。</p><p>在实践中，死锁在小型嵌入式系统中不是一个大问题，因为系统设计人员可以很好地理解整个应用程序，能够辨别和移除发生死锁的区域。</p><h1 id="递归互斥锁">递归互斥锁</h1><p>任务本身也可能发生死锁，如果一个任务多次尝试使用同一个互斥锁，而没有首先返还互斥锁，就会发生这种情况。假设如下场景：</p><ol type="1"><li>一个任务成功获取互斥锁。</li><li>持有互斥锁的同时调用库函数。</li><li>库函数尝试获取同一个互斥锁，然后进入阻塞态等待互斥锁可用。</li></ol><p>在此场景结束时，任务处于阻塞状态等待互斥锁返回，但任务已是互斥锁的持有者。因为任务处于阻塞状态等待自己，所以发生自锁。</p><p>使用递归互斥锁替代标准互斥锁可避免这种死锁。一个递归互斥锁可以被同一个任务多次“获取”，仅在每次调用递归互斥锁时，执行“给予”递归互斥锁调用后返回。</p><p>标准互斥锁和递归互斥锁以类似的方式创建和使用：</p><table><thead><tr class="header"><th>功能</th><th>标准互斥锁</th><th>递归互斥锁</th></tr></thead><tbody><tr class="odd"><td>创建</td><td>xSemaphoreCreateMutex()</td><td>xSemaphoreCreateRecursiveMutex()</td></tr><tr class="even"><td>获取</td><td>xSemaphoreTake()</td><td>xSemaphoreTakeRecursive()</td></tr><tr class="odd"><td>给出</td><td>xSemaphoreGive()</td><td>xSemaphoreGiveRecursive()</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;互斥是一种特殊的二进制信号量，用于控制对两个或多个任务之间共享资源的访问。要使用它，需在配置文件中设置 &lt;code&gt;configUSE_MUTEXES&lt;/code&gt; 为1。&lt;/p&gt;
&lt;p&gt;用于互斥时，互斥锁就像用于保护资源的令牌。当访问资源时，必须首先获取 (&#39;token</summary>
      
    
    
    
    <category term="RTOS" scheme="http://example.com/categories/RTOS/"/>
    
    
    <category term="Mutexes" scheme="http://example.com/tags/Mutexes/"/>
    
  </entry>
  
</feed>
