<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-13T08:02:22.969Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网页布局调整插件</title>
    <link href="http://example.com/2023/11/13/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E8%B0%83%E6%95%B4%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2023/11/13/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E8%B0%83%E6%95%B4%E6%8F%92%E4%BB%B6/</id>
    <published>2023-11-13T06:49:19.000Z</published>
    <updated>2023-11-13T08:02:22.969Z</updated>
    
    <content type="html"><![CDATA[<p>浏览网页时，一般网页上会出现很多附带花哨的内容，看起来很影响视觉效果，且都是些无用信息，网上看到个博主写了个网页插件，使用后，屏蔽了这些无用信息，整个页面看起来清爽很多。</p><p>插件GitHub地址：</p><div class="code-wrapper"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Camio1945/</span>adjust_website_chrome_extension</code></pre></div><p>插件屏蔽了指定网页上大部分内容，可以根据自己的需要进行相应的修改和调整。虽然插件是用在谷歌浏览器上的，但我的Microsoft Edge浏览器好像也能正常使用，以下是我调整修改后CSDN网页上的显示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231113154847896.png" alt="" /><figcaption>image-20231113154847896</figcaption></figure><p>调整修改后的插件，我已上传：<a href="https://gitee.com/kayoungzhang/my_codehub/blob/master/plugins/adjust_website%E6%8F%92%E4%BB%B6.zip">gitee</a></p><p>具体内容，请查看原插件说明文档，感兴趣的可以下载来使用看看，并根据自己的需要进行修改调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;浏览网页时，一般网页上会出现很多附带花哨的内容，看起来很影响视觉效果，且都是些无用信息，网上看到个博主写了个网页插件，使用后，屏蔽了这些无用信息，整个页面看起来清爽很多。&lt;/p&gt;
&lt;p&gt;插件GitHub地址：&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>typora插件</title>
    <link href="http://example.com/2023/11/10/typora%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2023/11/10/typora%E6%8F%92%E4%BB%B6/</id>
    <published>2023-11-10T07:20:16.000Z</published>
    <updated>2023-11-13T06:42:14.383Z</updated>
    
    <content type="html"><![CDATA[<p>在写 <code>markdown</code> 文档时，有时需要对文档进行格式处理，如字体大小，颜色设置，加粗等等，像在typora软件中，会有部分设置类型，通过鼠标右键或快捷键的方式可以很方便的操作，但有些常用的一些格式设置，软件中就没有。如果你懂些html的语法，也可以进行设置，在之前的文章中有分享，但总归感觉不太方便。</p><p>前段时间，在 <code>github</code> 上看到个typora插件（<a href="https://github.com/obgnail/typora_plugin">https://github.com/obgnail/typora_plugin</a>），在使用软件时，增加了很多功能，有些功能也比较实用。</p><p>使用之后，我发现有些增强功能我使用不到，typora软件的打开速度也变慢了，通过插件里面的配置文档，我删除了插件里面的部分增强功能，对自己经常用到的功能进行了更改和保留。如下所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231113143517868.png" alt="" /><figcaption>image-20231113143517868</figcaption></figure><ul><li><strong>只读模式 Ctrl+Shift+R</strong></li></ul><p>使用鼠标右键或快捷键 <code>Ctrl+Shift+R</code> 可以快速进入或退出<strong>只读模式</strong>，<strong>只读模式</strong>下，无法编辑，且文章右下角显示只读标志。</p><ul><li><strong>表格调整</strong></li></ul><p>创建表格后，使用 <code>ctrl+鼠标拖动</code> 可以修改表格的行高列宽。</p><ul><li><strong>文字颜色 Ctrl+Shift+C</strong></li></ul><p>使用鼠标右键或快捷键 <code>Ctrl+Shift+C</code> 可以弹出或退出文字颜色设置框，选中需要改变颜色的文字，即可进行颜色的设置。</p><ul><li><strong>右键菜单</strong></li></ul><p>这个主要是打开配置文件夹和github上的帮助文档。</p><ul><li><strong>白天/暗夜模式切换</strong></li></ul><p>文档右下角直接有 <strong>白天/暗夜模式切换</strong> 图标，鼠标左键点击即可进行不同模式的切换，比较实用。</p><ul><li><strong>快读返回顶底部</strong></li></ul><p>文档右下角直接有 <strong>快速返回顶/底部</strong> 图标，对于长文档的阅读，比较方便快捷。</p><p>以上就是我写文档会经常使用到的一些功能，已上传到<a href="https://gitee.com/kayoungzhang/my_codehub/blob/master/plugins/typora%E6%8F%92%E4%BB%B6%E7%B2%BE%E7%AE%80%E7%89%88.zip">gitee</a>，至于其它的功能，可以参考<a href="https://github.com/obgnail/typora_plugin">原插件</a>，感兴趣可以下载下来使用看看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在写 &lt;code&gt;markdown&lt;/code&gt; 文档时，有时需要对文档进行格式处理，如字体大小，颜色设置，加粗等等，像在typora软件中，会有部分设置类型，通过鼠标右键或快捷键的方式可以很方便的操作，但有些常用的一些格式设置，软件中就没有。如果你懂些html的语法，也可</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="typora" scheme="http://example.com/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>热敏电阻原理与代码实现</title>
    <link href="http://example.com/2023/10/25/%E7%83%AD%E6%95%8F%E7%94%B5%E9%98%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/10/25/%E7%83%AD%E6%95%8F%E7%94%B5%E9%98%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-10-25T07:29:47.000Z</published>
    <updated>2023-10-26T10:11:18.617Z</updated>
    
    <content type="html"><![CDATA[<p>在嵌入式产品开发中，会经常碰到温度检测的时候，在成本比较敏感而精度要求较低时，可采用热敏电阻来进行温度的检测。</p><h1 id="热敏电阻简介">热敏电阻简介</h1><p>热敏电阻作用有点像电阻器，但对温度比较敏感。它可用于产生随环境温度变化的模拟输出电压，这是因为由于热量变化会导致其电气特性发生变化。随着它的温度变化，它的电阻也会发生变化。</p><p>热敏电阻的主要用途是作为电阻式温度传感器，但它们也可以用作热敏限流器件。</p><p>随着温度的变化增加，电阻值有的是增大，有的是减小。所以对应了两种类型的热敏电阻：<strong>电阻的负温度系数（NTC）和电阻的正温度系数（PTC）。</strong>工程应用中，NTC热敏电阻使用更广泛一些，下面主要来看看NTC的相关内容。</p><h1 id="ntc的功能概述">NTC的功能概述</h1><p>NTC的性性是阻值随温度的升高而降低，变化率极大的半导体电阻器。NTC的电阻与温度存在如下关系曲线：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026113905028.png" alt="" /><figcaption>image-20231026113905027</figcaption></figure><p>对于NTC的这种电阻与温度的关系可以使用近似的公式来表示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026114506698.png" alt="" /><figcaption>image-20231026114506699</figcaption></figure><p>其中：</p><p><strong>R</strong>: 当前温度（K）零负荷电阻</p><p><strong>T：</strong> 当前温度（K）</p><p><strong>R0:</strong> T0(K)温度下标称电阻，一般是25℃。</p><p><strong>B:</strong> 热敏电阻材料常数，标称温度不同，B值也不同</p><p>有的NTC厂商会给出B值公式，只是上面那个公式的不同转换形式而已：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026120408078.png" alt="" /><figcaption>image-20231026120408077</figcaption></figure><p>由以上公式就可以推出温度与电阻的关系（<strong>℃</strong>）：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/72ac09cc4e50c51a63870bf9401d3a51.png" alt="" /><figcaption>img</figcaption></figure><h1 id="电路原理及程序实现">电路原理及程序实现</h1><p>热敏电阻的本质就是一个电阻，我们通过测量电阻的变化即可测量出来温度。最简单的方法是使用热敏电阻作为分压电路的一部分，测量电阻两端的电压变化，就可以得出温度的变化。</p><p>将电压值转变为对应的温度值，一般有两种方法：<strong>查表法</strong>和<strong>公式计算法（如上公式）</strong>，比较常用的是查表法。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026174558208.png" alt="" /><figcaption>image-20231026174558207</figcaption></figure><p>可以看出，只要知道了当前的电阻，就可以得出ADC的值，以<a href="https://atta.szlcsc.com/upload/public/pdf/source/20170728/C123387_1501225826403848951.pdf">南京时恒的MF58-103F3435</a>为例：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026173537979.png" alt="" /><figcaption>image-20231026173537976</figcaption></figure><p>由上图可以看出，每个温度下都有对应的电阻值，通过上面的公式，就可以计算出对应的电阻值下的ADC采集值。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/641.png" alt="" /><figcaption>图片</figcaption></figure><p>将所有AD值转换为HEX格式后，保存到一个一维数组中：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/640-16983137350834.png" alt="" /><figcaption>图片</figcaption></figure><p>然后用单片机采集到的AD值，一个个从头开始去查找对比就能知道温度了。（由于AD值是按照由大到小的顺序排列的，可以采用更高效的二分法查找，这里不再赘述）</p><p>单片机采集到的AD值一般落在了某个区间，所以要处理的数据基本上在两个温度的区间，如果要显示小数，两个温度区间可以看成是线性的，通过局部线性化就可以计算出温度的值。</p><p>什么是局部线性化，有网友解释的很清楚，这里直接搬过来，假如ADC采样的数字量为 0x80C，十进制是2060，对应在数据表的2048(25℃)和2095(24℃)中间，计算方式按照线性处理如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/640-16983137798156.png" alt="" /><figcaption>图片</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">uint16_t</span> ntc_ad;<span class="hljs-type">uint16_t</span> temp_index;<span class="hljs-type">float</span> temperature = <span class="hljs-number">0.0</span>;ntc_ad = GetADCResult();<span class="hljs-comment">//获取ADC值</span>temp_index = NTCADBinarySearch(ntc_ad);<span class="hljs-comment">//搜索NTC_AD温度表（得到数组标号）</span>temp_integer = temp_index - <span class="hljs-number">30</span>; <span class="hljs-comment">//最低温度-30℃</span>temperature = temp_integer+(<span class="hljs-type">float</span>)(NTC_AD[temp]-ntc_ad)/(<span class="hljs-type">float</span>)(NTC_AD[temp]-NTC_AD[temp+<span class="hljs-number">1</span>]);temperature = temperature * <span class="hljs-number">10</span>;</code></pre></div><p><strong>参考链接：</strong></p><p><a href="https://mp.weixin.qq.com/s/9gCKO-IeI86xJqkxHSZyNg">热敏电阻测温：原理讲解（附送电路图和程序） (qq.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在嵌入式产品开发中，会经常碰到温度检测的时候，在成本比较敏感而精度要求较低时，可采用热敏电阻来进行温度的检测。&lt;/p&gt;
&lt;h1 id=&quot;热敏电阻简介&quot;&gt;热敏电阻简介&lt;/h1&gt;
&lt;p&gt;热敏电阻作用有点像电阻器，但对温度比较敏感。它可用于产生随环境温度变化的模拟输出电压，这</summary>
      
    
    
    
    <category term="单片机" scheme="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="NTC" scheme="http://example.com/tags/NTC/"/>
    
  </entry>
  
  <entry>
    <title>RS485总结</title>
    <link href="http://example.com/2023/10/25/RS485%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/10/25/RS485%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-25T07:28:43.000Z</published>
    <updated>2023-10-26T02:51:47.059Z</updated>
    
    <content type="html"><![CDATA[<p>RS485是工业自动化控制上最常用的半双工通信总线之一，它弥补了RS-232通信距离短，速率低的缺点，它的速率可高达<strong>10Mbit/s</strong>，理论通讯距离可达<strong>1200米</strong>；RS-485采用的是<strong>差分传输</strong>，可抑制总线上的共模干扰。RS485通信只需要MCU有串口就可以使用了。</p><h1 id="rs485通信协议">RS485通信协议</h1><p><strong>RS485是硬件层协议</strong>，MCU管脚输出的是TTL电平，经过485通讯转换器芯片转换成差分信号（线A、线B），然后跟RS485相关设备进行通信。可以这样理解，硬件层协议是公路，目的是为了让车辆能够正常通行。如果想让它按照自己的意愿在某个车道运行，就需要交通规则进行约束了，对应RS485上，就需要上层协议的加入，<strong>即软件层协议</strong>，如常用的Modbus协议，而<strong>RS-485标准</strong>并没有规定应用层通信协议。</p><p>RS485协议规定（线A、B间电压差）：</p><p><span style="color:green"><strong>逻辑1：+2V ~ +6V</strong></span></p><p><span style="color:green"><strong>逻辑0：-6V ~ -2V</strong></span></p><p>很多收发器的标准达到甚至超过TIA/EIA-485A规范，在实际使用中，以器件的SPEC参数为主，如下某收发器的负输入阈值最小也是 <code>-200mV</code> 。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/d03c9ce486984b2fa454be8a59606835.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/1d5a4194976244ddbcac880dbe80e8f5.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><h1 id="rs485拓扑结构">RS485拓扑结构</h1><p>RS485主要采用的是两线制接线方式，在同一总线上最多可以挂接32个节点。RS485支持多从机模式，不支持多主机模式。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026093304812.png" alt="" /><figcaption>image-20231026093304812</figcaption></figure><h1 id="rs485常用电路">RS485常用电路</h1><ul><li><strong>RS485一般应用</strong></li></ul><p>这种应用方案有很多，大部分都是类同如下设计：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026094211229.png" alt="image-20231026094211229" style="zoom:80%;" /></p><ul><li><strong>RS485防雷应用</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026095802733.png" alt="" /><figcaption>image-20231026095802733</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/640.jpeg" alt="" /><figcaption>图片</figcaption></figure><ul><li><p><strong>RS485高压隔离应用</strong></p><ul><li><p><strong>光耦</strong> <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026100250702.png" alt="image-20231026100250702" /></p></li><li><p><strong>专用RS485隔离芯片</strong> <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231026100648487.png" alt="image-20231026100648487" /></p></li></ul></li><li><p><strong>RS485自动收发应用</strong></p><ul><li><strong>分立器件</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/d9524ee6bf62424f8b56f1989440748d.png" alt="" /><figcaption>img</figcaption></figure><p>原理分析如下：</p><p><span style="color:blue">发送过程：</span><strong>当USART_TX发送0时</strong>，三极管不导通，DE接高电平，进入发送模式，因为DI接地，所以<strong>AB引脚会传输0</strong>。<strong>当USART_TX发送1时</strong>，三极管导通，RE为低电平，进入接收模式，485芯片的AB引脚进入高阻状态，因为有上下拉电阻，所以<strong>AB传输的是1</strong>。一句话：<strong>TXD发1，AB就发1；TXD发0，AB就发0</strong></p><p><span style="color:blue">接收过程：</span>当<strong>USART_TX是高电平</strong>时，三极管导通，RE为低电平，485芯片进入接收状态，然后其RO引脚（也就是接USART_RX的引脚）就会接收AB传输过来的数据了。</p><ul><li><strong>自动切换方向芯片-MAX13487、MAX13488</strong></li></ul></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/087ca55942604e7aa24e9f1db2a7229a.png" alt="" /><figcaption>img</figcaption></figure><h1 id="rs485应用常见问题">RS485应用常见问题</h1><p>RS485在应用中有时会出现问题，如干扰，终端电阻匹配问题等，具体可参考这篇文章：</p><p><a href="https://mp.weixin.qq.com/s/hObz69bggXqIsttAz1Wo2w">485总线应用及常见问题 (qq.com)</a></p><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/weixin_46251230/article/details/126684223?spm=1001.2101.3001.6650.14&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-14-126684223-blog-103917713.235%5Ev38%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-14-126684223-blog-103917713.235%5Ev38%5Epc_relevant_default_base&amp;utm_relevant_index=22">【精选】RS-485接口协议详解_rs485_ONE_Day|的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_39400113/article/details/122387133">【精选】终于讲透了，史上最详细的RS485自动收发电路你一定要掌握-CSDN博客</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3MDQzOTUzMw==&amp;mid=2247510498&amp;idx=1&amp;sn=4cdfb6a6a3785730dc421f4e2d7cd9f7&amp;chksm=ead3ece0dda465f63f3d9d9bebe056fcb71ca380dbc27bfb4c201394675a8996c560c573da42&amp;scene=178&amp;cur_album_id=2499796242684952577#rd">大厂推荐：RS485接口电路如何设计？ (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s/uszrEinELLhIHucudf04kQ">为什么需要485隔离？常见RS485隔离方案介绍 (qq.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RS485是工业自动化控制上最常用的半双工通信总线之一，它弥补了RS-232通信距离短，速率低的缺点，它的速率可高达&lt;strong&gt;10Mbit/s&lt;/strong&gt;，理论通讯距离可达&lt;strong&gt;1200米&lt;/strong&gt;；RS-485采用的是&lt;strong&gt;差分传输</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="RS485" scheme="http://example.com/tags/RS485/"/>
    
  </entry>
  
  <entry>
    <title>关于迪文串口屏驱动</title>
    <link href="http://example.com/2023/10/25/%E5%85%B3%E4%BA%8E%E8%BF%AA%E6%96%87%E4%B8%B2%E5%8F%A3%E5%B1%8F%E9%A9%B1%E5%8A%A8/"/>
    <id>http://example.com/2023/10/25/%E5%85%B3%E4%BA%8E%E8%BF%AA%E6%96%87%E4%B8%B2%E5%8F%A3%E5%B1%8F%E9%A9%B1%E5%8A%A8/</id>
    <published>2023-10-25T07:27:08.000Z</published>
    <updated>2023-10-25T12:47:22.590Z</updated>
    
    <content type="html"><![CDATA[<p>嵌入式系统开发中，我们会经常使用到串口屏，主要是因为串口屏使用起来比较简单，不需要花费大量的时间来编写底层实现逻辑代码，我们只需要根据它的协议通过串口进行数据的传输和显示就好了。串口屏在工业上有很多品牌，这里主要以迪文显示屏为例，来看看它的使用和驱动编写。</p><h1 id="dgus-屏的简介">DGUS 屏的简介</h1><p>迪文串口屏采用的是 <span style="color:blue">DGUS（<strong>D</strong>WIN <strong>G</strong>raphic <strong>U</strong>tilized <strong>S</strong>oftware）开发体系</span>，由 DGUS 屏和 DGUS 开发软件构成，如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025164002877.png" /></p><p>DGUS 把 GUI（用户图形界面）的每一个页面分解成多个控件，用户需要实现某个功能只需要利用 PC 端的开发软件在相应的页面上添加功能控件即可实现。</p><p>使用上位机软件新建一个工程时，会自动生成一系列文件，这些文件包含了<strong>触控配置文件</strong>，<strong>变量配置文件</strong>，<strong>变量初始化文件</strong>，<strong>OS代码</strong>，<strong>图标库</strong>，<strong>屏幕参数配置文件</strong>。另外还需要准备一些界面图片。</p><h1 id="dgus-屏的存储空间">DGUS 屏的存储空间</h1><p>DGUS 屏提供有 <strong>FLASH储存空间、RAM储存空间、配置寄存器空间，以及曲线缓冲区</strong>。</p><ul><li><strong>FLASH储存空间（256MB/1GB/2GB）</strong></li></ul><p>FLASH 储存空间主要用于储存参数配置文件、图片文件、声音文件、字库文件、图标库、触控配置文件、变量配置文件、OS 代码、用户数据等。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025170212747.png" /></p><ul><li><strong>RAM储存空间（56KB）</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025170249644.png" alt="" /><figcaption>image-20231025170249644</figcaption></figure><ul><li><strong>配置寄存器空间（256Byte）</strong></li></ul><p>用来存放寄存器状态的，比如 RTC（实时时间）、背光亮度等实时的状态。通过 DGUS 的串口指令改变各寄存器的值，可实现上位机与 DGUS 屏信息传输及控制。寄存器地址0x00~0xFF，部分寄存器如下所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025172556583.png" alt="" /><figcaption>image-20231025172556583</figcaption></figure><ul><li><strong>曲线缓冲区（16KB）</strong></li></ul><p>缓冲区中可存储 8 条曲线趋势图。将数据按照 DGUS 指令格式发送至缓冲区中，即可快速实现曲线的显示。曲线缓冲区的数据都是 16 位无符号数。</p><h1 id="dgus-屏的串口通信">DGUS 屏的串口通信</h1><p>DGUS 屏采用串口（<strong>1 个起始位，8 个数据位，1 个停止位</strong>）通信，可采用 RS232 或 RS485 两种通信方式。串口波特率可通过 CONFIG 文件来配置。串口的所有指令或数据都是 16 进制（HEX）格式；对于字型（2 字节）数据，<strong>总是采用高字节先传送（MSB）方式</strong>，如 <code>0x1234</code> 先传送 <code>0x12</code>。</p><p>DGUS 屏采用变量驱动模式工作，屏的工作模式和 GUI 的状态完全由数据变量来控制。因此，<strong>串口指令也只需要对变量进行读、写即可</strong>，指令集非常简单，一共只有 <span style="color:green"><strong>5</strong></span> 条指令。如下所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025153443743.png" alt="" /><figcaption>image-20231025153443743</figcaption></figure><p>一条完整的串口指令协议结构如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231025172028362.png" alt="" /><figcaption>image-20231025172028362</figcaption></figure><p>编程时遵循这种协议格式进行数据传输，就可以实现屏幕与MCU之间的正常沟通。</p><h1 id="dgus-屏的驱动实现">DGUS 屏的驱动实现</h1><p>根据以上的通信协议，写出如下几个函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DGUS_FRAME_HEAD1 (0x5a)                     <span class="hljs-comment">/* DGUS帧头1 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DGUS_FRAME_HEAD2 (0xa5)                     <span class="hljs-comment">/* DGUS帧头2 */</span></span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">command</span></span><span class="hljs-class">&#123;</span>  CMD_REG_WRITE = <span class="hljs-number">0x80</span>,  <span class="hljs-comment">/* DGUS写寄存器指令 */</span>  CMD_REG_READ,          <span class="hljs-comment">/* DGUS读寄存器指令 */</span>  CMD_DATA_WRITE,        <span class="hljs-comment">/* DGUS写数据指令 */</span>  CMD_DATA_READ,         <span class="hljs-comment">/* DGUS读数据指令 */</span>  CMD_CURVE_WRITE        <span class="hljs-comment">/* DGUS写曲线指令 */</span>&#125;;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_reg_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_reg_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_data_write</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> addr, <span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_data_read</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> addr,<span class="hljs-type">uint8_t</span> length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_curve_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length, <span class="hljs-type">uint8_t</span> ch_mode)</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif dgus通过串口发送数据</span><span class="hljs-comment">  * @param p_tx_data 数据指针</span><span class="hljs-comment">  * @param size 数据长度</span><span class="hljs-comment">  * @retval none</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dgus_send_data</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> size)</span>&#123;  HAL_UART_Transmit(&amp;huart2, p_tx_data, size, <span class="hljs-number">1000</span>);<span class="hljs-keyword">while</span>(HAL_UART_GetState(&amp;huart2， UART_FLAG_TC) != SET);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif CRC16数据校验</span><span class="hljs-comment">  * @param buf 数据缓存指针</span><span class="hljs-comment">  * @param length 数据长度</span><span class="hljs-comment">  * @retval crc16 校验值</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> <span class="hljs-title function_">CalcDwinCRC16</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *buf,<span class="hljs-type">uint16_t</span> length)</span>&#123;  <span class="hljs-type">uint16_t</span> crc16,data,val;   crc16 = <span class="hljs-number">0x0000</span>;   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)  &#123;    <span class="hljs-keyword">if</span>((i % <span class="hljs-number">8</span>) == <span class="hljs-number">0</span>)    &#123;      data = (*buf++)&lt;&lt;<span class="hljs-number">8</span>;     &#125;    val = crc16 ^ data;    crc16 = crc16&lt;&lt;<span class="hljs-number">1</span>;    data = data &lt;&lt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(val&amp;<span class="hljs-number">0x8000</span>)    &#123;      crc16 = crc16 ^ <span class="hljs-number">0x8005</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> crc16;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif 向DGUS屏寄存器写入数据</span><span class="hljs-comment">  * @param reg_addr 寄存器地址</span><span class="hljs-comment">  * @param p_tx_data 写入数据的指针</span><span class="hljs-comment">  * @param length 写入的数据长度</span><span class="hljs-comment">  * @retval none.</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">dgus_reg_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length)</span>&#123;  <span class="hljs-type">uint8_t</span> frame_Reg_Write[<span class="hljs-number">20</span>];  frame_Reg_Write[<span class="hljs-number">0</span>] = DGUS_FRAME_HEAD1;  frame_Reg_Write[<span class="hljs-number">1</span>] = DGUS_FRAME_HEAD2;  frame_Reg_Write[<span class="hljs-number">2</span>] = (<span class="hljs-type">uint8_t</span>)(length+<span class="hljs-number">4</span>);  frame_Reg_Write[<span class="hljs-number">3</span>] = CMD_REG_WRITE;  frame_Reg_Write[<span class="hljs-number">4</span>] = reg_addr;  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)  &#123;    frame_Reg_Write[<span class="hljs-number">5</span>+i] = p_tx_data[i];  &#125;  <span class="hljs-type">uint16_t</span> checkCode=CalcDwinCRC16(&amp;frame_Reg_Write[<span class="hljs-number">3</span>]，length+<span class="hljs-number">2</span>);  frame_Reg_Write[length+<span class="hljs-number">5</span>]=(<span class="hljs-type">uint8_t</span>)checkCode; <span class="hljs-comment">//数组中高字节在后</span>  frame_Reg_Write[length+<span class="hljs-number">6</span>]=(<span class="hljs-type">uint8_t</span>)(checkCode&gt;&gt;<span class="hljs-number">8</span>);      dgus_send_data(frame_Reg_Write，(length+<span class="hljs-number">7</span>));&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif 读DGUS屏寄存器数据</span><span class="hljs-comment">  * @param reg_addr 寄存器地址</span><span class="hljs-comment">  * @param length 读取的数据长度</span><span class="hljs-comment">  * @retval none.</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">dgus_reg_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg_addr, <span class="hljs-type">uint8_t</span> length)</span>&#123;  <span class="hljs-type">uint8_t</span> frame_Reg_Read[<span class="hljs-number">20</span>];<span class="hljs-comment">//读数据命令</span>  frame_Reg_Read[<span class="hljs-number">0</span>] = DGUS_FRAME_HEAD1;  frame_Reg_Read[<span class="hljs-number">1</span>] = DGUS_FRAME_HEAD2;  frame_Reg_Read[<span class="hljs-number">2</span>] = (<span class="hljs-type">uint8_t</span>)(length+<span class="hljs-number">5</span>);  frame_Reg_Read[<span class="hljs-number">3</span>] = CMD_REG_READ;  frame_Reg_Read[<span class="hljs-number">4</span>] = reg_addr;  frame_Reg_Read[<span class="hljs-number">5</span>] = length;  <span class="hljs-type">uint16_t</span> checkCode=CalcDwinCRC16(&amp;frame_Reg_Read[<span class="hljs-number">3</span>],<span class="hljs-number">3</span>);  frame_Reg_Read[<span class="hljs-number">6</span>]=(<span class="hljs-type">uint8_t</span>)checkCode;  frame_Reg_Read[<span class="hljs-number">7</span>]=(<span class="hljs-type">uint8_t</span>)(checkCode&gt;&gt;<span class="hljs-number">8</span>);  dgus_send_data(frame_Reg_Read,<span class="hljs-number">0x08</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif 向DGUS屏变量存储器写数据</span><span class="hljs-comment">  * @param addr 变量存储器地址</span><span class="hljs-comment">  * @param p_tx_data 数据指针</span><span class="hljs-comment">  * @param length 写入的数据长度</span><span class="hljs-comment">  * @retval none.</span><span class="hljs-comment">  * @note 一次最多允许写47个字，即length&lt;=94</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">dgus_data_write</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> addr, <span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length)</span>&#123;  <span class="hljs-type">uint8_t</span> frame_data_Write[<span class="hljs-number">102</span>];  frame_data_Write[<span class="hljs-number">0</span>] = DGUS_FRAME_HEAD1;  frame_data_Write[<span class="hljs-number">1</span>] = DGUS_FRAME_HEAD2;  frame_data_Write[<span class="hljs-number">2</span>] = (<span class="hljs-type">uint8_t</span>)(length+<span class="hljs-number">3</span>);  frame_data_Write[<span class="hljs-number">3</span>] = CMD_DATA_WRITE;  frame_data_Write[<span class="hljs-number">4</span>] = (<span class="hljs-type">uint8_t</span>)(addr&gt;&gt;<span class="hljs-number">8</span>);<span class="hljs-comment">//起始地址</span>  frame_data_Write[<span class="hljs-number">5</span>] = (<span class="hljs-type">uint8_t</span>)addr;<span class="hljs-comment">//起始地址</span>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)  &#123;    frame_data_Write[<span class="hljs-number">6</span>+i] = p_tx_data[i];  &#125;  <span class="hljs-type">uint16_t</span> checkCode = CalcDwinCRC16(&amp;frame_data_Write[<span class="hljs-number">3</span>],length+<span class="hljs-number">3</span>);  frame_data_Write[length+<span class="hljs-number">6</span>] = (<span class="hljs-type">uint8_t</span>)checkCode;  frame_data_Write[length+<span class="hljs-number">7</span>] = (<span class="hljs-type">uint8_t</span>)(checkCode&gt;&gt;<span class="hljs-number">8</span>);  dgus_send_data(frame_data_Write,(length+<span class="hljs-number">8</span>));&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif 读DGUS屏变量存储器数据</span><span class="hljs-comment">  * @param addr 变量存储器地址</span><span class="hljs-comment">  * @param length 读取的数据长度</span><span class="hljs-comment">  * @retval none.</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">dgus_data_read</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> addr,<span class="hljs-type">uint8_t</span> length)</span>&#123;  <span class="hljs-type">uint8_t</span> frame_data_read[<span class="hljs-number">20</span>];<span class="hljs-comment">//读数据命令</span>  frame_data_read[<span class="hljs-number">0</span>] = DGUS_FRAME_HEAD1;  frame_data_read[<span class="hljs-number">1</span>] = DGUS_FRAME_HEAD2;  frame_data_read[<span class="hljs-number">2</span>] = <span class="hljs-number">0x04</span>;  frame_data_read[<span class="hljs-number">3</span>] = CMD_DATA_READ;  frame_data_read[<span class="hljs-number">4</span>] = (<span class="hljs-type">uint8_t</span>)(addr&gt;&gt;<span class="hljs-number">8</span>);<span class="hljs-comment">//起始地址</span>  frame_data_read[<span class="hljs-number">5</span>] = (<span class="hljs-type">uint8_t</span>)addr;<span class="hljs-comment">//起始地址</span>  frame_data_read[<span class="hljs-number">6</span>] = length;<span class="hljs-comment">//读取长度</span>    <span class="hljs-type">uint16_t</span> checkCode=CalcDwinCRC16(&amp;frame_data_read[<span class="hljs-number">3</span>],<span class="hljs-number">4</span>);  frame_data_read[<span class="hljs-number">7</span>]=(<span class="hljs-type">uint8_t</span>)checkCode;  frame_data_read[<span class="hljs-number">8</span>]=(<span class="hljs-type">uint8_t</span>)(checkCode&gt;&gt;<span class="hljs-number">8</span>);  dgus_send_data(frame_data_read,<span class="hljs-number">0x09</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @breif DGUS屏画曲线</span><span class="hljs-comment">  * @param p_tx_data 数据指针</span><span class="hljs-comment">  * @param length 数据长度</span><span class="hljs-comment">  * @param ch_mode 通道模式</span><span class="hljs-comment">  * @retval none.</span><span class="hljs-comment">  * @note 一次最多允许写8个字，即length&lt;=16</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">dgus_curve_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *p_tx_data, <span class="hljs-type">uint16_t</span> length, <span class="hljs-type">uint8_t</span> ch_mode)</span>&#123;  <span class="hljs-type">uint8_t</span> frame_curve_Write[<span class="hljs-number">23</span>];<span class="hljs-comment">//写曲线缓冲区命令</span>  frame_curve_Write[<span class="hljs-number">0</span>] = DGUS_FRAME_HEAD1;  frame_curve_Write[<span class="hljs-number">1</span>] = DGUS_FRAME_HEAD2;  frame_curve_Write[<span class="hljs-number">2</span>] = (<span class="hljs-type">uint8_t</span>)(length+<span class="hljs-number">2</span>);  frame_curve_Write[<span class="hljs-number">3</span>] = CMD_CURVE_WRITE;  frame_curve_Write[<span class="hljs-number">4</span>] = ch_mode;  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)  &#123;    frame_curve_Write[<span class="hljs-number">5</span>+i] = p_tx_data[i];  &#125;  <span class="hljs-type">uint16_t</span> checkCode=CalcDwinCRC16(&amp;frame_curve_Write[<span class="hljs-number">3</span>],length+<span class="hljs-number">2</span>);  frame_curve_Write[length+<span class="hljs-number">5</span>]=(<span class="hljs-type">uint8_t</span>)checkCode;  frame_curve_Write[length+<span class="hljs-number">6</span>]=(<span class="hljs-type">uint8_t</span>)(checkCode&gt;&gt;<span class="hljs-number">8</span>);  dgus_send_data(frame_curve_Write,length+<span class="hljs-number">7</span>);&#125;</code></pre></div><p>根据需求，在上层应用中调用以上API函数，即可实现屏幕与MCU的通信。</p><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/foxclever/article/details/121734689">【精选】外设驱动库开发笔记35：迪文触摸屏驱动_迪文k600+触摸校准-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;嵌入式系统开发中，我们会经常使用到串口屏，主要是因为串口屏使用起来比较简单，不需要花费大量的时间来编写底层实现逻辑代码，我们只需要根据它的协议通过串口进行数据的传输和显示就好了。串口屏在工业上有很多品牌，这里主要以迪文显示屏为例，来看看它的使用和驱动编写。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="单片机" scheme="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="串口屏" scheme="http://example.com/tags/%E4%B8%B2%E5%8F%A3%E5%B1%8F/"/>
    
  </entry>
  
  <entry>
    <title>阅读摘录</title>
    <link href="http://example.com/2023/10/22/%E9%98%85%E8%AF%BB%E6%91%98%E5%BD%95/"/>
    <id>http://example.com/2023/10/22/%E9%98%85%E8%AF%BB%E6%91%98%E5%BD%95/</id>
    <published>2023-10-22T14:23:41.000Z</published>
    <updated>2023-10-23T08:38:41.109Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在整理之前收录的文章，读到了一篇关于阅读意义的文章，觉得写的挺好，摘录如下：</p><ul><li><p>“<strong>我这辈子遇到的聪明人，来自各行各业的聪明人，没有不每天阅读的。没有，一个都没有。--------查理·芒格</strong>”</p></li><li><p><strong>一个人的成长，一个人的自我突破过程，很大程度上就是他的阅读史。</strong>所以我们才有了这样一句话：你的气质里，藏着你走过的路，读过的书，爱过的人。</p></li><li><p><strong><span style="color:green">几乎所有领导者都是通过读书打开了自我，从而有了自己清晰的人生目标与追求。</span></strong></p></li><li><p>读书的好处，是可以让我们跳出此时此地的限制，穿透一时一地的迷雾，从更大的格局和更长远的眼光来把握眼前的各种扰动，从而把不解和不安化成豁然开朗和淡定从容，最后养成战略上的定力。</p></li><li><p>好的书，提供的是在无数人的经验教训的基础之上总结出来的规律和原则，让人可以更好、更快地理解自己和所处的这个世界，以及背后的行为逻辑。</p></li><li><p><strong>使命是做什么，思想是怎么做。这都是领导力的核心，而这些都离不开读书。</strong></p></li><li><p>读经典，就是在跟大师对话。这是提高自己思维水平的最有效途径。</p></li><li><p><strong>读书一定要带着问题意识。</strong>最好的读书是联系实际来读书，善于把书本中的普遍规律与我们的具体实践结合起来。</p></li><li><p>高管需要的是理念，是思想，而基层需要的是解决具体问题的操作性方法。所以读书一定要分层级。就像共产党那样，从毛泽东的思想，到林彪的战术理念，到士兵的具体打法，一步步落地。</p></li></ul><p><strong>原文</strong>：<a href="https://mp.weixin.qq.com/s/p4OUvyx8edUlc1JyUFQUTA">为什么管理者必须要大量阅读？</a></p><p><strong>管理类书籍推荐：</strong></p><p><span style="color:blue">《乔布斯传》《从优秀到卓越》《创新者的窘境》《影响力》《卓有成效的管理者》《裂变》《穷查理宝典》《大赛车》《傻瓜理财指南》 《创业维艰》《精益创业》《从0到1》 《人性的优势》《献给经理人的一本书》《团队合作的五大障碍》《认识商业》《逃不开的经济周期》《失控》《思考，快与慢》《黑天鹅》《洞见》《基业长青》《滚雪球》吴军的《态度》《见识》《富足》《格局》《原则》</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两天在整理之前收录的文章，读到了一篇关于阅读意义的文章，觉得写的挺好，摘录如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;“&lt;strong&gt;我这辈子遇到的聪明人，来自各行各业的聪明人，没有不每天阅读的。没有，一个都没有。--------查理·芒格&lt;/strong&gt;”&lt;/p&gt;&lt;</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>stm32 IAP在线升级详解</title>
    <link href="http://example.com/2023/10/19/stm32-IAP%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/10/19/stm32-IAP%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-10-19T05:01:39.000Z</published>
    <updated>2023-10-26T02:55:44.313Z</updated>
    
    <content type="html"><![CDATA[<p>单片机程序的烧录方式主要有以下三种：</p><ul><li><span style="color:blue">ICP（In Circuit Programming）线路途径烧录</span></li></ul><p>烧录器Jlink、daplink等通过JTAG或SWD线路接口进行烧录。</p><ul><li><span style="color:blue">ISP（In System Programming）系统途径烧录</span></li></ul><p>通过BootLoader引导代码和外围uart或usb等接口引导进入Flash的System Memory区，进行程序的烧录。</p><ul><li><span style="color:blue">IAP（In Application Programming）应用程序途径烧录</span></li></ul><p>通过程序自身运行过程中，对flash进行程序烧录。</p><p>在产品发布后，需要添加新功能或修复bug，而使用预留的通信接口（UART、USB、WIFI、4G、网口、蓝牙等）进行IAP程序的烧录升级，就可避免拆开机器使用下载器烧写程序，方便快捷，所以，IAP方式使用的越来越广泛，下面我们主要来看看IAP的烧录方式具体情况。</p><h1 id="iap程序的组成">IAP程序的组成</h1><p>要实现IAP功能一般要设计两个工程代码：</p><ul><li><strong><span style="color:blue">自定义BootLoader程序</span></strong></li></ul><p>BootLoader主要起引导作用，引导程序从哪一部分映射地址启动。在STM32中有两类，一类是芯片厂商固化到Flash中的自举程序，用作ISP串口下载程序；另一类属于用户自定义BootLoader程序，用于检测APP区代码是否需要更新，以及跳转到APP区执行APP程序。</p><ul><li><strong><span style="color:blue">APP应用程序</span></strong></li></ul><p>这个程序才是真正实现产品功能的程序。APP程序可分成APP1和APP2两部分，即双区模式，APP1用来存储用户程序，APP2用来当更新缓存和备份区域用。</p><p><strong>IAP的实现流程</strong>：</p><p>单片机上电后先运行BootLoader程序，检测程序更新条件是否被触发(如：<strong>上位机是否发生特定的数据、特定的按键是否按下、串口是否接收到特定数据、U盘是否插入</strong>等)，如果有则对APP应用程序进行擦除和重新写入新的用户程序，如果没有则直接跳转到APP应用程序执行应用。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/66e1355f18e349069da43d2785c8237c.png" alt="img" style="zoom:50%;" /></p><h1 id="iap实现原理">IAP实现原理</h1><p>STM32微控制器在硬件上通过<strong>boot0</strong>和<strong>boot1</strong>两个引脚的设置，可进入不同的启动模式，如下所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231020085333996.png" alt="" /><figcaption>image-20231020085333996</figcaption></figure><p>微控制器进入不同的启动模式，就是改变了flash内部中断向量表起始地址的指向，<span style="color:green"><strong>IAP的本质其实是设置存放中断向量表的地址。</strong></span></p><ul><li><strong>正常程序上电执行流程</strong>：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231019184549407.png" /></p><ul><li><strong>加入IAP后上电执行流程</strong>：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231019191454635.png" /></p><p>更新中断向量表的方法：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> APPLICATION_ADDRESS   (uint32_t)0x08008000</span>SCB-&gt;VTOR = APPLICATION_ADDRESS;</code></pre></div><h1 id="iap-flash分区">IAP flash分区</h1><h1 id="程序的实现">程序的实现</h1><p>程序实现主要是BootLoader程序和APP用户程序的编写。</p><h4 id="bootloader程序">BootLoader程序</h4><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>APPLICATION_NORMAL = <span class="hljs-number">0</span>,<span class="hljs-comment">// APP能正常稳定运行</span>APPLICATION_UPDATED,<span class="hljs-comment">// APP刚更新完成，等待测试启动</span>APPLICATION_ERROR,<span class="hljs-comment">// APP错误，不能正常工作</span>&#125;Application_Status_t; <span class="hljs-keyword">typedef</span>__PACKED_STRUCT&#123;<span class="hljs-type">uint32_t</span> Device_id;<span class="hljs-comment">// 设备号</span><span class="hljs-type">uint32_t</span> Hardware_Version;<span class="hljs-comment">// 硬件版本信息</span><span class="hljs-type">uint32_t</span> Application0_Version;<span class="hljs-comment">// APP0软件版本</span><span class="hljs-type">uint32_t</span> Application1_Version;<span class="hljs-comment">// APP1软件版本</span><span class="hljs-type">uint32_t</span> Application0_Status;<span class="hljs-comment">// APP0的状态. @Application_Status_t</span><span class="hljs-type">uint32_t</span> Application1_Status;<span class="hljs-comment">// APP1的状态. @Application_Status_t</span><span class="hljs-type">uint8_t</span>  Server_Address[<span class="hljs-number">64</span>];<span class="hljs-comment">// 服务器的地址</span><span class="hljs-type">uint32_t</span> Server_Port;<span class="hljs-comment">// 服务器的端口号</span><span class="hljs-type">uint8_t</span>  Server_Key[<span class="hljs-number">4</span>];<span class="hljs-comment">// 服务器的登录密钥，随时更新</span><span class="hljs-type">uint32_t</span> SystemParamCRC;&#125;SystemParamTypeDef;<span class="hljs-type">void</span> <span class="hljs-title function_">System_ParamReadCheck</span><span class="hljs-params">(SystemParamTypeDef *pData)</span>&#123;<span class="hljs-type">uint32_t</span> crcdatalen = <span class="hljs-number">0</span>;SystemParamTypeDef sysparam, sysparambackup; <span class="hljs-comment">/* 读取主区和备份区的系统参数 */</span>FLASH_If_Read(SYSTEMPARAM_ADDRESS, (<span class="hljs-type">uint32_t</span>*) &amp;sysparam, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span>);FLASH_If_Read(SYSTEMPARAM_BACKUPADDRESS, (<span class="hljs-type">uint32_t</span>*) &amp;sysparambackup, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span>); <span class="hljs-comment">// 去掉系统参数CRC的数据校验长度</span>crcdatalen = <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span> - <span class="hljs-number">1</span>;<span class="hljs-comment">/* 主系统参数区放的的数据CRC校验  */</span><span class="hljs-keyword">if</span> (HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span>*) &amp;sysparam, crcdatalen)== sysparam.SystemParamCRC)&#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> *  @ 系统参数主存储区的数据校验正确，</span><span class="hljs-comment"> *  @ 开始校验系统参数备份区的数据：</span><span class="hljs-comment"> *    1、如果备份区的数据CRC校验正确，则进行对比数据一致性，不一致则将主区数据写入备份区</span><span class="hljs-comment"> *    2、如果备份区的数据CRC校验错误，则将主区的系统参数据写入备份区；</span><span class="hljs-comment"> * */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter main sector data checked OK\r\n&quot;</span>);<span class="hljs-keyword">if</span> (HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span>*) &amp;sysparambackup, crcdatalen) == sysparambackup.SystemParamCRC)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter backup sector data checked OK\r\n&quot;</span>);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(&amp;sysparam, &amp;sysparambackup, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef)) != <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter main sector and backup sector data are different, update backup sector data\r\n&quot;</span>);<span class="hljs-built_in">memcpy</span>(&amp;sysparambackup, &amp;sysparam, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, &amp;sysparambackup);&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter main sector and backup sector data are the same\r\n&quot;</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter backup sector data checked Fail, update backup sector data\r\n&quot;</span>);<span class="hljs-built_in">memcpy</span>(&amp;sysparambackup, &amp;sysparam, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, &amp;sysparambackup);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> *  @ 系统参数主存储区的数据校验错误</span><span class="hljs-comment"> *  @ 开始校验系统参数备份区的数据：</span><span class="hljs-comment"> *    1、如果备份区的数据CRC校验正确，则将备份区数据写入主区</span><span class="hljs-comment"> *    2、如果备份区的数据CRC校验错误，则将默认系统参数数据写入两个区域，强行启动APP0；</span><span class="hljs-comment"> * */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter main sector data checked Fail\r\n&quot;</span>);<span class="hljs-keyword">if</span> (HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span>*) &amp;sysparambackup, crcdatalen) == sysparambackup.SystemParamCRC)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter backup sector data checked OK, update master sector data\r\n&quot;</span>);<span class="hljs-built_in">memcpy</span>(&amp;sysparam, &amp;sysparambackup, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));System_ParamUpdate(SYSTEMPARAM_ADDRESS, &amp;sysparam);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System parameter main sector and backup sector data checked Fail, Restore defaults\r\n&quot;</span>);SystemParam_default.SystemParamCRC = HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span>*) &amp;SystemParam_default, crcdatalen);<span class="hljs-built_in">memcpy</span>(&amp;sysparam, &amp;SystemParam_default, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));<span class="hljs-built_in">memcpy</span>(&amp;sysparambackup, &amp;SystemParam_default, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));System_ParamUpdate(SYSTEMPARAM_ADDRESS, &amp;sysparam);System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, &amp;sysparambackup);&#125;&#125; <span class="hljs-built_in">memcpy</span>(pData, &amp;sysparam, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hardware_Version = 0x%08lX\r\n&quot;</span>, pData-&gt;Hardware_Version);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Application0_Version = 0x%08lX\r\n&quot;</span>, pData-&gt;Application0_Version);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Application0_Status  = 0x%08lX\r\n&quot;</span>, pData-&gt;Application0_Status);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Application1_Version = 0x%08lX\r\n&quot;</span>, pData-&gt;Application1_Version);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Application1_Status  = 0x%08lX\r\n&quot;</span>, pData-&gt;Application1_Status);&#125;<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">System_SelectBootAddress</span><span class="hljs-params">(SystemParamTypeDef *pData)</span>&#123;<span class="hljs-type">uint32_t</span> BootAddress = <span class="hljs-number">0</span>; <span class="hljs-keyword">if</span> (pData-&gt;Application0_Version &gt;= pData-&gt;Application1_Version)&#123;<span class="hljs-keyword">if</span> (pData-&gt;Application0_Status == APPLICATION_NORMAL)&#123;<span class="hljs-comment">/* 正常启动 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP0 APPLICATION_NORMAL. Run the APP0.\r\n&quot;</span>);BootAddress = APPLICATION0_ADDRESS;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pData-&gt;Application0_Status == APPLICATION_UPDATED)&#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * 刚IAP更新的程序固件，把APP的status改成 错误标志位 @APPLICATION_ERROR，</span><span class="hljs-comment"> * 1、若APP跳转运行正常后会修改成正常启动标志 @APPLICATION_NORMAL。</span><span class="hljs-comment"> * 2、若APP跳转运行失败（跑飞），那么看门狗会复位，重启后该APP是错误标志不会启动。</span><span class="hljs-comment"> * 3、清空版本信息，待启动修正。</span><span class="hljs-comment"> * 4、更新系统参数，写入flash</span><span class="hljs-comment"> * */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP0 APPLICATION_UPDATED. Clear APP0 system parameters, Run the APP0.\r\n&quot;</span>);pData-&gt;Application0_Version = <span class="hljs-number">0</span>;pData-&gt;Application0_Status = APPLICATION_ERROR;System_ParamUpdate(SYSTEMPARAM_ADDRESS, pData);System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, pData);BootAddress = APPLICATION0_ADDRESS;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 由于APP0信息错误，强制启动APP1 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP0 APPLICATION_ERROR. Forced the APP1 to run.\r\n&quot;</span>);BootAddress = APPLICATION1_ADDRESS;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (pData-&gt;Application1_Status == APPLICATION_NORMAL)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP1 APPLICATION_NORMAL. Run the APP1.\r\n&quot;</span>);BootAddress = APPLICATION1_ADDRESS;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pData-&gt;Application1_Status == APPLICATION_UPDATED)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP1 APPLICATION_UPDATED. Clear APP1 system parameters, Run the APP1.\r\n&quot;</span>);pData-&gt;Application1_Version = <span class="hljs-number">0</span>;pData-&gt;Application1_Status = APPLICATION_ERROR;System_ParamUpdate(SYSTEMPARAM_ADDRESS, pData);System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, pData);BootAddress = APPLICATION1_ADDRESS;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 由于APP1信息错误，强制启动APP0 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP1 APPLICATION_ERROR. Forced the APP0 to run.\r\n&quot;</span>);BootAddress = APPLICATION0_ADDRESS;&#125;&#125; <span class="hljs-keyword">return</span> BootAddress;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>   <span class="hljs-comment">/* USER CODE END 1 */</span>   <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>   <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>  HAL_Init();   <span class="hljs-comment">/* USER CODE BEGIN Init */</span>   <span class="hljs-comment">/* USER CODE END Init */</span>   <span class="hljs-comment">/* Configure the system clock */</span>  SystemClock_Config();   <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>   <span class="hljs-comment">/* USER CODE END SysInit */</span>   <span class="hljs-comment">/* Initialize all configured peripherals */</span>  MX_GPIO_Init();  MX_USART1_UART_Init();  MX_CRC_Init();  MX_IWDG_Init();  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nSudaroot, This is a advanced bootloader\r\n&quot;</span>);  <span class="hljs-comment">/* system param read check */</span>  System_ParamReadCheck(&amp;SystemParam);  <span class="hljs-comment">/* execute the new program */</span>  HAL_IWDG_Refresh(&amp;hiwdg);  JumpAddress = System_SelectBootAddress(&amp;SystemParam);  JumpAddress = *(__IO <span class="hljs-type">uint32_t</span>*) (JumpAddress + <span class="hljs-number">4</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Start program execution......\r\n\n\n&quot;</span>);  <span class="hljs-comment">/*</span><span class="hljs-comment">   * 关闭或反初始化前面用到的外设和中断</span><span class="hljs-comment">   * 1、反初始化UART</span><span class="hljs-comment">   * 2、关闭系统滴答定时器中断</span><span class="hljs-comment">   * */</span>  HAL_UART_DeInit(&amp;huart1);  HAL_SuspendTick();  <span class="hljs-comment">/* Refresh the IWDG. */</span>  HAL_IWDG_Refresh(&amp;hiwdg);  <span class="hljs-comment">/* Jump to user application */</span>  JumpToApplication = (pFunction) JumpAddress;  <span class="hljs-comment">/* Initialize user application&#x27;s Stack Pointer */</span>  __set_MSP(*(__IO <span class="hljs-type">uint32_t</span>*) (JumpAddress - <span class="hljs-number">4</span>));  JumpToApplication();  <span class="hljs-comment">/* USER CODE END 2 */</span>   <span class="hljs-comment">/* Infinite loop */</span>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;    <span class="hljs-comment">/* USER CODE END WHILE */</span>     <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>  &#125;  <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><h3 id="app程序">APP程序</h3><p>这部分可使用 <strong>YModem协议</strong>，也可不使用，</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Define APP0 software version */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>APPLICATION0_VERSION0x00000010U</span><span class="hljs-type">void</span> <span class="hljs-title function_">System_ParamReadCheckUpdate</span><span class="hljs-params">(SystemParamTypeDef *pData)</span>&#123;<span class="hljs-type">uint32_t</span> flash_update = <span class="hljs-number">0</span>; FLASH_If_Read(SYSTEMPARAM_ADDRESS, (<span class="hljs-type">uint32_t</span>*)pData, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span>); <span class="hljs-comment">/* APP0的软件版本号与固件内部软件版本号不一致，更新版本号并写入Flash */</span><span class="hljs-keyword">if</span>(pData-&gt;Application0_Version != APPLICATION0_VERSION)&#123;flash_update = <span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Update APP0 Software Version : 0x%08X\r\n&quot;</span>, APPLICATION0_VERSION);pData-&gt;Application0_Version = APPLICATION0_VERSION;&#125; <span class="hljs-comment">/* APP0 启动了，但是APP0的状态是错误标志.</span><span class="hljs-comment"> * 可能是由于更新完成后，第一次启动标记的，</span><span class="hljs-comment"> * 修正为APPLICATION_NORMAL，重新写入flash</span><span class="hljs-comment"> * */</span><span class="hljs-keyword">if</span>(pData-&gt;Application0_Status != APPLICATION_NORMAL)&#123;flash_update = <span class="hljs-number">1</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Update APP0 Status, APPLICATION_NORMAL\r\n&quot;</span>);pData-&gt;Application0_Status = APPLICATION_NORMAL;&#125; <span class="hljs-comment">/* 如果flash_update 等于 1， 即flash需要更新主存储区和备份区的系统参数数据</span><span class="hljs-comment"> * 更新数据后，需要重启</span><span class="hljs-comment"> * 注意：更新数据时，必须擦除一个扇区后写入完成后，才能更新另一个区域数据，否则有概率丢失两个扇区数据</span><span class="hljs-comment"> * */</span><span class="hljs-keyword">if</span>(flash_update == <span class="hljs-number">1</span>)&#123;pData-&gt;SystemParamCRC = HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span> *)pData, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span> - <span class="hljs-number">1</span>);System_ParamUpdate(SYSTEMPARAM_ADDRESS, pData);System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, pData);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;device reboot\r\n&quot;</span>);HAL_NVIC_SystemReset();&#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">SystemParam_IAP</span><span class="hljs-params">(SystemParamTypeDef *pData)</span>&#123;<span class="hljs-type">uint32_t</span> temp = <span class="hljs-number">0</span>;<span class="hljs-type">uint32_t</span> file_length= <span class="hljs-number">0</span>;<span class="hljs-type">uint32_t</span> timeout = HAL_MAX_DELAY; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System IAP start, update APP1\r\n&quot;</span>);<span class="hljs-comment">/* Download user application in the Flash */</span><span class="hljs-comment">/* 1. erase user application1 area */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Wait for the internal Flash erase to complete\r\n&quot;</span>);<span class="hljs-keyword">if</span>(FLASH_If_Erase(APPLICATION1_ADDRESS, APPLICATION1_SECTOR_NUM) == <span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Erase the internal Flash is fail\r\n&quot;</span>);Error_Handler();&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Erase the internal Flash is complete\r\n&quot;</span>); <span class="hljs-comment">/* 2. download a file via serial port */</span><span class="hljs-comment">/* Clean the input path */</span>__HAL_UART_FLUSH_DRREGISTER(&amp;huart1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for the file to be sent ... \r\n&quot;</span>); <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(HAL_UART_Receive(&amp;huart1, uart_buf, UART_BUF_SIZE, timeout) != HAL_OK)&#123;temp = UART_BUF_SIZE - (huart1.RxXferCount + <span class="hljs-number">1</span>);FLASH_If_Write(APPLICATION1_ADDRESS + file_length, (<span class="hljs-type">uint32_t</span>*)uart_buf, file_length / <span class="hljs-number">4</span>);file_length = file_length + temp;<span class="hljs-keyword">break</span>;&#125;timeout = <span class="hljs-number">1000</span>;FLASH_If_Write(APPLICATION1_ADDRESS + file_length, (<span class="hljs-type">uint32_t</span>*)uart_buf, UART_BUF_SIZE / <span class="hljs-number">4</span>);file_length = file_length + UART_BUF_SIZE;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Programming Completed Successfully! %ldBtye\r\n&quot;</span>, file_length);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Update system parameters\r\n&quot;</span>);pData-&gt;Application1_Version = <span class="hljs-number">0xFFFFFFFF</span>;pData-&gt;Application1_Status  = APPLICATION_UPDATED;pData-&gt;SystemParamCRC = HAL_CRC_Calculate(&amp;hcrc, (<span class="hljs-type">uint32_t</span> *)pData, <span class="hljs-keyword">sizeof</span>(SystemParamTypeDef) / <span class="hljs-number">4</span> - <span class="hljs-number">1</span>);System_ParamUpdate(SYSTEMPARAM_ADDRESS, pData);System_ParamUpdate(SYSTEMPARAM_BACKUPADDRESS, pData); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;device reboot\r\n&quot;</span>);HAL_NVIC_SystemReset();&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> key = <span class="hljs-number">0</span>; SCB-&gt;VTOR = APPLICATION0_ADDRESS;  <span class="hljs-comment">/* USER CODE END 1 */</span>   <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>   <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>  HAL_Init();   <span class="hljs-comment">/* USER CODE BEGIN Init */</span>   <span class="hljs-comment">/* USER CODE END Init */</span>   <span class="hljs-comment">/* Configure the system clock */</span>  SystemClock_Config();   <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>   <span class="hljs-comment">/* USER CODE END SysInit */</span>   <span class="hljs-comment">/* Initialize all configured peripherals */</span>  MX_GPIO_Init();  MX_USART1_UART_Init();  MX_IWDG_Init();  MX_CRC_Init();  MX_TIM2_Init();  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>  HAL_TIM_Base_Start_IT(&amp;htim2);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nSudaroot, This is IAP Application0\r\n&quot;</span>);  System_ParamReadCheckUpdate(&amp;SystemParam);  <span class="hljs-comment">/* USER CODE END 2 */</span>   <span class="hljs-comment">/* Infinite loop */</span>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n=================== Main Menu ============================\r\n\n&quot;</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  IAP:Download user application to the internal Flash ----- 1\r\n\n&quot;</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  Current System APP0 Version: 0x%08lX\r\n&quot;</span>, SystemParam.Application0_Version);  <span class="hljs-comment">/* Clean the input path */</span>  __HAL_UART_FLUSH_DRREGISTER(&amp;huart1);  <span class="hljs-keyword">if</span>(HAL_UART_Receive(&amp;huart1, &amp;key, <span class="hljs-number">1</span>, HAL_MAX_DELAY) == HAL_OK)  &#123;  <span class="hljs-keyword">if</span>(key == <span class="hljs-string">&#x27;1&#x27;</span>)  &#123;  SystemParam_IAP(&amp;SystemParam);  &#125;  &#125;    <span class="hljs-comment">/* USER CODE END WHILE */</span>     <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>  &#125;  <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><p><a href="https://blog.csdn.net/xys430381_1/article/details/105409808">stm32-IAP（在线升级程序）_stm32 在线升级-CSDN博客</a></p><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/sudaroot/article/details/106932736">STM32CubeIDE IAP原理讲解，及UART双APP交替升级IAP实现-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_41294615/article/details/104669766">STM32CubeMx开发之路—在线升级OTA_stm32ota升级例程-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单片机程序的烧录方式主要有以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;color:blue&quot;&gt;ICP（In Circuit Programming）线路途径烧录&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;烧录器Jlink、daplink等通过JT</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="IAP" scheme="http://example.com/tags/IAP/"/>
    
  </entry>
  
  <entry>
    <title>关于过零检测电路</title>
    <link href="http://example.com/2023/10/18/%E5%85%B3%E4%BA%8E%E8%BF%87%E9%9B%B6%E6%A3%80%E6%B5%8B%E7%94%B5%E8%B7%AF/"/>
    <id>http://example.com/2023/10/18/%E5%85%B3%E4%BA%8E%E8%BF%87%E9%9B%B6%E6%A3%80%E6%B5%8B%E7%94%B5%E8%B7%AF/</id>
    <published>2023-10-18T10:43:19.000Z</published>
    <updated>2023-10-19T03:23:27.053Z</updated>
    
    <content type="html"><![CDATA[<p>在电力工程中，会经常用到<span style="color:red">过零检测</span>技术，如在智能开关产品中通过零点电压检测技术来实现在零电压时导通，从而抑制了开机时浪涌电流冲击，达到保护继电器触点等器件的目的；在调光开关/调光器、电机调速产品中，通过零点电压检测技术对可控硅从零点开始控制交流电导通角的大小，实现调光灯具亮度、电机速度的调节。</p><h1 id="过零检测的概念">过零检测的概念</h1><p>什么是过零检测呢？在交流回路中，电压随时间成正弦波变化，当波形由正负半周交替转换时，电压为 <span style="color:red">零</span> 的点就是 <span style="color:red">过零点</span>，过零检测就是对 <strong>过零点</strong> 进行检测，如下图所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018221851569.png" /></p><h1 id="过零检测的作用">过零检测的作用</h1><p>过零检测主要有以下几个作用：</p><ul><li><strong>可控硅的控制。</strong>调节可控硅的导通时间，从而进行电压控制等。</li><li><strong>交流线路器件保护。</strong>当控制AC220v电压的器件在峰值附近闭合，会产生很大的浪涌电流和火花，在过零点处闭合，就会减少浪涌影响，从而保护了器件。</li><li><strong>计时。</strong>在我国交流电频率为50Hz，周期为20ms。经过全波整流后，在每个过零点处就是10ms，可通过检测过零点进行计时。</li></ul><h1 id="过零检测电路">过零检测电路</h1><p>过零检测时，其末端输出有如下两种形式，可以利用这种呈现方式设计出可以检测这种变化的电路，然后通过MCU中断接口进行触发判断，从而做出应对控制器件导通或关闭的动作。</p><ul><li><span style="color:blue">过零点时电路末端输出脉冲</span></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018221739979.png" alt="" /><figcaption>image-20231018221739979</figcaption></figure><ul><li><span style="color:blue">过零点时电路末端电平变化</span></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018221957043.png" alt="" /><figcaption>image-20231018221957043</figcaption></figure><p>下面看看工程设计中常见的几种设计思路：</p><ul><li><strong>采用三极管的过零检测电路</strong></li></ul><p>通过分压电阻将交流信号衰减至三极管基极，利用三极管特性进行过零检测来改变输出状态。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018222920964.png" alt="" /><figcaption>image-20231018222920964</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018224755520.png" alt="" /><figcaption>image-20231018224755520</figcaption></figure><ul><li><strong>采用比较器的过零检测电路</strong></li></ul><p>通过分压电阻将交流信号衰减至比较器正端输入，当交流输入超过零基准电压时，过零检测电路会改变比较器的输出状态。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018223535069.png" alt="image-20231018223535069" /><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018225206057.png" alt="image-20231018225206057" /></p><ul><li><strong>采用光耦隔离的过零检测电路</strong></li></ul><p>这是隔离方式中最常用的一种，在设计应用中，使用最广。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018223733354.png" alt="" /><figcaption>image-20231018223733354</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018224951457.png" alt="" /><figcaption>image-20231018224951457</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018225034226.png" alt="" /><figcaption>image-20231018225034226</figcaption></figure><ul><li><strong>采用ADC采集的过零检测电路</strong></li></ul><p>通过分压电阻将交流信号衰减至ADC输入端，通过ADC进行电压采样来检测过零点。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231018223927720.png" alt="" /><figcaption>image-20231018223927720</figcaption></figure><ul><li><strong>采用带过零检测功能的芯片</strong></li></ul><p>采用芯片方式，PCB布局占用面积小，可靠性高，但成本也相对要高些。如：</p><p>ROHM半导体公司的BM1ZxxxFJ系列：<a href="https://www.rohm.com.cn/products/power-management/ac-voltage-zero-cross-detection-ics#parametricSearch">过零检测IC罗姆半导体集团(ROHM Semiconductor)</a></p><p>国产的GS1102：<a href="http://www.silandtech.com/prodind.html?prodKey=ic_xp_GS1102">GS1102详情 (silandtech.com)</a></p><p>MOC303x、MOC304x、MOC308x等</p><p><strong>参考链接：</strong></p><p><a href="https://mp.weixin.qq.com/s/U4svW0Oxr6UoI1sYF5k8pg">https://mp.weixin.qq.com/s/U4svW0Oxr6UoI1sYF5k8pg</a></p><p><a href="https://mp.weixin.qq.com/s/oNA8LNU8WL6gEBPcWI3NiQ">https://mp.weixin.qq.com/s/oNA8LNU8WL6gEBPcWI3NiQ</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在电力工程中，会经常用到&lt;span style=&quot;color:red&quot;&gt;过零检测&lt;/span&gt;技术，如在智能开关产品中通过零点电压检测技术来实现在零电压时导通，从而抑制了开机时浪涌电流冲击，达到保护继电器触点等器件的目的；在调光开关/调光器、电机调速产品中，通过零点电压检测</summary>
      
    
    
    
    <category term="硬件" scheme="http://example.com/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="过零检测" scheme="http://example.com/tags/%E8%BF%87%E9%9B%B6%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>红外遥控NEC协议详解</title>
    <link href="http://example.com/2023/10/17/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7NEC%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/10/17/%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7NEC%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-10-17T02:31:50.000Z</published>
    <updated>2023-10-17T05:15:40.514Z</updated>
    
    <content type="html"><![CDATA[<p>红外遥控（IR）一般由发射和接收两部分组成，发射元件为红外发射管（遥控器），接收一般采用一体化红外接收头，发射载波频率与接收头固定频率需一致才能正确接收数据。</p><h3 id="发射">发射</h3><p>红外遥控是以调制方式发射数据，将数据调制到固定的载波上发送，调制发送抗干扰能力更强，传送距离也更远。常用的红外传输协议有很多，最常见的为NEC协议，红外遥控NEC传输协议采用<strong>脉冲位置调制(pulse distance encoding)</strong>，调制脉冲宽度不变，以发射红外载波的间隔时长代表“0”或“1”，每个脉冲的长度是560us，逻辑位定义如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231017122916998.png" /></p><p>编码过程：在红外输出口输出数据高电平期间，同时输出固定频率载波(一般是38kHz)，低电平期间则直接输出低。解码过程：红外接收头收到载波时输出高电平，没有载波时输出低电平，完成数据解码。</p><p>NEC协议格式如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231017122845611.png" /></p><p><strong>引导码:</strong> 由9ms的脉冲 + 4.5ms的低电平组成。</p><p><strong>4字节的数据:</strong> 8位地址码 + 8位地址反码 + 8位数据码 + 8位数据反码，反码用来校验数据是否传输正确。</p><p><u>记住</u>：一帧消息的末尾必须有一个560us的脉冲，以确定数据的最后一位。</p><p>当用户长时间按下遥控器按钮时，遥控器在发送一次指令码后，就不会再发送指令码了，而是周期性（110ms）发送一段数据码。这段数据码包含 <strong>9ms脉冲+2.25ms低电平+560us脉冲</strong>，如下图:</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231017123104556.png" /></p><h3 id="接收">接收</h3><p>红外接收常采用一体化红外接收头，集红外接收、放大、滤波、比较器输出等功能于一体，输出MCU可识别的TTL信号的。常用的一体化红外接收头有SCR638、HS0038、VS1838等，<strong><u>注意</u></strong>：有些红外接收头为了提高接收的灵敏度，输出的电平会跟正常解码的方式反相，即高低电平反转。</p><h3 id="编程思路">编程思路</h3><p>一般我们都是编写接收端（解码）程序，关于发送端（编码）程序，可参考：</p><p><a href="https://xiaolong.blog.csdn.net/article/details/118313109?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-118313109-blog-97166387.235%5Ev38%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-118313109-blog-97166387.235%5Ev38%5Epc_relevant_default_base&amp;utm_relevant_index=8">STM32入门开发: 制作红外线遥控器(智能居家-万能遥控器)_stm32遥控器程序怎么写-CSDN博客</a></p><p>解码程序的思路，一般是采用外部中断+定时器方式。在STM32中，可使用输入捕获方式，根据不同的条件下设置不同的捕获方式，记录每一段高低电平的持续时间，按照NEC协议进行判断，完成解码。可参考：</p><p><a href="https://xiaolong.blog.csdn.net/article/details/118281124">STM32入门开发: NEC红外线协议解码(超低成本无线传输方案)_nec32协议-CSDN博客</a></p><p><strong>参考链接：</strong></p><p><a href="https://www.sbprojects.net/knowledge/ir/nec.php">SB-Projects - IR - NEC Protocol (sbprojects.net)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;红外遥控（IR）一般由发射和接收两部分组成，发射元件为红外发射管（遥控器），接收一般采用一体化红外接收头，发射载波频率与接收头固定频率需一致才能正确接收数据。&lt;/p&gt;
&lt;h3 id=&quot;发射&quot;&gt;发射&lt;/h3&gt;
&lt;p&gt;红外遥控是以调制方式发射数据，将数据调制到固定的载波上发</summary>
      
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="NEC" scheme="http://example.com/tags/NEC/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xxx项目HAL文件概览</title>
    <link href="http://example.com/2023/10/08/stm32f1xxx%E9%A1%B9%E7%9B%AEHAL%E6%96%87%E4%BB%B6%E6%A6%82%E8%A7%88/"/>
    <id>http://example.com/2023/10/08/stm32f1xxx%E9%A1%B9%E7%9B%AEHAL%E6%96%87%E4%BB%B6%E6%A6%82%E8%A7%88/</id>
    <published>2023-10-08T07:11:36.000Z</published>
    <updated>2023-10-08T07:12:44.334Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cmsis">CMSIS</h3><ul><li><strong>stm32f1xx.h</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c">全局库文件的配置<span class="hljs-number">1.</span> 处理器芯片平台的选择及其头文件包含<span class="hljs-number">2.</span> CMSIS 版本<span class="hljs-number">3.</span> 平台共用宏：<span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BIT(REG, BIT)     ((REG) |= (BIT))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BIT(REG, BIT)   ((REG) &amp;= ~(BIT))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_BIT(REG, BIT)    ((REG) &amp; (BIT))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_REG(REG)        ((REG) = (0x0))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITE_REG(REG, VAL)   ((REG) = (VAL))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_REG(REG)         ((REG))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) &amp; (~(CLEARMASK))) | (SETMASK))) </span></code></pre></div><ul><li><strong>stm32f103xe.h</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c">stm32f103xe 芯片外设寄存器定义及位定义和内存映射<span class="hljs-number">1.</span> CMSIS的配置和中断号定义<span class="hljs-number">2.</span> 外设寄存器结构体的定义<span class="hljs-number">3.</span> 外设内存表及外设声明   <span class="hljs-comment">//如：#define GPIOA  ((GPIO_TypeDef *)GPIOA_BASE)</span><span class="hljs-number">4.</span> 外设寄存器位定义</code></pre></div><ul><li><strong>startup_stm32f103xe.s</strong></li></ul><div class="code-wrapper"><pre><code class="hljs armasm">针对MDK-<span class="hljs-meta">ARM</span>工具链STM32F103xE处理器的启动代码</code></pre></div><ul><li><strong>system_stm32f1xx.h/system_stm32f1xx.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c">系统初始化及时钟配置<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">SystemInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">SystemCoreClockUpdate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;</code></pre></div><h3 id="stm32f1xx_hal_driver">STM32F1xx_HAL_Driver</h3><ul><li><strong>stm32f1xx_hal.h/stm32f1xx_hal.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c">HAL库初始化及SysTick时钟相关项和Debug模式下各外设启用和禁用<span class="hljs-comment">/* Peripheral Control functions  ************************************************/</span>HAL_StatusTypeDef <span class="hljs-title function_">HAL_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;HAL_StatusTypeDef <span class="hljs-title function_">HAL_DeInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_MspInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_MspDeInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;HAL_StatusTypeDef <span class="hljs-title function_">HAL_InitTick</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> TickPriority)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_IncTick</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_Delay</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> Delay)</span>;<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">HAL_GetTick</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">HAL_GetTickPrio</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;HAL_StatusTypeDef <span class="hljs-title function_">HAL_SetTickFreq</span><span class="hljs-params">(HAL_TickFreqTypeDef Freq)</span>;HAL_TickFreqTypeDef <span class="hljs-title function_">HAL_GetTickFreq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_SuspendTick</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_ResumeTick</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;</code></pre></div><ul><li><strong>stm32f1xx_hal_cortex.h/stm32f1xx_hal_cortex.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1.</span> CORTEX M3 NVIC和SYSTICK相关项<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">HAL_NVIC_GetPriorityGrouping</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_NVIC_GetPriority</span><span class="hljs-params">(IRQn_Type IRQn, <span class="hljs-type">uint32_t</span> PriorityGroup, <span class="hljs-type">uint32_t</span>* pPreemptPriority, <span class="hljs-type">uint32_t</span>* pSubPriority)</span>;<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">HAL_NVIC_GetPendingIRQ</span><span class="hljs-params">(IRQn_Type IRQn)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_NVIC_SetPendingIRQ</span><span class="hljs-params">(IRQn_Type IRQn)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_NVIC_ClearPendingIRQ</span><span class="hljs-params">(IRQn_Type IRQn)</span>;<span class="hljs-type">uint32_t</span> <span class="hljs-title function_">HAL_NVIC_GetActive</span><span class="hljs-params">(IRQn_Type IRQn)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_SYSTICK_CLKSourceConfig</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> CLKSource)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_SYSTICK_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_SYSTICK_Callback</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-number">2.</span> MPU相关项</code></pre></div><ul><li><strong>stm32f1xx_hal_msp.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c">各外设与mcu相关项的初始化和复位，可在main.h中声明<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_MspInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></code></pre></div><ul><li><strong>stm32f1xx_hal_conf.h </strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1.</span> 外设使能宏，不使用的外设，注释掉。<span class="hljs-number">2.</span> HAL System配置、回调使能配置。<span class="hljs-number">3.</span> Ethernet配置<span class="hljs-number">4.</span> HAL库头文件的配置<span class="hljs-number">5.</span> assert_param 断言宏的配置<span class="hljs-meta">#<span class="hljs-keyword">define</span>  VDD_VALUE           3300U <span class="hljs-comment">/*!&lt; Value of VDD in mv */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  TICK_INT_PRIORITY   15U <span class="hljs-comment">/*!&lt; tick interrupt priority (lowest by default)  */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  USE_RTOS            0U</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  PREFETCH_ENABLE     1U</span></code></pre></div><ul><li><strong>stm32f1xx_it.h/stm32f1xx_it.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs">中断和异常处理函数</code></pre></div><ul><li><strong>stm32f1xx_hal_def.h</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1.</span> HAL库共用项<span class="hljs-meta">#<span class="hljs-keyword">define</span> HAL_MAX_DELAY      0xFFFFFFFFU</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HAL_IS_BIT_SET(REG, BIT)         (((REG) &amp; (BIT)) != 0U)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> HAL_IS_BIT_CLR(REG, BIT)         (((REG) &amp; (BIT)) == 0U)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)               \</span><span class="hljs-meta">                        do&#123;                                                      \</span><span class="hljs-meta">                              (__HANDLE__)-&gt;__PPP_DMA_FIELD__ = &amp;(__DMA_HANDLE__); \</span><span class="hljs-meta">                              (__DMA_HANDLE__).Parent = (__HANDLE__);             \</span><span class="hljs-meta">                          &#125; while(0U)</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(UNUSED)    #<span class="hljs-keyword">define</span> UNUSED(X) (void)X  <span class="hljs-comment">/* To avoid gcc/g++ warnings */</span></span><span class="hljs-number">2.</span> 编译器配置项</code></pre></div><ul><li><strong>stm32f1xx_hal_gpio.h/stm32f1xx_hal_gpio.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">gpio</span> hal库操作函数</code></pre></div><ul><li><strong>stm32f1xx_ll_gpio.h/stm32f1xx_ll_gpio.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">gpio</span> ll库寄存器操作函数</code></pre></div><ul><li><strong>main.h/main.c</strong></li></ul><div class="code-wrapper"><pre><code class="hljs">主程序，及共用项定义头文件</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;cmsis&quot;&gt;CMSIS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stm32f1xx.h&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs c&quot;&gt;全局库文件的配置
</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
  </entry>
  
  <entry>
    <title>解决Microsoft Edge浏览器关于“根据热门内容向你推荐”的问题</title>
    <link href="http://example.com/2023/10/07/%E8%A7%A3%E5%86%B3Microsoft-Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E4%BA%8E%E2%80%9C%E6%A0%B9%E6%8D%AE%E7%83%AD%E9%97%A8%E5%86%85%E5%AE%B9%E5%90%91%E4%BD%A0%E6%8E%A8%E8%8D%90%E2%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/10/07/%E8%A7%A3%E5%86%B3Microsoft-Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E4%BA%8E%E2%80%9C%E6%A0%B9%E6%8D%AE%E7%83%AD%E9%97%A8%E5%86%85%E5%AE%B9%E5%90%91%E4%BD%A0%E6%8E%A8%E8%8D%90%E2%80%9D%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-10-07T05:32:42.000Z</published>
    <updated>2023-10-07T06:43:43.429Z</updated>
    
    <content type="html"><![CDATA[<p>在使用微软的Edge浏览器搜索时，当我们点开某个页面后，它会自动在原网页弹出推荐的内容，如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231007135553301.png" alt="image-20231007135553301" style="zoom:80%;" /></p><p>通常情况下，它占用了屏幕大部分空间，且弹出的内容好多并无作用，浪费了浏览时间。在浏览器的设置中，并没有这个设置项。因为这个是点击所触发的情况，所以可以利用广告拦截的方式进行处理，具体操作如下：</p><ol type="1"><li>在浏览器扩展应用商店中搜索“<strong>广告拦截</strong>”,安装一个广告拦截器插件（我这里选择 AdGuard）:</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231007141805618.png" alt="image-20231007141805618" style="zoom:80%;" /></p><ol start="2" type="1"><li>安装完插件后，在搜索页面 <strong>鼠标右键 =&gt; AdGuard广告拦截器 =&gt; 拦截此网站上的广告</strong> ，选择搜索页面弹出的推荐外框，点击拦截即可。</li></ol><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231007143227303.png" alt="" /><figcaption>image-20231007143227303</figcaption></figure><p>这样设置后，就不会再弹出推荐的内容了，完美解决。</p><p><strong>参考：</strong></p><p><a href="https://blog.csdn.net/qq_42920270/article/details/128224356">拦截Edge的“根据热门内容向您推荐”_buding0716的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用微软的Edge浏览器搜索时，当我们点开某个页面后，它会自动在原网页弹出推荐的内容，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-2023100</summary>
      
    
    
    
    <category term="其它" scheme="http://example.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="Edge" scheme="http://example.com/tags/Edge/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中内存管理(HeapMemory)</title>
    <link href="http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(HeapMemory)/"/>
    <id>http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(HeapMemory)/</id>
    <published>2023-10-06T13:58:26.000Z</published>
    <updated>2023-10-13T06:53:06.029Z</updated>
    
    <content type="html"><![CDATA[<p>FreeRTOS在每次创建内核对象时分配内存，在每次删除内核对象时释放RAM。此策略减少了设计和规划工作，简化了API，并最大限度地减少了内存占用。</p><p>可以使用标准C库malloc()和free()函数分配内存，但有时它们可能不适用，因为：</p><ul><li><p>在小型嵌入式系统上并不总是可用的。</p></li><li><p>函数实现比较复杂，占用了宝贵的代码空间。</p></li><li><p>并非都是安全线程。</p></li><li><p>运行时间不确定，执行函数所花费的时间因调用而异。</p></li><li><p>内存碎片化。</p></li><li><p>使用不同的编译器时，需要进行复杂的配置。</p></li><li><p>为其他变量使用的堆内存扩展，则可能出现难以调试的错误。</p></li></ul><p>早期版本的FreeRTOS使用内存池分配方案，即在编译时预先分配不同大小的内存块池，然后由内存分配函数返回。因为它不能有效地使用RAM，使其只在非常小的嵌入式系统中可行，因此该方案被放弃了。</p><p>FreeRTOS提供了<code>pvPortMalloc()</code>和<code>vPortFree()</code>内存管理函数，它们具有与标准C库<code>malloc()</code>和<code>free()</code>函数相同的原型。FreeRTOS 提供了五种堆管理方案，其复杂性和功能各不相同，源码分别在<code>heap_1.c、heap_2.c、heap_3.c、heap_4.c、heap_5.c</code>源文件中，它们都位于<code>FreeRTOS/ source /portable/MemMang</code>目录中。</p><p>每次一个项目中，只应包含其中一个源文件，这些可移植层函数定义的堆将由 RTOS 内核使用。</p><p>它们的区别主要是：</p><ul><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00111.html#heap_1">heap_1</a> —— 最简单，不允许释放内存。</li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00111.html#heap_2">heap_2</a> —— 允许释放内存，但不会合并相邻的空闲块。</li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00111.html#heap_3">heap_3</a> —— 简单包装了标准 malloc() 和 free()，以保证线程安全。</li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00111.html#heap_4">heap_4</a> —— 合并相邻的空闲块以避免碎片化，包含绝对地址放置选项。</li><li><a href="https://www.freertos.org/zh-cn-cmn-s/a00111.html#heap_5">heap_5</a> —— 如同 heap_4，能够跨越多个不相邻内存区域的堆。</li></ul><p><strong>注意</strong>：</p><ul><li><strong>heap_1 不太有用，因为 FreeRTOS 添加了静态分配支持。</strong></li><li><strong>heap_2 现在被视为旧版，较新的 heap_4 实现是首选。</strong></li></ul><h2 id="heap_1">Heap_1</h2><p><code>heap_1.c</code> 实现了 <code>pvPortMalloc()</code>的一个非常基本的版本，并且没有实现<code>vPortFree()</code>。所以内存一经分配，就不允许释放。尽管如此，它还是适用于大量嵌入式应用程序，这是因为许多小型和深度嵌入的应用程序在系统启动时创建了所需的所有任务、队列、信号量等，并在程序的生命周期内使用所有这些对象（直到应用程序再次关闭或重新启动）。</p><p>当调用<code>pvPortMalloc()</code>时，heap_1分配方案将一个单一数组细分为更小的块，这个数组被称为堆，堆内存空间的总量通过配置文件宏： <strong>configTOTAL_HEAP_SIZE</strong> 设置，堆内存地址设置通过配置文件宏： <strong>configAPPLICATION_ALLOCATED_HEAP</strong> 设置。每个创建的任务需要从堆中分配一个任务控制块(<strong>TCB</strong>)和一个堆栈。</p><p>堆内存空间的总量通过配置文件宏： <strong>configTOTAL_HEAP_SIZE</strong> 设置。 堆内存地址设置通过配置文件宏： <strong>configAPPLICATION_ALLOCATED_HEAP</strong> 设置。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231013133023140.png" alt="" /><figcaption>image-20231013133023140</figcaption></figure><p>Heap_1实现：</p><ul><li>如果您的应用程序不删除任务、队列、信号量、互斥锁等，则可以使用。</li><li>始终具有确定性（总是需要相同的时间来执行）， 不会导致内存碎片化。</li><li>非常简单，且从静态分配的数组分配内存，这意味着它通常适合用于不允许真实动态内存分配的应用程序 。</li></ul><h2 id="heap_2">Heap_2</h2><p><code>heap_2.c</code> 使用最佳匹配算法来分配内存，允许释放内存。最佳匹配算法确保<code>pvPortMalloc()</code>使用大小最接近请求字节数的空闲内存块。Heap_2不会将相邻的空闲块合并，因此它更容易出现碎片。但是，如果分配和随后释放的内存块大小总是相同，那么就不会有碎片问题。</p><p>堆内存空间的总量通过配置文件宏： <strong>configTOTAL_HEAP_SIZE</strong> 设置。 堆内存地址设置通过配置文件宏： <strong>configAPPLICATION_ALLOCATED_HEAP</strong> 设置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231013141830263.png" /></p><p>Heap_2实现：</p><ul><li><p>适用于应用程序重复创建和删除任务、队列、信号量、互斥锁等，前提是分配给已创建任务的堆栈大小不变。</p></li><li><p>如果您应用程序的队列、任务、信号量、互斥锁等的顺序不可预测，可能会导致内存碎片化。</p></li><li><p>非确定性，但比malloc()和free()的大多数标准库实现要快。</p></li></ul><h2 id="heap_3">Heap_3</h2><p><code>heap_3.c</code>使用标准库 <code>malloc()</code>和<code>free()</code>函数，因此堆的大小由链接器配置，需要编译器库提供 <code>malloc()</code> 和 <code>free()</code> 实现,宏 <strong>configTOTAL_HEAP_SIZE</strong> 不起作用。Heap_3通过暂时挂起FreeRTOS调度器使malloc()和free()线程安全。</p><h2 id="heap_4">Heap_4</h2><p><code>heap_4.c</code> 是当前使用最多的方式，它使用第一拟合和内存合并算法,将相邻的空闲块合并(合并)成一个更大的块，从而最大限度地降低了碎片的风险，并使其适用于重复分配和释放不同大小的RAM块的应用程序。</p><p>堆内存空间的总量通过配置文件宏： <strong>configTOTAL_HEAP_SIZE</strong> 设置。 堆内存地址设置通过配置文件宏： <strong>configAPPLICATION_ALLOCATED_HEAP</strong> 设置。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231013142636425.png" alt="" /><figcaption>image-20231013142636425</figcaption></figure><p>heap_4实现：</p><ul><li>适用于应用程序重复创建和删除任务、队列、信号量、互斥锁等情况。</li><li>非确定性，但比malloc()和free()的大多数标准库实现要快。</li></ul><h2 id="heap_5">Heap_5</h2><p><code>heap_5.c</code>用于分配和释放内存的算法与heap_4使用的算法相同，允许堆跨越多个不相邻内存区域，但它并不局限于从单个静态声明的数组中分配内存，而是从多个独立的内存空间中分配内存。</p><p>创建 RTOS 对象（任务、队列、信号量等）将调用 <code>pvPortMalloc()</code>，heap_5必须在调用<code>pvPortMalloc()</code>之前显式初始化，即使用<code>vPortDefineHeapRegions()</code> API函数初始化。</p><p>heap_5实现：</p><p>当运行FreeRTOS的系统提供的内存在系统内存映射中不是单个连续块。</p><h1 id="heap相关api函数">Heap相关API函数</h1><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 分配内存 */</span><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( </span><span class="hljs-params">  <span class="hljs-type">size_t</span> xWantedSize <span class="hljs-comment">/* 分配的内存大小 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 释放内存 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( </span><span class="hljs-params">  <span class="hljs-type">void</span> * pv <span class="hljs-comment">/* 待释放的内存指针 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 获取堆内存大小 */</span><span class="hljs-type">size_t</span> <span class="hljs-title function_">xPortGetFreeHeapSize</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<span class="hljs-comment">/* 获取空闲内存容量的最小值 */</span><span class="hljs-type">size_t</span> <span class="hljs-title function_">xPortGetMinimumEverFreeHeapSize</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<span class="hljs-comment">/* 内存分配失败钩子 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">vApplicationMallocFailedHook</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;FreeRTOS在每次创建内核对象时分配内存，在每次删除内核对象时释放RAM。此策略减少了设计和规划工作，简化了API，并最大限度地减少了内存占用。&lt;/p&gt;
&lt;p&gt;可以使用标准C库malloc()和free()函数分配内存，但有时它们可能不适用，因为：&lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    <category term="RTOS" scheme="http://example.com/categories/RTOS/"/>
    
    
    <category term="RAM" scheme="http://example.com/tags/RAM/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中互斥量(Mutexes)</title>
    <link href="http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E4%BA%92%E6%96%A5%E9%87%8F(Mutexes)/"/>
    <id>http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E4%BA%92%E6%96%A5%E9%87%8F(Mutexes)/</id>
    <published>2023-10-06T13:50:32.000Z</published>
    <updated>2023-10-12T14:35:09.248Z</updated>
    
    <content type="html"><![CDATA[<p>互斥是一种特殊的二进制信号量，用于控制对两个或多个任务之间共享资源的访问。要使用它，需在配置文件中设置 <code>configUSE_MUTEXES</code> 为1。</p><p>用于互斥时，互斥锁就像用于保护资源的令牌。当访问资源时，必须首先获取 ('token') 令牌，使用资源后，必须“返回”令牌，这样其他任务就有机会访问此共享资源。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/mutexes.gif" alt="" /><figcaption>img</figcaption></figure><h1 id="互斥优先级反转">互斥优先级反转</h1><p>高优先级的任务必须等待低优先级的任务放弃对互斥锁的控制，这种方式的延迟，称为“优先级反转”。如果中等优先级任务开始执行，而高优先级任务正在等待信号量，这会导致高优先级任务等待低优先级任务，而低优先级任务甚至无法执行。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231012203208837.png" alt="" /><figcaption>image-20231012203208837</figcaption></figure><p>优先级反转显然是一个严重的问题，但在小型嵌入式系统中，通过考虑如何访问资源，通常可以在系统设计时避免这个问题。</p><h1 id="互斥优先级继承">互斥优先级继承</h1><p>与二进制信号量不同的是互斥锁包含基本的“优先级继承”机制，优先级继承是一种将优先级反转的负面影响降至最低的方案。它并没有“修复”优先级反转，只是通过确保总是有时间限制反转来减少其影响。然而优先级继承使系统时序分析复杂化，并且依赖它来进行正确的系统操作并不是一个好的实践。</p><p>优先级继承的工作原理是临时将互斥锁持有者的优先级提高到最高优先级。持有互斥锁的低优先级任务“继承”等待互斥锁任务的优先级。当互斥锁返回时，互斥锁持有者的优先级自动重置为其原始值。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231012204245838.png" alt="" /><figcaption>image-20231012204245838</figcaption></figure><p>不应在中断中使用互斥锁，因为：</p><ul><li>互斥锁使用的优先级继承机制要求从任务中（而不是从中断中）拿走和放入互斥锁。</li><li>中断无法保持阻塞来等待一个被互斥锁保护的资源 由互斥锁保护的资源变为可用。</li></ul><h1 id="死锁">死锁</h1><p>“死锁”是使用互斥锁进行互斥的另一个潜在陷阱，当两个任务都在等待由另一个任务持有的资源而无法运行时，就会发生死锁。假设任务A和任务B都需要互斥锁X和互斥锁Y来完成操作：</p><ul><li>任务A执行并成功获取互斥锁X</li><li>任务B抢占任务A</li><li>任务B成功地获取了互斥锁Y，在尝试获取互斥锁X，但被任务A持有，所以任务B选择进入阻塞态等待互斥锁X的释放。</li><li>任务A继续运行，它尝试获取互斥锁Y，但被任务B持有，任务A选择进入阻塞态等待互斥锁Y的释放。</li></ul><p>这个场景的最后，任务A等待任务B持有的互斥锁，任务B也在等待任务A持有的互斥锁，这两个任务都无法运行，所以发生死锁。</p><p>与优先级反转一样，避免死锁的最佳方法是设计系统避免发生死锁。让任务无限等待(没有超时)来获取互斥锁通常是不好的做法，相反，使用比期望等待互斥锁的最大时间稍长一点的超时时间，在此时间内未能获得互斥锁将是错误设计的征兆（死锁）。</p><p>在实践中，死锁在小型嵌入式系统中不是一个大问题，因为系统设计人员可以很好地理解整个应用程序，能够辨别和移除发生死锁的区域。</p><h1 id="递归互斥锁">递归互斥锁</h1><p>任务本身也可能发生死锁，如果一个任务多次尝试使用同一个互斥锁，而没有首先返还互斥锁，就会发生这种情况。假设如下场景：</p><ol type="1"><li>一个任务成功获取互斥锁。</li><li>持有互斥锁的同时调用库函数。</li><li>库函数尝试获取同一个互斥锁，然后进入阻塞态等待互斥锁可用。</li></ol><p>在此场景结束时，任务处于阻塞状态等待互斥锁返回，但任务已是互斥锁的持有者。因为任务处于阻塞状态等待自己，所以发生自锁。</p><p>使用递归互斥锁替代标准互斥锁可避免这种死锁。一个递归互斥锁可以被同一个任务多次“获取”，仅在每次调用递归互斥锁时，执行“给予”递归互斥锁调用后返回。</p><p>标准互斥锁和递归互斥锁以类似的方式创建和使用：</p><table><thead><tr class="header"><th>功能</th><th>标准互斥锁</th><th>递归互斥锁</th></tr></thead><tbody><tr class="odd"><td>创建</td><td>xSemaphoreCreateMutex()</td><td>xSemaphoreCreateRecursiveMutex()</td></tr><tr class="even"><td>获取</td><td>xSemaphoreTake()</td><td>xSemaphoreTakeRecursive()</td></tr><tr class="odd"><td>给出</td><td>xSemaphoreGive()</td><td>xSemaphoreGiveRecursive()</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;互斥是一种特殊的二进制信号量，用于控制对两个或多个任务之间共享资源的访问。要使用它，需在配置文件中设置 &lt;code&gt;configUSE_MUTEXES&lt;/code&gt; 为1。&lt;/p&gt;
&lt;p&gt;用于互斥时，互斥锁就像用于保护资源的令牌。当访问资源时，必须首先获取 (&#39;token</summary>
      
    
    
    
    <category term="RTOS" scheme="http://example.com/categories/RTOS/"/>
    
    
    <category term="Mutexes" scheme="http://example.com/tags/Mutexes/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中中断(Interrupt)</title>
    <link href="http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E4%B8%AD%E6%96%AD-Interrupt/"/>
    <id>http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E4%B8%AD%E6%96%AD-Interrupt/</id>
    <published>2023-10-06T13:47:57.000Z</published>
    <updated>2023-10-12T09:15:52.610Z</updated>
    
    <content type="html"><![CDATA[<p>在 RTOS 中，需要应对各类事件。在每种情况下，必须对最佳事件处理实现策略做出判断：</p><ul><li>怎么检测事件的发生？通常使用中断，但也可以是轮询输入。</li><li>当使用中断时，中断服务程序中内外各需要执行多少操作？一般让中断服务程序尽可能的短。</li><li>事件怎么和main函数通信，如何构建此代码以最好地适应可能的异步事件的发生？</li></ul><p>区分任务的优先级和中断的优先级是很重要的：</p><ul><li>任务是FreeRTOS运行的软件特性，跟硬件无关，任务的优先级通过程序员指定，在运行的状态，由调度器决定执行哪个任务。</li><li>尽管中断服务程序是通过软件写的，但它是一个硬件特性，因为中断服务程序在运行时，是由硬件控制运行的，只有当无ISR时，任务才会运行，最低优先级的中断会中断最高优先级的任务，任务无法抢占ISR，</li></ul><h1 id="isr中api函数">ISR中API函数</h1><p>很多 API 函数会导致任务进入阻塞状态，因此，FreeRTOS提供了两套API函数，一套在任务中使用，另一套在ISR中使用。<strong>注意</strong>：在FreeRTOS的ISR程序中，要调用后缀名为 <strong>FromISR</strong> 的API函数。</p><table style="width:100%;"><thead><tr class="header"><th>类型</th><th>在任务中</th><th>在ISR中</th></tr></thead><tbody><tr class="odd"><td>队列(Queue)</td><td>xQueueSendToBack()<br>xQueueSendToFront()<br>xQueueReceive()<br>xQueueOverwrite()<br>xQueuePeek()</td><td>xQueueSendToBackFromISR()<br>xQueueSendToFrontFromISR()<br>xQueueReceiveFromISR()<br>xQueueOverwriteFromISR()<br>xQueuePeekFromISR()</td></tr><tr class="even"><td>信号量(Semaphore)</td><td>xSemaphoreGive()<br>xSemaphoreTake()</td><td>xSemaphoreGiveFromISR()<br>xSemaphoreTakeFromISR()</td></tr><tr class="odd"><td>事件组(EventGroups)</td><td>xEventGroupSetBits()<br>xEventGroupGetBits()</td><td>xEventGroupSetBitsFromISR()<br>xEventGroupGetBitsFromISR()</td></tr><tr class="even"><td>任务通知(TaskNotification)</td><td>xTaskNotifyGive()<br>xTaskNotify()</td><td>vTaskNotifyGiveFromISR()<br>xTaskNotifyFromISR()</td></tr><tr class="odd"><td>软件定时器(SoftwareTimer)</td><td>xTimerStart()<br>xTimerStop()<br>xTimerReset()<br>xTimerChangePeriod()</td><td>xTimerStartFromISR()<br>xTimerStopFromISR()<br>xTimerResetFromISR()<br>xTimerChangePeriodFromISR()</td></tr></tbody></table><h3 id="两套api函数的优点">两套API函数的<strong>优点</strong>：</h3><ul><li>API函数不需要额外的逻辑判断是从任务中调用，还是从ISR中调用，额外的逻辑判断会让函数更长，更复杂，也更难测试。</li><li>在任务或ISR 中调用时，需要的参数不一样，不会导致参数无效。</li><li>不用每个FreeRTOS移植程序都提供一种机制来确定上下文的执行。</li><li>很容易确定执行的上下文体系，容易使用。</li></ul><p>使用两套函数可以让程序更高效，但是也有一些缺点，比如你要使用第三方库函数时，即会在任务中调用它，也会在ISR调用它。这个第三方库函数用到了FreeRTOS的API函数，你无法修改库函数。要解决这个问题，可通过以下方法：</p><ul><li>把中断的处理推迟到任务中执行，API函数只从任务的上下文中调用。</li><li>如果是支持中断嵌套的FreeRTOS移植，使用“FromISR”那一套API函数。</li><li>第三方代码一般会包含RTOS抽象层，用来测试调用函数（任务或ISR）的上下文，分别调用对应的函数。</li></ul><h3 id="xhigherprioritytaskwoken参数">xHigherPriorityTaskWoken参数</h3><p>如果中断执行上下文切换，那么在中断退出与进入时运行的任务可能不同——中断将中断一个任务，但返回到另一个任务。</p><p>一些FreeRTOS API函数可以将任务从阻塞态移到就绪态。如在<code>xQueueSendToBack()</code>函数中，如果有任务处于阻塞状态来等待当前队列上有可用的数据，则该函数将解除任务的阻塞。如果解除阻塞的任务优先级高于当前处于运行态的任务，那么根据FreeRTOS的调度策略，会切换到优先级更高的任务。切换到高优先级任务取决于调用的API函数的上下文：</p><ul><li>在任务中调用</li></ul><p>配置文件中<code>configUSE_PREEMPTION</code> 配置为1，自动切换到更高优先级任务</p><ul><li>在中断中调用</li></ul><p>设置 <code>*pxHigherPriorityTaskWoken</code> 为 <code>pdTRUE</code>,就可以切换到高优先级任务,第一次使用时要初始化为<code>pdFALSE</code>.</p><h3 id="portyield_from_isr宏">portYIELD_FROM_ISR()宏</h3><p>这个宏用于在中断中请求上下文切换，老版本中还有个汇编形式的宏：<code>portEND_SWITCHING_ISR()</code>。</p><div class="code-wrapper"><pre><code class="hljs c">portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</code></pre></div><p>如果<code>xHigherPriorityTaskWoken</code> 为<code>pdFALSE</code>,则表示不请求上下文切换，宏无作用，如果为<code>pdTRUE</code>,则表示请求上下文切换，处于运行态的任务将会改变。中断始终返回到处于运行态的任务，即使中断执行时处于运行态的任务发生了改变。</p><h1 id="isr的延迟处理">ISR的延迟处理</h1><p>在实践中，尽可能的让ISR程序简短些，因为：</p><ul><li>尽管任务被分配一个高的优先级，它们只会在硬件不提供中断服务的情况下运行。</li><li>ISR可中断任务的起始时间和执行时间。</li><li>取决于运行FreeRTOS的架构平台，一个ISR执行时不可能再接收新的中断。</li><li>程序员需要同时考虑和防护一个任务或ISR访问的变量，外设和内存缓冲等资源的后果。</li><li>一些FreeRTOS端口允许中断嵌套，但这会增加复杂性并降低可预测性。中断越短，嵌套的可能性就越小。</li></ul><p>ISR必须记录中断的原因，并清除中断。中断所需的任何其他操作通常可以在任务中执行，从而使ISR能够尽快退出，这被称为“延迟中断处理”，因为中断所需的处理从ISR“延迟”到任务。</p><p>如果中断处理延迟到的任务的优先级高于任何其他任务的优先级，那么处理将立即执行，就像在ISR本身中执行处理一样。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231012165252137.png" alt="" /><figcaption>image-20231012165252137</figcaption></figure><p>中断延迟处理在以下情况会比较有用：</p><ul><li>中断所需的处理不是微不足道的。例如，如果中断只是存储ADC转换的结果，这最好在ISR内执行，但如果转换的结果通过软件滤波器，那么最好在任务中执行滤波器的操作。</li><li>中断处理可以方便地执行不能在ISR中执行的操作，例如向控制台写操作或分配内存。</li><li>中断处理是不确定的，这意味着不能预先知道处理将花费多长时间。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 RTOS 中，需要应对各类事件。在每种情况下，必须对最佳事件处理实现策略做出判断：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;怎么检测事件的发生？通常使用中断，但也可以是轮询输入。&lt;/li&gt;
&lt;li&gt;当使用中断时，中断服务程序中内外各需要执行多少操作？一般让中断服务程序尽可能的短</summary>
      
    
    
    
    <category term="RTOS" scheme="http://example.com/categories/RTOS/"/>
    
    
    <category term="Interrupt" scheme="http://example.com/tags/Interrupt/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中事件组(EventGroups)</title>
    <link href="http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%BB%84(EventGroups)/"/>
    <id>http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%BB%84(EventGroups)/</id>
    <published>2023-10-06T13:46:34.000Z</published>
    <updated>2023-10-12T01:55:11.158Z</updated>
    
    <content type="html"><![CDATA[<p>事件组是FreeRTOS的一大特点，它允许任务间的事件传输。它跟队列和信号量的不同之处是：</p><ul><li>事件组允许任务在阻塞状态下等待一个或多个事件的组合发生。</li><li>当事件发生时，事件组将解除在等待同一事件或事件组合的所有任务的阻塞。</li></ul><p>事件组的这些特性使得它们可以同步多个任务，将事件广播到多个任务，允许任务在阻塞状态下等待事件组中的任何一事件发生，以及允许任务在阻塞状态下等待多个操作的完成。</p><p>事件组减少了内存占用，因为通常可以用单个事件组替换多个互斥信号量。事件组功能是可选项，要使用事件组功能，在工程中需要包含<code>event_groups.c</code>文件。</p><h1 id="事件组特性">事件组特性</h1><ul><li><strong>事件组、事件标志和事件控制位</strong></li></ul><p>事件标志就是一个布尔值（0或1）用来表示事件是否发生，事件组就是一个事件标志的集合。事件标志将事件标志的状态存储在单个bit位中，并将事件组中所有事件标志的状态存储在单个变量中。事件组每个事件标志的状态通过数据类型 <code>EventBits_t</code> 中的一个bit位来表示，如果这个bit位设置为1，代表事件发生，如果设置为0，代表事件没有发生。举例如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231012091104517.png" alt="" /><figcaption>image-20231012091104517</figcaption></figure><p>如果配置文件中 <code>configUSE_16_BIT_TICKS</code> 设置为1, 则每个事件组包含8个可用的bit位，如果设置为0,则包含24个可用的bit位。</p><ul><li><strong>事件组可被多个任务访问</strong></li></ul><p>事件组本身就是一个对象，可被任何知道其存在的任务或中断访问，同一个事件组可被任意一个任务访问。</p><h1 id="事件组api函数">事件组API函数</h1><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 动态创建事件组 */</span>EventGroupHandle_t <span class="hljs-title function_">xEventGroupCreate</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<span class="hljs-comment">/* 静态方法创建事件组 */</span>EventGroupHandle_t <span class="hljs-title function_">xEventGroupCreateStatic</span><span class="hljs-params">( </span><span class="hljs-params">  StaticEventGroup_t * pxEventGroupBuffer <span class="hljs-comment">/* 事件组缓存区指针 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 设置事件组中事件 */</span>EventBits_t <span class="hljs-title function_">xEventGroupSetBits</span><span class="hljs-params">( </span><span class="hljs-params">  EventGroupHandle_t xEventGroup,<span class="hljs-comment">/* 事件组句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">const</span> EventBits_t uxBitsToSet <span class="hljs-comment">/* 设置的bit位 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 中断模式下设置事件组中事件 */</span>BaseType_t <span class="hljs-title function_">xEventGroupSetBitsFromISR</span><span class="hljs-params">(</span><span class="hljs-params">  EventGroupHandle_t xEventGroup，<span class="hljs-comment">/* 事件组句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">const</span> EventBits_t uxBitsToSet，<span class="hljs-comment">/* 设置的bit位 */</span></span><span class="hljs-params">  BaseType_t*pxHigherPriorityTaskWoken<span class="hljs-comment">/* 唤醒高优先级任务 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 等待事件的到来 */</span>EventBits_t <span class="hljs-title function_">xEventGroupWaitBits</span><span class="hljs-params">( </span><span class="hljs-params">  <span class="hljs-type">const</span> EventGroupHandle_t xEventGroup,<span class="hljs-comment">/* 事件组句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">const</span> EventBits_t uxBitsToWaitFor,<span class="hljs-comment">/* 等待的事件bit位 */</span></span><span class="hljs-params">  <span class="hljs-type">const</span> BaseType_t xClearOnExit,<span class="hljs-comment">/* 函数退出时清除事件bit位 */</span></span><span class="hljs-params">  <span class="hljs-type">const</span> BaseType_t xWaitForAllBits,<span class="hljs-comment">/* 等待的事件位 */</span></span><span class="hljs-params">  TickType_t xTicksToWait <span class="hljs-comment">/* 阻塞态等待的时间 */</span></span><span class="hljs-params">)</span>;</code></pre></div><h1 id="任务同步">任务同步</h1><p>有时任务间需要同步，如：任务A接收一个事件，然后将该事件所需的一些处理委托给其他三个任务：任务B，任务C和任务D，如果任务A直到任务B、C和D都完成了前一个事件的处理才能接收另一个事件，那么这四个任务就需要彼此同步。每个任务的同步点就在这个任务完成其处理过程之后，除非其他任务都完成了相同的操作，否则无法继续执行。当四个任务都达到了它们的同步点，任务A才能接收另一个事件。</p><p>事件组可以用来创建任务的同步点：</p><ul><li><strong>必须参与同步的每个任务在事件组中被分配唯一的一个事件位。</strong></li><li><strong>每个任务在到达同步点时设置自己的事件位。</strong></li><li><strong>设置好事件位之后，每个任务在事件组中处于阻塞状态，等待其它代表同步任务的事件位也设置好</strong></li></ul><p>这种情形下就不能使用<code>xEventGroupSetBits()</code> 和 <code>xEventGroupWaitBits()</code> API 函数，而要使用 <code>xEventGroupSync()</code>函数。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 使用事件组进行任务间同步 */</span>EventBits_t <span class="hljs-title function_">xEventGroupSync</span><span class="hljs-params">( </span><span class="hljs-params">  EventGroupHandle_t xEventGroup, <span class="hljs-comment">/* 事件组句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">const</span> EventBits_t uxBitsToSet,<span class="hljs-comment">/* 设置的bit位 */</span></span><span class="hljs-params">  <span class="hljs-type">const</span> EventBits_t uxBitsToWaitFor,<span class="hljs-comment">/* 等待的事件bit位 */</span></span><span class="hljs-params">  TickType_t xTicksToWait<span class="hljs-comment">/* 阻塞态下等待的时间 */</span></span><span class="hljs-params">)</span>;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;事件组是FreeRTOS的一大特点，它允许任务间的事件传输。它跟队列和信号量的不同之处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件组允许任务在阻塞状态下等待一个或多个事件的组合发生。&lt;/li&gt;
&lt;li&gt;当事件发生时，事件组将解除在等待同一事件或事件组合的所有任务的阻塞。&lt;/l</summary>
      
    
    
    
    <category term="RTOS" scheme="http://example.com/categories/RTOS/"/>
    
    
    <category term="EventGroups" scheme="http://example.com/tags/EventGroups/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中软件定时器(SoftwareTimer)</title>
    <link href="http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8(SoftwareTimer)/"/>
    <id>http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8(SoftwareTimer)/</id>
    <published>2023-10-06T13:45:35.000Z</published>
    <updated>2023-10-12T03:33:04.387Z</updated>
    
    <content type="html"><![CDATA[<p>在FreeRTOS中，软件定时器由内核支配，不需要硬件支持，和硬件定时器无关，要使用软件定时器，需要在配置文件中设置<code>configUSE_TIMERS</code> 为 1。</p><h1 id="软件定时器特性">软件定时器特性</h1><ul><li>回调函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ATimerCallback</span><span class="hljs-params">(TimerHandle_t xTimer)</span>;</code></pre></div><p>回调函数尽可能短，一定不要进入阻塞状态。</p><ul><li>定时周期</li></ul><p>定时器启动到执行定时器回调函数之间的时间。</p><ul><li>定时器类型：一次性定时器和自动加载定时器</li><li>定时器的状态：休眠态(Dormant)和运行态(Running)</li></ul><h1 id="软件定时器的上下文">软件定时器的上下文</h1><ul><li><strong>RTOS的后台守护任务（Daemon Task）</strong></li></ul><p>所有软件定时器的回调函数都在同一个RTOS守护任务（定时器服务）的上下文中执行。</p><p>守护任务是一个标准的FreeRTOS任务，在调度器开启后自动创建，它的优先级和栈大小在配置文件中配置：<code>configTIMER_TASK_PRIORITY</code> 和 <code>configTIMER_TASK_STACK_DEPTH</code> 来设置。</p><p>软件定时器回调函数一定不能调用FreeRTOS API函数，这会导致任务进入阻塞状态，即导致守护任务进入阻塞态。</p><ul><li><strong>定时器指令队列</strong></li></ul><p>软件定时器API函数从调用任务到守护任务发送指令的队列称为 <strong>定时器指令队列</strong> 。它也是在调度器开启后自动创建，它的长度在配置文件中配置：<code>configTIMER_QUEUE_LENGTH</code>。</p><ul><li><strong>守护任务调度</strong></li></ul><p>守护任务的调度跟其它任务的调度一样，不同的是，当它运行时处于最高优先级，它仅仅执行命令，或执行定时器回调函数。举例如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231012105004755.png" alt="" /><figcaption>image-20231012105004755</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231012110049342.png" alt="" /><figcaption>image-20231012110049342</figcaption></figure><h1 id="软件定时器的创建和启动api函数">软件定时器的创建和启动API函数</h1><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 创建软件定时器 */</span>TimerHandle_t <span class="hljs-title function_">xTimerCreate</span><span class="hljs-params">(</span><span class="hljs-params">  <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcTimerName, <span class="hljs-comment">/* 软件定时器名 */</span></span><span class="hljs-params">  TickType_t xTimerPeriodInTicks,<span class="hljs-comment">/* 定时周期（ticks） */</span></span><span class="hljs-params">  UBaseType_t uxAutoReload,<span class="hljs-comment">/* 是否自动重装载 */</span></span><span class="hljs-params">  <span class="hljs-type">void</span> * pvTimerID,<span class="hljs-comment">/* 定时器ID */</span></span><span class="hljs-params">  TimerCallbackFunction_t pxCallbackFunction <span class="hljs-comment">/* 定时器回调函数 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 启动定时器 */</span>BaseType_t <span class="hljs-title function_">xTimerStart</span><span class="hljs-params">(</span><span class="hljs-params">  TimerHandle_t xTimer, <span class="hljs-comment">/* 定时器句柄 */</span></span><span class="hljs-params">  TickType_t xTicksToWait <span class="hljs-comment">/* 阻塞时间 */</span></span><span class="hljs-params">)</span>;</code></pre></div><h1 id="软件定时器id">软件定时器ID</h1><p>每一个软件定时器都有一个ID，<strong>void*</strong> 类型，当创建定时器时，会指派一个定时器ID的初始值，可以通过<code>vTimerSetTimerID（）</code> 函数更新ID值，通过<code>pvTimerGetTimerID（）</code> 获取ID值，跟其它软件定时器的API函数不同的是，这两个函数直接访问定时器而不需要通过定时器命令队列传送命令。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 设置定时器ID */</span><span class="hljs-type">void</span> <span class="hljs-title function_">vTimerSetTimerID</span><span class="hljs-params">( </span><span class="hljs-params">  <span class="hljs-type">const</span> TimerHandle_t xTimer, <span class="hljs-comment">/* 定时器句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">void</span> *pvNewID <span class="hljs-comment">/* 定时器新的ID */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 获取定时器ID */</span><span class="hljs-type">void</span> *<span class="hljs-title function_">pvTimerGetTimerID</span><span class="hljs-params">( </span><span class="hljs-params">  TimerHandle_t xTimer <span class="hljs-comment">/* 定时器句柄 */</span></span><span class="hljs-params">)</span>;</code></pre></div><h1 id="软件定时器其它api函数">软件定时器其它API函数</h1><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 改变定时器定时周期值 */</span>BaseType_t <span class="hljs-title function_">xTimerChangePeriod</span><span class="hljs-params">(</span><span class="hljs-params">  TimerHandle_t xTime,<span class="hljs-comment">/* 定时器句柄 */</span></span><span class="hljs-params">  TickType_t x NewTimerPeriodInTicks,<span class="hljs-comment">/* 新的定时周期 */</span></span><span class="hljs-params">  TickType <span class="hljs-type">_t</span> xTicksToWait<span class="hljs-comment">/* 阻塞态下等待的时长 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 中断模式下改变定时器定时周期值 */</span>BaseType_t <span class="hljs-title function_">xTimerChangePeriodFromISR</span><span class="hljs-params">( </span><span class="hljs-params">  TimerHandle_t xTimer,<span class="hljs-comment">/* 定时器句柄 */</span></span><span class="hljs-params">  TickType_t xNewPeriod,<span class="hljs-comment">/* 新的定时周期 */</span></span><span class="hljs-params">  BaseType_t *pxHigherPriorityTaskWoken <span class="hljs-comment">/* 唤醒高优先级任务 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 定时器复位 */</span>BaseType_t <span class="hljs-title function_">xTimerReset</span><span class="hljs-params">( </span><span class="hljs-params">  TimerHandle_t xTimer, <span class="hljs-comment">/* 定时器句柄 */</span></span><span class="hljs-params">  TickType_t xTicksToWait<span class="hljs-comment">/* 阻塞态下等待的时长 */</span></span><span class="hljs-params">)</span>;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在FreeRTOS中，软件定时器由内核支配，不需要硬件支持，和硬件定时器无关，要使用软件定时器，需要在配置文件中设置&lt;code&gt;configUSE_TIMERS&lt;/code&gt; 为 1。&lt;/p&gt;
&lt;h1 id=&quot;软件定时器特性&quot;&gt;软件定时器特性&lt;/h1&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="RTOS" scheme="http://example.com/categories/RTOS/"/>
    
    
    <category term="Timer" scheme="http://example.com/tags/Timer/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中任务通知(TaskNotifications)</title>
    <link href="http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5(TaskNotifications)/"/>
    <id>http://example.com/2023/10/06/FreeRTOS%E4%B8%AD%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5(TaskNotifications)/</id>
    <published>2023-10-06T13:45:01.000Z</published>
    <updated>2023-10-11T11:22:56.823Z</updated>
    
    <content type="html"><![CDATA[<p>在RTOS中，任务间的通信，可使用队列、信号量、事件组等方法，但这种方式需要通过中间媒介来完成，如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231011181422415.png" alt="image-20231011181422415" style="zoom:80%;" /></p><p>还有另一种直接通信的方式：<strong>任务通知</strong>，不需要中间的媒介对象，任务间直接通信，如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231011181508166.png" alt="image-20231011181508166" style="zoom:80%;" /></p><p>使用这种方式需要在配置文件(FreeRTOSConfig.h)中设置 <code>configUSE_TASK_NOTIFICATIONS = 1</code> 。</p><h1 id="任务通知的优势与劣势">任务通知的优势与劣势</h1><h3 id="优势">优势</h3><ul><li><p><strong>速度快</strong>：使用任务通知将事件或数据发送到任务要比使用队列、信号量、事件组快得多。</p></li><li><p><strong>内存占用小</strong>：相比于要创建通信媒介对象，每个任务的任务通知只占用固定的 8 Bytes。</p></li></ul><h3 id="劣势">劣势</h3><ul><li><p>不能发送事件或数据到中断。</p></li><li><p>不能有多个接收任务。</p></li><li><p>不能缓存数据项</p></li><li><p>不能广播到多个任务。</p></li><li><p>在阻塞状态下不能等待发送完成。</p></li></ul><h1 id="任务通知的api函数">任务通知的API函数</h1><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 发出通知(轻量版) */</span>BaseType_t <span class="hljs-title function_">xTaskNotifyGive</span><span class="hljs-params">( </span><span class="hljs-params">  TaskHandle_t xTaskToNotify <span class="hljs-comment">/* 发送通知的任务句柄 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 中断模式下发出通知(轻量版) */</span><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskNotifyGiveFromISR</span><span class="hljs-params">( </span><span class="hljs-params">  TaskHandle_t xTaskToNotify,<span class="hljs-comment">/* 发送通知的任务句柄 */</span></span><span class="hljs-params">  BaseType_t *pxHigherPriorityTaskWoken <span class="hljs-comment">/* 唤醒高优先级任务 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 读取通知(轻量版) */</span><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ulTaskNotifyTake</span><span class="hljs-params">( </span><span class="hljs-params">  BaseType_t xClearCountOnExit, <span class="hljs-comment">/* pdTRUE or pdFALSE 任务通知值的变化 */</span></span><span class="hljs-params">  TickType_t xTicksToWait <span class="hljs-comment">/* 任务在阻塞态下等待的最长时间 */</span></span><span class="hljs-params">)</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 发出通知(高级版) */</span>BaseType_t <span class="hljs-title function_">xTaskNotify</span><span class="hljs-params">( </span><span class="hljs-params">  TaskHandle_t xTaskToNotify,<span class="hljs-comment">/* 发送通知的任务句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">uint32_t</span> ulValue,<span class="hljs-comment">/* 通知的值 */</span></span><span class="hljs-params">  eNotifyAction eAction <span class="hljs-comment">/* 枚举，更新任务的通知值 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 中断模式下发出通知(高级版) */</span>BaseType_t <span class="hljs-title function_">xTaskNotifyFromISR</span><span class="hljs-params">( </span><span class="hljs-params">  TaskHandle_t xTaskToNotify,<span class="hljs-comment">/* 发送通知的任务句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">uint32_t</span> ulValue,<span class="hljs-comment">/* 通知的值 */</span></span><span class="hljs-params">  eNotifyAction eAction,<span class="hljs-comment">/* 枚举，更新任务的通知值 */</span></span><span class="hljs-params">  BaseType_t *pxHigherPriorityTaskWoken <span class="hljs-comment">/* 唤醒高优先级任务 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 读取通知(高级版) */</span>BaseType_t <span class="hljs-title function_">xTaskNotifyWait</span><span class="hljs-params">( </span><span class="hljs-params">  <span class="hljs-type">uint32_t</span> ulBitsToClearOnEntry,<span class="hljs-comment">/* 位设置，在任务检查前清除不是挂起或阻塞态的任务通知 */</span></span><span class="hljs-params">  <span class="hljs-type">uint32_t</span> ulBitsToClearOnExit,<span class="hljs-comment">/* 位设置，在函数退出前，传递通知值 */</span></span><span class="hljs-params">  <span class="hljs-type">uint32_t</span> *pulNotificationValue,<span class="hljs-comment">/* 用来传递任务的通知值 */</span></span><span class="hljs-params">  TickType_t xTicksToWait<span class="hljs-comment">/* 任务在阻塞态下等待的最长时间 */</span></span><span class="hljs-params">)</span>;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在RTOS中，任务间的通信，可使用队列、信号量、事件组等方法，但这种方式需要通过中间媒介来完成，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231</summary>
      
    
    
    
    <category term="RTOS" scheme="http://example.com/categories/RTOS/"/>
    
    
    <category term="Notification" scheme="http://example.com/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中信号量(Semaphore)</title>
    <link href="http://example.com/2023/10/05/FreeRTOS%E4%B8%AD%E4%BF%A1%E5%8F%B7%E9%87%8F(Semaphore)/"/>
    <id>http://example.com/2023/10/05/FreeRTOS%E4%B8%AD%E4%BF%A1%E5%8F%B7%E9%87%8F(Semaphore)/</id>
    <published>2023-10-05T13:47:08.000Z</published>
    <updated>2023-10-12T11:28:13.604Z</updated>
    
    <content type="html"><![CDATA[<p>任务间数据传输可用队列，消息队列用于传输多个数据，但有时候我们只需传递状态，这个状态用一个 数值表示，此时使用信号量效率更高、更节省内存。</p><p>在FreeRTOS中，信号量有二进制信号量和计数信号量。下面分别来看看这两种信号量。</p><h1 id="二进制信号量">二进制信号量</h1><p>二进制信号量用于互斥和同步目的，信号量 API 函数允许指定阻塞时间。</p><p>可将二进制信号量视为仅能容纳一个项目的队列。 因此，队列只能为空或满（因此称为二进制）。使用队列的任务和中断不在乎队列的内容，只在乎队列是空的还是满的。</p><p>轮询外围设备将会耗费 CPU 资源，阻止执行其他任务。 因此最好将大部分任务时间耗在阻塞状态（允许其他任务执行），仅在需要时再执行。 可以使用二进制信号量来实现同步任务与中断，“获取”信号量时使任务阻塞。 中断总是“给出”信号量（写入队列使其变满） ，但从不接收信号量，任务总是“接收”信号量（从队列中读取信号以使队列变空），但从不“给出”信号量。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/binary-semaphore.gif" alt="" /><figcaption>img</figcaption></figure><h1 id="计数信号量">计数信号量</h1><p>正如二进制信号量可以被认为是长度为 1 的队列那样，计数信号量也可以被认为是长度大于 1 的队列。</p><p>计数信号量通常用于两种情况：</p><ul><li><strong>计数事件</strong></li></ul><p>每次事件发生时，事件处理程序将“给出”一个信号量（信号量计数值递增），每次任务处理事件时，将“获取”一个信号量（信号量计数值递减）。计数值是已发生的事件数与已处理的事件数之间的差值。用来计数事件的计数信号量创建时初始为0。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231012185552265.png" alt="" /><figcaption>image-20231012185552265</figcaption></figure><ul><li><strong>资源管理</strong></li></ul><p>计数值表示可用资源的数量。要获得对资源的控制权，任务必须首先获取一个信号量（信号量计数值递减），当计数值为零时，表示没有空闲资源可用。当任务使用完资源时，“发回”一个信号量（信号量计数值递增）。用来管理资源的信号量值创建的初始值等于可用的资源数量。</p><h1 id="信号量api函数">信号量API函数</h1><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 动态创建二进制信号量 */</span>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateBinary</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<span class="hljs-comment">/* 静态创建二进制信号量 */</span>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateBinaryStatic</span><span class="hljs-params">( </span><span class="hljs-params">  StaticSemaphore_t *pxSemaphoreBuffer <span class="hljs-comment">/* 信号量缓存指针 */</span> </span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 动态创建计数信号量 */</span>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateCounting</span><span class="hljs-params">( </span><span class="hljs-params">  UBaseType_t uxMaxCount,<span class="hljs-comment">/* 最大计数值 */</span></span><span class="hljs-params">UBaseType_t uxInitialCount <span class="hljs-comment">/* 计数值初始值 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 静态创建计数信号量 */</span>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateCountingStatic</span><span class="hljs-params">( </span><span class="hljs-params">  UBaseType_t uxMaxCount,<span class="hljs-comment">/* 最大计数值 */</span></span><span class="hljs-params">UBaseType_t uxInitialCount <span class="hljs-comment">/* 计数值初始值 */</span></span><span class="hljs-params">  StaticSemaphore_t *pxSemaphoreBuffer <span class="hljs-comment">/* 信号量缓存指针 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 获取信号量 */</span>BaseType_t <span class="hljs-title function_">xSemaphoreTake</span><span class="hljs-params">( </span><span class="hljs-params">  SemaphoreHandle_t xSemaphore, <span class="hljs-comment">/* 信号量句柄 */</span></span><span class="hljs-params">  TickType_t xTicksToWait <span class="hljs-comment">/* 阻塞时间 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 中断模式下获取信号量 */</span>BaseType_t <span class="hljs-title function_">xSemaphoreTakeFromISR</span><span class="hljs-params">(</span><span class="hljs-params">  SemaphoreHandle_t xSemaphore,<span class="hljs-comment">/* 信号量句柄 */</span></span><span class="hljs-params">  BaseType_t *pxHigherPriorityTaskWoken<span class="hljs-comment">/* 唤醒高优先级任务 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 给出一个信号量 */</span>BaseType_t <span class="hljs-title function_">xSemaphoreGive</span><span class="hljs-params">( </span><span class="hljs-params">  SemaphoreHandle_t xSemaphore <span class="hljs-comment">/* 信号量句柄 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 中断模式下给出一个信号量 */</span>BaseType_t <span class="hljs-title function_">xSemaphoreGiveFromISR</span><span class="hljs-params">( </span><span class="hljs-params">  SemaphoreHandle_t xSemaphore,<span class="hljs-comment">/* 信号量句柄 */</span></span><span class="hljs-params">BaseType_t *pxHigherPriorityTaskWoken <span class="hljs-comment">/* 唤醒高优先级任务 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 删除信号量 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">vSemaphoreDelete</span><span class="hljs-params">( </span><span class="hljs-params">  SemaphoreHandle_t xSemaphore <span class="hljs-comment">/* 信号量句柄 */</span></span><span class="hljs-params">)</span>;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务间数据传输可用队列，消息队列用于传输多个数据，但有时候我们只需传递状态，这个状态用一个 数值表示，此时使用信号量效率更高、更节省内存。&lt;/p&gt;
&lt;p&gt;在FreeRTOS中，信号量有二进制信号量和计数信号量。下面分别来看看这两种信号量。&lt;/p&gt;
&lt;h1 id=&quot;二进制</summary>
      
    
    
    
    <category term="RTOS" scheme="http://example.com/categories/RTOS/"/>
    
    
    <category term="Semaphore" scheme="http://example.com/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中队列(Queue)</title>
    <link href="http://example.com/2023/10/05/FreeRTOS%E4%B8%AD%E9%98%9F%E5%88%97(Queue)/"/>
    <id>http://example.com/2023/10/05/FreeRTOS%E4%B8%AD%E9%98%9F%E5%88%97(Queue)/</id>
    <published>2023-10-05T13:46:36.000Z</published>
    <updated>2023-10-11T10:02:02.656Z</updated>
    
    <content type="html"><![CDATA[<p>在Free RTOS中，队列是任务间通信的主要形式。它们可以用于在任务之间、中断和任务之间发送消息。下面来看看队列的相关内容。</p><h1 id="队列特性">队列特性</h1><ol type="1"><li><strong>数据存储（Data Storage）</strong></li></ol><p>队列通常用作先进先出（FIFO）缓冲区，其中数据被写入队列的末尾（尾部），并从队列的前端（头部）移除。队列可以容纳有限数量（长度）的固定大小的数据项。每个数据项的长度和大小都是在创建队列时设置的。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/queue_animation.gif" alt="" /><figcaption>img</figcaption></figure><p>上图展示创建的队列可容纳5个项目，Task A向队列中写入数据，Task B从队列中读取数据，队列中数据被读取后就会被删除，头部就会指向下一个数据。</p><p>队列中数据传输有两种方式：</p><ul><li><strong>拷贝</strong>：把数据、把变量的值复制进队列里</li><li><strong>引用</strong>：把数据、把变量的地址复制进队列里</li></ul><p>在FreeRTOS中，使用的是拷贝方式进行队列数据传输，这是因为：</p><ul><li>局部变量的值可直接送入队列，后续即使函数退出、局部变量被回收，也不会影响队列中的数据</li><li>无需分配缓冲区来保存数据，队列中有 buffer</li><li>局部变量可以立即再次使用</li><li>发送任务、接收任务解耦：不用关心哪个任务有数据，哪个任务释放数据</li><li>如果数据实在太大，你还是可以使用队列传输它的地址</li><li>FreeRTOS 负责分配队列的数据存储空间</li><li>在内存保护系统中，任务可访问的内存将受到限制。在这种情况下，只有当发送和接收任务都可以访问存储数据的内存时，才能使用队列应用。而队列拷贝并没有这种限制，内核有足够权限，允许使用队列跨内存保护边界传递数据。</li></ul><ol start="2" type="1"><li><strong>可被多个任务访问 （Access by Multiple Tasks）</strong></li></ol><p>只要知道队列的句柄，任何任务或中断就能访问该队列，多个任务可以对同一个队列进行读写操作。多个任务对同一个队列写操作的情况很常见，但多个任务对同一个队列读操作的情况很少见。</p><ol start="3" type="1"><li><strong>队列阻塞（Blocking on Queues）</strong></li></ol><p>当任务从队列中读操作时，可以指定阻塞时间。当队列为空，则任务进入阻塞状态，一旦队列中有数据，该任务会自动进入就绪态。如果阻塞时间超时，则任务也会进入就绪态。多个任务可对一个队列读操作，因此多个任务会对一个队列阻塞等待数据的到来，这种情况下，当数据到来时，只有一个任务会处于非阻塞态，且该任务具有最高优先级。如果所有阻塞态的任务具有相同的优先级，则等待数据时间最长的任务退出阻塞态。</p><p>同理，当任务从队列中写操作时，也可以指定阻塞时间。这个阻塞时间是指如果队列已满，任务保持在阻塞态以等待队列上有可用空间的最长时间。多个任务可对一个队列写操作，因此多个任务会对一个满队列阻塞等待数据的发送，在这种情况下，当队列上有可用空间，只有一个任务处于非阻塞态，且该任务具有最高优先级。如果所有阻塞态的任务具有相同的优先级，则等待空间最长时间的任务将退出阻塞态。</p><h1 id="队列常用api函数">队列常用API函数</h1><p>Free RTOS中，队列的常用API函数有：</p><ul><li><strong>创建队列</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c">QueueHandle_t <span class="hljs-title function_">xQueueCreate</span><span class="hljs-params">( </span><span class="hljs-params">  UBaseType_t uxQueueLength, <span class="hljs-comment">/* 队列长度 */</span></span><span class="hljs-params">  UBaseType_t uxItemSize      <span class="hljs-comment">/* 每个队列项的数据大小 */</span></span><span class="hljs-params">                   )</span>;QueueHandle_t <span class="hljs-title function_">xQueueCreateStatic</span><span class="hljs-params">(</span><span class="hljs-params">  UBaseType_t uxQueueLength, <span class="hljs-comment">/* 队列长度 */</span></span><span class="hljs-params">  UBaseType_t uxItemSize, <span class="hljs-comment">/* 每个队列项的数据大小 */</span></span><span class="hljs-params">  <span class="hljs-type">uint8_t</span> *pucQueueStorageBuffer, <span class="hljs-comment">/* uint8_t[uxQueueLength *                                                       uxItemsSize ] */</span></span><span class="hljs-params">  StaticQueue_t *pxQueueBuffer<span class="hljs-comment">/* 队列数据缓冲区 */</span></span><span class="hljs-params">  )</span>;</code></pre></div><ul><li><strong>发送数据</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 常规方式 */</span>BaseType_t <span class="hljs-title function_">xQueueSendToFront</span><span class="hljs-params">( </span><span class="hljs-params">  QueueHandle_t xQueue, <span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params">                      <span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue, <span class="hljs-comment">/* 数据指针 */</span></span><span class="hljs-params">                      TickType_t xTicksToWait  <span class="hljs-comment">/* 阻塞态的最大时间(TickCount) */</span></span><span class="hljs-params">                     )</span>;BaseType_t <span class="hljs-title function_">xQueueSendToBack</span><span class="hljs-params">( </span><span class="hljs-params">  QueueHandle_t xQueue, <span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params">                      <span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue, <span class="hljs-comment">/* 数据指针 */</span></span><span class="hljs-params">                      TickType_t xTicksToWait  <span class="hljs-comment">/* 阻塞态的最大时间(TickCount) */</span></span><span class="hljs-params">                     )</span>;<span class="hljs-comment">/* 中断方式 */</span>BaseType_t <span class="hljs-title function_">xQueueSendToFrontFromISR</span><span class="hljs-params">(</span><span class="hljs-params"> QueueHandle_t xQueue, <span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue, <span class="hljs-comment">/* 数据指针 */</span></span><span class="hljs-params"> BaseType_t *pxHigherPriorityTaskWoken <span class="hljs-comment">/* 是否唤醒其它任务的指针 */</span></span><span class="hljs-params">  )</span>;BaseType_t <span class="hljs-title function_">xQueueSendToBackFromISR</span><span class="hljs-params">(</span><span class="hljs-params"> QueueHandle_t xQueue,<span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue, <span class="hljs-comment">/* 数据指针 */</span></span><span class="hljs-params"> BaseType_t *pxHigherPriorityTaskWoken<span class="hljs-comment">/* 是否唤醒其它任务的指针 */</span></span><span class="hljs-params">  )</span>;<span class="hljs-comment">/* 单个数据的队列 */</span>BaseType_t <span class="hljs-title function_">xQueueOverwrite</span><span class="hljs-params">(</span><span class="hljs-params">  QueueHandle_t xQueue, <span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue <span class="hljs-comment">/* 数据指针 */</span></span><span class="hljs-params"> )</span>;BaseType_t <span class="hljs-title function_">xQueueOverwriteFromISR</span><span class="hljs-params">(</span><span class="hljs-params">  QueueHandle_t xQueue,<span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue,<span class="hljs-comment">/* 数据指针 */</span></span><span class="hljs-params">  BaseType_t *pxHigherPriorityTaskWoken <span class="hljs-comment">/* 是否唤醒其它任务的指针 */</span></span><span class="hljs-params"> )</span>;</code></pre></div><ul><li><strong>接收数据</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 成功接收数据后，数据从队列删除 */</span>BaseType_t <span class="hljs-title function_">xQueueReceive</span><span class="hljs-params">( </span><span class="hljs-params">                  QueueHandle_t xQueue,<span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params">                  <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer,<span class="hljs-comment">/* 数据指针 */</span></span><span class="hljs-params">                  TickType_t xTicksToWait <span class="hljs-comment">/* 阻塞态的最大时间(TickCount) */</span></span><span class="hljs-params">                )</span>;BaseType_t <span class="hljs-title function_">xQueueReceiveFromISR</span><span class="hljs-params">( </span><span class="hljs-params">                QueueHandle_t xQueue, <span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params">                <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer, <span class="hljs-comment">/* 数据指针 */</span></span><span class="hljs-params">                BaseType_t * <span class="hljs-type">const</span> pxHigherPriorityTaskWoken <span class="hljs-comment">/* 是否唤醒其它任务的指针 */</span> </span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 成功接收数据后，数据不从队列删除 */</span>BaseType_t <span class="hljs-title function_">xQueuePeek</span><span class="hljs-params">(</span><span class="hljs-params"> QueueHandle_t xQueue,<span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params"> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer, <span class="hljs-comment">/* 数据指针 */</span></span><span class="hljs-params"> TickType_t xTicksToWait <span class="hljs-comment">/* 阻塞态的最大时间(TickCount) */</span></span><span class="hljs-params"> )</span>;BaseType_t <span class="hljs-title function_">xQueuePeekFromISR</span><span class="hljs-params">(</span><span class="hljs-params">QueueHandle_t xQueue,<span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params"><span class="hljs-type">void</span> *pvBuffer,<span class="hljs-comment">/* 数据指针 */</span></span><span class="hljs-params">)</span>;</code></pre></div><ul><li><strong>删除队列、复位队列及其它</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vQueueDelete</span><span class="hljs-params">( QueueHandle_t xQueue )</span>;<span class="hljs-comment">/* 队列删除 */</span>BaseType_t <span class="hljs-title function_">xQueueReset</span><span class="hljs-params">( xQueue )</span>;<span class="hljs-comment">/* 队列复位 */</span>UBaseType_t <span class="hljs-title function_">uxQueueMessagesWaiting</span><span class="hljs-params">( <span class="hljs-type">const</span> QueueHandle_t xQueue )</span>;<span class="hljs-comment">/* 队列中的数据个数 */</span>UBaseType_t <span class="hljs-title function_">uxQueueMessagesWaitingFromISR</span><span class="hljs-params">( <span class="hljs-type">const</span> QueueHandle_t xQueue )</span>;<span class="hljs-comment">/* 中断队列中的数据个数 */</span>UBaseType_t <span class="hljs-title function_">uxQueueSpacesAvailable</span><span class="hljs-params">( <span class="hljs-type">const</span> QueueHandle_t xQueue )</span>;<span class="hljs-comment">/* 队列可用的空间 */</span></code></pre></div><p>通过队列阻塞接收数据示例代码：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* sender function */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vSenderTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span>&#123;  <span class="hljs-type">int32_t</span> lValueToSend;  BaseType_t xStatus;  lValueToSend = ( <span class="hljs-type">int32_t</span> ) pvParameters;<span class="hljs-comment">/* 通过任务参数传递数据 */</span>  <span class="hljs-keyword">for</span>( ;; )  &#123;    xStatus = xQueueSendToBack( xQueue, &amp;lValueToSend, <span class="hljs-number">0</span> );    <span class="hljs-keyword">if</span>( xStatus != pdPASS )    &#123;    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Could not send to the queue.\r\n&quot;</span> );    &#125;  &#125;&#125;<span class="hljs-comment">/* reveiver function with blocking */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vReceiverTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span>&#123;  <span class="hljs-type">int32_t</span> lReceivedValue;  BaseType_t xStatus;  <span class="hljs-type">const</span> TickType_t xTicksToWait = pdMS_TO_TICKS( <span class="hljs-number">100</span> ); <span class="hljs-comment">/* 转换ms到tick*/</span>  <span class="hljs-keyword">for</span>( ;; )  &#123;    <span class="hljs-keyword">if</span>( uxQueueMessagesWaiting( xQueue ) != <span class="hljs-number">0</span> )    &#123;    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Queue should have been empty!\r\n&quot;</span> );    &#125;    xStatus = xQueueReceive( xQueue, &amp;lReceivedValue, xTicksToWait );    <span class="hljs-keyword">if</span>( xStatus == pdPASS )    &#123;    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Received = &quot;</span>, lReceivedValue );    &#125;    <span class="hljs-keyword">else</span>    &#123;    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Could not receive from the queue.\r\n&quot;</span> );    &#125;  &#125;&#125;<span class="hljs-comment">/* main function */</span>QueueHandle_t xQueue;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>&#123;  <span class="hljs-comment">/* 创建一个队列 */</span>  xQueue = xQueueCreate( <span class="hljs-number">5</span>, <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">int32_t</span> ) );  <span class="hljs-keyword">if</span>( xQueue != <span class="hljs-literal">NULL</span> )  &#123;    <span class="hljs-comment">/* 创建两个发送任务和一个接收任务，接收优先级更高 */</span>    xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender1&quot;</span>, <span class="hljs-number">1000</span>, ( <span class="hljs-type">void</span> * ) <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span> );    xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender2&quot;</span>, <span class="hljs-number">1000</span>, ( <span class="hljs-type">void</span> * ) <span class="hljs-number">200</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span> );    xTaskCreate( vReceiverTask, <span class="hljs-string">&quot;Receiver&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span> );    vTaskStartScheduler(); <span class="hljs-comment">/* 启动任务调度器 */</span>  &#125;  <span class="hljs-keyword">for</span>( ;; );&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231009173229604.png" alt="" /><figcaption>image-20231009173229604</figcaption></figure><h1 id="接收多任务数据-multiple-sources">接收多任务数据 Multiple Sources</h1><p>通过队列阻塞发送结构体数据，示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><span class="hljs-class">&#123;</span>  eSender1,  eSender2&#125; DataSource_t;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-type">uint8_t</span> ucValue;  DataSource_t eDataSource;&#125; Data_t;<span class="hljs-comment">/* 声明一个结构体变量数组 */</span><span class="hljs-type">static</span> <span class="hljs-type">const</span> Data_t xStructsToSend[ <span class="hljs-number">2</span> ] =&#123;  &#123; <span class="hljs-number">100</span>, eSender1 &#125;, <span class="hljs-comment">/* Used by Sender1. */</span>  &#123; <span class="hljs-number">200</span>, eSender2 &#125; <span class="hljs-comment">/* Used by Sender2. */</span>&#125;;<span class="hljs-comment">/* sender function */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vSenderTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span>&#123;  BaseType_t xStatus;  <span class="hljs-type">const</span> TickType_t xTicksToWait = pdMS_TO_TICKS( <span class="hljs-number">100</span> );  <span class="hljs-keyword">for</span>( ;; )  &#123;    xStatus = xQueueSendToBack( xQueue, pvParameters, xTicksToWait );    <span class="hljs-keyword">if</span>( xStatus != pdPASS )    &#123;    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Could not send to the queue.\r\n&quot;</span> );    &#125;  &#125;&#125;<span class="hljs-comment">/* receiver function */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vReceiverTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span>&#123;  Data_t xReceivedStructure;  BaseType_t xStatus;  <span class="hljs-keyword">for</span>( ;; )  &#123;    <span class="hljs-keyword">if</span>( uxQueueMessagesWaiting( xQueue ) != <span class="hljs-number">3</span> )    &#123;    pintf( <span class="hljs-string">&quot;Queue should have been full!\r\n&quot;</span> );    &#125;    xStatus = xQueueReceive( xQueue, &amp;xReceivedStructure, <span class="hljs-number">0</span> );    <span class="hljs-keyword">if</span>( xStatus == pdPASS )    &#123;      <span class="hljs-keyword">if</span>( xReceivedStructure.eDataSource == eSender1 )      &#123;        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;From Sender 1 = &quot;</span>, xReceivedStructure.ucValue );      &#125;      <span class="hljs-keyword">else</span>      &#123;        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;From Sender 2 = &quot;</span>, xReceivedStructure.ucValue );      &#125;    &#125;    <span class="hljs-keyword">else</span>    &#123;      <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Could not receive from the queue.\r\n&quot;</span> );    &#125;  &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>&#123;  <span class="hljs-comment">/* 创建一个队列 */</span>  xQueue = xQueueCreate( <span class="hljs-number">3</span>, <span class="hljs-keyword">sizeof</span>( Data_t ) );  <span class="hljs-keyword">if</span>( xQueue != <span class="hljs-literal">NULL</span> )  &#123;    <span class="hljs-comment">/* 创建三个任务 */</span>    xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender1&quot;</span>, <span class="hljs-number">1000</span>, &amp;( xStructsToSend[ <span class="hljs-number">0</span> ] ), <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span> );    xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender2&quot;</span>, <span class="hljs-number">1000</span>, &amp;( xStructsToSend[ <span class="hljs-number">1</span> ] ), <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span> );    xTaskCreate( vReceiverTask, <span class="hljs-string">&quot;Receiver&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span> );    vTaskStartScheduler();  &#125;  <span class="hljs-keyword">for</span>( ;; );&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231009165541823.png" alt="" /><figcaption>image-20231009165541823</figcaption></figure><h1 id="传输大量数据">传输大量数据</h1><p>使用队列可以发送不同类型的数据和不同长度的数据，当队列传输数据量较大时，使用数据指针传输更有效，使用时需要注意：</p><ul><li><strong>被指向的内存要明确定义。</strong></li></ul><p>当任务间通过指针共享内存时，需要保证两个任务不能同时修改内存内容，或其它导致内存的内容出错的动作。理想的情况下，在写队列之前只能由发送任务访问这块内存，在读队列之后只能由接收任务访问这块内存。</p><ul><li><strong>被指向的内存要有效</strong></li></ul><p>如果被指向的内存是动态分配的或从预分配缓冲池中分配的，那么就必须有个任务要去释放内存，释放后的内存，是不能访问的。</p><p>不要使用任务栈上分配的指针访问数据，因为栈改变后，数据就会无效。</p><h1 id="从多个队列接收数据">从多个队列接收数据</h1><p>前面展示了使用单个接收结构体的队列任务接收不同大小、不同含义和不同来源的数据。但有时限制的条件下，需要使用单独的队列来传输某些数据源。例如，将第三方代码集成到设计中就要用专用队列，这时“队列集”就派上用场了。</p><p><strong>队列集</strong> 允许任务从多个队列中接收数据，而无需依次轮询以确定哪个队列包含数据。</p><p>使用队列集从多个来源接收数据的设计，与使用单个接收结构体队列来实现同样功能的设计相比，会不整洁，效率也更低，建议仅在约束条件时需要使用到队列集的设计才使用队列集。</p><p>队列集中使用的函数主要有：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 创建队列集 */</span>QueueSetHandle_t <span class="hljs-title function_">xQueueCreateSet</span><span class="hljs-params">( </span><span class="hljs-params">  <span class="hljs-type">const</span> UBaseType_t uxEventQueueLength <span class="hljs-comment">/* 队列集中队列句柄的数目 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 把队列或信号量添加到队列集中 */</span>BaseType_t <span class="hljs-title function_">xQueueAddToSet</span><span class="hljs-params">( </span><span class="hljs-params">  QueueSetMemberHandle_t xQueueOrSemaphore, <span class="hljs-comment">/* 被添加的队列或信号量句柄 */</span></span><span class="hljs-params">  QueueSetHandle_t xQueueSet <span class="hljs-comment">/* 队列集句柄 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 读取队列集中队列句柄 */</span>QueueSetMemberHandle_t <span class="hljs-title function_">xQueueSelectFromSet</span><span class="hljs-params">( </span><span class="hljs-params">  QueueSetHandle_t xQueueSet, <span class="hljs-comment">/* 被读取的队列集句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">const</span> TickType_t xTicksToWait <span class="hljs-comment">/* 阻塞的最大等待时间 */</span></span><span class="hljs-params">)</span>;  <span class="hljs-comment">/* 中断方式读取队列集中队列句柄 */</span>QueueSetMemberHandle_t <span class="hljs-title function_">xQueueSelectFromSetFromISR</span><span class="hljs-params">( </span><span class="hljs-params">  QueueSetHandle_t xQueueSet <span class="hljs-comment">/* 被读取的队列集句柄 */</span></span><span class="hljs-params">)</span>;</code></pre></div><h1 id="使用队列创建邮箱">使用队列创建邮箱</h1><p>不同的RTOS，邮箱指的是不同的事物，这里指 <strong>长度为1的队列</strong>。</p><p>队列用于将数据从一个任务发送到另一个任务，或从中断中发送到一个任务。发送方将一个项目放入队列，接收方从队列中删除该项目，这样数据通过队列就从发送方传递到接收方了。</p><p>邮箱用于保存由任何任务或任何中断读取的数据。数据一直保留在邮箱中，直到被覆盖。发送方重写邮箱中的值。接收方从邮箱中读取该值，但不会删除它。</p><p>邮箱API函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 发送一个数据项到邮箱 */</span>BaseType_t <span class="hljs-title function_">xQueueOverwrite</span><span class="hljs-params">(</span><span class="hljs-params">QueueHandle_t xQueue, <span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue <span class="hljs-comment">/* 被发送数据项的指针 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 中断模式下，发送一个数据项到邮箱 */</span>BaseType_t <span class="hljs-title function_">xQueueOverwriteFromISR</span><span class="hljs-params">(</span><span class="hljs-params">  QueueHandle_t xQueue,<span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue,<span class="hljs-comment">/* 被发送数据项的指针 */</span></span><span class="hljs-params">  BaseType_t *pxHigherPriorityTaskWoken <span class="hljs-comment">/* 唤醒高优先级任务 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 从邮箱中读取一个数据项 */</span>BaseType_t <span class="hljs-title function_">xQueuePeek</span><span class="hljs-params">(</span><span class="hljs-params">  QueueHandle_t xQueue,<span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer,<span class="hljs-comment">/* 被读取数据项的缓存指针 */</span></span><span class="hljs-params">  TickType_t xTicksToWait<span class="hljs-comment">/* 任务阻塞等待的最长时间 */</span></span><span class="hljs-params">)</span>;<span class="hljs-comment">/* 中断模式下，从邮箱中读取一个数据项 */</span>BaseType_t <span class="hljs-title function_">xQueuePeekFromISR</span><span class="hljs-params">(</span><span class="hljs-params">  QueueHandle_t xQueue,<span class="hljs-comment">/* 队列句柄 */</span></span><span class="hljs-params">  <span class="hljs-type">void</span> *pvBuffer,<span class="hljs-comment">/* 被读取数据项的缓存指针 */</span></span><span class="hljs-params">)</span>;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Free RTOS中，队列是任务间通信的主要形式。它们可以用于在任务之间、中断和任务之间发送消息。下面来看看队列的相关内容。&lt;/p&gt;
&lt;h1 id=&quot;队列特性&quot;&gt;队列特性&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;strong&gt;数据存储（Data Storag</summary>
      
    
    
    
    <category term="RTOS" scheme="http://example.com/categories/RTOS/"/>
    
    
    <category term="queue" scheme="http://example.com/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS中任务(Task)</title>
    <link href="http://example.com/2023/10/05/FreeRTOS%E4%B8%AD%E4%BB%BB%E5%8A%A1(Task)/"/>
    <id>http://example.com/2023/10/05/FreeRTOS%E4%B8%AD%E4%BB%BB%E5%8A%A1(Task)/</id>
    <published>2023-10-05T02:41:10.000Z</published>
    <updated>2023-10-16T01:31:22.037Z</updated>
    
    <content type="html"><![CDATA[<p>使用 FreeRTOS 的实时应用程序，我们可以在应用程序中创建多个独立任务(task)，也可称为线程(thread)。</p><h1 id="任务的简介">任务的简介</h1><p>在FreeRTOS中创建任务时，每个任务都分配有自己的堆栈，在自己的上下文（寄存器值、堆栈内容等）中执行，不依赖于系统内的其他任务或 RTOS 调度器本身。在任何时间点，应用程序中只能执行一个任务，由调度器决定所要执行的任务调入和调出。当任务调出时，执行上下文信息被保存到该任务的堆栈中，以便再调入时可以正常恢复。</p><h1 id="任务的创建">任务的创建</h1><p>在 FreeRTOS 中，任务就是一个个独立且无法返回的函数，任务结构应如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vATask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span>&#123;    <span class="hljs-keyword">for</span>( ;; )    &#123;    <span class="hljs-comment">/* 添加任务实现代码 */</span>    &#125;vTaskDelete( <span class="hljs-literal">NULL</span> );<span class="hljs-comment">/* 如果任务需要退出，则删除该任务,NULL表示删除的是自己 /</span><span class="hljs-comment">&#125;</span></code></pre></div><p>如需创建任务，则调用 <code>xTaskCreate()</code>或 <code>xTaskCreateStatic()</code> ；如需删除任务，则调用 <code>vTaskDelete()</code> 。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 动态创建一个任务 */</span>BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">(TaskFunction_t pxTaskCode,  <span class="hljs-comment">/* 任务函数，如 vATask */</span></span><span class="hljs-params">                       <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName,<span class="hljs-comment">/* 任务名，自定义 */</span></span><span class="hljs-params">                       <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="hljs-comment">/* 任务栈大小，单位为word,10表示40字节 */</span></span><span class="hljs-params">                       <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,<span class="hljs-comment">/* 任务函数的参数 */</span></span><span class="hljs-params">                       UBaseType_t uxPriority,<span class="hljs-comment">/* 任务优先级,数值越小优先级越低 */</span></span><span class="hljs-params">                       TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask )</span> <span class="hljs-comment">/* 任务句柄,以后可用它来操作这个任务,如不使用该 handle，     可以传入 NULL */</span>    <span class="hljs-comment">/* 静态创建一个任务 */</span>    TaskHandle_t <span class="hljs-title function_">xTaskCreateStatic</span><span class="hljs-params">(TaskFunction_t pxTaskCode, <span class="hljs-comment">/* 任务函数，如 vATask */</span></span><span class="hljs-params">                               <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName,  <span class="hljs-comment">/* 任务名，自定义 */</span></span><span class="hljs-params">                               <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> ulStackDepth, <span class="hljs-comment">/* 任务栈大小，单位为word,10表示40字节 */</span></span><span class="hljs-params">                               <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters, <span class="hljs-comment">/* 任务函数的参数 */</span></span><span class="hljs-params">                               UBaseType_t uxPriority,<span class="hljs-comment">/* 任务优先级,数值越小优先级越低 */</span></span><span class="hljs-params">                               StackType_t * <span class="hljs-type">const</span> puxStackBuffer,<span class="hljs-comment">/* 静态分配的任务栈缓冲区数组 */</span></span><span class="hljs-params">                               StaticTask_t * <span class="hljs-type">const</span> pxTaskBuffer )</span><span class="hljs-comment">/* 任务缓冲区句柄 */</span><span class="hljs-comment">/* 删除一个任务 */</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">( TaskHandle_t xTaskToDelete )</span></code></pre></div><p>以上API函数在 <code>task.h</code> 文件中有详细的使用说明。举例如下：</p><ul><li>动态创建任务</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 具体的任务实现函数 */</span>  <span class="hljs-type">void</span> <span class="hljs-title function_">vStartLedTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>&#123; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123; HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);         vTaskDelay(<span class="hljs-number">500</span>); &#125;&#125;<span class="hljs-comment">/* 创建任务 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">vLedTask</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> ucParameterToPass;    TaskHandle_t xLedTaskHandle = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 任务句柄 */</span>    xTaskCreate(vStartLedTask, <span class="hljs-string">&quot;LEDTask&quot;</span>, <span class="hljs-number">128</span>, &amp;ucParameterToPass, osPriorityNormal, &amp;xLedTaskHandle);          <span class="hljs-keyword">if</span>(xLedTaskHandle != <span class="hljs-literal">NULL</span>)    &#123;        vTaskDelete(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">/* 任务退出，则删除任务 */</span>    &#125;&#125;</code></pre></div><ul><li>静态创建任务</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE 200 <span class="hljs-comment">/* 200 word */</span></span>StackType_t xStack[ STACK_SIZE ]; <span class="hljs-comment">/* 分配的静态栈数组大小 */</span>StaticTask_t xTaskBuffer; <span class="hljs-comment">/* 任务结构体数据句柄 */</span><span class="hljs-comment">/* 具体的任务实现函数 */</span>  <span class="hljs-type">void</span> <span class="hljs-title function_">vStartLedSaticTask</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>&#123; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123; HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);         vTaskDelay(<span class="hljs-number">500</span>); &#125;&#125;<span class="hljs-comment">/* 创建任务 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">vLedStaticTask</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    TaskHandle_t xReturnHandle = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 任务句柄 */</span>    xReturnHandle = xTaskCreateStatic(vStartLedSaticTask, <span class="hljs-string">&quot;LedStaticTask&quot;</span>, STACK_SIZE, <span class="hljs-literal">NULL</span>,                                                   osPriorityNormal, xStack, &amp;xTaskBuffer );     vTaskSuspend(xReturnHandle); <span class="hljs-comment">/* 挂起任务 */</span>&#125;</code></pre></div><p>另外，ARM公司和ST公司对FreeRTOS进行了重封装（<strong>cmsis_os2.h/cmsis_os2.c</strong>），引入了线程（thread）概念而取消任务的叫法，如使用STM32Cube MX自动生成工程文件时，会默认创建一个空任务，使用的就是<code>osThreadNew()</code>, 它的效果跟上面的例子差不多，不用过多纠结。</p><h1 id="任务的状态">任务的状态</h1><p>Free RTOS中任务的状态有以下几种：</p><ul><li><p><strong>运行</strong></p><p>当任务实际执行时，它被称为处于运行状态。 如果处理器只有一个内核， 那么在给定的任何时间内都只能有一个任务处于运行状态。</p></li><li><p><strong>准备就绪</strong></p><p>准备就绪任务指那些能够执行（它们不处于阻塞或挂起状态）， 但目前没有执行的任务， 因为同等或更高优先级的不同任务已经处于运行状态。</p></li><li><p><strong>阻塞</strong></p><p>如果任务当前正在等待外部事件，则该任务被认为处于阻塞状态。任务可以进入阻塞状态来等待两种不同类型的事件：</p><ol type="1"><li><strong>时间相关事件。</strong>可以是等待一段时间 <code>vTaskDelay()</code>或<code>osDelay()</code>，也可以是等到某个绝对时间<code>vTaskDelayUntil()</code>或<code>osDelayUntil()</code>。<strong>注意</strong>：这里的等待时间（Tick时间，不占用任务处理时间）和<code>HAL_Delay()</code>（占用任务处理时间）不一样。</li><li><strong>同步事件。</strong>事件由另一个任务或中断程序产生，可以由队列、信号量、事件组、通知或信号量等产生事件。如在一个队列中等待数据的到来。</li></ol><p>处于阻塞状态的任务通常有一个"超时"期，超时后即使该任务所等待的事件没有发生，任务也将退出阻塞状态。“阻塞”状态下的任务不使用任何处理时间，不能进入运行状态。高优先级任务进入阻塞态后，低优先级任务才有权限进入运行态。</p></li><li><p><strong>挂起</strong></p><p>“挂起”状态下（即暂停）的任务不能被选择调度器调用，只能通过 <code>vTaskSuspend()</code> 和 <code>xTaskResume()</code> 及 <code>xTaskResumeFromISR()</code> 函数进入或退出挂起状态。大部分的应用不会使用挂起状态。</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231005180546855.png" style="zoom:80%;" /></p><h1 id="任务的优先级">任务的优先级</h1><p>Free RTOS中每个任务都被分配了优先级：（<strong>0 ~ （configMAX_PRIORITIES - 1）</strong>），数值越大优先级越高，这与RT-Thread和μC/OS相反，<code>configMAX_PRIORITIES</code> 宏在 <code>FreeRTOSConfig.h</code>文件中进行配置定义。当 <code>configUSE_PORT_OPTIMIED_TASK_SELECTION = 1</code> 时，即使用端口优化任务选择机制，则 <code>configMAX_PRIORITIES</code> 配置不能大于32， 其它情况，为了RAM使用效率，应将其保持为实际所需的最小值。</p><p>Free RTOS调度器会一直选择<strong><u>最高优先级的任务</u></strong>进入运行的状态。当多个任务处于同一优先级，调度器会使用<u><strong>时间切片轮询方式</strong></u>切换这些任务，此时宏 <code>configUSE_TIME_SLICING  = 1</code>。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231005185629584.png" alt="image-20231005185629584" style="zoom:80%;" /></p><div class="code-wrapper"><pre><code class="hljs c">UBaseType_t <span class="hljs-title function_">uxTaskPriorityGet</span><span class="hljs-params">( TaskHandle_t xTask )</span>; <span class="hljs-comment">/* 获得任务的优先级 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskPrioritySet</span><span class="hljs-params">( TaskHandle_t xTask, UBaseType_t uxNewPriority )</span>; <span class="hljs-comment">/* 设置任务的优先级 */</span></code></pre></div><h1 id="空闲任务和空闲任务钩子idle-task-hook">空闲任务和空闲任务钩子（Idle Task Hook）</h1><p>RTOS 调度器启动时，会自动创建空闲任务，以确保始终存在一个能够运行的任务。它以最低优先级创建，要么处于就绪态，要么处于运行态，永远不会阻塞。空闲任务负责释放被删除任务的内存。</p><p>空闲任务钩子是在空闲任务的每个周期中调用的函数，在没有能够运行的更高优先级的任务时，这种空闲钩子函数就会被执行。 它的作用主要有：</p><ul><li>执行一些低优先级的、后台的、需要连续执行的函数 。</li><li>测量系统的空闲时间。</li><li>让系统进入低功耗省电模式。</li></ul><p>要创建一个空闲钩子，需要在 <code>FreeRTOSConfig.h</code> 文件中将 <strong>configUSE_IDLE_HOOK</strong> 设置为 1，然后定义空闲钩子回调函数 <code>void vApplicationIdleHook( void );</code></p><p><strong>需要注意的是</strong>：空闲钩子函数不调用任何可能导致其阻塞的 API 函数。 此外，如果应用程序使用 <code>vTaskDelete()</code> API 函数，则必须允许空闲任务钩子定期返回 。</p><h1 id="任务的调度">任务的调度</h1><p>FreeRTOS 调度算法主要针对单核、非对称多核 (AMP)、和对称多核 (SMP) RTOS的配置。在 AMP 中， 每个处理器核心运行自身的 FreeRTOS 实例。在 SMP 中， 存在一个 FreeRTOS 实例，可以跨多核调度 RTOS 任务 。FreeRTOS调度默认针对是单核，这里主要看看单核调度算法。</p><p>调度算法，是指决定哪个就绪态的任务可以切换到运行态的程序。可通过 <code>FreeRTOSConfig.h</code> 中的三个配置项来改变调度算法 ：</p><ul><li><strong>configUSE_PREEMPTION</strong></li></ul><p>如果设置为 0，则关闭“抢占”， 只有当运行态的任务进入“阻塞”或“挂起”状态， 或调用 <code>taskYIELD()</code>， 或中断服务程序 (ISR) 手动请求上下文切换时，才会发生上下文切换。</p><ul><li><strong>configUSE_TIME_SLICING</strong></li></ul><p>如果设置为 0，则表示时间切片已关闭， 因此调度器不会在每个 tick 中断上在同等优先级的任务之间切换 。</p><ul><li><strong>configUSE_TICKLESS_IDLE</strong></li></ul><p>用于关闭Tick中断来实现省电。</p><p>调度算法的行为主要体现在两方面：高优先级的任务先运行、同优先级的就绪态任务如何被选中。调度算法要确保同优先级的就绪态任务，能轮询运行，策略是"轮询调度"(Round Robin Scheduling)。</p><p><strong>对于单核来讲，FreeRTOS 默认使用固定优先级的抢占式调度策略，对同等优先级的任务执行时间片轮询调度，即将上面的配置项设置为1。</strong></p><p>使用抢占式优先级调度，避免了任务间的强盗行为，因为不进入“阻塞”或 “挂起”状态的高优先级任务会让其它低优先级任务不被执行。例如，一个高优先级任务正在等待一个事件， 它不应该处于事件的循环（轮询）中，因为它永远不会进入阻塞或挂起状态。任务应进入阻塞状态以等待事件，优先级较低的任务从而可以被调度执行，当使用任务间通信将事件发送给高优先级任务时，它会自动从“阻塞”状态进入再次运行状态。</p><p>每个任务具有固定的优先级时，其时间片轮询调度时序图如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231005212220169.png" alt="image-20231005212220169" style="zoom:80%;" /></p><p>当有两个任务优先级一样时，其时间片轮询调度时序图如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20231005212233030.png" alt="image-20231005212233030" style="zoom:80%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 FreeRTOS 的实时应用程序，我们可以在应用程序中创建多个独立任务(task)，也可称为线程(thread)。&lt;/p&gt;
&lt;h1 id=&quot;任务的简介&quot;&gt;任务的简介&lt;/h1&gt;
&lt;p&gt;在FreeRTOS中创建任务时，每个任务都分配有自己的堆栈，在自己的上下文（寄存器</summary>
      
    
    
    
    <category term="RTOS" scheme="http://example.com/categories/RTOS/"/>
    
    
    <category term="Task" scheme="http://example.com/tags/Task/"/>
    
  </entry>
  
</feed>
