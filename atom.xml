<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-23T09:30:27.904Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见的开发概念及开源资源</title>
    <link href="http://example.com/2023/08/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E5%8F%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BC%80%E6%BA%90%E8%B5%84%E6%BA%90/"/>
    <id>http://example.com/2023/08/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E5%8F%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BC%80%E6%BA%90%E8%B5%84%E6%BA%90/</id>
    <published>2023-08-20T04:09:58.000Z</published>
    <updated>2023-08-23T09:30:27.904Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/gnu-100-b98545.png"><p align="center"><b style="font-size:25px">GNU</b></p></p><p>GNU是一个开源组织，同时也是一个100%自由软件的操作系统，包含了所有的官方GNU软件包，也包括非GNU自由软件。</p><p>GNU官网：https://www.gnu.org/</p><ul><li><p><strong>GCC/G++</strong>：GNU工具链中的编译器。</p></li><li><p><strong><ahref="https://www.gnu.org/software/make/">Make</a></strong>：GNU工具链中的构建生成器，搭配makefile文件使用。</p></li><li><p><strong><a href="https://www.sourceware.org/gdb/">GDB（GNUDebuger）</a></strong>：GNU 开源组织发布的一个强大的UNIX下的程序调试工具。</p></li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6ac65d24163b5b6e0.jpeg"><p align="center"><b style="font-size:25px">LLVM</b></p></p><p>LLVM是编译器和工具链技术的集合。</p><p>官网： https://clang.llvm.org/</p><p><strong>clang/clang++</strong> ：LLVM工具链中C/C++/Objective-C编译器。</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/weq.png"><p align="center"><b style="font-size:25px">Cygwin</b></p></p><p>Cygwin是GNU编译器和大量开源工具的集合，能够在Windows系统上提供类似于Linux系统的功能。它提供了大量的POSIXAPI功能。</p><p>官网：https://www.cygwin.com/index.html</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/%EF%BC%ADinGW-w64-long.png"><p align="center"><b style="font-size:25px">MinGw</b></p></p><p>MinGW(Minimalist GNU forWindows)是一个开源的基于GNU的编译器套件，允许你在Windows平台生成本地的Windows程序而不需要系统运行库(CRuntime library，静态库lib或动态库dll)。</p><p>官网：https://www.mingw-w64.org/</p><p><ahref="https://zhuanlan.zhihu.com/p/76613134?utm_source=QQ_article_bottom">MinGW-w64安装教程——著名C/C++编译器GCC的Windows版本</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/RE1Mu3b.png"><p align="center"><b style="font-size:25px">MSVC</b></p></p><p>MSVC(Microsoft VisualC/C++)是微软公司开发的Windows下编译器工具链，已经集成到Microsoft VisualStudio环境中。</p><p>官网：https://learn.microsoft.com/zh-cn/cpp/build/projects-and-build-systems-cpp?view=msvc-170</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/Cmake-logo-header.png"><p align="center"><b style="font-size:25px">CMake</b></p></p><p>CMake(Cross platformmake)是比Make更高一层的工具,搭配CmakeList.txt文件，产生标准的建构档，再依一般的建构方式进行项目构建。</p><p>官网：https://cmake.org/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/Qt-logo-neon-small.png" alt="img" style="zoom:33%;" /><p align="center"><b style="font-size:25px">qmake</b></p></p><p>qmake 是QT工程的项目构建生成器。</p><p>官网：https://www.qt.io/product/development-tools</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/SCons-Bricks.png"><p align="center"><b style="font-size:25px">SCons</b></p></p><p>SCons 是项目构建工具，使用 SConstruct 和 SConscript文件来替代复杂规则的makefile文件，像RT-thread系统构建中有使用。</p><p>官网：https://www.scons.org/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/tux.png"><p align="center"><b style="font-size:25px">Linux</b></p></p><ul><li><p><strong>Linux Kernel</strong> ：Linux内核 ，Linux系统核心。</p><p>官网：https://kernel.org/</p></li><li><p><strong>U-Boot</strong>：Linux系统启动引导代码。全称 UniversalBoot Loader。</p><p>官网：https://u-boot.readthedocs.io/en/latest/</p><p>源码网址：</p><ul><li>https://source.denx.de/u-boot/u-boot</li><li>https://ftp.denx.de/pub/u-boot/ （或ftp://ftp.denx.de/pub/u-boot/）</li></ul></li><li><p><strong>BusyBox</strong>：BusyBox 是一个集成了众多最常用 linux命令和工具的精简工具箱。它提供了一个比较完善的环境，可用于构建轻量级的根文件系统。</p><p>官网：https://busybox.net/</p><p><ahref="http://www.taodudu.cc/news/show-318004.html?action=onClick">busybox详解</a></p></li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818231609048.png" alt="image-20230818231609048" style="zoom:50%;" /><p align="center"><b style="font-size:25px">OpenOCD</b></p></p><p><strong>OpenOCD(Open On-ChipDebugger)</strong>是一个开源片上调试器，用于嵌入式系统的开发和调试。</p><p>官网：https://www.openocd.org/</p><p>下载地址：https://sourceforge.net/projects/openocd/files/</p><p>Windows下openocd：https://gnutoolchains.com/arm-eabi/openocd/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818232211015.png" alt="image-20230818232211015" style="zoom:67%;" /><p align="center"><b style="font-size:25px">FatFs</b></p></p><p>FatFs 是用于小型嵌入式系统的通用 FAT/exFAT 文件系统开源项目。</p><p>官网：http://elm-chan.org/fsw/ff/00index_e.html</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/floating.png" alt="Back to Savannah Homepage" style="zoom:80%;" /><p align="center"><b style="font-size:25px">lwIP</b></p></p><p><strong>lwIP(light weight IP)</strong>是一个开源的小型轻量级的 TCP/IP协议栈。</p><p>官网：http://savannah.nongnu.org/projects/lwip/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/logo_lvgl.png" alt="logo" style="zoom: 67%;" /><p align="center"><b style="font-size:25px">LVGL</b></p></p><p><strong>LVGL(Light and Versatile Graphics Library)</strong>,是一个开源的轻量级嵌入式图形库，可为任何 MCU、MPU和显示类型创建漂亮的 UI。</p><p>官网：https://lvgl.io/</p><p>源码：https://github.com/lvgl/lvgl/releases</p><p>百问网LVGL：http://lvgl.100ask.net/8.2/index.html</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230819001230032.png"><p align="center"><b style="font-size:25px">MQTT</b></p></p><p>MQTT(Message Queuing TelemetryTransport,消息队列遥测传输协议)是一种基于发布/订阅(PUBLISH/SUBSCRIBE)模式的轻量级的物联网通信协议。</p><p>官网：https://mqtt.org/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/logo.png"><p align="center"><b style="font-size:25px">OpenCV</b></p></p><p>OpenCV是一个开源跨平台的计算机视觉库，被用于各种各样的计算机视觉应用程序中，包括人脸检测、目标识别、图像分割、机器人视觉、运动跟踪、手势识别等。OpenCV提供了许多用于图像处理和计算机视觉的功能，包括图像滤波、特征检测、特征匹配、图像分割、摄像机校准、三维重建等。它还提供了C++、Python和Java等编程语言的接口，方便用户在各种平台上进行开发。</p><p>官网：https://opencv.org/</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230821084024530.png"><p align="center"><b style="font-size:25px">CMSIS</b></p></p><p><strong>CMSIS(Common Microcontroller Software InterfaceStandard)</strong> : ARMCortex™通用微控制器软件接口标准，由ARM公司跟芯片软件厂商共同提出的，开源。它提供了一种内核与外设、实时操作系统和中间件接口的通用方法。参考：<ahref="https://blog.csdn.net/m0_54929728/article/details/128695058?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-128695058-blog-126438165.235%5Ev38%5Epc_relevant_sort&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-128695058-blog-126438165.235%5Ev38%5Epc_relevant_sort&amp;utm_relevant_index=11">CMSIS到底是个什么东西</a></p><p>官网：https://www.arm.com/technologies/cmsis</p><p>CMSIS资源包含：</p><ul><li><ahref="http://arm-software.github.io/CMSIS_5/RTOS2/html/index.html">CMSIS-RTOS</a>：一个 API，能够使中间件和库组件实现一致的软件层</li><li><ahref="http://arm-software.github.io/CMSIS_5/DSP/html/index.html">CMSIS-DSP</a>：DSP库是Arm针对各种Cortex-M处理器内核优化的DSP功能的丰富集合</li><li><ahref="http://arm-software.github.io/CMSIS_5/Driver/html/index.html">CMSIS-Driver</a>：CMSIS驱动程序接口可用于许多微控制器系列</li><li><ahref="http://arm-software.github.io/CMSIS_5/Pack/html/index.html">CMSIS-Pack</a>：定义了包含软件组件的软件包结构</li><li><ahref="http://arm-software.github.io/CMSIS_5/SVD/html/index.html">CMSIS-SVD</a>：该文件允许查看具有当前寄存器状态的设备外设的详细视图</li><li><ahref="http://arm-software.github.io/CMSIS_5/DAP/html/index.html">CMSIS-DAP</a>：它是Cortex 调试访问端口（DAP）的标准化接口</li><li><ahref="http://arm-software.github.io/CMSIS_5/NN/html/index.html">CMSIS-NN</a>：这是高效神经网络内核的集合</li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230823133444089.png"><p align="center"><b style="font-size:25px">MIPI Alliance</b></p></p><p><strong>MIPI(Mobile Industry ProcessorInterface)移动行业处理器接口</strong>，MIPI联盟是一个全球协作组织，制定和推进移动设备接口技术标准，提供一个世界性，全面性的接口规范生态系统，有效地互连各种移动组件和受移动影响的设备。这些规范标准涵盖了设备所需的所有接口应用，包括调制解调器、应用处理器、相机、显示器、音频、存储、天线、调谐器、功率放大器、滤波器、开关、电池等的接口。</p><p>官网：https://www.mipi.org/</p><p>MIPI联盟各接口规格及开发工作组主要有（非MIPI联盟成员只能查看接口公开版规格书）：</p><ul><li><strong>Audio</strong><ul><li><a href="https://www.mipi.org/groups/audio"><strong>Audio WorkingGroup</strong></a></li></ul></li><li><strong>Camera &amp; Imaging</strong><ul><li><strong><a href="https://www.mipi.org/groups/camera">Camera WorkingGroup</a></strong></li></ul></li><li><strong>Chip-to-chip/IPC</strong><ul><li><strong><ahref="https://www.mipi.org/groups/unipro-working-group">UniPro WorkingGroup</a></strong></li></ul></li><li><strong>Control &amp; Data</strong><ul><li><strong><a href="https://www.mipi.org/groups/i3c">I3C WorkingGroup</a></strong></li><li><strong><a href="https://www.mipi.org/groups/rf-front-end">RFFront-End Control Working Group</a></strong></li></ul></li><li><strong>Debug &amp; Trace</strong><ul><li><strong><a href="https://www.mipi.org/groups/debug">Debug WorkingGroup</a></strong></li></ul></li><li><strong>Display &amp; Touch</strong><ul><li><strong><a href="https://www.mipi.org/groups/display">DisplayWorking Group</a></strong></li></ul></li><li><strong>Physical Layers</strong><ul><li><strong><a href="https://www.mipi.org/groups/phy">PHY SteeringGroup</a></strong></li><li><strong><a href="https://www.mipi.org/groups/a-phy">A-PHY WorkingGroup</a></strong></li><li><strong><a href="https://www.mipi.org/groups/c-phy">C-PHY WorkingGroup</a></strong></li><li><strong><a href="https://www.mipi.org/groups/d-phy">D-PHY WorkingGroup</a></strong></li><li><strong><a href="https://www.mipi.org/groups/m-phy">M-PHY WorkingGroup</a></strong></li></ul></li><li><strong>Software Integration</strong><ul><li><strong><a href="https://www.mipi.org/groups/software">SoftwareWorking Group</a></strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://gitee.com/kayoungzhang/picgo_res/raw/master/img/gnu-100-b98545.png&quot;&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;b style=&quot;fo</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="开源" scheme="http://example.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>编译工具链</title>
    <link href="http://example.com/2023/08/18/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>http://example.com/2023/08/18/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/</id>
    <published>2023-08-18T06:40:47.000Z</published>
    <updated>2023-08-18T06:54:23.796Z</updated>
    
    <content type="html"><![CDATA[<p>在编写程序后，一般需要进行编译处理，生成可执行的程序文件，才能下载到芯片中运行，在IDE集成开发环境中，编译的过程都是由其内部的编译工具链进行处理。但在Linux开发过程中，一般需要自己进行编译器的配置等操作，下面简单了解下编译工具链的相关知识。</p><h2 id="编译工具链简介">编译工具链简介</h2><p>编译程序是一个由多个步骤组成的过程，每个步骤都需要使用不同的工具进行处理。这些工具紧密协作，前一个工具的输出会成为后一个工具的输入，故称之为工具链，习惯称为编译工具链。这个工具链中包含多种工具和相关C库，如预编译器，编译器，汇编器，链接器，调试器等等。</p><h2 id="编译工具链分类">编译工具链分类</h2><p>针对不同的应用平台和芯片架构，编译工具链种类有很多，有免费开源授权版和付费授权版。</p><p><strong>免费版工具链</strong> 主要有两大主流：</p><ul><li><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/gnu-100-b98545-16923412898262.png"alt="gnu-100-b98545" /> <a href="https://www.gnu.org/">GNUToolchain</a></p></li><li><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6ac54669f4b30cb07094375cbd65d24163b5b6e0.jpeg"alt="6ac54669f4b30cb07094375cbd65d24163b5b6e0" /> <ahref="https://llvm.org/">LLVM Toolchain</a></p></li></ul><p>对于开源的这两大工具链，主要是ARM和Linaro开发社区提供：</p><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818145258689.png"alt="image-20230818145258689" /> <ahref="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain">armDeveloper</a></p><p>arm主要提供GNU工具链。</p><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818131408554.png"alt="image-20230818131408554" /> <ahref="https://www.linaro.org/">Linaro</a></p><p>Linaro两种都有提供。</p><p><strong>收费版工具链</strong>主要是一些大公司开发的专用工具链，必须购买获取授权，才能使用，像ARM原厂提供的armcc、IAREWARM，微软的MSVC等等。</p><h2 id="编译工具链一般命名规则">编译工具链一般命名规则</h2><p>编译工具链的命名规则为： <strong>arch [-vendor] [-os][-(gnu)eabi]</strong></p><p><strong>arch</strong> - 芯片体系架构，如arm，mips，aarch64等。</p><p><strong>vendor</strong> -工具链提供商，可以是none、unknow或者省略。</p><p><strong>os</strong> - 目标操作系统，这个字段一般是linux或者none。</p><p><strong>eabi</strong> - 嵌入式应用二进制接口（Embedded ApplicationBinaryInterface)，它指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。</p><p>如：</p><p>arm-none-eabi</p><p>aarch64-none-linux-gnu</p><p>arm-none-linux-gnueabihf</p><h2 id="gnu编译工具链">GNU编译工具链</h2><h4 id="arm-gnu-toolchain">Arm GNU Toolchain</h4><p>下载地址：https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain</p><p>由ARM公司开发用于Arm架构的GNU开源编译工具链（称作“Arm GNUToolchain”），可以让合作伙伴，开发人员和社区能够使用新功能，这些功能来自最新Arm架构和GCC，Binutils，glibc，Newlib和GDB的开源项目。</p><ul><li><a href="https://gcc.gnu.org/"><strong>GNU C/C++ Compiler(GCC)</strong></a> ： 编译工具，把源程序编译为可执行文件。</li><li><ahref="https://www.gnu.org/software/binutils/"><strong>Binutils</strong></a>：一组二进制工具程序集合。</li><li><ahref="https://www.sourceware.org/gdb/"><strong>GDB</strong></a>：GNU本地调试器，可以用来调试C、C++和其他语言编写的程序。<br /></li><li><ahref="https://sourceware.org/newlib/"><strong>Newlib</strong></a>：C库</li><li><ahref="https://www.gnu.org/software/libc/libc.html"><strong>Glibc</strong></a>：C库</li></ul><p><strong>注意</strong>：Arm发布的旧版GNU工具链有两种：一种针对A系列芯片，另一种是针对M系列和R系列芯片(<ahref="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads">GNUToolchain for A-profile processors</a> 和 <ahref="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">GNUArm Embedded Toolchain</a>)。现在已经合二为一。</p><h3 id="gnu-toolchain">GNU Toolchain</h3><p>其他开源组织开发的GNU编译工具链</p><p>https://gnutoolchains.com/download/</p><h3 id="llvm-toolchain">LLVM Toolchain</h3><p>下载地址：https://github.com/llvm/llvm-project/releases/</p><p>LLVM项目是一个模块化和可重用的编译器和工具链技术的集合。LLVM核心库提供了一个独立的代码优化器，且支持大多数流行的CPU的代码生成。</p><ul><li><strong><a href="https://clang.llvm.org/">Clangcompiler</a></strong>：LLVM工具链中的编译器。</li><li><a href="https://lldb.llvm.org/"><strong>LLDBdebugger</strong></a>：本机调试器。</li><li><strong><a href="https://libcxx.llvm.org/">libc++</a></strong>:C++标准库</li><li><a href="https://compiler-rt.llvm.org/"><strong>Compiler-RT runtimelibraries</strong></a>：编译运行库</li><li><strong><a href="https://lld.llvm.org/">LLDlinker</a></strong>：链接器</li></ul><p>以上是关于编译器的一些介绍，如果不是做编译器底层开发的话，不建议深入学习，毕竟还是有点复杂，对于我们一般开发者而言，了解它的一般原理，知道在哪下载，怎么使用，这些已足够了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在编写程序后，一般需要进行编译处理，生成可执行的程序文件，才能下载到芯片中运行，在IDE集成开发环境中，编译的过程都是由其内部的编译工具链进行处理。但在Linux开发过程中，一般需要自己进行编译器的配置等操作，下面简单了解下编译工具链的相关知识。&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="编译" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>内存的分区(栈区、堆区、全局区、常量区和代码区)</title>
    <link href="http://example.com/2023/08/13/%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E5%8C%BA-%E6%A0%88%E5%8C%BA%E3%80%81%E5%A0%86%E5%8C%BA%E3%80%81%E5%85%A8%E5%B1%80%E5%8C%BA%E3%80%81%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8C%BA/"/>
    <id>http://example.com/2023/08/13/%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E5%8C%BA-%E6%A0%88%E5%8C%BA%E3%80%81%E5%A0%86%E5%8C%BA%E3%80%81%E5%85%A8%E5%B1%80%E5%8C%BA%E3%80%81%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8C%BA/</id>
    <published>2023-08-13T14:30:12.000Z</published>
    <updated>2023-08-21T14:57:51.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存分区简介">内存分区简介</h2><p>内存一般分为四个区域：<strong>堆区、栈区、全局区（静态区）、代码区</strong>。而编译程序占用的内存分为以下五个部分：<strong>堆区、栈区、全局区（静态区）、常量区、代码区</strong>。</p><p>C、C++程序在编译链接后生成的映像（image）中，将只包含<strong>代码段(.Text)</strong>、<strong>只读数据段(.rodata)</strong> 和<strong>读写数据段(.data)</strong> 。在程序运行之前，将生成<strong>未初始化数据段(.bss)</strong>，在程序的运行时还将动态生成<strong>堆(Heap)区域</strong> 和 <strong>栈(Stack)区域</strong> 。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230821192124971.png"alt="image-20230821192124971" /><figcaption aria-hidden="true">image-20230821192124971</figcaption></figure><h2 id="内存各分区功能">内存各分区功能</h2><ul><li><p><strong>栈区（Read and Write）</strong></p><ul><li>临时创建的局部变量和const定义的局部变量及函数形参、返回值存放在栈上。</li><li>栈区按内存地址由高到低方向生长，先进后出原则。</li><li>栈区由编译器自动分配释放，无须手动管理。栈上内容在函数运行结束就会自动销毁。</li></ul></li><li><p><strong>堆区（Read and Write）</strong></p><ul><li>由程序员分别调用malloc()和free()函数分配和释放内存。若申请了内存，忘记释放会造成内存泄漏。</li><li>堆区按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。</li></ul></li><li><p><strong>全局区(静态区)（Read and Write）</strong></p><ul><li><strong>.data段</strong>：存放初始化的全局变量和静态(static)变量。编译期间其大小及数据被确定，这些变量<strong>需要占用内存空间</strong>。</li><li><strong>.bss段(Block Started bySymbol)</strong>：存放未初始化的全局变量和静态(static)变量。程序运行之前被内核初始化为0或者空（NULL）。这些变量<strong>在程序运行之前不占内存空间</strong>。</li></ul></li><li><p><strong>常量区（Read Only）</strong></p><ul><li>存放 <strong>字符串</strong>、<strong>数字</strong> 等常量。</li><li>存放 <strong>const修饰的全局变量</strong>。</li></ul></li><li><p><strong>代码区（Read Only）</strong></p><ul><li><p>存放程序的编译后的可执行二进制代码，CPU执行的机器指令。</p></li><li><p>代码区的地址:函数的地址,程序的入口地址，函数的名称也是一个指针，可以通过查询函数名称所处的内存地址，查询函数存放的区域。</p></li><li><p>字符串常量和define定义的常量也有可能存放在代码区。</p></li></ul></li></ul><h2 id="举例">举例</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> a;   <span class="hljs-comment">//存放在全局未初始化区 .bss段</span><span class="hljs-type">char</span>* p1;   <span class="hljs-comment">//存放在全局未初始化区</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> b;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span>* p2;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span>* p3 = <span class="hljs-string">&quot;123456&quot;</span>;<span class="hljs-comment">//123456\0在常量区，p3在栈区。</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>；<span class="hljs-comment">//全局(静态)初始化区 .data段</span>p1 = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);p2 = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);<span class="hljs-comment">//使用malloc分配得来得10和20字节的区域就在堆区。</span><span class="hljs-built_in">strcpy</span>(p1, <span class="hljs-string">&quot;123456&quot;</span>);<span class="hljs-comment">//123456\0在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span>&#125;</code></pre></div><p><strong>参考:</strong></p><p><ahref="https://blog.csdn.net/u014470361/article/details/79297601?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%2279297601%22%2C%22source%22%3A%22zky0830%22%7D&amp;fromshare=blogdetail">什么是代码区、常量区、静态区（全局区）、堆区、栈区？</a></p><p><ahref="https://blog.csdn.net/weixin_44364057/article/details/126541545">五大内存分区</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存分区简介&quot;&gt;内存分区简介&lt;/h2&gt;
&lt;p&gt;内存一般分为四个区域：&lt;strong&gt;堆区、栈区、全局区（静态区）、代码区&lt;/strong&gt;。而编译程序占用的内存分为以下五个部分：&lt;strong&gt;堆区、栈区、全局区（静态区）、常量区、代码区&lt;/strong&gt;
。</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="内存" scheme="http://example.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>计算机结构</title>
    <link href="http://example.com/2023/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/</id>
    <published>2023-08-13T11:42:45.000Z</published>
    <updated>2023-08-14T00:03:33.617Z</updated>
    
    <content type="html"><![CDATA[<p>计算机的五个基本组成部分：<strong>运算器、控制器、存储器、输入设备、输出设备</strong>。</p><p>计算机常见的两种结构，<strong>哈佛结构（HarvardArchitecture）</strong>和 <strong>冯·诺依曼结构（Von NeumannArchitecture）</strong>：</p><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230813204135256.png" /></p><p>从这两种结构图上可以看出，它们的主要区别是内存存在方式的不同。</p><h3 id="哈佛结构">哈佛结构</h3><p>哈佛结构是一种将程序指令储存和数据储存分开的存储器结构。每个存储器独立编址，使用两条独立的总线传输，中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作(通常是执行)。程序指令储存和数据储存分开，<strong>数据和指令的储存可以同时进行</strong>，可以使指令和数据有不同的数据宽度。</p><p>哈佛结构的微处理器执行时可以预先读取下一条指令，因此具有较高的执行效率。</p><h3 id="冯诺依曼结构">冯诺依曼结构</h3><p>冯诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的结构。指令和数据统一编址，使用同一条总线传输，节约了资源。</p><p>冯.诺依曼结构中，将程序和数据一样看待，<strong>将程序编码为数据，然后与数据一同存放在存储器中</strong>，无论什么程序，最终都是会转换为数据的形式存储在存储器中，要执行相应的程序只需要从存储器中依次取出指令、执行，这样减少了硬件的连接。</p><h3 id="改进型哈佛结构">改进型哈佛结构</h3><p>现在的计算机，其实是这两种结构的混合体。对于一台计算机的整体来说，我们可以认为是冯·诺依曼结构，计算机中的内存是统一的，并没有明确分为指令内存还是数据内存。</p><p>相对于CPU的速度来说，从内存读取数据和写入数据都很慢的，因此CPU内部有另外一种速度更快的存储介质来存放数据和指令，我们称之为缓存（Cache），分为D-Cache和l-Cache，分别用于存储数据和程序指令。在CPU外部则使用RAM存储数据和指令。只有需要改变数据时，缓存才会到RAM中加载新的数据。现代计算机中缓存通常有多层，每一层都比下一层快，但比下一层可以存放的数据少。</p><p>实际上，这种结构从内部看属于哈佛结构，从外部看则属于冯诺依曼结构，这是一种混合式结构，而现在的计算机CPU大多采用这样的结构，已经不再是纯粹的冯诺依曼结构或者哈佛结构了。</p><h4 id="参考链接">参考链接</h4><p>https://zhuanlan.zhihu.com/p/63322067</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机的五个基本组成部分：&lt;strong&gt;运算器、控制器、存储器、输入设备、输出设备&lt;/strong&gt;
。&lt;/p&gt;
&lt;p&gt;计算机常见的两种结构，&lt;strong&gt;哈佛结构（Harvard
Architecture）&lt;/strong&gt;和 &lt;strong&gt;冯·诺依曼结构（V</summary>
      
    
    
    
    <category term="C语言" scheme="http://example.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>stm32 sct分散加载文件详解</title>
    <link href="http://example.com/2023/08/09/stm32-sct%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/09/stm32-sct%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-09T10:28:31.000Z</published>
    <updated>2023-08-10T11:32:50.678Z</updated>
    
    <content type="html"><![CDATA[<p>keil软件在编译过程中会生成分散加载文件（Scatter-Loading DescriptionFile），它可以用来描述链接器生成映像文件时需要的信息，通过这些信息分配Code、RO-Data，RW-Data，ZI-Data 等数据的存放地址。</p><p>一个sct文件主要由一个<strong>加载区（loadregion）</strong>和多个<strong>执行区（executionregion）</strong>构成。</p><p>加载区是用来保存永久性数据（程序和只读变量）的区域；执行区是程序执行时，从加载区域将数据复制到相应执行区后才能被正确执行。</p><p>sct文件一般格式：</p><div class="code-wrapper"><pre><code class="hljs assembly">LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region  ER_IROM1 0x08000000 0x00080000  &#123;  ; load address = execution address   *.o (RESET, +First)    *(InRoot$$Sections)    .ANY (+RO)   &#125;  RW_IRAM1 0x20000000 0x00010000  &#123;  ; RW data   .ANY (+RW +ZI)   &#125;&#125;</code></pre></div><p>下面分别通过三个方面详细了解一下其格式语法：</p><h4 id="加载区域语法">1. 加载区域语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">加载区名(基地址|&quot;+&quot;偏移地址)[属性][大小]&#123;执行区操作+    ;+号表示可以有一个或者多个运行区&#125;</code></pre></div><p>属性列表：</p><ul><li>ABSOLUTE：绝对地址；</li><li>PI：与位置无关；</li><li>RELOC：可重定位；</li><li>OVERLAY：覆盖；</li><li>NOCOMPRESS：不能进行压缩。</li></ul><h4 id="执行区语法">2. 执行区语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">执行区名(基地址|&quot;+&quot;偏移地址)[属性][大小|&quot; &quot;长度]&#123;输入段内容&#125;</code></pre></div><p>属性列表：</p><ul><li><p>ABSOLUTE：绝对地址；</p></li><li><p>PI：与位置无关；</p></li><li><p>RELOC：可重定位；</p></li><li><p>OVERLAY：覆盖；</p></li><li><p>FIXED：固定地址。</p></li><li><p>ALIGNalignment：将执行区的对齐约束从 4 增加到alignment。alignment 必须为 2 的正数幂。如果执行区具有base_address，则它必须为 alignment 对齐。如果执行区具有offset，则链接器将计算的区基址与 alignment 边界对齐；</p></li><li><p>EMPTY：在执行区中保留一个给定长度的空白内存块，通常供堆或堆栈使用。</p></li><li><p>ZEROPAD：零初始化的段作为零填充块写入 ELF文件，因此，运行时无需使用零进行填充；</p></li><li><p>PADVALUE：定义任何填充的值。如果指定PADVALUE，则必须为其赋值；</p></li><li><p>NOCOMPRESS：不能进行压缩；</p></li><li><p>UNINIT：未初始化的数据。</p></li></ul><h4 id="输入段内容语法">3. 输入段内容语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">module_select_pattern [ &quot;(&quot; input_section_selector ( &quot;,&quot; input_section_selector )* &quot;)&quot; ](&quot;+&quot; input_section_attr | input_section_pattern | input_symbol_pattern)</code></pre></div><ul><li>module_select_pattern：目标文件滤波器，支持通配符“*”与“?”。字符不区分大小写。</li><li>input_section_selector: 模块选择器模式,有以下几种：<ul><li>包含段和目标文件的名称；</li><li>库成员名称（不带前导路径名）；</li><li>库的完整名称（包括路径名）。如果名称包含空格，则可以使用通配符简化。例如，使用*libname.lib匹配 C:dir.lib。</li></ul></li><li>nput_section_attr：属性选择器与输入段属性相匹配。每个input_section_attr的前面有“+”号。如果指定一个模式以匹配输入段名称，名称前面必须有一个“+”号。可以省略紧靠“+”号前面的任何逗号。选择器不区分大小写。可以识别以下选择器：<ul><li>RO-CODE，RO-DATA，RO（RO-CODE 和RO-DATA），CODE（RO-CODE）、CONST（RO-DATA），TEXT（RO）</li><li>RW-DATA，RW-CODE，RW（RW-CODE 和 RW-DATA），DATA（RW）</li><li>ZI，BSS（ZI）</li><li>ENTRY（即包含 ENTRY 点的段），FIRST，LAST</li></ul></li></ul><p>通过使用特殊模块选择器模式.ANY可以将输入段分配给执行区，而无需考虑其父模块。可以使用一个或多个.ANY模式以任意分配方式填充运行区。在大多数情况下，使用单个.ANY等效于使用*模块选择器。</p><p>由以上语法分析，查看具体实例，如下所示：</p><div class="code-wrapper"><pre><code class="hljs assembly">; IROM1加载区，地址：0x08000000，大小：0x00080000LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region  ; ER_IROM1执行区，地址：0x08000000，大小：0x00080000  ER_IROM1 0x08000000 0x00080000    &#123;  ; load address = execution address   *.o (RESET, +First) ;将REST段最先放到本区，+First表示强制放到首地址   *(InRoot$$Sections) ;将ARM相关库放进来，InRoot$$Sections即ARM库的链接器标号，主要作用COPY RW区到RAM，然后再RW区后面创建ZI区。   .ANY (+RO) ;执行所有目标文件的只读属性数据  &#125;    ; RW_IRAM1执行区，地址：0x20000000，大小：0x00010000  RW_IRAM1 0x20000000 0x00010000    &#123;  ; RW data   .ANY (+RW +ZI) ;执行所有目标文件的可读可写属性及初始化为零的数据  &#125;&#125;</code></pre></div><p>以上就是sct分散加载文件的简要介绍，一般作为了解内存的分布情况，若想尝试修改区域数据存放的内存位置，可参考附件内周立功老师关于其具体使用的介绍。</p><p><ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/stm32%20sct%20file%20.zip">附件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;keil软件在编译过程中会生成分散加载文件（Scatter-Loading Description
File），它可以用来描述链接器生成映像文件时需要的信息，通过这些信息分配
Code、RO-Data，RW-Data，ZI-Data 等数据的存放地址。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sct" scheme="http://example.com/tags/sct/"/>
    
  </entry>
  
  <entry>
    <title>stm32 map文件详解</title>
    <link href="http://example.com/2023/08/09/stm32-map%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/09/stm32-map%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-09T10:25:35.000Z</published>
    <updated>2023-08-14T10:54:30.924Z</updated>
    
    <content type="html"><![CDATA[<p>MDK-ARM在编译时会生成很多类型的中间文件，最终通过这些中间文件生成可下载到MCU的hex文件。.map文件就是其中编译器链接时生成的一个文件，主要包含了交叉链接信息。</p><p>通过 .map文件，可以知晓工程中函数的大小，入口地址，变量、调用关系、FLASH 和 RAM占用空间大小等信息，根据这些信息，可以对代码进行优化。</p><p>要生成 .map 文件，需要在keil软件中进行如下相应设置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809191148933.png" alt="image-20230809191148933" style="zoom: 80%;" /></p><p>为了更好的分析 map 文件，需要了解一些基础概念：</p><ul><li>Section：描述映像文件的代码或数据块，我们简称程序段</li><li>RO：包括只读数据（RO data）和代码（RO code）两部分内容，占用 FLASH空间</li><li>RW：包含可读写数据（RW data，有初值，且不为 0），占用FLASH（存储初值）和 RAM（读写操作）</li><li>ZI：Zero initialized 的缩写，包含初始化为 0 的数据（ZI data），占用RAM 空间。</li><li>.text：相当于 RO code</li><li>.constdata：相当于 RO data</li><li>.bss：相当于 ZI data</li><li>.data：相当于 RW data</li></ul><p>使用notepad打开map文件，会发现map文件主要有 5 个组成部分：</p><ul><li><strong>程序段交叉引用关系（Section Cross References）</strong></li><li><strong>删除映像未使用的程序段（Removing Unused input sections fromthe image）</strong></li><li><strong>映像符号表（Image Symbol Table）</strong></li><li><strong>映像内存分布图（Memory Map of the image）</strong></li><li><strong>映像组件大小（Image component sizes）</strong></li></ul><p>下面分别进行介绍：</p><h4id="程序段交叉引用关系section-cross-references">1.程序段交叉引用关系（SectionCross References）</h4><p>这部分内容描述了各个文件（.c/.s等）之间函数（程序段）的调用关系。</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 1.程序段交叉引用关系</span><span class="hljs-comment"> * .o文件是.c源文件生成的中间文件，括号内是文件或函数入口地址，每句末尾表示被调用的函数或内容</span><span class="hljs-comment"> */</span>Section Cross References     startup_stm32f103xe.o(RESET) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    startup_stm32f103xe.o(RESET) refers to startup_stm32f103xe.o(.text) <span class="hljs-keyword">for</span> Reset_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.NMI_Handler) <span class="hljs-keyword">for</span> NMI_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.HardFault_Handler) <span class="hljs-keyword">for</span> HardFault_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.MemManage_Handler) <span class="hljs-keyword">for</span> MemManage_Handler    省略......    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash_ex.o(i.FLASH_OB_RDP_LevelConfig) <span class="hljs-keyword">for</span> FLASH_OB_RDP_LevelConfig    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash.o(i.FLASH_WaitForLastOperation) <span class="hljs-keyword">for</span> FLASH_WaitForLastOperation    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash.o(.bss) <span class="hljs-keyword">for</span> pFlash    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry10a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>D) <span class="hljs-keyword">for</span> __rt_final_cpp    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry11a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>F) <span class="hljs-keyword">for</span> __rt_final_exit    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry7b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000008</span>) <span class="hljs-keyword">for</span> _main_clock    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry8b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>A) <span class="hljs-keyword">for</span> _main_cpp_init    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry9a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>B) <span class="hljs-keyword">for</span> _main_init    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) <span class="hljs-keyword">for</span> _main_scatterload    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000001</span>) <span class="hljs-keyword">for</span> _main_stk    entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000001</span>) refers to entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00002712</span>) <span class="hljs-keyword">for</span> __lit__00000000    entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00002712</span>) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    entry2.o(__vectab_stack_and_reset_area) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    entry2.o(__vectab_stack_and_reset_area) refers to entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) <span class="hljs-keyword">for</span> __main    entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) refers to init.o(.text) <span class="hljs-keyword">for</span> __scatterload    entry9a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>B) refers to main.o(i.main) <span class="hljs-keyword">for</span> main    entry9b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>C) refers to main.o(i.main) <span class="hljs-keyword">for</span> main    init.o(.text) refers to entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) <span class="hljs-keyword">for</span> __main_after_scatterload</code></pre></div><h4id="删除映像未使用的程序段removing-unused-input-sections-from-the-image">2.删除映像未使用的程序段（RemovingUnused input sections from the image）</h4><p>这部分内容描述了工程中由于未被调用而被删除的冗余程序段（函数/数据）。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 2. 删除映像未使用的程序段</span><span class="hljs-comment"> * 每行显示删除的文件，位置及大小</span><span class="hljs-comment"> * 这部分最末显示删除的汇总信息。</span><span class="hljs-comment"> */</span>Removing Unused <span class="hljs-selector-tag">input</span> sections from the image.    Removing startup_stm32f103xe<span class="hljs-selector-class">.o</span>(HEAP), (<span class="hljs-number">512</span> bytes).    Removing <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>(.rev16_text), (<span class="hljs-number">4</span> bytes).    Removing <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>(.revsh_text), (<span class="hljs-number">4</span> bytes).    省略......    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_ClearConfigLine), (<span class="hljs-number">104</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_ClearPending), (<span class="hljs-number">20</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GenerateSWI), (<span class="hljs-number">20</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetConfigLine), (<span class="hljs-number">140</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetHandle), (<span class="hljs-number">12</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetPending), (<span class="hljs-number">24</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_IRQHandler), (<span class="hljs-number">36</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_RegisterCallback), (<span class="hljs-number">14</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_SetConfigLine), (<span class="hljs-number">164</span> bytes).<span class="hljs-number">226</span> unused <span class="hljs-selector-tag">section</span>(s) (total <span class="hljs-number">11022</span> bytes) removed from the image.</code></pre></div><h4 id="映像符号表image-symbol-table">3.映像符号表（Image SymbolTable）</h4><p>映像符号表（Image SymbolTable）描述了被引用的各个符号（程序段/数据）在存储器中的存储地址、类型、大小等信息。映像符号表分为两类：本地符号（LocalSymbols）和全局符号（Global Symbols）。</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 3. 映像符号表</span><span class="hljs-comment"> * 映像符号包括Local Symbols（本地符号）和Global Symbols（全局符号）</span><span class="hljs-comment"> * 每行描述映像符号的名称、地址、类型、大小及生成目标。</span><span class="hljs-comment"> */</span>Image Symbol Table    Local Symbols    Symbol Name                              Value     Ov Type        Size  <span class="hljs-built_in">Object</span>(Section)    ../Core/Src/dma<span class="hljs-selector-class">.c</span>                        <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  dma<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/gpio<span class="hljs-selector-class">.c</span>                       <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  gpio<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>                       <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/stm32f1xx_hal_msp<span class="hljs-selector-class">.c</span>          <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_msp<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/stm32f1xx_it<span class="hljs-selector-class">.c</span>               <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_it<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/system_stm32f1xx<span class="hljs-selector-class">.c</span>           <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  system_stm32f1xx<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/usart<span class="hljs-selector-class">.c</span>                      <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  usart<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_cortex<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_cortex<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_dma<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_dma<span class="hljs-selector-class">.o</span> ABSOLUTE    省略......    Global Symbols    Symbol Name                              Value     Ov Type        Size  <span class="hljs-built_in">Object</span>(Section)    BuildAttributes$<span class="hljs-variable">$THM_ISAv4</span><span class="hljs-variable">$P</span><span class="hljs-variable">$D</span><span class="hljs-variable">$K</span><span class="hljs-variable">$B</span><span class="hljs-variable">$S</span><span class="hljs-variable">$PE</span><span class="hljs-variable">$A</span>:L22UL41UL21<span class="hljs-variable">$X</span>:L11<span class="hljs-variable">$S22US41US21</span><span class="hljs-variable">$IEEE1</span><span class="hljs-variable">$IW</span><span class="hljs-variable">$USESV6</span>$~STKCKD<span class="hljs-variable">$USESV7</span>$~SHL<span class="hljs-variable">$OSPACE</span><span class="hljs-variable">$EBA8</span><span class="hljs-variable">$MICROLIB</span><span class="hljs-variable">$REQ8</span><span class="hljs-variable">$PRES8</span><span class="hljs-variable">$EABIv2</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  anon$<span class="hljs-variable">$obj</span><span class="hljs-selector-class">.o</span> ABSOLUTE    __ARM_use_no_argv                        <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> ABSOLUTE    __cpp_initialize__aeabi_                  - Undefined Weak Reference    __cxa_finalize                            - Undefined Weak Reference    __decompress                              - Undefined Weak Reference    _clock_init                               - Undefined Weak Reference    _microlib_exit                            - Undefined Weak Reference    __Vectors_Size                           <span class="hljs-number">0</span>x00000130   Number         <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span> ABSOLUTE    __Vectors                                <span class="hljs-number">0</span>x08000000   Data           <span class="hljs-number">4</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(RESET)    __Vectors_End                            <span class="hljs-number">0</span>x08000130   Data           <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(RESET)    __main                                   <span class="hljs-number">0</span>x08000131   Thumb Code     <span class="hljs-number">0</span>  entry<span class="hljs-selector-class">.o</span>(<span class="hljs-selector-class">.ARM</span>.Collect$$$$<span class="hljs-number">00000000</span>)    _main_stk                                <span class="hljs-number">0</span>x08000131   Thumb Code     <span class="hljs-number">0</span>  entry2<span class="hljs-selector-class">.o</span>(<span class="hljs-selector-class">.ARM</span>.Collect$$$$<span class="hljs-number">00000001</span>)    省略......    SystemCoreClock                          <span class="hljs-number">0</span>x20000030   Data           <span class="hljs-number">4</span>  system_stm32f1xx<span class="hljs-selector-class">.o</span>(.data)    uwTickFreq                               <span class="hljs-number">0</span>x20000034   Data           <span class="hljs-number">1</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    uwTickPrio                               <span class="hljs-number">0</span>x20000038   Data           <span class="hljs-number">4</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    uwTick                                   <span class="hljs-number">0</span>x2000003c   Data           <span class="hljs-number">4</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    huart1                                   <span class="hljs-number">0</span>x20000040   Data          <span class="hljs-number">72</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    hdma_usart1_rx                           <span class="hljs-number">0</span>x20000088   Data          <span class="hljs-number">68</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    hdma_usart1_tx                           <span class="hljs-number">0</span>x200000cc   Data          <span class="hljs-number">68</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    __initial_sp                             <span class="hljs-number">0</span>x20000510   Data           <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(STACK)</code></pre></div><h4 id="映像内存分布图memory-map-of-the-image">4.映像内存分布图（MemoryMap of the image）</h4><p>映像文件分为加载域（Load Region）和运行域（ExecutionRegion），一个加载域必须有至少一个运行域（可以有多个运行域），而一个程序又可以有多个加载域。加载域为映像程序的实际存储区域，而运行域则是MCU上电后的运行状态。加载域和运行域的简化关系（这里仅表示一个加载域的情况）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809213411201.png" alt="image-20230809213411201" style="zoom:80%;" /></p><div class="code-wrapper"><pre><code class="hljs dns">/* * <span class="hljs-number">4</span>. 映像内存分布图 * 映像文件分为加载域（Load Region）和运行域（Execution Region）。 */Memory Map of the image  /* 映象入口地址 */  Image Entry point : <span class="hljs-number">0x08000131</span>     /* LR_IROM1加载域地址及大小 */  Load Region LR_IROM1 (Base: <span class="hljs-number">0x08000000</span>, Size: <span class="hljs-number">0</span>x<span class="hljs-number">000017c8</span>, Max: <span class="hljs-number">0x00080000</span>, ABSOLUTE)     /* ER_IROM1运行域地址及大小 */  Execution Region ER_IROM1 (Base: <span class="hljs-number">0x08000000</span>, Size: <span class="hljs-number">0x00001788</span>, Max: <span class="hljs-number">0x00080000</span>, ABSOLUTE)     Base Addr    Size         Type   Attr      Idx    E Section Name        Object    <span class="hljs-number">0x08000000</span>   <span class="hljs-number">0x00000130</span>   Data   RO            <span class="hljs-number">3</span>    RESET               startup_stm32f103xe.o    <span class="hljs-number">0x08000130</span>   <span class="hljs-number">0x00000000</span>   Code   RO         <span class="hljs-number">1809</span>  * .ARM.Collect$$$$<span class="hljs-number">00000000</span>  mc_w.l(entry.o)    <span class="hljs-number">0x08000130</span>   <span class="hljs-number">0x00000004</span>   Code   RO         <span class="hljs-number">1816</span>    .ARM.Collect$$$$<span class="hljs-number">00000001</span>  mc_w.l(entry2.o)    <span class="hljs-number">0x08000134</span>   <span class="hljs-number">0x00000004</span>   Code   RO         <span class="hljs-number">1819</span>    .ARM.Collect$$$$<span class="hljs-number">00000004</span>  mc_w.l(entry5.o)    省略......    <span class="hljs-number">0x08001708</span>   <span class="hljs-number">0x00000034</span>   Code   RO           <span class="hljs-number">15</span>    i.main              main.o    <span class="hljs-number">0</span>x0800173c   <span class="hljs-number">0x00000010</span>   Data   RO          <span class="hljs-number">364</span>    .constdata          system_stm32f1xx.o    <span class="hljs-number">0</span>x0800174c   <span class="hljs-number">0x00000008</span>   Data   RO          <span class="hljs-number">365</span>    .constdata          system_stm32f1xx.o    <span class="hljs-number">0x08001754</span>   <span class="hljs-number">0x00000012</span>   Data   RO         <span class="hljs-number">1023</span>    .constdata          stm32f1xx_hal_rcc.o    <span class="hljs-number">0x08001766</span>   <span class="hljs-number">0x00000002</span>   PAD    <span class="hljs-number">0x08001768</span>   <span class="hljs-number">0x00000020</span>   Data   RO         <span class="hljs-number">1832</span>    Region$$Table       anon$$obj.o    /* RW_IRAM1运行域，地址，大小 */    Execution Region RW_IRAM1 (Base: <span class="hljs-number">0x20000000</span>, Size: <span class="hljs-number">0x00000510</span>, Max: <span class="hljs-number">0x00010000</span>, ABSOLUTE)     Base Addr    Size         Type   Attr      Idx    E Section Name        Object    <span class="hljs-number">0x20000000</span>   <span class="hljs-number">0</span>x0000002f   Data   RW           <span class="hljs-number">16</span>    .data               main.o    <span class="hljs-number">0</span>x2000002f   <span class="hljs-number">0x00000001</span>   PAD    <span class="hljs-number">0x20000030</span>   <span class="hljs-number">0x00000004</span>   Data   RW          <span class="hljs-number">366</span>    .data               system_stm32f1xx.o    <span class="hljs-number">0x20000034</span>   <span class="hljs-number">0</span>x0000000c   Data   RW          <span class="hljs-number">860</span>    .data               stm32f1xx_hal.o    <span class="hljs-number">0x20000040</span>   <span class="hljs-number">0</span>x<span class="hljs-number">000000d0</span>   Zero   RW          <span class="hljs-number">200</span>    .bss                usart.o    <span class="hljs-number">0x20000110</span>   <span class="hljs-number">0x00000400</span>   Zero   RW            <span class="hljs-number">1</span>    STACK               startup_stm32f103xe.o</code></pre></div><h4 id="映像组件大小image-component-sizes">5.映像组件大小（Imagecomponent sizes）</h4><p>各文件编译后所占代码空间的大小，keilIDE编译后输出框显示的文件占用空间大小与此部分一致。</p><div class="code-wrapper"><pre><code class="hljs tap">/* * 5. 映像组件大小 * 文件编译后所占代码空间的大小。 */Image component sizes/* 代码大小(内联函数大小) 只读大小  读写大小  零初始化大小  调试大小  文件名 */      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name       <span class="hljs-number"> 60 </span>        <span class="hljs-number"> 4 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 682 </span>  dma.o       <span class="hljs-number"> 28 </span>        <span class="hljs-number"> 6 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 663 </span>  gpio.o      <span class="hljs-number"> 150 </span>       <span class="hljs-number"> 10 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 47 </span>        <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 455148 </span>  main.o       <span class="hljs-number"> 36 </span>        <span class="hljs-number"> 8 </span>      <span class="hljs-number"> 304 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1024 </span>      <span class="hljs-number"> 760 </span>  startup_stm32f103xe.o      <span class="hljs-number"> 164 </span>       <span class="hljs-number"> 28 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 12 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 6105 </span>  stm32f1xx_hal.o      <span class="hljs-number"> 198 </span>       <span class="hljs-number"> 14 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 28331 </span>  stm32f1xx_hal_cortex.o     <span class="hljs-number"> 1236 </span>       <span class="hljs-number"> 52 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4358 </span>  stm32f1xx_hal_dma.o      <span class="hljs-number"> 504 </span>       <span class="hljs-number"> 42 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1928 </span>  stm32f1xx_hal_gpio.o       <span class="hljs-number"> 60 </span>        <span class="hljs-number"> 8 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 786 </span>  stm32f1xx_hal_msp.o     <span class="hljs-number"> 1240 </span>       <span class="hljs-number"> 84 </span>       <span class="hljs-number"> 18 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4604 </span>  stm32f1xx_hal_rcc.o     <span class="hljs-number"> 1500 </span>       <span class="hljs-number"> 24 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 10186 </span>  stm32f1xx_hal_uart.o       <span class="hljs-number"> 56 </span>       <span class="hljs-number"> 18 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4700 </span>  stm32f1xx_it.o        <span class="hljs-number"> 2 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 24 </span>        <span class="hljs-number"> 4 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 987 </span>  system_stm32f1xx.o      <span class="hljs-number"> 276 </span>       <span class="hljs-number"> 30 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 208 </span>     <span class="hljs-number"> 1728 </span>  usart.o    -------------------------------------------------------------------<span class="language-yaml"><span class="hljs-meta">---</span></span><span class="language-yaml">      <span class="hljs-number">5522        </span><span class="hljs-number">328</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">520966</span>   <span class="hljs-string">Object</span> <span class="hljs-string">Totals</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>         <span class="hljs-number">32</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Generated)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器生成的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">        <span class="hljs-number">12</span>          <span class="hljs-number">0</span>          <span class="hljs-number">2</span>          <span class="hljs-number">1</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Padding)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器填充的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span>  <span class="hljs-string">库文件名</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Member</span> <span class="hljs-string">Name</span></span><span class="language-yaml"></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry10a.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry11a.o</span></span><span class="language-yaml">         <span class="hljs-number">8</span>          <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry2.o</span></span><span class="language-yaml">         <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry5.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry7b.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry8b.o</span></span><span class="language-yaml">         <span class="hljs-number">8</span>          <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry9a.o</span></span><span class="language-yaml">        <span class="hljs-number">30</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">handlers.o</span></span><span class="language-yaml">        <span class="hljs-number">36</span>          <span class="hljs-number">8</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>         <span class="hljs-number">68</span>   <span class="hljs-string">init.o</span></span><span class="language-yaml">        <span class="hljs-number">36</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">108</span>   <span class="hljs-string">memseta.o</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Totals</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Padding)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器填充的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span>  <span class="hljs-string">库文件名</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Name</span></span><span class="language-yaml"></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">mc_w.l</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Totals</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   </span><span class="language-yaml"></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">518434</span>   <span class="hljs-string">Grand</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">整个映像大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">518434</span>   <span class="hljs-string">ELF</span> <span class="hljs-string">Image</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">ELF可执行格式映像大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">ROM</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">整个ROM大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">RO</span>  <span class="hljs-string">Size</span> <span class="hljs-string">(Code</span> <span class="hljs-string">+</span> <span class="hljs-string">RO</span> <span class="hljs-string">Data)</span>                 <span class="hljs-number">6024</span> <span class="hljs-string">(</span>   <span class="hljs-number">5.</span><span class="hljs-string">88kB)</span></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">RW</span>  <span class="hljs-string">Size</span> <span class="hljs-string">(RW</span> <span class="hljs-string">Data</span> <span class="hljs-string">+</span> <span class="hljs-string">ZI</span> <span class="hljs-string">Data)</span>              <span class="hljs-number">1296</span> <span class="hljs-string">(</span>   <span class="hljs-number">1.</span><span class="hljs-string">27kB)</span></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">ROM</span> <span class="hljs-string">Size</span> <span class="hljs-string">(Code</span> <span class="hljs-string">+</span> <span class="hljs-string">RO</span> <span class="hljs-string">Data</span> <span class="hljs-string">+</span> <span class="hljs-string">RW</span> <span class="hljs-string">Data)</span>       <span class="hljs-number">6088</span> <span class="hljs-string">(</span>   <span class="hljs-number">5.</span><span class="hljs-string">95kB)</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span></code></pre></div><p>Code是代码区，RO-data 代表常量区，RW-data代表已初始化的全局变量和静态变量，属于静态区（全局区），ZI-data代表未初始化但被编译器初始化为0的全局变量和静态变量，属于静态区（全局区）。</p><p><ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/stm32_map_file.zip">haluart map文件与正点原子详解附件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MDK-ARM在编译时会生成很多类型的中间文件，最终通过这些中间文件生成可下载到MCU的hex文件。.map
文件就是其中编译器链接时生成的一个文件，主要包含了交叉链接信息。&lt;/p&gt;
&lt;p&gt;通过 .map
文件，可以知晓工程中函数的大小，入口地址，变量、调用关系、FL</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="map" scheme="http://example.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>stm32启动文件详解</title>
    <link href="http://example.com/2023/08/08/stm32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/08/08/stm32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-08-08T04:30:03.000Z</published>
    <updated>2023-08-09T10:00:07.283Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道程序一般是从<code>main</code>函数开始运行的，但在<code>main</code>函数运行之前，程序已经做了一些准备工作，对于STM32F1芯片，这些准备工作是通过启动文件来完成的。下面来详细看看stm32库中的启动代码文件（STM32Cube_FW_F1_V1.8.532F1xx_stm32f103xe.s）。</p><p>启动文件是由汇编语言编写，是系统上电复位后第一个执行的程序。首先我们来看看启动文件使用的ARM汇编指令：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809173349258.png"alt="image-20230809173349258" /><figcaption aria-hidden="true">image-20230809173349258</figcaption></figure><p>整个启动文件主要做了以下操作：</p><ul><li>**设置初始化堆栈指针SP = _initial_sp**</li><li><strong>设置初始化计数器指针PC = Reset_Handler</strong></li><li><strong>设置堆栈大小</strong></li><li><strong>初始化中断向量表</strong></li><li><strong>调用 SystemInit() 函数初始化系统时钟</strong></li><li>**跳转到C库中的 __main函数初始化用户堆栈（最终调用main()函数）**</li></ul><div class="code-wrapper"><pre><code class="hljs assembly">;1-栈 ######;开辟栈的大小为 0X00000400（1K字节），名字为 STACK， NOINIT 即不初始化，可读可写， 8（2^3）字节对齐。;标号__initial_sp 表示栈的结束地址，即栈顶地址，栈是由高向低生长的。; Amount of memory (in bytes) allocated for Stack  ; Tailor this value to your application needs    ; &lt;h&gt; Stack Configuration   ;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;   ; &lt;/h&gt;Stack_Size      EQU     0x00000400                    AREA    STACK, NOINIT, READWRITE, ALIGN=3  Stack_Mem       SPACE   Stack_Size   __initial_sp</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;2-堆 ######;开辟堆的大小为 0X00000200（512字节），名字为 HEAP， 不初始化，可读可写， 8（2^3）字节对齐。;标号__heap_base 表示堆的起始地址， __heap_limit 表示堆的结束地址。堆是由低向高生长的，跟栈的生长方向相反。                                                  ; &lt;h&gt; Heap Configuration  ;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;  ; &lt;/h&gt;Heap_Size       EQU     0x00000200                  AREA    HEAP, NOINIT, READWRITE, ALIGN=3 __heap_baseHeap_Mem        SPACE   Heap_Size__heap_limit</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;3-向量表; 定义一个名为RESET的数据段，只读，并声明三个全局属性的标号 __Vectors、 __Vectors_End 和__Vectors_Size; Vector Table Mapped to Address 0 at Reset                AREA    RESET, DATA, READONLY                EXPORT  __Vectors                EXPORT  __Vectors_End                EXPORT  __Vectors_Size__Vectors       DCD     __initial_sp               ; Top of Stack #栈顶                DCD     Reset_Handler              ; Reset Handler                DCD     NMI_Handler                ; NMI Handler                DCD     HardFault_Handler          ; Hard Fault Handler                DCD     MemManage_Handler          ; MPU Fault Handler                DCD     BusFault_Handler           ; Bus Fault Handler                DCD     UsageFault_Handler         ; Usage Fault Handler                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     SVC_Handler                ; SVCall Handler                DCD     DebugMon_Handler           ; Debug Monitor Handler                DCD     0                          ; Reserved                DCD     PendSV_Handler             ; PendSV Handler                DCD     SysTick_Handler            ; SysTick Handler                ; External Interrupts #外部中断                DCD     WWDG_IRQHandler            ; Window Watchdog                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect                DCD     TAMPER_IRQHandler          ; Tamper                DCD     RTC_IRQHandler             ; RTC                DCD     FLASH_IRQHandler           ; Flash                DCD     RCC_IRQHandler             ; RCC                DCD     EXTI0_IRQHandler           ; EXTI Line 0                DCD     EXTI1_IRQHandler           ; EXTI Line 1                DCD     EXTI2_IRQHandler           ; EXTI Line 2                DCD     EXTI3_IRQHandler           ; EXTI Line 3                DCD     EXTI4_IRQHandler           ; EXTI Line 4                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7                DCD     ADC1_2_IRQHandler          ; ADC1 &amp; ADC2                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break                DCD     TIM1_UP_IRQHandler         ; TIM1 Update                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare                DCD     TIM2_IRQHandler            ; TIM2                DCD     TIM3_IRQHandler            ; TIM3                DCD     TIM4_IRQHandler            ; TIM4                DCD     I2C1_EV_IRQHandler         ; I2C1 Event                DCD     I2C1_ER_IRQHandler         ; I2C1 Error                DCD     I2C2_EV_IRQHandler         ; I2C2 Event                DCD     I2C2_ER_IRQHandler         ; I2C2 Error                DCD     SPI1_IRQHandler            ; SPI1                DCD     SPI2_IRQHandler            ; SPI2                DCD     USART1_IRQHandler          ; USART1                DCD     USART2_IRQHandler          ; USART2                DCD     USART3_IRQHandler          ; USART3                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10                DCD     RTC_Alarm_IRQHandler        ; RTC Alarm through EXTI Line                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break                DCD     TIM8_UP_IRQHandler         ; TIM8 Update                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare                DCD     ADC3_IRQHandler            ; ADC3                DCD     FSMC_IRQHandler            ; FSMC                DCD     SDIO_IRQHandler            ; SDIO                DCD     TIM5_IRQHandler            ; TIM5                DCD     SPI3_IRQHandler            ; SPI3                DCD     UART4_IRQHandler           ; UART4                DCD     UART5_IRQHandler           ; UART5                DCD     TIM6_IRQHandler            ; TIM6                DCD     TIM7_IRQHandler            ; TIM7                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5__Vectors_End__Vectors_Size  EQU  __Vectors_End - __Vectors</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;4-复位中断程序，系统上电后第一个要执行的程序;调用外部 SystemInit() 函数初始化系统时钟，然后调用 C 库函数_mian()，最终调用 main()函数去到 C 的世界。               ; Reset handlerReset_Handler   PROC                EXPORT  Reset_Handler             [WEAK]                IMPORT  __main                IMPORT  SystemInit                LDR     R0, =SystemInit                BLX     R0                               LDR     R0, =__main                BX      R0                ENDP</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;5-空的中断服务函数，[WEAK]弱声明无限循环函数，用户可以对其进行重定义。             ; Dummy Exception Handlers (infinite loops which can be modified)NMI_Handler     PROC                EXPORT  NMI_Handler                [WEAK]                B       .                ENDPHardFault_Handler\                PROC                EXPORT  HardFault_Handler          [WEAK]                B       .                ENDPMemManage_Handler\                PROC                EXPORT  MemManage_Handler          [WEAK]                B       .                ENDPBusFault_Handler\                PROC                EXPORT  BusFault_Handler           [WEAK]                B       .                ENDPUsageFault_Handler\                PROC                EXPORT  UsageFault_Handler         [WEAK]                B       .                ENDPSVC_Handler     PROC                EXPORT  SVC_Handler                [WEAK]                B       .                ENDPDebugMon_Handler\                PROC                EXPORT  DebugMon_Handler           [WEAK]                B       .                ENDPPendSV_Handler  PROC                EXPORT  PendSV_Handler             [WEAK]                B       .                ENDPSysTick_Handler PROC                EXPORT  SysTick_Handler            [WEAK]                B       .                ENDPDefault_Handler PROC                EXPORT  WWDG_IRQHandler            [WEAK]                EXPORT  PVD_IRQHandler             [WEAK]                EXPORT  TAMPER_IRQHandler          [WEAK]                EXPORT  RTC_IRQHandler             [WEAK]                EXPORT  FLASH_IRQHandler           [WEAK]                EXPORT  RCC_IRQHandler             [WEAK]                EXPORT  EXTI0_IRQHandler           [WEAK]                EXPORT  EXTI1_IRQHandler           [WEAK]                EXPORT  EXTI2_IRQHandler           [WEAK]                EXPORT  EXTI3_IRQHandler           [WEAK]                EXPORT  EXTI4_IRQHandler           [WEAK]                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]                EXPORT  ADC1_2_IRQHandler          [WEAK]                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]                EXPORT  CAN1_RX1_IRQHandler        [WEAK]                EXPORT  CAN1_SCE_IRQHandler        [WEAK]                EXPORT  EXTI9_5_IRQHandler         [WEAK]                EXPORT  TIM1_BRK_IRQHandler        [WEAK]                EXPORT  TIM1_UP_IRQHandler         [WEAK]                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]                EXPORT  TIM1_CC_IRQHandler         [WEAK]                EXPORT  TIM2_IRQHandler            [WEAK]                EXPORT  TIM3_IRQHandler            [WEAK]                EXPORT  TIM4_IRQHandler            [WEAK]                EXPORT  I2C1_EV_IRQHandler         [WEAK]                EXPORT  I2C1_ER_IRQHandler         [WEAK]                EXPORT  I2C2_EV_IRQHandler         [WEAK]                EXPORT  I2C2_ER_IRQHandler         [WEAK]                EXPORT  SPI1_IRQHandler            [WEAK]                EXPORT  SPI2_IRQHandler            [WEAK]                EXPORT  USART1_IRQHandler          [WEAK]                EXPORT  USART2_IRQHandler          [WEAK]                EXPORT  USART3_IRQHandler          [WEAK]                EXPORT  EXTI15_10_IRQHandler       [WEAK]                EXPORT  RTC_Alarm_IRQHandler        [WEAK]                EXPORT  USBWakeUp_IRQHandler       [WEAK]                EXPORT  TIM8_BRK_IRQHandler        [WEAK]                EXPORT  TIM8_UP_IRQHandler         [WEAK]                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]                EXPORT  TIM8_CC_IRQHandler         [WEAK]                EXPORT  ADC3_IRQHandler            [WEAK]                EXPORT  FSMC_IRQHandler            [WEAK]                EXPORT  SDIO_IRQHandler            [WEAK]                EXPORT  TIM5_IRQHandler            [WEAK]                EXPORT  SPI3_IRQHandler            [WEAK]                EXPORT  UART4_IRQHandler           [WEAK]                EXPORT  UART5_IRQHandler           [WEAK]                EXPORT  TIM6_IRQHandler            [WEAK]                EXPORT  TIM7_IRQHandler            [WEAK]                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]WWDG_IRQHandlerPVD_IRQHandlerTAMPER_IRQHandlerRTC_IRQHandlerFLASH_IRQHandlerRCC_IRQHandlerEXTI0_IRQHandlerEXTI1_IRQHandlerEXTI2_IRQHandlerEXTI3_IRQHandlerEXTI4_IRQHandlerDMA1_Channel1_IRQHandlerDMA1_Channel2_IRQHandlerDMA1_Channel3_IRQHandlerDMA1_Channel4_IRQHandlerDMA1_Channel5_IRQHandlerDMA1_Channel6_IRQHandlerDMA1_Channel7_IRQHandlerADC1_2_IRQHandlerUSB_HP_CAN1_TX_IRQHandlerUSB_LP_CAN1_RX0_IRQHandlerCAN1_RX1_IRQHandlerCAN1_SCE_IRQHandlerEXTI9_5_IRQHandlerTIM1_BRK_IRQHandlerTIM1_UP_IRQHandlerTIM1_TRG_COM_IRQHandlerTIM1_CC_IRQHandlerTIM2_IRQHandlerTIM3_IRQHandlerTIM4_IRQHandlerI2C1_EV_IRQHandlerI2C1_ER_IRQHandlerI2C2_EV_IRQHandlerI2C2_ER_IRQHandlerSPI1_IRQHandlerSPI2_IRQHandlerUSART1_IRQHandlerUSART2_IRQHandlerUSART3_IRQHandlerEXTI15_10_IRQHandlerRTC_Alarm_IRQHandlerUSBWakeUp_IRQHandlerTIM8_BRK_IRQHandlerTIM8_UP_IRQHandlerTIM8_TRG_COM_IRQHandlerTIM8_CC_IRQHandlerADC3_IRQHandlerFSMC_IRQHandlerSDIO_IRQHandlerTIM5_IRQHandlerSPI3_IRQHandlerUART4_IRQHandlerUART5_IRQHandlerTIM6_IRQHandlerTIM7_IRQHandlerDMA2_Channel1_IRQHandlerDMA2_Channel2_IRQHandlerDMA2_Channel3_IRQHandlerDMA2_Channel4_5_IRQHandler                B       .                ENDP                ALIGN</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;6-将堆栈地址传递给C库函数_main()，利用C库函数初始化堆栈或由用户自己初始化堆栈。;*******************************************************************************; User Stack and Heap initialization;*******************************************************************************                 IF      :DEF:__MICROLIB  ;#keil-MDK IDE勾选MicroLIB宏                ;#赋予以下三个标号全局属性                 EXPORT  __initial_sp                 EXPORT  __heap_base                 EXPORT  __heap_limit                                 ELSE        ;#keil-MDK IDE没有勾选MicroLIB宏                                 IMPORT  __use_two_region_memory ;#导入双段存储器模式，需要用户自己实现。                 EXPORT  __user_initial_stackheap ;#赋予标号__user_initial_stackheap全局属性                 __user_initial_stackheap                 LDR     R0, =  Heap_Mem                 LDR     R1, =(Stack_Mem + Stack_Size)                 LDR     R2, = (Heap_Mem +  Heap_Size)                 LDR     R3, = Stack_Mem                 BX      LR                 ALIGN</code></pre></div><p><ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/startup_stm32f103xe.zip">启动文件与正点原子详解附件</a></p><p>参考链接：</p><p>https://www.elecfans.com/news/1802838.html</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道程序一般是从&lt;code&gt;main&lt;/code&gt;函数开始运行的，但在&lt;code&gt;main&lt;/code&gt;函数运行之前，程序已经做了一些准备工作，对于STM32F1芯片，这些准备工作是通过启动文件来完成的。下面来详细看看stm32库中的启动代码文件（STM32Cube_F</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="startup" scheme="http://example.com/tags/startup/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_sd库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T10:30:31.000Z</published>
    <updated>2023-08-14T00:03:33.381Z</updated>
    
    <content type="html"><![CDATA[<p>SecureDigital,简称SD,SD内存卡是一种使用非常广泛的存储设备，以下来看看HAL库关于SD卡的使用方法。</p><h3 id="sd外设库的使用">SD外设库的使用</h3><p>这是一个通用分层的SDIO存储驱动，它使用HALSDIO驱动函数来连接SD内存卡。</p><p><strong>1. 初始化SDIO底层。HAL_SD_MspInit()</strong></p><ul><li>使能SDIO接口时钟。__HAL_RCC_SDIO_CLK_ENABLE()</li><li>配置SDIO引脚<ul><li>使能SDIO GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置SDIO引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_SD_ReadBlocks_DMA() ，HAL_SD_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDIO和DMA中断优先级，DMA优先级高于SDIO。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code>， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code>，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_SD_ReadBlocks_IT()，HAL_SD_WriteBlocks_IT()<ul><li>配置SDIO中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code>， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code>，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. SD卡的初始化和配置</strong></p><p>使用HAL_SD_Init()函数来初始化SD卡，并进入睡眠状态（已准备好数据传输）。SD卡初始化后，就可以执行SD卡的读、写、擦除操作。</p><ul><li><p>以400KHz的频率配置初始化SD卡。</p><p>SD卡频率：SDIO_CK = SDIOCLK / (ClockDiv + 2)；</p><p>初始化时，根据SD卡标准，确保SDIO_CK频率不要超过400KHz，通过SDIO底层函数SDIO_Init()和SDIO_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化SD卡。HAL_SD_InitCard()</p><p>这个函数用于初始化和识别SDIO及检查SD卡的类型（标准容量或高容量），此初始化流程与SD卡标准兼容。这个函数也可以在插拔时重新初始化SD卡。</p></li><li><p>配置SD卡数据传输频率，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据SD卡标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDIO外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的SD卡。</p></li><li><p>配置SD卡宽总线模式：4位数据。</p></li></ul><p><strong>3. SD卡的读操作</strong></p><ul><li><p>轮询模式下读取SD卡。HAL_SD_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态。</p></li><li><p>DMA模式下读取SD卡。HAL_SD_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDRx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取SD卡。HAL_SD_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDRx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. SD卡的写操作</strong></p><ul><li><p>轮询模式下向SD卡写操作。HAL_SD_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD卡的状态。</p></li><li><p>DMA模式下向SD卡写操作。HAL_SD_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDTx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向SD卡写操作。HAL_SD_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_SD_GetCardState()函数来检查SD的状态，通过SDTx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取SD卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取SD卡信息。HAL_SDIO_GetCardInfo()</p><p>它会返回关于SD卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_SDIO_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_SDIO_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="sd-hal常用宏定义列表">SD HAL常用宏定义列表</h3><ul><li><p>__HAL_SD_ENABLE : 使能 SD设备</p></li><li><p>__HAL_SD_DISABLE : 禁止 SD 设备</p></li><li><p>__HAL_SD_DMA_ENABLE: 使能 SD DMA 传输</p></li><li><p>__HAL_SD_DMA_DISABLE: 禁止 SD DMA 传输</p></li><li><p>__HAL_SD_ENABLE_IT: 使能 SD 设备中断</p></li><li><p>__HAL_SD_DISABLE_IT: 禁止 SD 设备中断</p></li><li><p>__HAL_SD_GET_FLAG:检查 SD 标志是否设置</p></li><li><p>__HAL_SD_CLEAR_FLAG: 清除 SD 的挂起标志</p></li></ul><h3 id="sd回调函数的注册">SD回调函数的注册</h3><p>当 USE_HAL_SD_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SD_RegisterCallback(),HAL_SD_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>ErrorCallback : 发生错误回调函数</li><li>AbortCpltCallback : 中止完成回调函数</li><li>MspInitCallback : SD 相关MCU初始化回调函数</li><li>MspDeInitCallback : SD 相关MCU去初始化回调函数</li></ul><p>默认情况下, SD 初始化（HAL_SD_Init()）后，当状态是HAL_SD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SD_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Secure
Digital,简称SD,SD内存卡是一种使用非常广泛的存储设备，以下来看看HAL库关于SD卡的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;sd外设库的使用&quot;&gt;SD外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用分层的SDIO存储驱动，它使用HAL
SDIO驱动函数</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sd" scheme="http://example.com/tags/sd/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_mmc库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T09:30:31.000Z</published>
    <updated>2023-08-14T00:03:33.327Z</updated>
    
    <content type="html"><![CDATA[<p>MultiMediaCard,简称MMC,它属于SD卡的一种，是一种一体化、可拆卸、多功能的内存卡,以下来看看HAL库关于MMC的使用方法。</p><h3 id="mmc外设库的使用">MMC外设库的使用</h3><p>这是一个通用分层的MMC存储器驱动，它使用HAL SDMMC驱动函数来连接MMC和eMMC卡。</p><p><strong>1. 初始化MMC底层。HAL_MMC_MspInit()</strong></p><ul><li>使能MMC接口时钟。__HAL_RCC_SDMMC_CLK_ENABLE()</li><li>配置MMC引脚<ul><li>使能MMC GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置MMC引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_MMC_ReadBlocks_DMA() ，HAL_MMC_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDMMC和DMA中断优先级，DMA优先级高于SDMMC。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code>， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code>，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_MMC_ReadBlocks_IT()，HAL_MMC_WriteBlocks_IT()<ul><li>配置SDMMC中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code>， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code>，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. MMC的初始化和配置</strong></p><p>使用HAL_MMC_Init()函数来初始化SDMMC，并进入睡眠状态（已准备好数据传输）。MMC卡初始化后，就可以执行MMC读、写、擦除操作。</p><ul><li><p>使用默认配置初始化SDMMC外设接口。默认频率：400KHz。</p><p>MMC频率：SDMMC_CK = SDMMCCLK / (ClockDiv + 2)；</p><p>初始化时，根据MMC标准，确保SDMMC_CK频率不要超过400KHz，通过SDMMC底层函数SDMMC_Init()和SDMMC_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化MMC卡。HAL_MMC_InitCard()</p><p>这个函数用于初始化和识别MMC及检查MMC卡的类型（标准容量或高容量），此初始化流程与MMC标准兼容。这个函数也可以在插拔时重新初始化MMC卡。</p></li><li><p>配置MMC卡数据传输频率，默认传输频率是24MHz，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据MMC标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDMMC外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的MMC卡。</p></li><li><p>配置MMC宽总线模式：4位数据。</p></li></ul><p><strong>3. MMC的读操作</strong></p><ul><li><p>轮询模式下读取MMC卡。HAL_MMC_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下读取MMC卡。HAL_MMC_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCRx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取MMC卡。HAL_MMC_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCRx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. MMC的写操作</strong></p><ul><li><p>轮询模式下向MMC卡写操作。HAL_MMC_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下向MMC卡写操作。HAL_MMC_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCTx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向MMC卡写操作。HAL_MMC_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整"NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMCTx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取MMC卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取MMC卡信息。HAL_MMC_GetCardInfo()</p><p>它会返回关于MMC卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_MMC_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_MMC_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="mmc-hal常用宏定义列表">MMC HAL常用宏定义列表</h3><ul><li><p>__HAL_MMC_ENABLE : 使能 MMC设备</p></li><li><p>__HAL_MMC_DISABLE : 禁止 MMC 设备</p></li><li><p>__HAL_MMC_DMA_ENABLE: 使能 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_DMA_DISABLE: 禁止 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_ENABLE_IT: 使能 MMC 设备中断</p></li><li><p>__HAL_MMC_DISABLE_IT: 禁止 MMC 设备中断</p></li><li><p>__HAL_MMC_GET_FLAG:检查 MMC 标志是否设置</p></li><li><p>__HAL_MMC_CLEAR_FLAG: 清除 MMC 的挂起标志</p></li></ul><h3 id="mmc回调函数的注册">MMC回调函数的注册</h3><p>当 USE_HAL_MMC_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_MMC_RegisterCallback(),HAL_MMC_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>ErrorCallback : 发生错误回调函数</li><li>AbortCpltCallback : 中止完成回调函数</li><li>MspInitCallback : MMC 相关MCU初始化回调函数</li><li>MspDeInitCallback : MMC 相关MCU去初始化回调函数</li></ul><p>默认情况下, MMC 初始化（HAL_MMC_Init()）后，当状态是HAL_MMC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_MMC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_MMC_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MultiMediaCard,简称MMC,它属于SD卡的一种，是一种一体化、可拆卸、多功能的内存卡,以下来看看HAL库关于MMC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;mmc外设库的使用&quot;&gt;MMC外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用分层的MMC存储器驱动，它使用HA</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="mmc" scheme="http://example.com/tags/mmc/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_nor库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T04:15:11.000Z</published>
    <updated>2023-08-14T00:03:33.347Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于Nor flash存储器的使用方法。</p><h3 id="nor存储器外设库的使用">NOR存储器外设库的使用</h3><p>此驱动是一个通用的分层驱动程序，包含一组用于控制NOR闪存的API。它使用FSMC层函数来连接NOR闪存。</p><ol type="1"><li><p>配置NOR flash 存储器的控制和时序参数。HAL_NOR_Init()</p></li><li><p>读取NOR flash 存储器制造商和设备ID。HAL_NOR_Read_ID()</p><p>读取的信息存储在函数调用的NOR_ID_TypeDef类型结构体中。</p></li><li><p>对NOR flash存储器进行读写操作。HAL_NOR_Read(),HAL_NOR_Program()</p></li><li><p>执行NOR flash块擦除或芯片擦除操作。 HAL_NOR_Erase_Block() ,HAL_NOR_Erase_Chip()</p></li><li><p>读取NOR flash的通用闪存接口ID（CFI IDs）。HAL_NOR_Read_CFI()</p><p>读取的信息存储在被上述函数调用的已声明NOR_CFI_TypeDef结构体中。</p></li><li><p>可分别通过调用 HAL_NOR_WriteOperation_Enable() /HAL_NOR_WriteOperation_Disable()函数来使能/禁止 NORFlash的写操作，从而控制NOR Flash设备。</p></li><li><p>监测NOR设备状态。 HAL_NOR_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通NOR flash操作APIs。如果NORflash设备包含不同的操作和方法，应该单独实施。</p><h3 id="nor存储器外设常用宏定义">NOR存储器外设常用宏定义</h3><ul><li>NOR_WRITE : NOR 存储器向指定的地址写入数据。</li></ul><h3 id="nor存储器回调函数的注册">NOR存储器回调函数的注册</h3><p>当 USE_HAL_NOR_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_NOR_RegisterCallback(),HAL_NOR_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : NOR 相关MCU初始化回调函数</li><li>MspDeInitCallback : NOR 相关MCU去初始化回调函数</li></ul><p>默认情况下, NOR 初始化（HAL_NOR_Init()）后，当状态是HAL_NOR_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_NOR_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_NOR_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于Nor flash存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;nor存储器外设库的使用&quot;&gt;NOR存储器外设库的使用&lt;/h3&gt;
&lt;p&gt;此驱动是一个通用的分层驱动程序，包含一组用于控制NOR闪存的API。它使用FSMC层函数来连接NOR
闪存。&lt;/p</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="nor" scheme="http://example.com/tags/nor/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_pccard库的使用</title>
    <link href="http://example.com/2023/08/07/stm32f1xx-hal-pccard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/07/stm32f1xx-hal-pccard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-07T04:15:11.000Z</published>
    <updated>2023-08-14T00:03:33.356Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于PCCARD存储器的使用方法。</p><h3 id="pccard存储器外设库的使用">PCCARD存储器外设库的使用</h3><p>此驱动是一个通用的分层驱动程序，包含一组用于控制PCCARD/小型闪存的API。它使用FSMC层函数来连接PCCARD存储器。</p><ol type="1"><li><p>配置PCCARD/小型闪存的控制和时序参数。HAL_PCCARD_Init()/HAL_CF_Init()</p></li><li><p>读取PCCARD/小型闪存制造商和设备ID。HAL_PCCARD_Read_ID()/HAL_CF_Read_ID()</p><p>读取的信息存储在函数调用的CompactFlash_ID结构体中。</p></li><li><p>对PCCARD/小型闪存进行扇区读写操作：</p><ul><li><p>HAL_PCCARD_Read_Sector()/ HAL_PCCARD_Write_Sector()</p></li><li><p>HAL_CF_Read_Sector()/HAL_CF_Write_Sector()</p></li></ul></li><li><p>执行PCCARD/小型闪存复位操作。HAL_PCCARD_Reset()/HAL_CF_Reset()</p></li><li><p>执行PCCARD/小型闪存扇区擦除操作。HAL_PCCARD_Erase_Sector()/HAL_CF_Erase_Sector()</p></li><li><p>读取PCCARD/小型闪存的状态。HAL_PCCARD_ReadStatus()/HAL_CF_ReadStatus()</p></li><li><p>监测PCCARD/小型闪存的状态。HAL_PCCARD_GetState()/HAL_CF_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通PCCARD/小型闪存操作API。如果PCCARD/小型闪存设备包含不同的操作和方法，应该单独实施。</p><h3 id="pccard存储器回调函数的注册">PCCARD存储器回调函数的注册</h3><p>当 USE_HAL_PCCARD_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_PCCARD_RegisterCallback(),HAL_PCCARD_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : PCCARD 相关MCU初始化回调</li><li>MspDeInitCallback : PCCARD 相关MCU去初始化回调</li></ul><p>默认情况下, PCCARD 初始化（HAL_PCCARD_Init()）后，当状态是HAL_PCCARD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_PCCARD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_PCCARD_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于PCCARD存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;pccard存储器外设库的使用&quot;&gt;PCCARD存储器外设库的使用&lt;/h3&gt;
&lt;p&gt;此驱动是一个通用的分层驱动程序，包含一组用于控制PCCARD/小型闪存的API。它使用FSMC层函数来连接PC</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="pccard" scheme="http://example.com/tags/pccard/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_nand库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-nand%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-nand%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T14:32:31.000Z</published>
    <updated>2023-08-14T00:03:33.336Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于NAND flash存储器的使用方法。</p><h3 id="nand外设库的使用">NAND外设库的使用</h3><ol type="1"><li><p>配置NAND flash 存储器。HAL_NAND_Init()</p></li><li><p>读取NAND flash 存储器制造商和设备ID。HAL_NAND_Read_ID()</p><p>读取的信息存储在函数调用的NAND_ID_TypeDef类型结构体中。</p></li><li><p>对NAND flash存储器进行读写操作：</p><ul><li>HAL_NAND_Read_Page_8b()/HAL_NAND_Read_SpareArea_8b()</li><li>HAL_NAND_Write_Page_8b()/HAL_NAND_Write_SpareArea_8b()</li><li>HAL_NAND_Read_Page_16b()/HAL_NAND_Read_SpareArea_16b()</li><li>HAL_NAND_Write_Page_16b()/HAL_NAND_Write_SpareArea_16b()</li></ul><p>这些函数使用用户在 NAND_DeviceConfigTypeDef结构体中预定义的设备信息(块、页面大小等)，结构体中包含读写地址信息。</p></li><li><p>执行NAND flash复位操作。HAL_NAND_Reset()</p></li><li><p>执行NAND flash块擦除操作。HAL_NAND_Erase_Block()</p><p>块擦除信息作为参数传入Nand_Address_Typedef结构体。</p></li><li><p>读取NAND flash的状态操作。HAL_NAND_Read_Status()</p></li><li><p>分别通过调用 HAL_NAND_ECC_Enable() /HAL_NAND_ECC_Disable()函数来使能/禁止 ECC码更正特性，或通过HAL_NAND_GetECC() 函数获取 ECC更正码，从而控制NAND 设备。</p></li><li><p>监测NAND设备状态。 HAL_NAND_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通NAND flash操作APIs。如果NANDflash设备包含不同的操作和方法，应该单独实施。</p><h3 id="nand回调函数的注册">NAND回调函数的注册</h3><p>当 USE_HAL_NAND_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_NAND_RegisterCallback(),HAL_NAND_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : NAND 相关MCU初始化回调函数</li><li>MspDeInitCallback : NAND 相关MCU去初始化回调函数</li></ul><p>默认情况下, NAND 初始化（HAL_NAND_Init()）后，当状态是HAL_NAND_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_NAND_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_NAND_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于NAND flash存储器的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;nand外设库的使用&quot;&gt;NAND外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;配置NAND flash 存储器。HAL_NAND_Init()&lt;/p&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="nand" scheme="http://example.com/tags/nand/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_rtc库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-rtc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-rtc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T13:10:31.000Z</published>
    <updated>2023-08-14T00:03:33.377Z</updated>
    
    <content type="html"><![CDATA[<p>Real TimeClock，简称RTC，实时时钟，以下来看看HAL库关于RTC的使用方法。</p><h3 id="rtc外设库的使用">RTC外设库的使用</h3><ol type="1"><li>使能RTC域。</li><li>配置RTC预分频系数(异步预分频器生成RTC 1Hz时基)。 HAL_RTC_Init()</li><li>配置时间和日期。<ul><li>配置RTC日历(时间和日期)。HAL_RTC_SetTime()，HAL_RTC_SetDate()</li><li>读RTC日历。HAL_RTC_GetTime() ，HAL_RTC_GetDate()</li></ul></li><li>闹钟配置。<ul><li>配置RTC闹钟。HAL_RTC_SetAlarm() ，HAL_RTC_SetAlarm_IT()</li><li>读RTC闹钟。HAL_RTC_GetAlarm()</li></ul></li><li>RTC 入侵检测配置。RTC Tamper<ul><li>使能RTCTamper，配置Tamper电平。HAL_RTCEx_SetTamper()，HAL_RTCEx_SetTamper_IT()</li><li>TAMPER1 复用功能映射到PC13 。</li></ul></li><li>配置备份数据寄存器（Backup Data Registers）<ul><li>向RTC备份数据寄存器写数据。HAL_RTCEx_BKUPWrite()</li><li>读RTC备份数据寄存器。HAL_RTCEx_BKUPRead()</li></ul></li></ol><h3 id="提示-hal-rtc驱动的限制">==提示: HAL RTC驱动的限制==</h3><ul><li>STM32F1系列芯片上的RTC版本是V1，F1系列芯片不支持V2版本（其它系列）的所有特性。</li><li>对于V2版本，RTC主要的特性是通过硬件控制的。但在F1芯片，日期特性完全由软件控制。</li><li>跟其它系列芯片相比，F1系列芯片有一些限制：<ul><li>HAL库只支持24小时格式（不支持12小时）。</li><li>日期保存在SRAM中，当MCU处于停止或待机模式时，日期就会丢失。用户应该在进入低功耗模式之前保存日期。（基于备份寄存器的固件包提供了一个示例）</li><li>每次调用时间和日期函数时，日期就会自动更新。HAL_RTC_GetTime()，HAL_RTC_GetDate()</li><li>闹钟检测被限制在一天内，它只会过期一次（无重复闹钟，需要编一个新的闹钟）。</li></ul></li></ul><h3 id="备用域操作条件">备用域操作条件</h3><ul><li>当主电源关闭时，可通过VBAT电源来给RTC和RTC备份寄存器供电。当VDD关闭，为了维持RTC备份寄存器的内容和给RTC供电，VBAT引脚连接到一个电池或其它电源的备用电源。</li><li>当主数字电源（VDD）关闭，为了RTC的操作，VBAT引脚需为以下模块供电：<ul><li>RTC</li><li>LSE振荡器</li><li>使能低功耗备用稳压器时的备用SRAM</li><li>PC13 ~ PC15 I/O引脚，加上 PI8引脚 (当可使用时)</li></ul></li><li>当备用域通过VDD（模拟开关连接到VDD）供电，可使用PC13引脚，用作入侵检测引脚。</li><li>当备用域通过VBAT（模拟开关连接到VBAT，因为VDD不存在）供电，可使用PC13引脚，用作入侵检测引脚。</li></ul><h3 id="备用域复位">备用域复位</h3><ul><li>备用域复位将所有的RTC寄存器和RCC_BDCR寄存器设为复位值。</li><li>当发生以下任一事件，就会产生备用域复位：<ul><li>设置RCC备用域控制寄存器（RCC_BDCR）中的BDRST位触发软件复位。</li><li>如果两个供电之前都关闭了，那么VDD或VBAT电压就会打开。</li><li>入侵检测事件复位所有的数据备份寄存器。</li></ul></li></ul><h3 id="访问备用域">访问备用域</h3><ul><li>复位后, 备用域 (RTC寄存器,RTC备份数据寄存器和备份SRAM)就会被保护，不能进行写操作。</li><li>为了访问RTC域和RTC寄存器，可通过以下方式：<ul><li>调用HAL_RCCEx_PeriphCLKConfig()函数，其中PeriphClockSelection为RCC_PERIPHCLK_RTC，并选择RTCClockSelection(LSE, LSI 或 HSE)。</li><li>使能备用域时钟。__HAL_RCC_BKP_CLK_ENABLE()</li></ul></li></ul><h3 id="rtc和低功耗模式">RTC和低功耗模式</h3><ul><li>通过RTC复用函数可把MCU从低功耗模式中唤醒。</li><li>RTC复用函数是RTC闹钟（闹钟A）和检测RTC入侵事件。这些复用函数可将系统从停止和待机低功耗模式下唤醒。</li><li>系统还可以通过RTC闹钟从低功耗模式下唤醒，而无需依赖外部中断（自动唤醒模式）</li></ul><h3 id="rtc回调函数的注册">RTC回调函数的注册</h3><p>当 USE_HAL_RTC_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_RTC_RegisterCallback(),HAL_RTC_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>AlarmAEventCallback : RTC闹钟A 事件回调函数</p></li><li><p>Tamper1EventCallback : RTC入侵检测1事件回调函数</p></li><li><p>MspInitCallback : RTC相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : RTC相关MCU去初始化回调函数</p></li></ul><p>默认情况下, RTC 初始化（HAL_RTC_Init()）后，当状态是HAL_RTC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_RTC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_RTC_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Real Time
Clock，简称RTC，实时时钟，以下来看看HAL库关于RTC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;rtc外设库的使用&quot;&gt;RTC外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;使能RTC域。&lt;/li&gt;
&lt;li&gt;配置RTC预分频系数(</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="rtc" scheme="http://example.com/tags/rtc/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_spi库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-spi%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-spi%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:50:31.000Z</published>
    <updated>2023-08-14T00:03:33.426Z</updated>
    
    <content type="html"><![CDATA[<p>Serial PeripheralInterface，简称SPI，串行外设接口。以下来看看HAL库关于SPI的使用方法。</p><h3 id="spi外设库的使用">SPI外设库的使用</h3><ol type="1"><li><p>声明一个 SPI_HandleTypeDef 结构体,如：SPI_HandleTypeDefhspi;</p></li><li><p>初始化SPI底层。HAL_SPI_MspInit()</p></li></ol><ul><li>使能SPIx 接口时钟。</li><li>配置SPI引脚<ul><li>使能SPI GPIO 时钟</li><li>配置SPI引脚为复用推挽模式</li></ul></li><li>如果使用到中断，则配置NVIC。<ul><li>配置SPIx 中断优先级</li><li>使能NVIC SPI IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体参数。</li><li>配置DMA Tx或Rx通道。</li><li>将hdma_tx 或hdma_rx 跟 hspi DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置hspi初始化结构体中各参数。</li><li>调用 HAL_SPI_Init() 函数初始化 SPI寄存器。</li></ol><h3 id="循环模式规则">循环模式规则</h3><ul><li>当SPI配置在以下模式时，就不能使用DMA循环模式：<ul><li>主机2线只接收 (Master 2Lines RxOnly)</li><li>主机1线接收 (Master 1Line Rx)</li></ul></li><li>当使能DMA循环模式时，就不能使用CRC功能。</li><li>当使用了SPI DMA暂停/停止功能时，必须只能在SPI回调函数中使用HAL_SPI_DMAPause()/HAL_SPI_DMAStop()函数。</li></ul><h3 id="主机接收模式规则">主机接收模式规则</h3><p>在主机单向接收模式 (MSTR =1, BIDIMODE=0, RXONLY=1) 或双向接收模式(MSTR=1, BIDIMODE=1,BIDIOE=0)，为了确保SPI没有发起新的数据传输，需要重视以下函数：</p><ul><li><p>HAL_SPI_DeInit()</p></li><li><p>HAL_SPI_Init()</p></li></ul><h3 id="spi回调函数的注册">SPI回调函数的注册</h3><p>当 USE_HAL_SPI_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SPI_RegisterCallback(),HAL_SPI_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxCpltCallback : SPI 发送完成回调函数</p></li><li><p>RxCpltCallback : SPI 接收完成回调函数</p></li><li><p>TxRxCpltCallback : SPI 发送接收完成回调函数</p></li><li><p>TxHalfCpltCallback : SPI 发送过半回调函数</p></li><li><p>RxHalfCpltCallback : SPI 接收过半回调函数</p></li><li><p>TxRxHalfCpltCallback : SPI 发送接收过半回调函数</p></li><li><p>ErrorCallback : SPI 错误回调函数</p></li><li><p>AbortCpltCallback : SPI 中止回调函数</p></li><li><p>MspInitCallback : SPI 相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : SPI 相关MCU去初始化回调函数</p></li></ul><p>默认情况下, SPI 初始化（HAL_SPI_Init()）后，当状态是HAL_SPI_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SPI_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SPI_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Serial Peripheral
Interface，简称SPI，串行外设接口。以下来看看HAL库关于SPI的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;spi外设库的使用&quot;&gt;SPI外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;声明一个 SPI_Han</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="spi" scheme="http://example.com/tags/spi/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_smartcard库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-smartcard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-smartcard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:32:31.000Z</published>
    <updated>2023-08-14T00:03:33.416Z</updated>
    
    <content type="html"><![CDATA[<p>Smart Card，智能卡，以下来看看HAL库关于SMARTCARD的使用方法。</p><h3 id="smartcard外设库的使用">SMARTCARD外设库的使用</h3><ol type="1"><li><p>声明一个 SMARTCARD_HandleTypeDef 结构体。</p></li><li><p>初始化SMARTCARD底层。HAL_SMARTCARD_MSMARTCARDnit()</p></li></ol><ul><li>使能SMARTCARDx关联到USARTx 的接口时钟。</li><li>配置SMARTCARD引脚<ul><li>使能SMARTCARD GPIO 时钟</li><li>配置SMARTCARD引脚为复用上拉模式</li></ul></li><li>如果使用到中断（HAL_SMARTCARD_Transmit_IT()，HAL_SMARTCARD_Receive_IT()），则配置NVIC。<ul><li>配置USARTx中断优先级</li><li>使能NVIC USART IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_SMARTCARD_Transmit_DMA()，HAL_SMARTCARD_Receive_DMA()<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体Tx/Rx参数。</li><li>配置DMA Tx或Rx通道。</li><li>将DMA 跟 SMARTCARD DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置SMARTCARD初始化结构体中各参数。</li><li>调用 HAL_SMARTCARD_Init() 函数初始化 SMARTCARD寄存器。</li></ol><p>在发送和接收过程中，使用宏定义 __HAL_SMARTCARD_ENABLE_IT() 和__HAL_SMARTCARD_DISABLE_IT() 来管理SMARTCARD的中断(发送完成中断，接收非空中断，错误中断)。</p><h3 id="smartcard轮询模式io操作">SMARTCARD轮询模式IO操作</h3><ul><li>阻塞方式下，发送一定数量的数据。HAL_SMARTCARD_Transmit()</li><li>阻塞方式下，接收一定数量的数据。HAL_SMARTCARD_Receive()</li></ul><h3 id="smartcard中断模式io操作">SMARTCARD中断模式IO操作</h3><ul><li><p>非阻塞方式下，发送一定数量的数据。HAL_SMARTCARD_Transmit_IT()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_SMARTCARD_TxCpltCallback()</p></li><li><p>非阻塞方式下，接收一定数量的数据。HAL_SMARTCARD_Receive_IT()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_SMARTCARD_RxCpltCallback()</p></li><li><p>传输出错时，执行出错回调函数，用户自行添加代码。HAL_SMARTCARD_ErrorCallback()</p></li></ul><h3 id="smartcard-dma-模式io操作">SMARTCARD DMA 模式IO操作</h3><ul><li><p>非阻塞方式(DMA)下，发送一定数量的数据。HAL_SMARTCARD_Transmit_DMA()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_SMARTCARD_TxCpltCallback()</p></li><li><p>非阻塞方式(DMA)下，接收一定数量的数据。HAL_SMARTCARD_Receive_DMA()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_SMARTCARD_RxCpltCallback()</p></li><li><p>传输出错时，执行出错回调函数，用户自行添加代码。HAL_SMARTCARD_ErrorCallback()</p></li></ul><h3 id="smartcard-常用宏定义">SMARTCARD 常用宏定义</h3><ul><li><p>__HAL_SMARTCARD_ENABLE: 使能SMARTCARD 外设</p></li><li><p>__HAL_SMARTCARD_DISABLE: 禁止SMARTCARD 外设</p></li><li><p>__HAL_SMARTCARD_GET_FLAG : 检查SMARTCARD 标志是否设置</p></li><li><p>__HAL_SMARTCARD_CLEAR_FLAG : 清除 SMARTCARD 挂起标志</p></li><li><p>__HAL_SMARTCARD_ENABLE_IT: 使能 SMARTCARD 中断</p></li><li><p>__HAL_SMARTCARD_DISABLE_IT: 禁止 SMARTCARD 中断</p></li></ul><h3 id="smartcard回调函数的注册">SMARTCARD回调函数的注册</h3><p>当 USE_HAL_SMARTCARD_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SMARTCARD_RegisterCallback(),HAL_SMARTCARD_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxCpltCallback : 发送完成回调函数</p></li><li><p>RxCpltCallback : 接收完成回调函数</p></li><li><p>ErrorCallback : 错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>AbortTransmitCpltCallback : 中止发送完成回调函数</p></li><li><p>AbortReceiveCpltCallback : 中止接收完成回调函数</p></li><li><p>MspInitCallback : SMARTCARD 相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : SMARTCARD 相关MCU去初始化回调函数</p></li></ul><p>默认情况下, SMARTCARD 初始化（HAL_SMARTCARD_Init()）后，当状态是HAL_SMARTCARD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SMARTCARD_STATE_READY状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SMARTCARD_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Smart Card，智能卡，以下来看看HAL库关于SMARTCARD的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;smartcard外设库的使用&quot;&gt;SMARTCARD外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;声明一个 SMARTCARD_Handle</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="smartcard" scheme="http://example.com/tags/smartcard/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_tim库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-tim%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-tim%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T12:20:30.000Z</published>
    <updated>2023-08-14T00:03:33.496Z</updated>
    
    <content type="html"><![CDATA[<p>timer,简称TIM，定时器是MCU控制中使用最广泛的外设，STM32中有多个TIM，下面来看看HAL库关于TIM的介绍和使用方法。</p><h3 id="tim外设库的一般特性">TIM外设库的一般特性</h3><ul><li>16位向上，向下，向上向下自动重装载计数器</li><li>16位可编程预分频系数，允许对计数器时钟进行 1 ~ 65536 的分频。</li><li>多达4各独立的通道：<ul><li>输入捕获 Input Capture</li><li>输出比较 Output Compare</li><li>产生PWM（边沿和中心对齐模式）</li><li>单脉冲模式输出 One-pulse mode output</li></ul></li><li>用外部信号的同步电路来控制定时器，并将多个定时器互连在一起。</li><li>支持增量编码器的定位目的</li></ul><h3 id="tim外设库的使用">TIM外设库的使用</h3><ol type="1"><li><p>根据所选的功能特性，初始化TIM底层：</p><ul><li>Time Base : HAL_TIM_Base_MspInit()</li><li>Input Capture : HAL_TIM_IC_MspInit()</li><li>Output Compare : HAL_TIM_OC_MspInit()</li><li>PWM generation : HAL_TIM_PWM_MspInit()</li><li>One-pulse mode output : HAL_TIM_OnePulse_MspInit()</li><li>Encoder mode output : HAL_TIM_Encoder_MspInit()</li><li>Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()</li></ul></li><li><p>使能TIM接口时钟。__HAL_RCC_TIMx_CLK_ENABLE()</p></li><li><p>配置TIM引脚。</p><ul><li>使能TIM GPIOs时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置TIM引脚复用功能。HAL_GPIO_Init()</li></ul></li><li><p>默认时钟是来自APBx的内部时钟，如果有需要，可配置外部时钟。HAL_TIM_ConfigClockSource()</p><p>该配置需在任何启动函数之前完成。</p></li><li><p>在所需的功能模式下配置TIM：</p><ul><li><p>使用定时器产生时基（time base）。HAL_TIM_Base_Init()</p></li><li><p>使用定时器产生输出比较信号。 HAL_TIM_OC_Init() ,HAL_TIM_OC_ConfigChannel()</p></li><li><p>使用定时器产生PWM信号。HAL_TIM_PWM_Init() ,HAL_TIM_PWM_ConfigChannel()</p></li><li><p>使用定时器测量外部信号。HAL_TIM_IC_Init() ,HAL_TIM_IC_ConfigChannel()</p></li><li><p>单脉冲模式下使用定时器。HAL_TIM_OnePulse_Init() ,HAL_TIM_OnePulse_ConfigChannel()</p></li><li><p>使用定时器编码接口。HAL_TIM_Encoder_Init()</p></li><li><p>使用定时器 HallSensor接口，如果有需要中断和DMA请求，则配置通信事件。HAL_TIMEx_HallSensor_Init()， HAL_TIMEx_ConfigCommutEvent()</p><p><strong>注意</strong>：一个定时器用于与Hallsensor接口连接，另一个定时器用于通信事件。</p></li></ul></li><li><p>根据功能特性开启TIM外设：</p><ul><li>Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(),HAL_TIM_Base_Start_IT()</li><li>Input Capture : HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(),HAL_TIM_IC_Start_IT()</li><li>Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(),HAL_TIM_OC_Start_IT()</li><li>PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(),HAL_TIM_PWM_Start_IT()</li><li>One-pulse mode output : HAL_TIM_OnePulse_Start(),HAL_TIM_OnePulse_Start_IT()</li><li>Encoder mode output : HAL_TIM_Encoder_Start(),HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT()</li><li>Complementary Output Compare : HAL_TIMEx_OCN_Start(),HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OCN_Start_IT()</li><li>Complementary PWM generation : HAL_TIMEx_PWMN_Start(),HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()</li><li>Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(),HAL_TIMEx_OnePulseN_Start_IT()</li><li>Hall Sensor output : HAL_TIMEx_HallSensor_Start(),HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().</li></ul></li><li><p>管理控制DMA Busrt功能。HAL_TIM_DMABurst_WriteStart()，HAL_TIM_DMABurst_ReadStart()</p></li></ol><h3 id="tim回调函数的注册">TIM回调函数的注册</h3><p>当 USE_HAL_TIM_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_TIM_RegisterCallback(),HAL_TIM_UnRegisterCallback()</p><p>回调函数：</p><ul><li>Base_MspDeInitCallback : TIM 时基相关MCU去初始化回调函数</li><li>IC_MspInitCallback : TIM 输入捕获相关MCU初始化回调函数</li><li>IC_MspDeInitCallback : TIM 输入捕获相关MCU去初始化回调函数</li><li>OC_MspInitCallback : TIM 输出比较相关MCU初始化回调函数</li><li>OC_MspDeInitCallback : TIM 输出比较相关MCU去初始化回调函数</li><li>PWM_MspInitCallback : TIM PWM 相关MCU初始化回调函数</li><li>PWM_MspDeInitCallback : TIM PWM 相关MCU去初始化回调函数</li><li>OnePulse_MspInitCallback : TIM 单脉冲相关MCU初始化回调函数</li><li>OnePulse_MspDeInitCallback : TIM 单脉冲相关MCU去初始化回调函数</li><li>Encoder_MspInitCallback : TIM 编码器相关MCU初始化回调函数</li><li>Encoder_MspDeInitCallback : TIM 编码器相关MCU去初始化回调函数</li><li>HallSensor_MspInitCallback : TIM Hall Sensor相关MCU初始化回调函数</li><li>HallSensor_MspDeInitCallback : TIM Hall Sensor相关MCU去初始化回调函数</li><li>PeriodElapsedCallback : TIM 周期时间结束回调函数</li><li>PeriodElapsedHalfCpltCallback : TIM 半周期时间结束回调函数</li><li>TriggerCallback : TIM 触发回调函数</li><li>TriggerHalfCpltCallback : TIM 半触发回调函数</li><li>IC_CaptureCallback : TIM 输入捕获回调函数</li><li>IC_CaptureHalfCpltCallback : TIM 半输入捕获回调函数</li><li>OC_DelayElapsedCallback : TIM 输出比较延时回调函数</li><li>PWM_PulseFinishedCallback : TIM PWM 脉冲结束回调函数</li><li>PWM_PulseFinishedHalfCpltCallback : TIM PWM 半脉冲结束回调函数</li><li>ErrorCallback : TIM 错误回调函数</li><li>CommutationCallback : TIM 通信回调函数</li><li>CommutationHalfCpltCallback : TIM 半通信回调函数</li><li>BreakCallback : TIM 打断回调函数</li></ul><p>默认情况下, TIM初始化（HAL_TIM_Init()）后，当状态是HAL_TIM_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_TIM_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_TIM_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;timer,
简称TIM，定时器是MCU控制中使用最广泛的外设，STM32中有多个TIM，下面来看看HAL库关于TIM的介绍和使用方法。&lt;/p&gt;
&lt;h3 id=&quot;tim外设库的一般特性&quot;&gt;TIM外设库的一般特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;16位向上，向下，向上向下</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="tim" scheme="http://example.com/tags/tim/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_sram库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-sram%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-sram%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T11:20:30.000Z</published>
    <updated>2023-08-14T00:03:33.439Z</updated>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于SRAM 内存的使用方法。</p><h3 id="sram外设库的使用">SRAM外设库的使用</h3><p>这是一个通用的分层驱动，包含一套控制SRAM内存的API。它使用FSMC层函数与SRAM设备进行连接。要配置FSMC与SRAM/PSRAM的连接，应遵循以下顺序：</p><ol type="1"><li><p>声明一个SRAM_HandleTypeDef类型结构体。如：SRAM_HandleTypeDefhsram;</p><ul><li>对SRAM_HandleTypeDef 句柄中“Init”中成员赋值。</li><li>对SRAM_HandleTypeDef句柄中“Instance”填入预先定义的NOR或SRAM设备基地址寄存器实例。</li><li>对SRAM_HandleTypeDef句柄中“Extended”填入预先定义的NOR或SRAM扩展模式基地址寄存器实例。</li></ul></li><li><p>为正常模式和扩展模式声明两个 FSMC_NORSRAM_TimingTypeDef类型结构体，并进行赋值。如：</p><p>​ FSMC_NORSRAM_TimingTypeDef Timing ， FSMC_NORSRAM_TimingTypeDefExTiming;</p></li><li><p>初始化 SRAM 控制器。HAL_SRAM_Init()</p><ul><li>配置底层硬件。HAL_SRAM_MspInit()</li><li>使用 FSMC NORSRAM 接口配置控制寄存器。FSMC_NORSRAM_Init()</li><li>使用 FSMC NORSRAM接口配置时序寄存器。FSMC_NORSRAM_Timing_Init()</li><li>使用 FSMC NORSRAM接口配置扩展模式时序寄存器。FSMC_NORSRAM_Extended_Timing_Init()</li><li>使能SRAM设备。__FSMC_NORSRAM_ENABLE()</li></ul></li><li><p>在这个阶段，你就可以执行内存与NOR/SRAM Bank之间的读、写操作。</p><ul><li>轮询模式下的读写：HAL_SRAM_Read()/HAL_SRAM_Write()</li><li>DMA模式下的读写：HAL_SRAM_Read_DMA()/HAL_SRAM_Write_DMA()</li></ul></li><li><p>你也可以通过调用HAL_SRAM_WriteOperation_Enable() /HAL_SRAM_WriteOperation_Disable() 函数来控制SRAM设备的写操作。</p></li><li><p>你可以持续监测SRAM设备的状态。HAL_SRAM_GetState()</p></li></ol><h3 id="sram回调函数的注册">SRAM回调函数的注册</h3><p>当 USE_HAL_SRAM_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_SRAM_RegisterCallback(),HAL_SRAM_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : SRAM 相关MCU初始化回调函数</li><li>MspDeInitCallback : SRAM 相关MCU去初始化回调函数</li></ul><p>默认情况下, SRAM 初始化（HAL_SRAM_Init()）后，当状态是HAL_SRAM_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SRAM_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SRAM_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面来看看HAL库关于SRAM 内存的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;sram外设库的使用&quot;&gt;SRAM外设库的使用&lt;/h3&gt;
&lt;p&gt;这是一个通用的分层驱动，包含一套控制SRAM内存的API。它使用FSMC层函数与SRAM设备进行连接。要配置FSMC与SRAM/PSR</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="sram" scheme="http://example.com/tags/sram/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_hcd库和pcd的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-hcd%E5%BA%93%E5%92%8Cpcd%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-hcd%E5%BA%93%E5%92%8Cpcd%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T10:30:31.000Z</published>
    <updated>2023-08-07T14:49:16.982Z</updated>
    
    <content type="html"><![CDATA[<p>Host Controller Driver 和 Peripheral ControllerDriver，分别简称HCD，PCD，它们是USB外设控制器相关驱动，下面来看看HAL库关于HCD和PCD的使用方法介绍。</p><h3 id="hcd外设库的使用">HCD外设库的使用</h3><ol type="1"><li>声明一个 HCD_HandleTypeDef 类型结构体。如：HCD_HandleTypeDefhhcd;</li><li>对hhcd结构体的各参数进行赋值。</li><li>初始化 HCD外设。HAL_HCD_Init();</li><li>初始化HCD底层。HAL_HCD_MspInit();<ul><li>使能 HCD/USB 底层接口时钟。__HAL_RCC_USB_OTG_FS_CLK_ENABLE();</li><li>初始化相关GPIO时钟</li><li>配置HCD引脚为输出模式</li><li>配置HCD NVIC中断</li></ul></li><li>将上层USB主机栈关联到HAL HCD驱动。hhcd.pData = phost;</li><li>使能HCD发送和接收。HAL_HCD_Start();</li></ol><h3 id="pcd外设库的使用">PCD外设库的使用</h3><ol type="1"><li>声明一个 PCD_HandleTypeDef 类型结构体。如：PCD_HandleTypeDefhpcd;</li><li>对hpcd结构体的各参数进行赋值。</li><li>初始化 PCD外设。HAL_PCD_Init();</li><li>初始化PCD底层。HAL_PCD_MspInit();<ul><li>使能 PCD/USB 底层接口时钟。<ul><li>对于一般USB设备：__HAL_RCC_USB_CLK_ENABLE();</li><li>对于USB全速设备：__HAL_RCC_USB_OTG_FS_CLK_ENABLE();</li></ul></li><li>初始化相关GPIO时钟</li><li>配置PCD引脚为输出模式</li><li>配置PCD NVIC中断</li></ul></li><li>将上层USB设备栈关联到HAL PCD驱动。hpcd.pData = pdev;</li><li>使能PCD发送和接收。HAL_PCD_Start();</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Host Controller Driver 和 Peripheral Controller
Driver，分别简称HCD，PCD，它们是USB外设控制器相关驱动，下面来看看HAL库关于HCD和PCD的使用方法介绍。&lt;/p&gt;
&lt;h3 id=&quot;hcd外设库的使用&quot;&gt;HCD</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="hcd" scheme="http://example.com/tags/hcd/"/>
    
    <category term="pcd" scheme="http://example.com/tags/pcd/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_eth库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-eth%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-eth%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T09:30:31.000Z</published>
    <updated>2023-08-14T00:03:33.214Z</updated>
    
    <content type="html"><![CDATA[<p>Ethernet，简称ETH，以太网，以下来看看HAL库关于ETH的使用方法。</p><h3 id="eth外设库的使用">ETH外设库的使用</h3><ol type="1"><li><p>声明一个ETH_HandleTypeDef 类型结构体，如：ETH_HandleTypeDefheth;</p></li><li><p>对初始化结构体heth中参数进行赋值。</p></li><li><p>初始化ETH。Call HAL_ETH_Init()</p></li><li><p>初始化ETH底层。HAL_ETH_MspInit()</p><ul><li><p>使能ETH接口时钟。<code>__HAL_RCC_ETHMAC_CLK_ENABLE()</code>，<code>__HAL_RCC_ETHMACTX_CLK_ENABLE()</code>，<code>__HAL_RCC_ETHMACRX_CLK_ENABLE()</code></p></li><li><p>初始化相关GPIO时钟。</p></li><li><p>配置ETH引脚为输出</p></li><li><p>配置ETH NVIC中断（中断模式）</p></li></ul></li><li><p>以链模式（chain mode ）初始化ETHDMA描述符并指向已分配的缓冲区：</p></li></ol><ul><li>发送过程：HAL_ETH_DMATxDescListInit()</li><li>接收过程：HAL_ETH_DMARxDescListInit()</li></ul><ol start="6" type="1"><li><p>使能MAC并进行DMA发送和接收。HAL_ETH_Start()</p></li><li><p>准备好 ETH DMA 发送描述符，助力于ETH DMA传输数据帧到 MAC TXFIFO。HAL_ETH_TransmitFrame()</p></li><li><p>轮询接收ETHDMA接收描述符中的数据帧，并获取数据帧参数。HAL_ETH_GetReceivedFrame()(在无限循环中调用)</p></li><li><p>当ETH接收中断发生时，获取一帧接收数据。HAL_ETH_GetReceivedFrame_IT()(仅在中断模式中调用)</p></li><li><p>与外部PHY通信:</p><ul><li>从PHY中读取指定寄存器。HAL_ETH_ReadPHYRegister();</li><li>向指定的PHY寄存器中写入数据。HAL_ETH_WritePHYRegister();</li></ul></li><li><p>当 ETH 外设初始化后配置MAC。HAL_ETH_ConfigMAC()</p><p>所有的MAC参数都应该赋值。</p></li><li><p>当 ETH 外设初始化后配置DMA 。HAL_ETH_ConfigDMA()</p><p>所有的DMA参数都应该赋值。</p></li></ol><p><strong>注意</strong>：本驱动不支持PTP 协议和DMA描述符环状模式（DMAdescriptors ring mode）。</p><h3 id="eth回调函数的注册">ETH回调函数的注册</h3><p>当 USE_HAL_ETH_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_ETH_RegisterCallback(),HAL_ETH_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>DMAErrorCallback : DMA 错误回调函数</li><li>MspInitCallback : ETH相关MCU初始化回调函数</li><li>MspDeInitCallback: ETH相关MCU去初始化回调函数</li></ul><p>默认情况下, ETH 初始化（HAL_ETH_Init()）后，当状态是HAL_ETH_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_ETH_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_ETH_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Ethernet，简称ETH，以太网，以下来看看HAL库关于ETH的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;eth外设库的使用&quot;&gt;ETH外设库的使用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;声明一个ETH_HandleTypeDef 类型结构体，如：ETH_H</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="eth" scheme="http://example.com/tags/eth/"/>
    
  </entry>
  
  <entry>
    <title>stm32f1xx_hal_cec库的使用</title>
    <link href="http://example.com/2023/08/06/stm32f1xx-hal-cec%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/08/06/stm32f1xx-hal-cec%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-08-06T08:30:31.000Z</published>
    <updated>2023-08-07T05:07:43.010Z</updated>
    
    <content type="html"><![CDATA[<p>Consumer Electronics Control，简称CEC，消费电子控制，是一种允许用户通过一个遥控器控制多个电子设备的技术，通常用于家庭娱乐系统。以下来看看HAL库关于CEC的使用方法。</p><h3 id="cec外设库的使用">CEC外设库的使用</h3><ol type="1"><li><p>声明一个CEC_HandleTypeDef 类型结构体。</p></li><li><p>初始化CEC底层。HAL_CEC_MspInit()</p></li></ol><ul><li>使能CEC接口时钟。</li><li>配置CEC引脚<ul><li><p>使能CEC GPIO 时钟</p></li><li><p>配置CEC引脚为复用上拉模式</p></li><li><p>如果使用到中断，如：HAL_CEC_Transmit_IT() ，HAL_CEC_Receive_IT()</p><ul><li>配置CEC 中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC CEC IRQ。HAL_NVIC_EnableIRQ()</li><li>在发送和接收过程中使用宏定义 __HAL_CEC_ENABLE_IT() 和__HAL_CEC_DISABLE_IT()来控制CEC的中断（发送完成中断，接收非空中断，错误中断）。</li></ul></li></ul></li></ul><ol start="3" type="1"><li>在hcec初始化结构体中设置位定时错误模式和位周期错误模式。Bit TimingError Mode / Bit Period Error Mode</li><li>初始化CEC寄存器。HAL_CEC_Init()</li></ol><h3 id="cec回调函数的注册">CEC回调函数的注册</h3><p>当 USE_HAL_CEC_REGISTER_CALLBACKS为1时，允许用户注册或注销回调函数。HAL_CEC_RegisterCallback(),HAL_CEC_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>ErrorCallback : 错误回调函数</li><li>MspInitCallback : CEC 底层初始化回调函数</li><li>MspDeInitCallback : CEC 底层析构回调函数</li></ul><p>默认情况下, CEC 初始化（HAL_CEC_Init()）后，当状态是HAL_CEC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_CEC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_CEC_REGISTER_CALLBACKS为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Consumer Electronics Control
，简称CEC，消费电子控制，是一种允许用户通过一个遥控器控制多个电子设备的技术，通常用于家庭娱乐系统。以下来看看HAL库关于CEC的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;cec外设库的使用&quot;&gt;CEC外设库的使用&lt;/</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="cec" scheme="http://example.com/tags/cec/"/>
    
  </entry>
  
</feed>
