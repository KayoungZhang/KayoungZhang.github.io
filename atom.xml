<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-06-14T13:09:51.222Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Qt Creator的使用</title>
    <link href="http://example.com/2023/06/14/Qt-Creator%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/06/14/Qt-Creator%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-06-14T10:41:05.000Z</published>
    <updated>2023-06-14T13:09:51.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="qt-creator的设置">Qt Creator的设置</h3><p>打开Qt Creator, 选择Tools -&gt; Options 进入设置界面：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190132386.png" alt="image-20230614190132386" style="zoom:80%;" /></p><ul><li>Environment：可以设置相应的主题和语言环境及UI颜色。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190238354.png" alt="image-20230614190238354" style="zoom:80%;" /></p><ul><li>Text Editor：可以进行相应的文本编辑设置。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190418754.png" alt="image-20230614190418754" style="zoom:80%;" /></p><ul><li>Build &amp; Run：进行编译和运行的设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190635317.png" alt="image-20230614190635317" style="zoom:80%;" /></p><h3 id="新建qt-widget项目">新建Qt Widget项目</h3><ul><li>依次点击 File -&gt; New File or Project,选择Qt WidgetApplication</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614191012944.png" alt="image-20230614191012944" style="zoom:80%;" /></p><ul><li>填写工程名和选择存储路径，选择 qmake 编译，用 qmake 生成 Makefile用于项目的编译。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614191554835.png" alt="image-20230614191554835" style="zoom:80%;" /></p><ul><li>选择基类：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614192700423.png" alt="image-20230614192700423" style="zoom:80%;" /></p><ul><li>选择目标平台的编译器：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614192942055.png" alt="image-20230614192942055" style="zoom:80%;" /></p><ul><li>可选择版本控制：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614193215345.png" alt="image-20230614193215345" style="zoom:80%;" /></p><ul><li>完成项目创建，可点击左下角绿色图标编译运行，此时会弹出一个空白框。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614193358548.png" alt="image-20230614193358548" style="zoom:80%;" /></p><h3 id="项目文件介绍">项目文件介绍</h3><ul><li>demo.pro: 项目管理文件。</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614194650370.png"alt="image-20230614194650370" /><figcaption aria-hidden="true">image-20230614194650370</figcaption></figure><p>还可以在其中设置应用程序其他信息：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#程序版本</span>VERSION = 1.0.0.0<span class="hljs-comment">#程序图标</span>RC_ICONS = client.ico<span class="hljs-comment">#公司名称</span>QMAKE_TARGET_COMPANY =<span class="hljs-string">&quot;KayoungZhang&quot;</span><span class="hljs-comment">#程序说明</span>QMAKE_TARGET_DESCRIPTION = <span class="hljs-string">&quot;TCP Client&quot;</span><span class="hljs-comment">#版权信息</span>QMAKE_TARGET_COPYRIGHT = <span class="hljs-string">&quot;Copyright(C) 2022&quot;</span><span class="hljs-comment">#程序名称</span>QMAKE_TARGET_PRODUCT = <span class="hljs-string">&quot;app&quot;</span><span class="hljs-comment">#程序语言</span><span class="hljs-comment">#0x0800代表和系统当前语言一致</span>RC_LANG = 0x0800</code></pre></div><ul><li><p>Header 分组，存放的是项目内所有的头文件*.h。</p></li><li><p>Source 分组，存放的是项目内的所有C++源码文件*.cpp。</p></li><li><p>Forms分组，存放项目内所有界面文件*.ui。双击ui文件就可以进入图形设计界面，返回时则点击左边Edit图标。</p></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614195710035.png"alt="image-20230614195710035" /><figcaption aria-hidden="true">image-20230614195710035</figcaption></figure><p>在控件区，拖拽一个<strong>Label</strong>组件到中间的设计区，编辑文字内容为：“<strong>Hello，Qt！</strong>”，选择此<strong>Lable</strong> 然后在其属性区，找到 <strong>geometry</strong>,将 <strong>Width</strong> 改为 <strong>80</strong>，<strong>Height</strong> 改为 <strong>30</strong>，然后找到<strong>font</strong>，将 <strong>Point Size</strong>设置为<strong>12</strong>，勾选 <strong>Bold</strong>。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614201322669.png"alt="image-20230614201322669" /><figcaption aria-hidden="true">image-20230614201322669</figcaption></figure><h3 id="项目的编译和运行">项目的编译和运行</h3><p>单击左窗口的 <strong>Projects</strong> 图标，查看编译工具。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614201800354.png"alt="image-20230614201800354" /><figcaption aria-hidden="true">image-20230614201800354</figcaption></figure><p>然后点击左下角编译运行：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614201932984.png" alt="image-20230614201932984" style="zoom:80%;" /></p><p>至此完成一个简单的项目创建。</p><h3 id="项目的发布">项目的发布</h3><p>当项目全部完成后，就可以进行打包发行了。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614202600194.png" alt="image-20230614202600194" style="zoom:80%;" /></p><p>选择<strong>Release</strong>后，编译运行完，打开项目工程目录，找到编译后的exe文件，双击运行，会发现运行不了，是因为缺少dll动态链接库。可以将Qt的bin目录添加到电脑系统的Path环境变量中，为了保证在其他电脑上也可以正常运行，需要找到相应的dll文件，Qt提供了一个<strong>windeployqt</strong>工具，可以自动创建可部署的文件夹，具体操作如下：</p><ol type="1"><li>将生成的exe文件复制到一个空的文件夹中。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614203121788.png" alt="image-20230614203121788" style="zoom:80%;" /></p><ol start="2" type="1"><li>打开Qt的MinGW命令行，进入刚才的文件夹，然后输入命令：<strong>windeployqt</strong>后面跟程序名。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614204728719.png" alt="image-20230614204728719" style="zoom:80%;" /></p><ol start="3" type="1"><li>可以将部分不需要的内容删除，如下所示：</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614205216379.png"alt="image-20230614205216379" /><figcaption aria-hidden="true">image-20230614205216379</figcaption></figure><ol start="4" type="1"><li><p>将精简后的程序压缩即可在其他同平台电脑运行了,也可以使用工具“单文件制作封装工具(Enigma VirtualBox)”将其打包成独立版程序。如果需要整理成一个安装程序，就需要专用工具进行打包处理，一般用到的工具有：</p><ul><li>HM NIS Edit（https://hmne.sourceforge.net/）</li><li>NSIS</li><li>Inno setup（https://jrsoftware.org/）</li></ul><p>后面再做详细介绍。</p></li></ol><p>工程文件：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/demo.zip">Qtdemo</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;qt-creator的设置&quot;&gt;Qt Creator的设置&lt;/h3&gt;
&lt;p&gt;打开Qt Creator, 选择Tools -&amp;gt; Options 进入设置界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kayoungzhang/p</summary>
      
    
    
    
    <category term="Qt" scheme="http://example.com/categories/Qt/"/>
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt开发环境的搭建</title>
    <link href="http://example.com/2023/06/14/Qt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2023/06/14/Qt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2023-06-14T09:15:03.000Z</published>
    <updated>2023-06-14T10:52:15.539Z</updated>
    
    <content type="html"><![CDATA[<h3 id="qt简介">Qt简介</h3><p>Qt 是一个跨平台的 C++开发库，主要用来开发图形用户界面（Graphical UserInterface，简称 GUI）程序。Qt 是跨平台的，支持Windows、Linux、macOS、Android、iOS、WinRT 等平台，将已编写好的 Qt程序移植到这些平台，只需重新编译一次源代码即可。</p><h3 id="qt-creator的下载安装">Qt Creator的下载安装</h3><p>QtCreator是Qt集成开发环境（IDE），包括C++代码编辑器，集成的GUI外观和版式设计器（QtDesigner），项目生成和管理工具，集成的上下文相关帮助系统，图形化调试器，代码管理和浏览工具等。</p><h4 id="下载qt-creator">1.下载Qt Creator</h4><p>官网地址：https://download.qt.io/</p><p>5.14及之前版本可以下载完整安装包，进行离线安装，5.15版本之后不再提供离线安装包，只能通过下载器进行在线安装。</p><p>离线版：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614174035183.png"alt="image-20230614174035183" /><figcaption aria-hidden="true">image-20230614174035183</figcaption></figure><p>在线版：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614174826980.png"alt="image-20230614174826980" /><figcaption aria-hidden="true">image-20230614174826980</figcaption></figure><p>一般从官网下载比较慢，可以通过国内镜像网站进行下载安装，国内著名的 Qt镜像网站，主要是各个高校的：</p><ul><li>中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/</li><li>清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/</li><li>中国互联网络信息中心：https://mirrors.cnnic.cn/qt/</li></ul><h4 id="安装qt-creator">2.安装Qt Creator</h4><p>这里我下载的是离线版本：qt-opensource-windows-x86-5.14.2.exe。</p><p><strong>注意：</strong>若已经安装了其他版本的Qt，请先卸载，再安装，否则会发生一些奇奇怪怪的错误。</p><ul><li>双击安装包进行安装，登录Qt账户，如果没有账号，进行注册。（断网后重新安装可跳过此步骤）</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614181334729.png" alt="image-20230614181334729" style="zoom:80%;" /></p><ul><li>选择安装路径</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614180858111.png" alt="image-20230614180858111" style="zoom:80%;" /></p><ul><li>按需选择组件，一般只需选择对应的编译环境即可，其他组件后续可以再进行补充安装。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614182944200.png" alt="image-20230614182944200" style="zoom:80%;" /></p><ul><li>完成安装</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614185126853.png" alt="image-20230614185126853" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614183307230.png" alt="image-20230614183307230" style="zoom:80%;" /></p><h3 id="参考链接">参考链接</h3><p>http://t.csdn.cn/VNaHm</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;qt简介&quot;&gt;Qt简介&lt;/h3&gt;
&lt;p&gt;Qt 是一个跨平台的 C++开发库，主要用来开发图形用户界面（Graphical User
Interface，简称 GUI）程序。Qt 是跨平台的，支持
Windows、Linux、macOS、Android、iOS、</summary>
      
    
    
    
    <category term="Qt" scheme="http://example.com/categories/Qt/"/>
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>STM32以太网通信</title>
    <link href="http://example.com/2023/06/07/STM32%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9CEthernet/"/>
    <id>http://example.com/2023/06/07/STM32%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9CEthernet/</id>
    <published>2023-06-07T11:39:13.000Z</published>
    <updated>2023-06-12T12:08:29.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ositcpip-和-lwip-简介">OSI、TCP/IP 和 LwIP 简介</h3><p><strong>OSI</strong>（Open System Interconnect），即开放式系统互联，一般都叫OSI参考模型。</p><p><strong>TCP/IP</strong>（Transmission Control Protocol/InternetProtocol），传输控制协议/网际协议，又名网络通讯协议，是 Internet最基本的协议、Internet 国际互联网络的基础，由网络层的 IP 协议和传输层的TCP 协议组成。TCP/IP定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。</p><p><strong>LwIP</strong>（Light weight IP），一种开源轻量级的 IP协议,占用内存少，它只需十几 KB 的 RAM 和 40K 左右的 ROM就可以运行。其网址：http://savannah.nongnu.org/projects/lwip/。</p><p><strong>MAC</strong> （Medium AccessControl），简称媒体访问控制，数据链路层的芯片称之为MAC控制器。</p><p><strong>PHY</strong>（Physical），端口物理层，物理层的芯片称之为PHY，是IEEE802.3规定的一个标准模块。IEEE定义了0~15这16个寄存器的功能，16~31这16个寄存器由厂商自行实现。</p><h3 id="网络模型">网络模型</h3><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606202025717.png"alt="image-20230606202025717" /><figcaption aria-hidden="true">image-20230606202025717</figcaption></figure><h3 id="通信实现">通信实现</h3><p>实现以太网通信硬件电路一般情况是SOC+MAC+PHY+网络变压器+RJ45，如下图：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230512193517675.png"alt="image-20230512193517675" /><figcaption aria-hidden="true">image-20230512193517675</figcaption></figure><p>通信硬件主要部分：MAC和PHY。对于内置MAC的SOC，其外部必须搭配一个PHY芯片。内部没有MAC的SOC芯片，就需要使用外置的MAC+PHY一体芯片了。具体实现有以下几种方式：</p><ul><li><strong>SOC（集成MAC层），外接一个PHY芯片（比如DM9162，LAN8720等），网络变压器和RJ45，总计4个器件，需单片机需处理TCP/IP协议栈。</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230512192817057.png"alt="image-20230512192817057" /><figcaption aria-hidden="true">image-20230512192817057</figcaption></figure><ul><li><p><strong>SOC，外加一个MAC和PHY集成一体芯片（包含MAC和PHY，比如DM9000、ENC28J60等），外加RJ45（集成网络变压器），总计3个电子器件，需单片机处理TCP/IP协议栈</strong>。</p></li><li><p><strong>SOC，外加一个MAC和PHY集成一体芯片（包含MAC+PHY+TCP/IP协议栈，如W5500,CH9121,CH395等），外加RJ45（集成网络变压器），总计3个电子器件，无需详细了解TCP/IP协议栈，开发方便。</strong></p></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230512192748527.png"alt="image-20230512192748527" /><figcaption aria-hidden="true">image-20230512192748527</figcaption></figure><ul><li><strong>SOC，加一个MAC芯片和一个PHY芯片，外加RJ45（集成网络变压器），总共4个器件。需单片机需处理TCP/IP协议栈。此方式使用较少。</strong></li></ul><p>其中：</p><p>MII/RMII接口用来传输网络数据，MIDO接口用来读写PHY的内部寄存器。</p><p><strong>MII</strong>(Media IndependentInterface)，介质独立接口，它是IEEE-802.3定义的以太网标准接口，用于以太网MAC连接PHY芯片。</p><p><strong>RMII</strong>(Reduced Media IndependentInterface)，精简的介质独立接口。</p><p><strong>MDIO</strong>(Management DataInput/Output)，管理数据输入输出接口，是一个两线串行接口，一根MDIO数据线，一根MDC时钟线。可以通过MDIO和MDC这两根线访问PHY芯片的任意一个寄存器。</p><p>网络变压器用于隔离以及滤波等，现在很多RJ45座子内部已经集成了网络变压器，比如最常用的HR911105A就是内置网络变压器的RJ45座。RJ45座子上一般有两个灯，绿灯亮表示网络正常，黄色闪烁说明正在进行网络通信。PHY芯片会有两个引脚来控制这两个灯。</p><h4 id="参考链接">参考链接：</h4><p>https://www.jianshu.com/p/bb363a41afcf</p><p>https://xie.infoq.cn/article/29110ce061176979d5d61959b</p><p>https://mp.weixin.qq.com/s/Wys9IgAgimCgHmVvvywK3w</p><p>http://t.csdn.cn/qLH6F</p><p>http://t.csdn.cn/Ob4tg</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ositcpip-和-lwip-简介&quot;&gt;OSI、TCP/IP 和 LwIP 简介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;OSI&lt;/strong&gt;（Open System Interconnect），即开放式系统互联，
一般都叫OSI参考模型。&lt;/p&gt;
&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之USB</title>
    <link href="http://example.com/2023/06/06/STM32CubeMX%E4%B9%8BUSB/"/>
    <id>http://example.com/2023/06/06/STM32CubeMX%E4%B9%8BUSB/</id>
    <published>2023-06-06T13:47:48.000Z</published>
    <updated>2023-06-07T11:38:13.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="usb简介">USB简介</h3><p>USB（Universal Serial BUS）通用串行总线，是一个外部总线标准。USB接口支持设备的即插即用和热插拔功能。</p><p>标准 USB 共四根线组成,除 VCC/GND 外,另外为D+,D-，这两根数据线采用的是差分电压的方式进行数据传输的。在 USB主机上，D-和 D+都是接了 15K的电阻到低的，所以在没有设备接入的时候，D+、D-均是低电平。而在 USB设备中，如果是高速设备，则会在 D+上接一个 1.5K 的电阻到VCC，而如果是低速设备，则会在 D-上接一个 1.5K 的电阻到VCC。这样当设备接入主机的时候，主机就可以判断是否有设备接入，并能判断设备是高速设备还是低速设备。</p><p>STM32F103 的 MCU 自带 USB 从控制器，符合 USB 规范的通信连接；PC主机和微控制器之间的数据传输是通过共享一专用的数据缓冲区来完成的，该数据缓冲区能被USB外设直接访问。这块专用数据缓冲区的大小由所使用的端点数目和每个端点最大的数据分组大小所决定，每个端点最大可使用512 字节缓冲区（专用的 512 字节，和 CAN 共用），最多可用于 16 个单向或 8个双向端点。USB 模块同 PC 主机通信，根据 USB规范实现令牌分组的检测，数据发送/接收的处理，和握手分组的处理。整个传输的格式由硬件完成，其中包括CRC 的生成和校验。</p><p>USB功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606220817086.png" alt="image-20230606220817086" style="zoom:80%;" /></p><p>整个 USB 通信的详细过程是很复杂的，要正常使用 STM32F1 的USB，就得编写 USB 驱动，好在ST 官方提供了一套完整的 USB驱动库，通过这个库，我们可以很方便的实现USB功能，而不需要详细了解 USB的整个驱动，大大缩短了我们的开发时间和精力。</p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606221327095.png" alt="image-20230606221327095" style="zoom:80%;" /></p><p>利用 STM32 自带的 USB 功能,连接电脑 USB,虚拟出一个USB串口，实现电脑和开发板的数据通信。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>激活USB，参数默认即可。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606222512234.png" alt="image-20230606222512234" style="zoom:80%;" /></p><ul><li>RCC设置外接HSE，主时钟设置为72M，USB时钟设置为48M。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606222338962.png" alt="image-20230606222338962" style="zoom:80%;" /></p><ul><li>在中间件中选择 <code>USB_DEVICE</code> 设置，在<code>Class For FS IP</code> 设备类别选择<code>Communication Device Class（Virtual Port Com）</code>虚拟串口，参数保持默认。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606222858420.png" alt="image-20230606222858420" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在usbd_cdc_if.c文件中找到发送和接收函数，其中，发生函数可以在外调用，接收函数则是自动触发，为了在串口助手中回送数据，需要在接收函数中添加发送函数。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  Data received over USB OUT endpoint are sent over CDC interface</span><span class="hljs-comment">  *         through this function.</span><span class="hljs-comment">  *</span><span class="hljs-comment">  *         @note</span><span class="hljs-comment">  *         This function will issue a NAK packet on any OUT packet received on</span><span class="hljs-comment">  *         USB endpoint until exiting this function. If you exit this function</span><span class="hljs-comment">  *         before transfer is complete on CDC interface (ie. using DMA controller)</span><span class="hljs-comment">  *         it will result in receiving more data while previous ones are still</span><span class="hljs-comment">  *         not sent.</span><span class="hljs-comment">  *</span><span class="hljs-comment">  * @param  Buf: Buffer of data to be received</span><span class="hljs-comment">  * @param  Len: Number of data received (in bytes)</span><span class="hljs-comment">  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">int8_t</span> <span class="hljs-title function_">CDC_Receive_FS</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* Buf, <span class="hljs-type">uint32_t</span> *Len)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 6 */</span>  USBD_CDC_SetRxBuffer(&amp;hUsbDeviceFS, &amp;Buf[<span class="hljs-number">0</span>]);  USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS);  CDC_Transmit_FS(Buf, *Len);<span class="hljs-comment">//添加回送函数</span>  <span class="hljs-keyword">return</span> (USBD_OK);  <span class="hljs-comment">/* USER CODE END 6 */</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  CDC_Transmit_FS</span><span class="hljs-comment">  *         Data to send over USB IN endpoint are sent over CDC interface</span><span class="hljs-comment">  *         through this function.</span><span class="hljs-comment">  *         @note</span><span class="hljs-comment">  *</span><span class="hljs-comment">  *</span><span class="hljs-comment">  * @param  Buf: Buffer of data to be sent</span><span class="hljs-comment">  * @param  Len: Number of data to be sent (in bytes)</span><span class="hljs-comment">  * @retval USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">CDC_Transmit_FS</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* Buf, <span class="hljs-type">uint16_t</span> Len)</span>&#123;  <span class="hljs-type">uint8_t</span> result = USBD_OK;  <span class="hljs-comment">/* USER CODE BEGIN 7 */</span>  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;  <span class="hljs-keyword">if</span> (hcdc-&gt;TxState != <span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">return</span> USBD_BUSY;  &#125;  USBD_CDC_SetTxBuffer(&amp;hUsbDeviceFS, Buf, Len);  result = USBD_CDC_TransmitPacket(&amp;hUsbDeviceFS);  <span class="hljs-comment">/* USER CODE END 7 */</span>  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><ul><li>在main.c函数中添加测试代码：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;usbd_cdc_if.h&quot;</span></span><span class="hljs-comment">/* USER CODE END Includes */</span><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint8_t</span> usb_send_buffer[] = <span class="hljs-string">&quot;This is USB Virtual Test.\r\n&quot;</span>;<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;CDC_Transmit_FS(usb_send_buffer, <span class="hljs-keyword">sizeof</span>(usb_send_buffer));HAL_Delay(<span class="hljs-number">1000</span>);<span class="hljs-comment">/* USER CODE END WHILE */</span><span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;</code></pre></div><ul><li>编译正常，下载到开发板，将USB连接线连接电脑和开发板的USBSLAVE口，打开串口助手，选择出现的虚拟端口号，串口不停的发送数据，当从串口助手发送数据时，也会回显到串口助手上。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606235349209.png" alt="image-20230606235349209" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606235715688.png" alt="image-20230606235715688" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/usb.zip">usb</a></p><h4 id="参考链接">参考链接：</h4><p>http://t.csdn.cn/ZrHap</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;usb简介&quot;&gt;USB简介&lt;/h3&gt;
&lt;p&gt;USB（Universal Serial BUS）通用串行总线，是一个外部总线标准。USB
接口支持设备的即插即用和热插拔功能。&lt;/p&gt;
&lt;p&gt;标准 USB 共四根线组成,除 VCC/GND 外,另外为
D+,D-</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之FatFs文件系统</title>
    <link href="http://example.com/2023/05/31/STM32CubeMX%E4%B9%8BFatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/05/31/STM32CubeMX%E4%B9%8BFatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-05-31T05:22:46.000Z</published>
    <updated>2023-06-06T00:12:18.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fatfs-文件系统">FatFs 文件系统</h3><p>文件系统是为了存储和管理数据，而在存储介质中建立的一种组织结构，这些结构包括操作系统引导区、目录和文件。常见的windows 下的文件系统格式包括FAT32、NTFS、exFAT。在使用文件系统前，要先对存储介质进行格式化。</p><p>使用文件系统时，数据都以文件的形式存储。写入新文件时，先在目录中创建一个文件索引，它指示了文件存放的物理地址，再把数据存储到该地址中。当需要读取数据时，可以从目录中找到该文件的索引，进而在相应的地址中读取出数据。</p><p>FatFs 就是一个完全免费开源，面向小型嵌入式系统的一种通用的 FAT文件系统。它完全是由 ANSI C 语言编写并且完全独立于底层的 I/O介质。因此它可以很容易地不加修改地移植到其他的处理器当中，如8051、PIC、AVR、SH、Z80、H8、ARM 等。FatFs 支持 FAT12、FAT16、FAT32等格式。</p><p>FatFs 文件系统官网：http://elm-chan.org/fsw/ff/00index_e.html</p><p>FatFs 模块的层次结构如下图示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531201529949.png" alt="image-20230531201529949" style="zoom:80%;" /></p><p>一般只需要编写最底层驱动代码，它包括存储媒介读／写接口（diskI/O）和供给文件创建修改时间的实时时钟等。</p><p>FatFs源码相关文件如下表示，移植时，一般只需要修改2个文件（即<strong>ffconf.h</strong>和<strong>diskio.c</strong>）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531202042461.png" alt="image-20230531202042461" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>使用FatFs 文件系统对SD卡进行相关操作，并使用串口1来打印调试信息。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531193736005.png" alt="image-20230531193736005" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活CRC；</li><li>激活SDIO，选择4线SD模式，使能硬件流控，分频因子设为4，其余默认设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531195623706.png" alt="image-20230531195623706" style="zoom:80%;" /></p><ul><li>打开FATFS文件系统，按下图配置，其余默认值</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531215923184.png" alt="image-20230531215923184" style="zoom:80%;" /></p><ul><li>增大堆空间</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531220058287.png" alt="image-20230531220058287" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在main.c中添加测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint32_t</span> wr_size;                <span class="hljs-comment">/* File write counts */</span><span class="hljs-type">uint32_t</span> rd_size;                 <span class="hljs-comment">/* File read counts */</span><span class="hljs-type">uint8_t</span> wr_buffer[] = <span class="hljs-string">&quot;This is STM32 working with FatFs.&quot;</span>; <span class="hljs-comment">/* File write buffer */</span><span class="hljs-type">uint8_t</span> rd_buffer[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;                   <span class="hljs-comment">/* File read buffers */</span><span class="hljs-type">char</span> *filename = <span class="hljs-string">&quot;STM32cubemx.txt&quot;</span>; <span class="hljs-comment">/* File will be open */</span><span class="hljs-type">char</span> *sensor_file = <span class="hljs-string">&quot;Sensor.txt&quot;</span>; <span class="hljs-comment">/* File will be create */</span><span class="hljs-type">char</span> sensor_buffer[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">/* 写入的数据缓存*/</span><span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fatfs_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">/* 1.挂载SD卡，进行格式化测试 */</span>retSD = f_mount(&amp;SDFatFS,SDPath,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(retSD == FR_NO_FILESYSTEM)<span class="hljs-comment">/* SD卡没有文件系统 */</span>  &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡还没有文件系统，即将进行格式化...\r\n&quot;</span>);retSD = f_mkfs(SDPath, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 格式化 */</span><span class="hljs-keyword">if</span>(retSD == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡格式化成功。\r\n&quot;</span>);retSD = f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 格式化后，先取消挂载 */</span>retSD = f_mount(&amp;SDFatFS, SDPath, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 重新挂载 */</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡格式化失败。\r\n&quot;</span>);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);&#125;  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(retSD != FR_OK) <span class="hljs-comment">/* SD卡挂载出现其它错误，打印错误码 */</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡挂载失败。%d \r\n&quot;</span>, retSD);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">/* SD卡挂载成功 */</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件系统挂载成功，可以进行读写测试!!!\r\n&quot;</span>);&#125;<span class="hljs-comment">/* 2.文件系统测试，写测试 */</span>  <span class="hljs-keyword">if</span>(f_open(&amp;SDFile, filename, FA_CREATE_ALWAYS | FA_WRITE) == FR_OK)  &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 打开文件成功，开始写入指定数据...\r\n&quot;</span>);retSD = f_write(&amp;SDFile, wr_buffer, <span class="hljs-keyword">sizeof</span>(wr_buffer), &amp;wr_size);<span class="hljs-comment">/* 将指定存储区内容写入到文件内 */</span><span class="hljs-keyword">if</span>(retSD == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 成功写入 %d 字节数据。\r\n&quot;</span>, wr_size);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 写入的数据 : %s\r\n&quot;</span>, wr_buffer);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件写入失败，错误码： %d\r\n&quot;</span>, retSD);&#125;f_close(&amp;SDFile);<span class="hljs-comment">/* 不再读写，关闭文件 */</span>  &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件打开失败。\r\n&quot;</span>);&#125;<span class="hljs-comment">/* 3.文件系统测试，读测试 */</span><span class="hljs-keyword">if</span>(f_open(&amp;SDFile, filename, FA_OPEN_EXISTING | FA_READ) == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 打开文件成功，开始读取数据...\r\n&quot;</span>);retSD = f_read(&amp;SDFile, rd_buffer, <span class="hljs-keyword">sizeof</span>(rd_buffer), &amp;rd_size);<span class="hljs-comment">/* 读取数据 */</span><span class="hljs-keyword">if</span>(retSD == FR_OK) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 成功读取 %d 字节数据。\r\n&quot;</span>, rd_size);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 读取的数据: %s\r\n&quot;</span>, rd_buffer);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 读取文件失败，错误码： %d\r\n&quot;</span>, retSD);&#125;f_close(&amp;SDFile);<span class="hljs-comment">/* 不再读写，关闭文件 */</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件打开失败。\r\n&quot;</span>);&#125;<span class="hljs-comment">/* 4.文件系统测试，创建文件 */</span><span class="hljs-keyword">if</span>(f_open(&amp;SDFile,sensor_file,FA_CREATE_ALWAYS|FA_WRITE) == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; %s 文件创建成功。\r\n&quot;</span>, sensor_file);<span class="hljs-comment">/* 首先写入项目栏参数 */</span><span class="hljs-built_in">sprintf</span>(sensor_buffer, <span class="hljs-string">&quot;Item\tTemp\tHumi\tLight\r\n&quot;</span>);f_write(&amp;SDFile, sensor_buffer, <span class="hljs-built_in">strlen</span>(sensor_buffer), &amp;wr_size);    <span class="hljs-comment">/* 然后写入具体数据 */</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<span class="hljs-built_in">sprintf</span>(sensor_buffer, <span class="hljs-string">&quot;%d\t%d\t%d\t%d\r\n&quot;</span>,i + <span class="hljs-number">1</span>, i + <span class="hljs-number">20</span>, i + <span class="hljs-number">30</span>, i + <span class="hljs-number">40</span>);f_write(&amp;SDFile,sensor_buffer, <span class="hljs-built_in">strlen</span>(sensor_buffer), &amp;wr_size);f_sync(&amp;SDFile);&#125;f_close(&amp;SDFile);  &#125;  f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 不再使用文件系统，取消挂载文件系统 */</span>&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>编译无误下载到开发板后，串口打印出如下信息：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230605205919074.png" alt="image-20230605205919074" style="zoom:80%;" /></p><p>将SD卡插入PC后，可以看到SD卡里建立了2个文件：Sensor.txt和STM32cubemx.txt，打开文件后可以看到写入的数据</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230605210046746.png" alt="image-20230605210046746" style="zoom: 67%;" /></p><p>工程代码Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/fatfs_sd.zip">fatfs</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;fatfs-文件系统&quot;&gt;FatFs 文件系统&lt;/h3&gt;
&lt;p&gt;文件系统是为了存储和管理数据，而在存储介质中建立的一种组织结构，这些结构包括操作系统引导区、目录和文件。常见的
windows 下的文件系统格式包括
FAT32、NTFS、exFAT。在使用文件系</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之SDIO_SD卡</title>
    <link href="http://example.com/2023/05/31/STM32CubeMX%E4%B9%8BSDIO_SD%E5%8D%A1/"/>
    <id>http://example.com/2023/05/31/STM32CubeMX%E4%B9%8BSDIO_SD%E5%8D%A1/</id>
    <published>2023-05-31T05:22:11.000Z</published>
    <updated>2023-06-06T00:12:18.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sd卡介绍">SD卡介绍</h3><p>SD卡（Secure Digital Memory Card）即：安全数码卡。</p><p>根据容量大小，有下面几种分类：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531172428049.png" alt="image-20230531172428049" style="zoom:80%;" /></p><p>关于SD卡其他介绍，可参考 <ahref="https://www.baidu.com/link?url=sXgupcfG8fflzEDeeUlhH7psACkhlMJWwL8aFDGca27sSn-LNEp_vK-jAyAPEjvk&amp;wd=&amp;eqid=c46ac4b50003b4c30000000664771096">SD卡通识篇</a></p><p>SD卡物理结构：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531182505470.png"alt="image-20230531182505470" /><figcaption aria-hidden="true">image-20230531182505470</figcaption></figure><table><thead><tr class="header"><th>SD卡寄存器</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>CID（Card identification number）</td><td>SD卡唯一识别码</td></tr><tr class="even"><td>RCA（Relative card address）</td><td>SD卡本地系统相对地址</td></tr><tr class="odd"><td>DSR（Driver Stage Register）</td><td>配置SD卡输出驱动</td></tr><tr class="even"><td>CSD（Card Specific Data）</td><td>SD卡操作状态特定信息</td></tr><tr class="odd"><td>SCR（SD Configuration Register）</td><td>SD卡特殊信息性能配置</td></tr><tr class="even"><td>OCR（Operation conditions Register）</td><td>SD卡操作状态信息</td></tr><tr class="odd"><td>SSR（SD Status）</td><td>SD卡属性信息</td></tr><tr class="even"><td>CSR（Card Status）</td><td>SD卡的状态</td></tr></tbody></table><p>SD卡初始化流程：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531190032444.png"alt="image-20230531190032444" /><figcaption aria-hidden="true">image-20230531190032444</figcaption></figure><h3 id="sdio-简介">SDIO 简介</h3><p>SDIO ，全称： Secure Digital Input andOutput，即安全数字输入输出接口。STM32的SDIO控制器支持多媒体卡（MMC卡）、SD存储卡、SDI/O卡和CE-ATA设备。</p><p>SDIO框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531192743598.png" alt="image-20230531192743598" style="zoom:80%;" /></p><p>其中，SDIO 适配器</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531193038925.png" alt="image-20230531193038925" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>插上SD卡，开机的初始化 SD 卡，如果 SD卡初始化完成，则串口1打印初始化成功，没初始化成功，则打印初始化失败。然后打印SD卡相关信息，最后写入和读取SD 卡扇区 0 的数据，通过串口1发送到电脑。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531193736005.png" alt="image-20230531193736005" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活SDIO，选择4线SD模式，使能硬件流控，分频因子设为4，其余默认设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531195623706.png" alt="image-20230531195623706" style="zoom:80%;" /></p><ul><li>最好激活CRC功能，以避免后续读写SD卡报CRC校验错误</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531195739768.png" alt="image-20230531195739768" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击 GENERATE CODE，生成工程代码。</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在sdio.c文件下可以看到sdio初始化函数，同时在该文件下添加显示SD卡信息函数,并在sdio.h头文件中声明。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-comment">//显示SD卡信息函数</span><span class="hljs-type">void</span> <span class="hljs-title function_">Show_SDMMC_Info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;HAL_SD_CardCIDTypeDef SDCard_CID;HAL_SD_CardInfoTypeDef SDCard_INFO;<span class="hljs-type">uint64_t</span> CardCap;<span class="hljs-comment">//SD卡容量</span>HAL_SD_GetCardCID(&amp;hsd,&amp;SDCard_CID);<span class="hljs-comment">//获取CID</span>HAL_SD_GetCardInfo(&amp;hsd,&amp;SDCard_INFO);<span class="hljs-comment">//获取SD卡信息</span><span class="hljs-keyword">switch</span>(SDCard_INFO.CardType)<span class="hljs-comment">//SD卡类型</span>&#123;<span class="hljs-keyword">case</span> CARD_SDSC:<span class="hljs-keyword">if</span>(SDCard_INFO.CardVersion == CARD_V1_X)      &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Type: SDSC V1\r\n&quot;</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(SDCard_INFO.CardVersion == CARD_V2_X)      &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Type: SDSC V2\r\n&quot;</span>);&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> CARD_SDHC_SDXC:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Type: SDHC\r\n&quot;</span>);<span class="hljs-keyword">break</span>;&#125;CardCap = (<span class="hljs-type">uint64_t</span>)(SDCard_INFO.LogBlockNbr)*(<span class="hljs-type">uint64_t</span>)(SDCard_INFO.LogBlockSize)/<span class="hljs-number">1024</span>/<span class="hljs-number">1024</span>;<span class="hljs-comment">//计算SD卡容量(单位：MB)</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card ManufacturerID: %d\r\n&quot;</span>,SDCard_CID.ManufacturerID);<span class="hljs-comment">//制造商ID</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card RelativeAddress: %d\r\n&quot;</span>,SDCard_INFO.RelCardAdd);<span class="hljs-comment">//卡相对地址</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LogicBlockNumber: %d\r\n&quot;</span>,SDCard_INFO.LogBlockNbr);<span class="hljs-comment">//逻辑块数量</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LogBlockSize: %d\r\n&quot;</span>,SDCard_INFO.LogBlockSize);<span class="hljs-comment">//逻辑块大小</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Capacity: %d MB\r\n&quot;</span>,(<span class="hljs-type">uint32_t</span>)CardCap);<span class="hljs-comment">//显示容量</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card BlockSize: %d\r\n&quot;</span>,SDCard_INFO.BlockSize);<span class="hljs-comment">//块大小</span>&#125;<span class="hljs-comment">/* USER CODE END 1 */</span></code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main.c文件中编写SD卡读写测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-comment">/* USER CODE END Includes */</span><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> Buffer_Tx[<span class="hljs-number">256</span>],Buffer_Rx[<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-type">uint32_t</span> i;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span> Show_SDMMC_Info();<span class="hljs-comment">/* 准备好数据 */</span><span class="hljs-comment">//  memset(Buffer_Tx,0x15,sizeof(Buffer_Tx));</span><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)&#123;    Buffer_Tx[i] = i;&#125;<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">/* 擦除SD卡 */</span>    <span class="hljs-keyword">if</span>(HAL_SD_Erase(&amp;hsd,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) == HAL_OK)    &#123;        <span class="hljs-keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) != HAL_SD_CARD_TRANSFER);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nErase Block Success!\r\n&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nErase Block Failed!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">100</span>);    <span class="hljs-comment">/* 向SD卡写数据 */</span>        <span class="hljs-keyword">if</span>(HAL_SD_WriteBlocks(&amp;hsd,Buffer_Tx,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0xffffffff</span>) == HAL_OK)    &#123;        <span class="hljs-keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) != HAL_SD_CARD_TRANSFER);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Write Block Success!\r\n&quot;</span>);        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">sizeof</span>(Buffer_Tx); i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02x:%02d  &quot;</span>, i, Buffer_Tx[i]);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Write Block Failed!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">100</span>);    <span class="hljs-comment">/* 读取SD卡数据 */</span>    <span class="hljs-keyword">if</span>(HAL_SD_ReadBlocks(&amp;hsd,Buffer_Rx,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0xffffffff</span>) == HAL_OK)    &#123;        <span class="hljs-keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) != HAL_SD_CARD_TRANSFER);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nRead Block Success!\r\n&quot;</span>);        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">sizeof</span>(Buffer_Rx); i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02x:%02d  &quot;</span>, i, Buffer_Rx[i]);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nRead Block Failed!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">2000</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，插入SD卡，打开串口助手，显示SD卡信息及其他数据</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230602185047037.png"alt="image-20230602185047037" /><figcaption aria-hidden="true">image-20230602185047037</figcaption></figure><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/sdio.zip">sdio</a></p><h3 id="参考链接">参考链接：</h3><p>https://www.sdcard.org/downloads/pls/</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;sd卡介绍&quot;&gt;SD卡介绍&lt;/h3&gt;
&lt;p&gt;SD卡（Secure Digital Memory Card）即：安全数码卡。&lt;/p&gt;
&lt;p&gt;根据容量大小，有下面几种分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/kayoungzha</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之内存管理</title>
    <link href="http://example.com/2023/05/31/STM32CubeMX%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/05/31/STM32CubeMX%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-05-31T05:21:53.000Z</published>
    <updated>2023-06-06T00:12:18.401Z</updated>
    
    <content type="html"><![CDATA[<p>STM32F103ZET6内部有64KB的SRAM内存，加上外扩的128KB容量的SRAM后，可使用的内存还是比较多的。内存管理是指软件运行时对计算机内存资源的分配和使用的技术，其最主要的目的是如何高效、快速的分配，并且在适当的时候释放和回收内存资源。</p><p>这里介绍一种比较简单的内存管理方法：分块式内存管理，其实现原理如下图示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531163251884.png" alt="image-20230531163251884" style="zoom:80%;" /></p><p>内存管理表的项值代表的意义为：该项值代表该项对应的内存块已经被占用，其数值则代表被连续占用的内存块数。比如某项值为10，那么说明包括本项对应的内存块在内，总共分配了10 个内存块给外部的某个指针。</p><p><strong>分配原理</strong>：当指针p调用malloc申请内存的时候，先判断p要分配的内存块数（m），然后从第n项开始，向下查找，直到找到m块连续的空内存块（即对应内存管理表项为0），然后将这m个内存管理表项的值都设置为m（标记被占用），最后把剩下空内存块的地址返回指针p，完成一次分配。注意，如果当内存不够的时候（找到最后也没找到连续的m块空闲内存），则返回NULL给p，表示分配失败。</p><p><strong>释放原理</strong>：当p申请的内存用完，需要释放的时候，调用free函数实现。free函数先判断p指向的内存地址所对应的内存块，然后找到对应的内存管理表项目，得到p所占用的内存块数目m（内存管理表项目的值就是所分配内存块的数目），将这m个内存管理表项目的值都清零，标记释放，完成一次内存释放。</p><p><strong>注意</strong>：申请的内存在用完以后，一定要释放。</p><h3 id="硬件设计">硬件设计</h3><p>KEY0 用于申请内存，每次申请 2K 字节内存。KEY1用于写数据到申请到的内存里面。KEY2用于释放内存。UART1用来显示内存状态及内存使用率.</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PE2/PE3/PE4设置为GPIO输入模式、上拉；PA0设置为GPIO输入模式，下拉；</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>添加内存管理驱动文件malloc.c和malloc.h，可直接移植正点原子代码。</li><li>添加按键驱动文件key.c和key.h,可参照前面按键输入一章。</li><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main.c文件下添加相应的头文件，编写内存管理测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> key=<span class="hljs-number">0</span>, i=<span class="hljs-number">0</span>, *p=<span class="hljs-number">0</span>; <span class="hljs-type">uint8_t</span> paddr[<span class="hljs-number">8</span>];<span class="hljs-type">uint8_t</span> sramx=<span class="hljs-number">0</span>;<span class="hljs-comment">//默认为内部sram</span><span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-comment">/* 初始化内部内存池 */</span>my_mem_init(SRAMIN);<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    key = key_scan(<span class="hljs-number">0</span>);    <span class="hljs-keyword">switch</span>(key)    &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> KEY0_PRES:            &#123;                p = mymalloc(sramx, <span class="hljs-number">2048</span>); <span class="hljs-comment">//创建2k 字节空间并写入内容</span>                <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)                &#123;                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2K byte space create success!\r\n&quot;</span>);                    <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span>*)p, <span class="hljs-string">&quot;Memory Malloc Test%03d&quot;</span>,i); <span class="hljs-comment">//写入内容</span>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\r\n&quot;</span>, p);                &#125;                <span class="hljs-keyword">break</span>;            &#125;           <span class="hljs-keyword">case</span> KEY1_PRES:            &#123;                <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)                &#123;                    <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span>*)paddr, <span class="hljs-string">&quot;Create space Addr:0X%08X&quot;</span>, (<span class="hljs-type">uint32_t</span>)p);<span class="hljs-comment">//显示p的地址</span>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\r\n&quot;</span>, paddr);                &#125;                <span class="hljs-keyword">break</span>;            &#125;        <span class="hljs-keyword">case</span> KEY2_PRES:            &#123;                myfree(sramx, p); <span class="hljs-comment">//释放内存</span>                p = <span class="hljs-number">0</span>;                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2K byte space is free now!\r\n&quot;</span>);                <span class="hljs-keyword">break</span>;            &#125;        <span class="hljs-keyword">case</span> WKUP_PRES:            &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Internal RAM usage：%d%%\r\n&quot;</span>,my_mem_perused(SRAMIN)); <span class="hljs-comment">//显示内部内存使用率</span>                i++;            &#125;    &#125;  &#125;</code></pre></div><ul><li>编译无误下载到开发板后，KEY0 用于申请内存，每次申请 2K字节内存，并写入内容，KEY1 显示写入的内容，KEY2用于释放内存，KEY_UP显示内部内存使用率。串口助手显示内存状态及内存使用率.</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230602235006078.png" alt="image-20230602235006078" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/mem_management.zip">mem_management</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;STM32F103ZET6内部有64KB的SRAM内存，加上外扩的128KB容量的SRAM后，可使用的内存还是比较多的。内存管理是指软件运行时对计算机内存资源的分配和使用的技术，其最主要的目的是如何高效、快速的分配，并且在适当的时候释放和回收内存资源。&lt;/p&gt;
&lt;p&gt;这里</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之外部SRAM</title>
    <link href="http://example.com/2023/05/31/STM32CubeMX%E4%B9%8B%E5%A4%96%E9%83%A8SRAM/"/>
    <id>http://example.com/2023/05/31/STM32CubeMX%E4%B9%8B%E5%A4%96%E9%83%A8SRAM/</id>
    <published>2023-05-31T05:20:28.000Z</published>
    <updated>2023-06-06T00:12:18.402Z</updated>
    
    <content type="html"><![CDATA[<h3 id="外部sramxm8a51216简介">外部SRAM(XM8A51216)简介</h3><p>STM32F103ZET6芯片自带64K字节的SRAM，对一般应用已经足够了，但在一些对内存要求高的场合，就需要添加外部SRAM了，开发板上带有一颗1M 字节（512K x 16bit）容量的 SRAM 芯片：IS62WV51216BLL；</p><p>其逻辑功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604164952473.png" alt="image-20230604164952473" style="zoom:80%;" /></p><p>芯片操作控制表：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531153007310.png" alt="image-20230531153007310" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531134019640.png" alt="image-20230531134019640" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531083826527.png" alt="image-20230531083826527" style="zoom:80%;" /></p><p>实验使用 FSMC BANK1的第<strong>3</strong>区来控制IS62WV51216BLL，将外部 SRAM 容量大小显示在LCD 上延时一段时间，显示预存在外部 SRAM 的数据。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活FSMC，选中Bank1，片选为NE3（即Bank1的第3区），存储器类型选为SRAM，数据宽度设为16位,勾选Byte enable。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531161352775.png" alt="image-20230531161352775" style="zoom:80%;" /></p><ul><li>在FSMC配置菜单中，使能存储器写，根据SRAM驱动芯片的数据参数设置地址建立时间、数据保存时间、总线周转阶段持续时间（设置为0），模式A</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531162647366.png" alt="image-20230531162647366" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>添加IS62WV51216BLL芯片驱动文件sram.c和sram.h</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief在指定地址(WriteAddr+Bank1_SRAM3_ADDR)开始,连续写入n个字节.</span><span class="hljs-comment">  * @parampBuffer:字节指针</span><span class="hljs-comment">  * @param  WriteAddr:要写入的地址</span><span class="hljs-comment">  * @param  n:要写入的字节数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fsmc_sram_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pBuffer,<span class="hljs-type">uint32_t</span> WriteAddr,<span class="hljs-type">uint32_t</span> n)</span>&#123;<span class="hljs-keyword">while</span>(n--)&#123;*(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>*)(Bank1_SRAM3_ADDR+WriteAddr)=*pBuffer;WriteAddr++;pBuffer++;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief在指定地址((WriteAddr+Bank1_SRAM3_ADDR))开始,连续读出n个字节.</span><span class="hljs-comment">  * @parampBuffer:字节指针</span><span class="hljs-comment">  * @param  ReadAddr:要读出的起始地址</span><span class="hljs-comment">  * @param  n:要读出的字节数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fsmc_sram_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pBuffer,<span class="hljs-type">uint32_t</span> ReadAddr,<span class="hljs-type">uint32_t</span> n)</span>&#123;<span class="hljs-keyword">while</span>(n--)&#123;*pBuffer++=*(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>*)(Bank1_SRAM3_ADDR+ReadAddr);ReadAddr++;&#125;&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main.c文件下编写SRAM测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fsmc_sram_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> writeData = <span class="hljs-number">0xf0</span>, readData;<span class="hljs-type">uint16_t</span> cap = <span class="hljs-number">0</span>;<span class="hljs-comment">//SRAM 容量大小</span><span class="hljs-type">uint32_t</span> addr;  <span class="hljs-comment">/* 以1024字节为单位计算，IS62WV51216的容量为1MB */</span><span class="hljs-keyword">for</span>(addr = <span class="hljs-number">1024</span>; addr &lt;= <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; addr += <span class="hljs-number">1024</span>)&#123;  fsmc_sram_write(&amp;writeData, addr, <span class="hljs-number">1</span>);  fsmc_sram_read(&amp;readData, addr, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(readData == writeData)&#123;cap++;<span class="hljs-comment">//如果相同表示写入/读出成功，容量加1KB</span>readData = <span class="hljs-number">0</span>; <span class="hljs-comment">//读出的值清零 </span>&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;External SRAM Memory Size: %dKB\r\n&quot;</span>, cap);&#125;<span class="hljs-comment">/* USER CODE END 0 */</span><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> write_string[] = <span class="hljs-string">&quot;This is SRAM testing...&quot;</span>;<span class="hljs-type">uint8_t</span> textlen = <span class="hljs-keyword">sizeof</span>(write_string);<span class="hljs-type">uint8_t</span> read_buf[textlen];<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_Delay(<span class="hljs-number">100</span>);fsmc_sram_test();<span class="hljs-comment">//打印SRAM大小</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    fsmc_sram_write(write_string, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(write_string));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SRAM_Write:%s\r\n&quot;</span>, write_string);    HAL_Delay(<span class="hljs-number">1000</span>);    fsmc_sram_read(read_buf, <span class="hljs-number">0</span>, textlen);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SRAM_Read:%s\r\n&quot;</span>, read_buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，串口助手打印出外部SRAM大小：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604181111942.png" alt="image-20230604181111942" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/sram.zip">sram</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;外部sramxm8a51216简介&quot;&gt;外部SRAM(XM8A51216)简介&lt;/h3&gt;
&lt;p&gt;STM32F103ZET6芯片自带
64K字节的SRAM，对一般应用已经足够了，但在一些对内存要求高的场合，就需要添加外部SRAM了，开发板上带有一颗
1M 字节（</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之FSMC_TFTLCD</title>
    <link href="http://example.com/2023/05/30/STM32CubeMX%E4%B9%8BFSMC-TFTLCD/"/>
    <id>http://example.com/2023/05/30/STM32CubeMX%E4%B9%8BFSMC-TFTLCD/</id>
    <published>2023-05-30T03:40:01.000Z</published>
    <updated>2023-06-06T00:27:17.694Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tftlcd简介">TFTLCD简介</h3><p>TFT-LCD（thin film transistor-liquid crystaldisplay）即薄膜晶体管液晶显示器。液晶显示屏的每一个像素上都设置有一个薄膜晶体管（TFT），每个像素都可以通过点脉冲直接控制。</p><p>常用的通信模式有6800模式和8080模式，本例程使用8080并口模式（简称80并口），8080接口有5条基本的控制线和多条数据线（8/9/16/18位）：</p><ul><li><p>CS：TFTLCD 片选信号。</p></li><li><p>WR：向 TFTLCD 写入数据。</p></li><li><p>RD：从 TFTLCD 读取数据。</p></li><li><p>RST：硬复位 TFTLCD。</p></li><li><p>RS：命令/数据标志（0，读写命令；1，读写数据）。</p></li><li><p>D[15：0]：16 位双向数据线。</p></li></ul><p>实验中使用的LCD是正点原子TFTLCD，其内部控制芯片ILI9341，其功能框图如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531102629121.png" alt="image-20230531102629121"  /></p><p><strong>ILI9341 部分重要命令</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082242026.png" alt="image-20230606082242026" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082317721.png" alt="image-20230606082317721" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082349293.png" alt="image-20230606082349293" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082521224.png" alt="image-20230606082521224" style="zoom:80%;" /></p><p><strong>8080时序图：</strong></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531103103667.png"alt="image-20230531103103667" /><figcaption aria-hidden="true">image-20230531103103667</figcaption></figure><p>一般 TFTLCD 模块的使用流程：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531103242060.png" alt="image-20230531103242060" style="zoom:80%;" /></p><p>其中，其中硬复位和初始化序列，只需要执行一次。</p><p>例如点操作流程：</p><ul><li>画点：设置坐标 → 写 GRAM 指令 → 写入颜色数据 → LCD 上显示颜色；</li><li>读点：设置坐标 → 读 GRAM 指令 → 读取颜色数据 →获取到对应点的颜色；</li></ul><p>设置TFT液晶显示通常需要以下几个步骤：</p><ul><li><p>设置STM32F1与TFTLCD模块连接的IO口，将与TFTLCD模块相连的IO口进行初始化，以便驱动LCD，ILI9341的 8080 通讯接口时序可以由 STM32 普通 I/O接口进行模拟，但这样效率太低，STM32 提供了一种特别的控制方法——使用 FSMC接口实现 8080接口时序。</p></li><li><p>初始化TFTLCD模块，向LCD控制器写入一系列的设置值（比如RGB格式、LCD显示方向、伽马校准等），这部分代码一般LCD厂商会提供，初始化之后LCD才可以正常使用。</p></li><li><p>通过函数将字符和数字显示到TFTLCD模块上，点操作只是一个点的处理，因此需要设计一个函数来多次使用这个步骤以实现字符和数字的显示。</p></li></ul><h3 id="fsmc-简介">FSMC 简介</h3><p>FSMC（Flexible Static MemoryController即灵活的静态存储控制器）是STM32系列采用的一种新型存储器扩展技术，能够连接同步、异步存储器和16位PC存储卡，STM32通过FSMC可以与SRAM、ROM、PSRAM、NORFlash和NAND Flash等存储器的引脚直接相连。</p><h4 id="stm32f1的fsmc内部框图">STM32F1的FSMC内部框图</h4><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530152947731.png" alt="image-20230530152947731" style="zoom:80%;" /></p><p>从上图我们可以看出，STM32 的 FSMC 将外部设备分为 3 类：NOR/PSRAM设备、NAND设备、PC卡设备。他们共用地址、数据总线等信号，具有不同的片选(NE[4:1])以区分不同的设备。</p><h4 id="fsmc-存储器划分">FSMC 存储器划分</h4><p>FSMC 将外部存储器划分固定大小为 256M 字节的四个存储块,如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530155325449.png" alt="image-20230530155325449" style="zoom:80%;" /></p><ul><li><strong>NOR/PSRAM块</strong>有四个区：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531083826527.png" alt="image-20230531083826527" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531084817727.png" alt="image-20230531084817727" style="zoom:80%;" /></p><ul><li><strong>NAND Flash块和PC Card块</strong>：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531091707020.png" alt="image-20230531091707020" style="zoom:80%;" /></p><p>​ 其中，NAND Flash有三个区：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531091542061.png" alt="image-20230531091542061" style="zoom:80%;" /></p><h4 id="传输时序模式">传输时序模式</h4><ul><li><p>NOR Flash/PSRAM 控制器 <strong>异步</strong> 传输时序模式：</p><ul><li><p><strong>Mode 1</strong> - SRAM/PSRAM (CRAM)</p></li><li><p><strong>Mode A</strong> - SRAM/PSRAM (CRAM) 输出使能触发</p></li><li><p><strong>Mode 2/B</strong> - NOR Flash</p></li><li><p><strong>Mode C</strong> - NOR Flash 输出使能触发</p></li><li><p><strong>Mode D</strong> - 扩展地址异步传输</p></li><li><p><strong>Muxed mode</strong> - NOR Flash复合异步传输</p></li></ul></li><li><p>NAND Flash和PC Card只有一种异步传输时序模式：</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531095320326.png" alt="image-20230531095320326" style="zoom:80%;" /></p><p>本实验中使用的TFTLCD采用Mode A模式连接到STM32 FSMC上，其ModeA读写时序如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531100226860.png" alt="image-20230531100226860" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531100246088.png" alt="image-20230531100246088" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531113726434.png" alt="image-20230531113726434" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530152024061.png" alt="image-20230530152024061" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>设置PB0为GPIO输出模式，上拉，高速，默认低电平。（背光控制信号）</li><li>选择FSMC，选中Bank1，片选为NE4（即Bank1的第4区），存储器类型选为LCDInterface，LCD寄存器选择（RS）设置为A10，数据宽度设为16位</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531114601180.png" alt="image-20230531114601180" style="zoom:80%;" /></p><ul><li>在FSMC配置菜单中，使能存储器写，根据LCD驱动芯片的数据参数设置地址建立时间、数据保存时间、总线周转阶段持续时间（设置为0），模式A</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531115913269.png" alt="image-20230531115913269" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>创建TFTLCD驱动文件tftlcd.c和tftlcd.h,部分代码如下，详细代码见工程。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* LCD重要参数集 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">uint16_t</span> width;     <span class="hljs-comment">/* LCD 宽度 */</span>    <span class="hljs-type">uint16_t</span> height;    <span class="hljs-comment">/* LCD 高度 */</span><span class="hljs-type">uint16_t</span> lcd_id;    <span class="hljs-comment">/* lcd id */</span>    <span class="hljs-type">uint8_t</span> dir;        <span class="hljs-comment">/* 横屏还是竖屏控制：0，竖屏；1，横屏。 */</span>&#125;<span class="hljs-type">lcd_dev_t</span>;<span class="hljs-comment">/* LCD背光控制 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_BL(x)   do&#123; x ? \</span><span class="hljs-meta">                      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET) : \</span><span class="hljs-meta">                      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET); \</span><span class="hljs-meta">                     &#125;while(0)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSMC_ADDR_CMD  ((uint32_t*)0x6C000000)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSMC_ADDR_DATA ((uint32_t*)0x6C000800) </span><span class="hljs-comment">/******************************************************************************************/</span><span class="hljs-comment">/* LCD 属性,根据使用的屏幕改变其属性 */</span><span class="hljs-comment">/** ---------------------------------</span><span class="hljs-comment"> * | LCD ID Type | Width or Height |</span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> * |    9343     |     240*320     | </span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> * | 5510/1963   |     480*800     |</span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> * |    5310     |     320*480     |</span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_WIDTH       240</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_HEIGHT      320</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_VERTICAL    0  </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_HORIZONTAL  1</span><span class="hljs-comment">/* LCD device ID */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_9341    (0X9341)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_8552    (0X8552)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_5510    (0X5510)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_1963    (0X1963)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_5310    (0X5310)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_7789    (0x7789)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_5761    (0X5761)</span><span class="hljs-comment">/******************************************************************************************/</span><span class="hljs-comment">/* ILI9341、SSD1963、ST7789、NT35310 command */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD9341_READ_ID   0xd3     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD7789_READ_ID   0x04     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5310_READ_ID   0xd4     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1963_READ_ID   0xa1     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_SCAN_DIR       0x36     <span class="hljs-comment">//scanning direction of frame memory.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_DISPLAY_ON     0x29     <span class="hljs-comment">//Display on</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_DISPLAY_OFF    0x28     <span class="hljs-comment">//Display off</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_ADDR_COLUMN    0x2a     <span class="hljs-comment">//X坐标 Column Address Set</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_ADDR_PAGE      0x2b     <span class="hljs-comment">//Y坐标 Page Address Set </span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_WR_GRAM        0x2c     <span class="hljs-comment">//Memory Write</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_RD_GRAM        0x2e     <span class="hljs-comment">//Memory Read</span></span><span class="hljs-comment">/* NT5510 command */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_READ_IDH       0xC500     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_READ_IDL       0xC501     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_SCAN_DIR       0x3600     <span class="hljs-comment">//scanning direction of frame memory.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_DISPLAY_ON     0x2900     <span class="hljs-comment">//Display on</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_DISPLAY_OFF    0x2800     <span class="hljs-comment">//Display off</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_ADDR_COLUMN    0X2A00     <span class="hljs-comment">//X坐标 Column Address Set</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_ADDR_PAGE      0X2B00     <span class="hljs-comment">//Y坐标 Page Address Set </span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_WR_GRAM        0X2C00     <span class="hljs-comment">//Memory Write</span></span><span class="hljs-comment">/* 屏幕扫描方向定义 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> L2R_U2D         0           <span class="hljs-comment">/* 从左到右,从上到下, 默认的扫描方向 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> L2R_D2U         1           <span class="hljs-comment">/* 从左到右,从下到上 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> R2L_U2D         2           <span class="hljs-comment">/* 从右到左,从上到下 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> R2L_D2U         3           <span class="hljs-comment">/* 从右到左,从下到上 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> U2D_L2R         4           <span class="hljs-comment">/* 从上到下,从左到右 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> U2D_R2L         5           <span class="hljs-comment">/* 从上到下,从右到左 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> D2U_L2R         6           <span class="hljs-comment">/* 从下到上,从左到右 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> D2U_R2L         7           <span class="hljs-comment">/* 从下到上,从右到左 */</span></span><span class="hljs-comment">/******************************************************************************************/</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_data</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> value)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_cmd</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> cmd)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_write_reg</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> cmd, <span class="hljs-type">uint16_t</span> value)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;                        <span class="hljs-comment">/* 初始化LCD */</span> <span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_clear</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> color)</span>;     <span class="hljs-comment">/* LCD清屏 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_draw_line</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x1, <span class="hljs-type">uint16_t</span> y1, <span class="hljs-type">uint16_t</span> x2, <span class="hljs-type">uint16_t</span> y2, <span class="hljs-type">uint16_t</span> color)</span>;     <span class="hljs-comment">/* 画直线 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_draw_rectangle</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x1, <span class="hljs-type">uint16_t</span> y1, <span class="hljs-type">uint16_t</span> x2, <span class="hljs-type">uint16_t</span> y2, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-comment">/* 画矩形 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_char</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">char</span> chr, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">uint8_t</span> mode, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_num</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> len, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_xnum</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> len, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">uint8_t</span> mode, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_string</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">uint16_t</span> width, <span class="hljs-type">uint16_t</span> height, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">char</span> *p, <span class="hljs-type">uint16_t</span> color)</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 定义一个LCD结构体变量 */</span><span class="hljs-type">lcd_dev_t</span> lcddev = &#123;.width = LCD_WIDTH,.height = LCD_HEIGHT,.dir = LCD_VERTICAL  <span class="hljs-comment">/* 默认为竖屏 */</span>&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD写数据</span><span class="hljs-comment"> * @param       data: 要写入的数据</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_data</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> value)</span>&#123;    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_DATA) = value;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD写指令</span><span class="hljs-comment"> * @param       cmd: lcd指令</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_cmd</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> cmd)</span>&#123;    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_CMD) = cmd;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD读数据</span><span class="hljs-comment"> * @param       无</span><span class="hljs-comment"> * @retval      读取到的数据</span><span class="hljs-comment"> */</span><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">lcd_rd_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-keyword">return</span> (*( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_DATA));&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD写寄存器</span><span class="hljs-comment"> * @param       cmd:指令</span><span class="hljs-comment"> * @param       data:要写入的数据</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_write_reg</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> cmd, <span class="hljs-type">uint16_t</span> value)</span>&#123;    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_CMD) = cmd;       <span class="hljs-comment">/* 写入要写的指令 */</span>    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_DATA) = value;    <span class="hljs-comment">/* 写入数据 */</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       初始化LCD</span><span class="hljs-comment"> * @note        该初始化函数可以初始化各种型号的LCD(详见本.c文件最前面的描述)</span><span class="hljs-comment"> * @param       无</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* 获取屏幕id */</span>  lcddev.lcd_id = lcd_read_id();  <span class="hljs-comment">/* 显示之前必须lcd芯片初始化 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_7789)    &#123;        lcd_ex_st7789_reginit();    <span class="hljs-comment">/* 执行ST7789初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_9341)    &#123;        lcd_ex_ili9341_reginit();   <span class="hljs-comment">/* 执行ILI9341初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5310)    &#123;        lcd_ex_nt35310_reginit();   <span class="hljs-comment">/* 执行NT35310初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5510)    &#123;        lcd_ex_nt35510_reginit();   <span class="hljs-comment">/* 执行NT35510初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_1963)    &#123;        lcd_ex_ssd1963_reginit();   <span class="hljs-comment">/* 执行SSD1963初始化 */</span>        lcd_ssd_set_backlight(<span class="hljs-number">100</span>); <span class="hljs-comment">/* 背光设置为最亮 */</span>    &#125;    <span class="hljs-comment">/* 设置屏幕大小、方向及扫描方向 */</span>  lcd_set_scan_dir(L2R_U2D);    <span class="hljs-comment">/* 开背光 */</span>    LCD_BL(<span class="hljs-number">1</span>);       <span class="hljs-comment">/* 清屏 */</span>    lcd_clear(WHITE);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       读取屏幕id</span><span class="hljs-comment"> * @param       None</span><span class="hljs-comment"> * @retval      屏幕id</span><span class="hljs-comment"> */</span><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">lcd_read_id</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* 尝试9341 ID的读取 */</span>    lcd_wr_cmd(LCD9341_READ_ID);    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* dummy read */</span>    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读到0X00 */</span>    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读取93 */</span>    lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;    lcddev.lcd_id |= lcd_rd_data(); <span class="hljs-comment">/* 读取41 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_9341)    <span class="hljs-comment">/* 不是 9341 , 尝试看看是不是 ST7789 */</span>    &#123;        lcd_wr_cmd(LCD7789_READ_ID);        lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* dummy read */</span>        lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* 读到0X85 */</span>        lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* 读取0X85 */</span>        lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;        lcddev.lcd_id |= lcd_rd_data();     <span class="hljs-comment">/* 读取0X52 */</span>                <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_8552)        <span class="hljs-comment">/* 将8552的ID转换成7789 */</span>        &#123;            lcddev.lcd_id = LCD_7789;        &#125;        <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_7789)        <span class="hljs-comment">/* 也不是ST7789, 尝试是不是 NT35310 */</span>        &#123;            lcd_wr_cmd(LCD5310_READ_ID);            lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* dummy read */</span>            lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读回0X01 */</span>            lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读回0X53 */</span>            lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;            lcddev.lcd_id |= lcd_rd_data(); <span class="hljs-comment">/* 这里读回0X10 */</span>            <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_5310)    <span class="hljs-comment">/* 也不是NT35310,尝试看看是不是NT35510 */</span>            &#123;                <span class="hljs-comment">/* 发送秘钥（厂家提供,照搬即可） */</span>                lcd_write_reg(<span class="hljs-number">0xF000</span>, <span class="hljs-number">0x0055</span>);                lcd_write_reg(<span class="hljs-number">0xF001</span>, <span class="hljs-number">0x00AA</span>);                lcd_write_reg(<span class="hljs-number">0xF002</span>, <span class="hljs-number">0x0052</span>);                lcd_write_reg(<span class="hljs-number">0xF003</span>, <span class="hljs-number">0x0008</span>);                lcd_write_reg(<span class="hljs-number">0xF004</span>, <span class="hljs-number">0x0001</span>);                                lcd_wr_cmd(LCD5510_READ_IDH);           <span class="hljs-comment">/* 读取ID高8位 */</span>                lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* 读回0X55 */</span>                lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;                lcd_wr_cmd(LCD5510_READ_IDL);           <span class="hljs-comment">/* 读取ID低8位 */</span>                lcddev.lcd_id |= lcd_rd_data();     <span class="hljs-comment">/* 读回0X10 */</span>                HAL_Delay(<span class="hljs-number">5</span>);                                <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_5510)        <span class="hljs-comment">/* 也不是NT5510,尝试看看是不是SSD1963 */</span>                &#123;                    lcd_wr_cmd(LCD1963_READ_ID);                    lcddev.lcd_id = lcd_rd_data();                    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读回0X57 */</span>                    lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;                    lcddev.lcd_id |= lcd_rd_data(); <span class="hljs-comment">/* 读回0X61 */</span>                    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5761)lcddev.lcd_id = LCD_1963; <span class="hljs-comment">/* SSD1963读回的ID是5761H,为方便区分,我们强制设置为1963 */</span>                &#125;            &#125;        &#125;    &#125;<span class="hljs-keyword">return</span> lcddev.lcd_id;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       设置LCD的自动扫描方向(对RGB屏无效)</span><span class="hljs-comment"> * @note</span><span class="hljs-comment"> *              9341/5310/5510/1963/7789等IC已经实际测试</span><span class="hljs-comment"> *              注意:其他函数可能会受到此函数设置的影响(尤其是9341),</span><span class="hljs-comment"> *              所以,一般设置为L2R_U2D即可,如果设置为其他扫描方式,可能导致显示不正常.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param       dir:0~7,代表8个方向</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_set_scan_dir</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> dir)</span>&#123;    <span class="hljs-type">uint16_t</span> regval = <span class="hljs-number">0</span>;    <span class="hljs-type">uint16_t</span> dirreg = <span class="hljs-number">0</span>;    <span class="hljs-type">uint16_t</span> temp;    <span class="hljs-comment">/* 横屏时，对1963不改变扫描方向！其他IC改变扫描方向！竖屏时1963改变方向，其他IC不改变扫描方向 */</span>    <span class="hljs-keyword">if</span> ((lcddev.dir == LCD_HORIZONTAL &amp;&amp; lcddev.lcd_id != LCD_1963) || (lcddev.dir == LCD_VERTICAL &amp;&amp; lcddev.lcd_id == LCD_1963))    &#123;        <span class="hljs-keyword">switch</span> (dir)   <span class="hljs-comment">/* 方向转换 */</span>        &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: dir = <span class="hljs-number">6</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: dir = <span class="hljs-number">7</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: dir = <span class="hljs-number">4</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: dir = <span class="hljs-number">5</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: dir = <span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: dir = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: dir = <span class="hljs-number">3</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: dir = <span class="hljs-number">2</span>; <span class="hljs-keyword">break</span>;        &#125;    &#125;<span class="hljs-comment">/* 根据扫描方式 设置 0X36/0X3600 寄存器 bit 5,6,7 位的值 */</span><span class="hljs-keyword">switch</span> (dir)&#123;<span class="hljs-keyword">case</span> L2R_U2D:<span class="hljs-comment">/* 从左到右,从上到下 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> L2R_D2U:<span class="hljs-comment">/* 从左到右,从下到上 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> R2L_U2D:<span class="hljs-comment">/* 从右到左,从上到下 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> R2L_D2U:<span class="hljs-comment">/* 从右到左,从下到上 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> U2D_L2R:<span class="hljs-comment">/* 从上到下,从左到右 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> U2D_R2L:<span class="hljs-comment">/* 从上到下,从右到左 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> D2U_L2R:<span class="hljs-comment">/* 从下到上,从左到右 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> D2U_R2L:<span class="hljs-comment">/* 从下到上,从右到左 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;&#125;dirreg = LCD_SCAN_DIR;  <span class="hljs-comment">/* 对绝大部分驱动IC, 由0X36寄存器控制 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5510)    &#123;        dirreg = LCD5510_SCAN_DIR;    <span class="hljs-comment">/* 对于5510, 和其他驱动ic的寄存器有差异 */</span>    &#125;     <span class="hljs-comment">/* 9341 &amp; 7789 要设置BGR位 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_9341 || lcddev.lcd_id == LCD_7789)    &#123;        regval |= <span class="hljs-number">0X08</span>;    &#125;lcd_write_reg(dirreg, regval);<span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_1963)   <span class="hljs-comment">/* 1963不做坐标处理 */</span>&#123;<span class="hljs-keyword">if</span> (regval &amp; <span class="hljs-number">0X20</span>)&#123;<span class="hljs-keyword">if</span> (lcddev.width &lt; lcddev.height)   <span class="hljs-comment">/* 交换X,Y */</span>&#123;temp = lcddev.width;lcddev.width = lcddev.height;lcddev.height = temp;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (lcddev.width &gt; lcddev.height)   <span class="hljs-comment">/* 交换X,Y */</span>&#123;temp = lcddev.width;lcddev.width = lcddev.height;lcddev.height = temp;&#125;&#125;&#125;<span class="hljs-comment">/* 设置显示区域(开窗)大小 */</span><span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5510)&#123;lcd_wr_cmd(LCD5510_ADDR_COLUMN);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_COLUMN + <span class="hljs-number">1</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_COLUMN + <span class="hljs-number">2</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_cmd(LCD5510_ADDR_COLUMN + <span class="hljs-number">3</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE + <span class="hljs-number">1</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE + <span class="hljs-number">2</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE + <span class="hljs-number">3</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);&#125;<span class="hljs-keyword">else</span>&#123;lcd_wr_cmd(LCD_ADDR_COLUMN);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);lcd_wr_cmd(LCD_ADDR_PAGE);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       清屏函数</span><span class="hljs-comment"> * @param       color: 要清屏的颜色</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_clear</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> color)</span>&#123;    <span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>;    <span class="hljs-type">uint32_t</span> totalpoint = lcddev.width;    totalpoint *= lcddev.height;    <span class="hljs-comment">/* 得到总点数 */</span>    lcd_set_cursor(<span class="hljs-number">0x00</span>, <span class="hljs-number">0x0000</span>);   <span class="hljs-comment">/* 设置光标位置 */</span>  <span class="hljs-keyword">if</span>(lcddev.lcd_id == LCD_5510)&#123;  lcd_wr_cmd(LCD5510_WR_GRAM);        <span class="hljs-comment">/* 开始写入GRAM */</span>&#125;<span class="hljs-keyword">else</span>&#123;  lcd_wr_cmd(LCD_WR_GRAM);        <span class="hljs-comment">/* 开始写入GRAM */</span>&#125;    <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; totalpoint; index++)    &#123;  lcd_wr_data(color);    &#125;&#125;</code></pre></div><ul><li>在main.c文件下编写TFTLCD测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./Lcd/tftlcd.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">/* USER CODE END Includes */</span><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> x = <span class="hljs-number">0</span>;<span class="hljs-type">uint8_t</span> dev_id[<span class="hljs-number">12</span>];<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>lcd_init();                                         <span class="hljs-comment">/* 初始化LCD */</span><span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)dev_id, <span class="hljs-string">&quot;LCD ID:%04X&quot;</span>, lcddev.lcd_id);  <span class="hljs-comment">/* 将LCD ID打印到lcd_id数组 */</span><span class="hljs-comment">//printf(&quot;LCD ID:%x\r\n&quot;, lcddev.lcd_id); /* 打印LCD ID 此处没有初始化串口，无法打印 */</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">switch</span> (x)    &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: lcd_clear(WHITE);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: lcd_clear(BLACK);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: lcd_clear(BLUE);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: lcd_clear(RED);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: lcd_clear(MAGENTA);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: lcd_clear(GREEN);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: lcd_clear(CYAN);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: lcd_clear(YELLOW);  <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: lcd_clear(BRRED);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: lcd_clear(GRAY);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: lcd_clear(LGRAY);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: lcd_clear(BROWN);<span class="hljs-keyword">break</span>;    &#125;    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">240</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&quot;STM32&quot;</span>, RED);    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">80</span>, <span class="hljs-number">240</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&quot;TFTLCD TEST&quot;</span>, GREEN);    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">110</span>, <span class="hljs-number">240</span>, <span class="hljs-number">16</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;KayoungZhang&quot;</span>, GREEN);    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">130</span>, <span class="hljs-number">240</span>, <span class="hljs-number">16</span>, <span class="hljs-number">16</span>, (<span class="hljs-type">char</span> *)dev_id, RED); <span class="hljs-comment">/* 显示LCD ID */</span>    <span class="hljs-keyword">if</span> (x++ == <span class="hljs-number">12</span>)        x = <span class="hljs-number">0</span>;    HAL_Delay(<span class="hljs-number">1000</span>); <span class="hljs-comment">//1s轮换一次画面</span>&#125;</code></pre></div><ul><li>编译无误下载到开发板后，LCD屏循环显示相应的文字</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604142633939.png" alt="image-20230604142633939" style="zoom: 50%;" /><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604142703634.png" alt="image-20230604142703634" style="zoom: 50%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/tftlcd.zip">tftlcd</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;tftlcd简介&quot;&gt;TFTLCD简介&lt;/h3&gt;
&lt;p&gt;TFT-LCD（thin film transistor-liquid crystal
display）即薄膜晶体管液晶显示器。液晶显示屏的每一个像素上都设置有一个薄膜晶体管（TFT），每个像素都可以通过点</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之SPI_Flash</title>
    <link href="http://example.com/2023/05/30/STM32CubeMX%E4%B9%8BSPI-Flash/"/>
    <id>http://example.com/2023/05/30/STM32CubeMX%E4%B9%8BSPI-Flash/</id>
    <published>2023-05-30T03:33:12.000Z</published>
    <updated>2023-06-06T00:32:54.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="spi-简介">SPI 简介</h3><p>SPI全称Serial PeripheralInterface，即串行外围设备接口。它是Motorola首先在其MC68HCXX系列处理器上定义的。SPI是一种高速的、全双工、同步通讯总线。</p><p>标准的SPI需要四根信号线：</p><p><strong>SS（SlaveSelect）</strong>：从设备选择，也称片选，master通过拉低slave的片选信号选择slave<strong>SCK（SerialClock）</strong>：传输时钟的信号线，时钟信号由master产生，类似于I2C的SCL<strong>MOSI（Master Out SlaveIn）</strong>：master输出，slave输入，由master向slave发送数据的通道<strong>MISO（Master In SlaveOut）</strong>：master输入，slave输出，由slave向master发送数据的通道</p><p>通常一个master主设备可以连接多个slave从设备，同一时刻只有一个slave可以与master通信，通过片选信号来进行区别，还有一种类似菊花链的连接方式，可自行了解。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2294744-20220112223510175-1577265499.jpg"alt="SPI多从机示意图" /><figcaption aria-hidden="true">SPI多从机示意图</figcaption></figure><p>SPI的工作基于移位寄存器，工作过程就像一个环形传送带，由master逐位将数据放在传送带上，并驱动传送带将数据传送到slave，同时slave也会同步地逐位将数据传送给master。简单的理解:可以认为是数据交换，外设的写操作和读操作时同步完成的，如果只进行写操作，主设备只需要忽略接收到的字节，如果主设备要进行读操作，就必须发送一个空字节来引发从设备的传输。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2294744-20220112223510132-1684027745.jpg"alt="SPI移位原理" /><figcaption aria-hidden="true">SPI移位原理</figcaption></figure><p>SPI总线根据时钟极性（CPOL）和时钟相位（CPHA）的配置不同，可以有四种工作方式：</p><ul><li><strong>mode 0：CPOL = 0，CPHA = 0；</strong></li></ul><p>时钟空闲时为低电平，第一个上升沿采样，第一个下降沿传输数据</p><ul><li><strong>mode 1：CPOL = 0，CPHA = 1；</strong></li></ul><p>时钟空闲时为低电平，第一个上升沿传输数据，第一个下降沿采样</p><ul><li><strong>mode 2：CPOL = 1，CPHA = 0；</strong></li></ul><p>时钟空闲时为高电平，第一个下降沿采样，第一个上升沿传输数据</p><ul><li><strong>mode 3：CPOL = 1，CPHA = 1；</strong></li></ul><p>时钟空闲时为高电平，第一个下降沿传输数据，第一个上升沿采样</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530135814179.png" alt="image-20230530135814179" style="zoom:80%;" /></p><p>STM32内部集成有 SPI 控制器，其内部框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530132423592.png" alt="image-20230530132423592" style="zoom:80%;" /></p><h3 id="w25qxx芯片简介">W25QXX芯片简介</h3><p>外部flash使用比较多的是华邦公司推出的W25QXX系列spiflash芯片，开发板上使用的flash是W25Q128。</p><p>它的容量为128M-bit（16M字节），它分为256个块(Block)（块大小为64KB），每个块又分为16个扇区(Sector)（扇区大小为4KB），最小擦除单位为一个扇区即4KB，因此在选择芯片的时候必须要有4K以上的SRAM（可以开辟4K的缓冲区）。</p><p>W25Q128 flash框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530141712311.png" alt="image-20230530141712311"  /></p><p>其常用指令如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530141512789.png" alt="image-20230530141512789"  /></p><h3 id="硬件设计">硬件设计</h3><p>我们将使用 STM32 的 SPI2 来读取外部 SPI FLASH芯片（W25Q128），向flash写入数据，然后读出来，并使用串口打印出来。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530142337023.png" alt="image-20230530142337023" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>PB12设置为GPIO推挽输出模式、默认高电平输出、上拉、高速（片选引脚）</li><li>激活SPI2，不开启NSS，数据长度8位，MSB先输出，分频因子256，CPOL为HIGH，CPHA为第二个边沿，不开启CRC检验，NSS为软件控制</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530145350108.png" alt="image-20230530145350108" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li><p>在spi.c文件下可以看到SPI2的初始化函数，片选管脚的初始化在gpio.c中。</p></li><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</p></li><li><p>在工程中创建w25qxx文件夹，并编写flash驱动文件：w25qxx.c和w25qxx.h,注意添加头文件及路径，部分重要的函数如下：</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  使用SPI2发送一个字节的数据并返回读取的一字节数据</span><span class="hljs-comment"> * @param  byte：要发送的数据</span><span class="hljs-comment"> * @retval 返回接收到的数据</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">spi2_rd_wr_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> TxData)</span>&#123;<span class="hljs-type">uint8_t</span> Rxdata;HAL_SPI_TransmitReceive(&amp;hspi2,&amp;TxData,&amp;Rxdata,<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>);        <span class="hljs-keyword">return</span> Rxdata;              <span class="hljs-comment">//返回收到的数据</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  读取flash id</span><span class="hljs-comment"> * @param  None.</span><span class="hljs-comment"> * @retval Temp: 返回的ID值</span><span class="hljs-comment"> */</span><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">w25qxx_readID</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint16_t</span> Temp = <span class="hljs-number">0</span>;W25QXX_CS_LOW();  <span class="hljs-comment">/* Send &quot;RDID &quot; instruction */</span>spi2_rd_wr_byte(W25X_ManufactDeviceID);<span class="hljs-comment">//发送读取ID命令    </span>spi2_rd_wr_byte(Dummy_Byte);     spi2_rd_wr_byte(Dummy_Byte);     spi2_rd_wr_byte(Dummy_Byte);  Temp|=spi2_rd_wr_byte(Dummy_Byte)&lt;&lt;<span class="hljs-number">8</span>;  Temp|=spi2_rd_wr_byte(Dummy_Byte); W25QXX_CS_HIGH();    <span class="hljs-keyword">return</span> Temp;&#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  擦除FLASH扇区</span><span class="hljs-comment">  * @param  SectorAddr：要擦除的扇区地址</span><span class="hljs-comment">  * @retval 无</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_erase_sector</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> SectorAddr)</span>   &#123;  w25qxx_write_enable();                  <span class="hljs-comment">//SET WEL  </span>w25qxx_wait_busy();   W25QXX_CS_LOW();                            <span class="hljs-comment">//使能器件   </span>spi2_rd_wr_byte(W25X_SectorErase);   <span class="hljs-comment">//发送扇区擦除指令 </span><span class="hljs-keyword">if</span>(W25QXX_TYPE==W25Q256)                <span class="hljs-comment">//如果是W25Q256的话地址为4字节的，要发送最高8位</span>&#123;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((SectorAddr)&gt;&gt;<span class="hljs-number">24</span>)); &#125;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((SectorAddr)&gt;&gt;<span class="hljs-number">16</span>));  <span class="hljs-comment">//发送24bit地址    </span>spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((SectorAddr)&gt;&gt;<span class="hljs-number">8</span>));   spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)SectorAddr);  W25QXX_CS_HIGH();                            <span class="hljs-comment">//取消片选           </span>w25qxx_wait_busy();       <span class="hljs-comment">//等待擦除完成</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  对FLASH写入数据，调用本函数写入数据前需要先擦除扇区</span><span class="hljs-comment">  * @param pBuffer，要写入数据的指针</span><span class="hljs-comment">  * @param  WriteAddr，写入地址</span><span class="hljs-comment">  * @param  NumByteToWrite，写入数据长度</span><span class="hljs-comment">  * @retval 无</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer, <span class="hljs-type">uint32_t</span> WriteAddr, <span class="hljs-type">uint16_t</span> NumByteToWrite)</span>&#123;<span class="hljs-type">uint8_t</span> NumOfPage = <span class="hljs-number">0</span>, NumOfSingle = <span class="hljs-number">0</span>, Addr = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, temp = <span class="hljs-number">0</span>;Addr = WriteAddr % W25X_PageSize;   <span class="hljs-comment">//mod运算求余，若writeAddr是W25X_PageSize整数倍，运算结果Addr值为0</span>count = W25X_PageSize - Addr;<span class="hljs-comment">//差count个数据值，刚好可以对齐到页地址</span>NumOfPage =  NumByteToWrite / W25X_PageSize; <span class="hljs-comment">//计算出要写多少整数页</span>NumOfSingle = NumByteToWrite % W25X_PageSize; <span class="hljs-comment">//mod运算求余，计算出剩余不满一页的字节数</span><span class="hljs-comment">/* Addr=0,则WriteAddr 刚好按页对齐 aligned  */</span><span class="hljs-keyword">if</span> (Addr == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (NumOfPage == <span class="hljs-number">0</span>) <span class="hljs-comment">// NumByteToWrite &lt; W25X_PageSize</span>&#123;   w25qxx_page_write(pBuffer, WriteAddr, NumByteToWrite);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">while</span> (NumOfPage--)<span class="hljs-comment">//先把整数页都写了</span>&#123;w25qxx_page_write(pBuffer, WriteAddr, W25X_PageSize);WriteAddr +=  W25X_PageSize;pBuffer += W25X_PageSize;&#125;w25qxx_page_write(pBuffer, WriteAddr, NumOfSingle);<span class="hljs-comment">//若有多余的不满一页的数据，把它写完</span>&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">/* WriteAddr 不能按页对齐 */</span>&#123;<span class="hljs-keyword">if</span> (NumOfPage == <span class="hljs-number">0</span>) <span class="hljs-comment">//NumByteToWrite &lt; W25X_PageSize</span>&#123;<span class="hljs-keyword">if</span> (NumOfSingle &gt; count) <span class="hljs-comment">//当前页剩余的count个位置比NumOfSingle小，写不完</span>&#123;temp = NumOfSingle - count;w25qxx_page_write(pBuffer, WriteAddr, count);<span class="hljs-comment">//先写满当前页</span>WriteAddr +=  count;pBuffer += count;w25qxx_page_write(pBuffer, WriteAddr, temp);<span class="hljs-comment">//再写剩余的数据</span>&#125;<span class="hljs-keyword">else</span> &#123;w25qxx_page_write(pBuffer, WriteAddr, NumByteToWrite);&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/*地址不对齐多出的count分开处理，不加入这个运算*/</span>NumByteToWrite -= count;NumOfPage =  NumByteToWrite / W25X_PageSize;NumOfSingle = NumByteToWrite % W25X_PageSize;w25qxx_page_write(pBuffer, WriteAddr, count);WriteAddr +=  count;pBuffer += count;<span class="hljs-keyword">while</span> (NumOfPage--)<span class="hljs-comment">//把整数页都写了</span>&#123;w25qxx_page_write(pBuffer, WriteAddr, W25X_PageSize);WriteAddr +=  W25X_PageSize;pBuffer += W25X_PageSize;&#125;<span class="hljs-keyword">if</span> (NumOfSingle != <span class="hljs-number">0</span>)<span class="hljs-comment">//若有多余的不满一页的数据，把它写完</span>&#123;w25qxx_page_write(pBuffer, WriteAddr, NumOfSingle);&#125;&#125;&#125;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief   读取FLASH数据</span><span class="hljs-comment">  * @param   pBuffer，存储读出数据的指针</span><span class="hljs-comment">  * @param   ReadAddr，读取地址</span><span class="hljs-comment">  * @param   NumByteToRead，读取数据长度</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer,<span class="hljs-type">uint32_t</span> ReadAddr,<span class="hljs-type">uint16_t</span> NumByteToRead)</span>   &#123;     W25QXX_CS_LOW();                            <span class="hljs-comment">//使能器件   </span>spi2_rd_wr_byte(W25X_ReadData);      <span class="hljs-comment">//发送读取命令  </span><span class="hljs-keyword">if</span>(W25QXX_TYPE==W25Q256)                <span class="hljs-comment">//如果是W25Q256的话地址为4字节的，要发送最高8位</span>&#123;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((ReadAddr)&gt;&gt;<span class="hljs-number">24</span>));    &#125;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((ReadAddr)&gt;&gt;<span class="hljs-number">16</span>));   <span class="hljs-comment">//发送24bit地址    </span>spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((ReadAddr)&gt;&gt;<span class="hljs-number">8</span>));   spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)ReadAddr);<span class="hljs-comment">/* 读取数据 */</span><span class="hljs-keyword">while</span> (NumByteToRead--)&#123;*pBuffer = spi2_rd_wr_byte(Dummy_Byte);<span class="hljs-comment">/* 指向下一个字节缓冲区 */</span>pBuffer++;&#125;W25QXX_CS_HIGH();            &#125;</code></pre></div><ul><li>在main.c文件下编写SPI测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> wData[<span class="hljs-number">255</span>];<span class="hljs-type">uint8_t</span> rData[<span class="hljs-number">255</span>];<span class="hljs-type">uint32_t</span> i;<span class="hljs-type">uint16_t</span> flash_id = <span class="hljs-number">0</span>;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>flash_id = w25qxx_readID();<span class="hljs-keyword">if</span>(flash_id == W25Q128)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash type is W25Q128. ID: %#X \r\n&quot;</span>, flash_id);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash type is unknown. ID: %#X \r\n&quot;</span>, flash_id);&#125;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)&#123;    wData[i] = i;    rData[i] = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 写入数据，写入之前必须擦除 */</span>w25qxx_erase_sector(<span class="hljs-number">0</span>);w25qxx_write(wData, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">/* 读取数据 */</span>    w25qxx_read(rData, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);     <span class="hljs-comment">/* 打印数据 */</span>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02X &quot;</span>, rData[i]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">2000</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，串口助手每隔1秒打印读取的数据信息。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230602214324217.png" alt="image-20230602214324217" style="zoom:80%;" /></p><p>工程文件Gitee： <ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/spi_flash.zip">spi_flash</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;spi-简介&quot;&gt;SPI 简介&lt;/h3&gt;
&lt;p&gt;SPI全称Serial Peripheral
Interface，即串行外围设备接口。它是Motorola首先在其MC68HCXX系列处理器上定义的。SPI是一种高速的、全双工、同步通讯总线。&lt;/p&gt;
&lt;p&gt;标准</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之I2C_EEPROM</title>
    <link href="http://example.com/2023/05/30/STM32CubeMX%E4%B9%8BI2C-EEPROM/"/>
    <id>http://example.com/2023/05/30/STM32CubeMX%E4%B9%8BI2C-EEPROM/</id>
    <published>2023-05-30T03:32:09.000Z</published>
    <updated>2023-06-02T00:35:17.524Z</updated>
    
    <content type="html"><![CDATA[<h3 id="i2c-简介">I2C 简介</h3><p>I2C（Inter-IntegratedCircuit）总线是由PHILIPS公司开发的由数据线SDA和时钟线SCL构成的两线式串行总线，用于连接微控制器及其外围I2C设备。</p><p>在物理层结构框图上：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9f8e02deafc832aa7db61065c5a469b8f2d0f1d4.png@831w_276h_progressive.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>它有如下特点：</p><ul><li><p>在一个 I2C 通讯总线中，可连接多个 I2C设备，支持多个通讯主机及多个通讯从机。每个连接到总线的设备都有一个独立的地址，主机利用这个地址进行不同设备之间的访问；</p></li><li><p>总线通过上拉电阻接到电源。当 I2C设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。</p></li><li><p>多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p></li><li><p>有三种传输模式，标准模式（100kbit/s）、快速模式（400kbit/s）、高速模式（3.4Mbit/s多数I2C设备不支持）</p></li><li><p>连接到相同总线的 I2C 设备数量受到总线的最大电容 400pF限制。</p></li></ul><p>在I2C协议层上：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/1487d890ccbbd39731bc795c2c18b007b6f09e6f.png@831w_236h_progressive.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>I2C总线在传送数据的过程中共有三种类型信号：</p><ul><li>开始信号:SCL为高电平时，SDA由高电平向低电平跳变，开始传送数据</li><li>结束信号:SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据</li><li>应答信号:接收数据的IC在接收到8位数据后，向发送数据的IC发出特定的低电平脉冲，表示已经收到数据。</li></ul><p>I2C总线寻址按照从机地址可分为7位和10位（寻址字节）寻址两种，D7~D1位组成从机的地址，D0位是数据传送方向（0表示主机向从机写数据/1表示主机由从机读数据）</p><h3 id="eeprom简介">EEPROM简介</h3><p>EEPROM芯片具有掉电后存储内容不丢失的功能，所以一般用来存储参数数据，比较常用的AT24C02芯片，内部含有256个字节，具有I2C通讯接口。</p><p>AT24C02芯片的器件地址为7位，高4位固定为1010，低3位有上表中的A0/A1/A2引脚的电平决定，还有一位（最低位R/W）用来选择读写方向。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530124753089.png"alt="image-20230530124753089" /><figcaption aria-hidden="true">image-20230530124753089</figcaption></figure><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530122039619.png" alt="image-20230530122039619" style="zoom:80%;" /></p><p>通过向AT24C02写入特定的数据，然后断电从其中读取数据，通过串口1打印出来。</p><h3 id="软件设计">软件设计</h3><p>I2C程序可以通过gpio模拟的方式编写，但STM32集成有I2C控制器，所以可以直接通过其I2C控制器进行程序的控制。</p><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活I2C1，选择标准传输模式，选择7位寻址地址，其余默认设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601204436710.png" alt="image-20230601204436710" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li><p>在i2c.c文件下可以看到I2C1初始化函数;</p></li><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</p></li><li><p>添加AT24C02驱动文件24cxx.c和24cxx.h,并添加头文件和头文件路径，主要代码如下：</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief   从EEPROM里面读取一块数据   </span><span class="hljs-comment">  *@param     pBuffer:存放从EEPROM读取的数据的缓冲区指针</span><span class="hljs-comment">  *@param     WriteAddr:接收数据的EEPROM的地址</span><span class="hljs-comment">  * @param     NumByteToWrite:要从EEPROM读取的字节数</span><span class="hljs-comment">  * @retval  无</span><span class="hljs-comment">  */</span><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">at24cxx_BufferRead</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer, <span class="hljs-type">uint8_t</span> ReadAddr, <span class="hljs-type">uint16_t</span> NumByteToRead)</span>&#123;HAL_StatusTypeDef status = HAL_OK;status=HAL_I2C_Mem_Read(&amp;hi2c1,EEPROM_ADDRESS,ReadAddr, I2C_MEMADD_SIZE_8BIT, (<span class="hljs-type">uint8_t</span> *)pBuffer, NumByteToRead,<span class="hljs-number">1000</span>);<span class="hljs-keyword">return</span> status;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief     将缓冲区中的数据写到I2C EEPROM中  </span><span class="hljs-comment">  *@param     pBuffer:缓冲区指针</span><span class="hljs-comment">  *@param     WriteAddr:写地址</span><span class="hljs-comment">  * @param     NumByteToWrite:写的字节数</span><span class="hljs-comment">  * @retval    无</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">at24cxx_BufferWrite</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer, <span class="hljs-type">uint8_t</span> WriteAddr, <span class="hljs-type">uint16_t</span> NumByteToWrite)</span>&#123;  <span class="hljs-type">uint8_t</span> NumOfPage = <span class="hljs-number">0</span>, NumOfSingle = <span class="hljs-number">0</span>, Addr = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;  Addr = WriteAddr % EEPROM_PAGESIZE;  count = EEPROM_PAGESIZE - Addr;  NumOfPage =  NumByteToWrite / EEPROM_PAGESIZE;  NumOfSingle = NumByteToWrite % EEPROM_PAGESIZE;   <span class="hljs-comment">/* If WriteAddr is I2C_PageSize aligned  */</span>  <span class="hljs-keyword">if</span>(Addr == <span class="hljs-number">0</span>)   &#123;    <span class="hljs-comment">/* If NumByteToWrite &lt; I2C_PageSize */</span>    <span class="hljs-keyword">if</span>(NumOfPage == <span class="hljs-number">0</span>)     &#123;      at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);    &#125;    <span class="hljs-comment">/* If NumByteToWrite &gt; I2C_PageSize */</span>    <span class="hljs-keyword">else</span>      &#123;      <span class="hljs-keyword">while</span>(NumOfPage--)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, EEPROM_PAGESIZE);         WriteAddr +=  EEPROM_PAGESIZE;        pBuffer += EEPROM_PAGESIZE;      &#125;      <span class="hljs-keyword">if</span>(NumOfSingle!=<span class="hljs-number">0</span>)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);      &#125;    &#125;  &#125;  <span class="hljs-comment">/* If WriteAddr is not I2C_PageSize aligned  */</span>  <span class="hljs-keyword">else</span>   &#123;    <span class="hljs-comment">/* If NumByteToWrite &lt; I2C_PageSize */</span>    <span class="hljs-keyword">if</span>(NumOfPage== <span class="hljs-number">0</span>)     &#123;      at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);    &#125;    <span class="hljs-comment">/* If NumByteToWrite &gt; I2C_PageSize */</span>    <span class="hljs-keyword">else</span>    &#123;      NumByteToWrite -= count;      NumOfPage =  NumByteToWrite / EEPROM_PAGESIZE;      NumOfSingle = NumByteToWrite % EEPROM_PAGESIZE;            <span class="hljs-keyword">if</span>(count != <span class="hljs-number">0</span>)      &#123;          at24cxx_PageWrite(pBuffer, WriteAddr, count);        WriteAddr += count;        pBuffer += count;      &#125;             <span class="hljs-keyword">while</span>(NumOfPage--)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, EEPROM_PAGESIZE);        WriteAddr +=  EEPROM_PAGESIZE;        pBuffer += EEPROM_PAGESIZE;        &#125;      <span class="hljs-keyword">if</span>(NumOfSingle != <span class="hljs-number">0</span>)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);       &#125;    &#125;  &#125;  &#125;</code></pre></div><ul><li>在main.c中添加测试代码：</li></ul><p>AT24C02的2Kbit分为32页，每页8个字节。而EEPROM也可以按页写入，本例使用了按页写入的方式，分32次写入。注意每次写入完毕需要延时5ms，是AT24C02芯片的要求；读取数据没有页的限制，可以一次全部读取256个字节</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> WriteBuf[<span class="hljs-number">256</span>];<span class="hljs-type">uint8_t</span> ReadBuf[<span class="hljs-number">256</span>];<span class="hljs-type">uint16_t</span> i;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">256</span>; i++)&#123; <span class="hljs-comment">//初始化写数据缓冲区</span>    WriteBuf[i] = i;&#125;<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    at24cxx_BufferWrite(WriteBuf, <span class="hljs-number">0x00</span>, <span class="hljs-number">256</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EEPROM 24C02 write Test OK!\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">3000</span>); <span class="hljs-comment">//延时3s</span>    <span class="hljs-comment">/* EEPROM读取没有页限制，可以一次读取256个字节 */</span>    at24cxx_BufferRead(ReadBuf, <span class="hljs-number">0x00</span>, (<span class="hljs-type">uint16_t</span>)<span class="hljs-number">256</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>;i++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02X &quot;</span>,ReadBuf[i]);    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(WriteBuf,ReadBuf,<span class="hljs-number">256</span>) == <span class="hljs-number">0</span>)    &#123;<span class="hljs-comment">//通过内存比较，判断读取和写入的数据是否相同</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nEEPROM 24C02 Read Test OK!\r\n&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nEEPROM 24C02 Read Test False!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">500</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，同时串口助手打印出相应信息</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601220435162.png" alt="image-20230601220435162" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/i2c_eeprom.zip">i2c_eeprom</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;i2c-简介&quot;&gt;I2C 简介&lt;/h3&gt;
&lt;p&gt;I2C（Inter-Integrated
Circuit）总线是由PHILIPS公司开发的由数据线SDA和时钟线SCL构成的两线式串行总线，用于连接微控制器及其外围I2C设备。&lt;/p&gt;
&lt;p&gt;在物理层结构框图上：</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之MCU内部温度传感器</title>
    <link href="http://example.com/2023/05/29/STM32CubeMX%E4%B9%8BMCU%E5%86%85%E9%83%A8%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    <id>http://example.com/2023/05/29/STM32CubeMX%E4%B9%8BMCU%E5%86%85%E9%83%A8%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/</id>
    <published>2023-05-29T13:15:35.000Z</published>
    <updated>2023-06-01T00:44:28.616Z</updated>
    
    <content type="html"><![CDATA[<p>STM32F103 有一个内部的温度传感器，可以用来测量 CPU及周围的温度(TA)。该温度传感器在内部和 ADCx_IN16输入通道相连接，此通道把传感器输出的电压转换成数字值,这也属于ADC。此温度传感器官方推荐采样时间是17.1 µs。</p><p>其内部框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530101309912.png" alt="image-20230530101309912" style="zoom:80%;" /></p><p><strong>温度公式： = (V25 - VSENSE) / Avg_Slope + 25 °C</strong></p><p>其中：</p><ul><li>V25 为 25°C时VSENSE的电压值（典型值：1.43V）</li><li>Avg_Slope 为温度与Vsense曲线的平均斜率（典型值为4.3 mV/°C）</li></ul><p>在datasheet电气特性章节中看到：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210530101608931.png"alt="image-20210530101608931" /><figcaption aria-hidden="true">image-20210530101608931</figcaption></figure><h3 id="硬件设计">硬件设计</h3><p>本实验通过ADC1通道16采集内部温度，将采样的AD值和转换后的温度值通过USART1串口打印出来</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活ADC1温度传感器通道，设置右对齐，关闭扫描、连续及间断模式，使能regularconversion，设置软件触发、设置采样时间239.5个周期（239.5/12MHz=19.96us）</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210530103255512.png"alt="image-20210530103255512" /><figcaption aria-hidden="true">image-20210530103255512</figcaption></figure><ul><li>RCC设置外接HSE，时钟设置为72M，ADC预分频因子设置为6，ADC_CLK为12MHz</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210530090558085.png"alt="image-20210530090558085" /><figcaption aria-hidden="true">image-20210530090558085</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在主函数while循环中添加如下测试程序</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint16_t</span> ad_value = <span class="hljs-number">0</span>;<span class="hljs-type">float</span> voltage = <span class="hljs-number">0.0f</span>, temperature = <span class="hljs-number">0.0f</span>;<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;HAL_ADC_Start(&amp;hadc1);<span class="hljs-comment">//启动ADC转换</span>HAL_ADC_PollForConversion(&amp;hadc1,<span class="hljs-number">10</span>);<span class="hljs-comment">//等待转换完成，10ms表示超时时间</span>ad_value = HAL_ADC_GetValue(&amp;hadc1);<span class="hljs-comment">//读取ADC转换数据（12位数据）</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN16 ADC value: %d\r\n&quot;</span>, ad_value);voltage = ad_value*(<span class="hljs-number">3.3</span>/<span class="hljs-number">4096</span>);<span class="hljs-comment">//AD值乘以分辨率即为电压值</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN16 VOL value: %.2fV\r\n&quot;</span>, voltage);temperature = (<span class="hljs-number">1.43</span> - voltage)/<span class="hljs-number">0.0043</span> + <span class="hljs-number">25</span>;<span class="hljs-comment">//根据公式算出温度值</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MCU Internal Temperature: %.2f ℃\r\n&quot;</span>, temperature);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);HAL_Delay(<span class="hljs-number">1000</span>);&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>编译无误后下载到开发板，串口助手每隔1秒打印读取的温度数据</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601084339509.png" alt="image-20230601084339509" style="zoom:80%;" /></p><p>工程文件Gitee： <ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/adc_inter_temp.zip">adc_inter_temp</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;STM32F103 有一个内部的温度传感器，可以用来测量 CPU
及周围的温度(TA)。该温度传感器在内部和 ADCx_IN16
输入通道相连接，此通道把传感器输出的电压转换成数字值,这也属于ADC。此温度传感器官方推荐采样时间是
17.1 µs。&lt;/p&gt;
&lt;p&gt;其</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之DAC</title>
    <link href="http://example.com/2023/05/29/STM32CubeMX%E4%B9%8BDAC/"/>
    <id>http://example.com/2023/05/29/STM32CubeMX%E4%B9%8BDAC/</id>
    <published>2023-05-29T13:14:40.000Z</published>
    <updated>2023-06-02T00:35:17.522Z</updated>
    
    <content type="html"><![CDATA[<p>DAC（digital to analogconverter）即数模转换器，它可以将数字信号转换为模拟信号.在常见的数字信号系统中，大部分传感器信号被转化成电压信号，而ADC把电压模拟信号转换成易于计算机存储、处理的数字编码，由计算机处理完成后，再由DAC输出电压模拟信号来驱动某些执行器件，使人类易于感知。如音频信号的采集和还原就是这样的一个过程。</p><p>STM32F1的DAC模块是12位电压输出型DAC。可以配置为8位或12位模式，在12位模式下，数据可以设置为左对齐或右对齐。它有2个输出通道，2个通道可以独立地进行转换。</p><p>DAC通道框图如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530105255132.png" alt="image-20230530105255132" style="zoom:80%;" /></p><p><strong>DAC的转换公式</strong>：<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530105432369.png" alt="image-20230530105432369" style="zoom:80%;" /></p><p>DOR：DAC数据输出寄存器值；</p><h3 id="硬件设计">硬件设计</h3><p>本实验通过 DAC 通道1输出模拟电压，用KEY1用来增加DAC输入值，WK_UP用来减少DAC输入值，然后使用USART1将输出的电压值打印出来</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530111127269.png" alt="image-20230530111127269" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PE3设置为GPIO输入模式、上拉；PA0设置为GPIO输入模式，下拉；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601203040597.png" alt="image-20230601203040597" style="zoom:80%;" /></p><ul><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活DAC_OUT1，关闭输出缓冲，不使用触发功能</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601132917195.png" alt="image-20230601132917195" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>因为使用到按键功能，所以移植之前用到的按键输入工程中Key文件,记得添加头文件和路径（#include"key.h"）。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601175003752.png" alt="image-20230601175003752" style="zoom:80%;" /></p><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main.c文件下编写DAC测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint16_t</span> dac_val;<span class="hljs-comment">//读取的DAC值</span><span class="hljs-type">float</span> dac_vol;<span class="hljs-comment">//转换后的电压值</span><span class="hljs-type">uint16_t</span> dac_setval = <span class="hljs-number">0</span>;<span class="hljs-comment">//DAC设置值</span><span class="hljs-type">uint8_t</span> key = <span class="hljs-number">0</span>;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_DAC_Start(&amp;hdac,DAC_CHANNEL_1);<span class="hljs-comment">//开启DAC通道1</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    key = key_scan(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(key == KEY1_PRES)    &#123;        <span class="hljs-keyword">if</span>(dac_setval &gt; <span class="hljs-number">4000</span>)            dac_setval = <span class="hljs-number">0</span>;        dac_setval += <span class="hljs-number">200</span>;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key == WKUP_PRES)    &#123;        <span class="hljs-keyword">if</span>(dac_setval &lt; <span class="hljs-number">200</span>)            dac_setval = <span class="hljs-number">4000</span>;        dac_setval -= <span class="hljs-number">200</span>;    &#125;    HAL_DAC_SetValue(&amp;hdac,DAC_CHANNEL_1,DAC_ALIGN_12B_R,dac_setval);    <span class="hljs-keyword">if</span>(key == KEY1_PRES || key == WKUP_PRES)    &#123;        dac_val = HAL_DAC_GetValue(&amp;hdac,DAC_CHANNEL_1);<span class="hljs-comment">//其值=dac_setval</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DAC_OUT1 DAC value: %d\r\n&quot;</span>,dac_val);        dac_vol = (<span class="hljs-type">float</span>)dac_val * (<span class="hljs-number">3.3</span>/<span class="hljs-number">4096</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DAC_OUT1 VOL value: %.2fV\r\n&quot;</span>,dac_vol);    &#125;    HAL_Delay(<span class="hljs-number">10</span>);&#125;</code></pre></div><ul><li>编译无误后下载到开发板，打印出DAC通道1的DAC值和电压值，按下按键，DAC值和电压值发生变化。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601202614101.png" alt="image-20230601202614101" style="zoom:80%;" /></p><p>工程文件Gitee： <ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/dac.zip">dac</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DAC（digital to analog
converter）即数模转换器，它可以将数字信号转换为模拟信号.在常见的数字信号系统中，大部分传感器信号被转化成电压信号，而ADC把电压模拟信号转换成易于计算机存储、处理的数字编码，由计算机处理完成后，再由DAC输出电压模拟信</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之ADC</title>
    <link href="http://example.com/2023/05/29/STM32CubeMX%E4%B9%8BADC/"/>
    <id>http://example.com/2023/05/29/STM32CubeMX%E4%B9%8BADC/</id>
    <published>2023-05-29T13:14:04.000Z</published>
    <updated>2023-06-01T01:32:51.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="adc简介">ADC简介</h3><p>ADC（analog to digitalconverter）即模数转换器，它可以将模拟量信号转换为数字信号，按照转换原理主要分为逐次逼近型、双积分型、电压频率转换型三种。</p><p>STM32 的 ADC 是 12 位逐次逼近型的模拟数字转换器。它有 18个通道，可测量 16 个外部和 2 个内部信号源。各通道的 A/D转换模式有单次、连续、扫描或间断模式。ADC的转换结果可以以左对齐或右对齐方式存储在 16位数据寄存器中。ADC时钟挂载在APB2上，最大14MHz。</p><p>单个ADC功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530083701000.png" alt="image-20230530083701000" style="zoom:80%;" /></p><p>STM32 将 ADC 的转换分为 2 个通道组：规则通道组和注入通道组。STM32 其ADC 的规则通道组最多包含 16 个转换，而注入通道组最多包含 4 个通道。</p><p>ADC 的转换时间可以由以下公式计算：Time = 采样时间 + 12.5个周期；</p><p>ADC能3种产生相应中断：规则转换与注入转换结束、模拟看门狗事件、DMA请求；</p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530084243966.png" alt="image-20230530084243966" style="zoom:80%;" /></p><p>通过ADC1通道1（PA1）采样外部电压值，将采样的AD值和转换后的电压值通过USART1串口打印出来。如上图，可以将不同的电压（0~3.3V）连接到连接座上。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活ADC1通道1，设置右对齐，关闭扫描、连续及间断模式，使能regularconversion，设置软件触发、设置采样时间1.5个周期</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530090516872.png" alt="image-20230530090516872" style="zoom:80%;" /></p><ul><li>RCC设置外接HSE，时钟设置为72M，ADC预分频因子设置为6，ADC_CLK为12MHz</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530090558085.png"alt="image-20230530090558085" /><figcaption aria-hidden="true">image-20230530090558085</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper periapheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在主函数while循环中添加如下测试程序，ADC1是12位转换精度，因此电压分辨率为：3.3/(2^12)= 3.3/4096</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint16_t</span> ad_value = <span class="hljs-number">0</span>;<span class="hljs-type">float</span> voltage = <span class="hljs-number">0.0f</span>;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    HAL_ADC_Start(&amp;hadc1);<span class="hljs-comment">//启动ADC转换</span>    HAL_ADC_PollForConversion(&amp;hadc1,<span class="hljs-number">10</span>);<span class="hljs-comment">//等待转换完成，10ms表示超时时间</span>    ad_value = HAL_ADC_GetValue(&amp;hadc1);<span class="hljs-comment">//读取ADC转换数据（12位数据）</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN1 ADC value: %d\r\n&quot;</span>,ad_value);    voltage = ad_value*(<span class="hljs-number">3.3</span>/<span class="hljs-number">4096</span>);<span class="hljs-comment">//AD值乘以分辨率即为电压值</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN1 VOL value: %.2fV\r\n&quot;</span>,voltage);    HAL_Delay(<span class="hljs-number">1000</span>);&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>编译无误后下载到开发板，通过接口接入不同的电压（0~3.3），获取的AD转换值和电压值将变化，并通过串口打印出来</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531225347273.png" alt="image-20230531225347273" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/adc.zip">adc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;adc简介&quot;&gt;ADC简介&lt;/h3&gt;
&lt;p&gt;ADC（analog to digital
converter）即模数转换器，它可以将模拟量信号转换为数字信号，按照转换原理主要分为逐次逼近型、双积分型、电压频率转换型三种。&lt;/p&gt;
&lt;p&gt;STM32 的 ADC 是</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之RTC</title>
    <link href="http://example.com/2023/05/29/STM32CubeMX%E4%B9%8BRTC/"/>
    <id>http://example.com/2023/05/29/STM32CubeMX%E4%B9%8BRTC/</id>
    <published>2023-05-29T13:11:52.000Z</published>
    <updated>2023-06-01T00:17:40.925Z</updated>
    
    <content type="html"><![CDATA[<p>STM32的实时时钟RTC是一个独立的定时器,RTC模块和时钟配置系统（RCC_BDCR寄存器）是在后背区域，即在系统复位或从待机模式唤醒后RTC的设置和事件维持不变。但是在系统复位后，会自动禁止访问后备寄存器和RTC，以防止对后备区域（BKP）的意外操作。所以在要设置时间之前，要先取消备份区域写保护。</p><p>RTC的功能框图如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529212612816.png" alt="image-20230529212612816" style="zoom:80%;" /></p><p>RTC由两个主要部分组成：第一部分（APB1接口）用来和APB1总线相连；另一部分（RTC核心）由一组可编程计数器组成，分为两个主要模块，第一个模块是RTC的预分频模块，可编程产生1秒的RTC时间基准TR_CLK，第二个模块是一个32位的可编程计数器（RTC_CNT），可被初始化为当前的系统时间。</p><h3 id="硬件设计">硬件设计</h3><p>RTC 属于 STM32F1内部资源，本实验通过RTC的秒中断来持续输出时间通过串口1打印出来，并通过设置闹钟中断实现一个闹钟提醒。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li><p>RCC设置中开启外部高速晶振（HSE）以及外部低速晶振（LSE）；</p></li><li><p>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</p></li><li><p>激活时钟源，激活日历，选择RTCOutput，设置初始日期和时间，在NVIC中使能RTC全局中断。</p></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529222921310.png"alt="image-20230529222921310" /><figcaption aria-hidden="true">image-20230529222921310</figcaption></figure><ul><li>时钟树设置HCLK为72MHz，RTC时钟为32.768KHz</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529223151558.png" alt="image-20230529223151558" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在rtc.c文件中编写秒中断处理回调函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-comment">/* 定义日期和时间结构体 */</span>RTC_DateTypeDef GetDate;RTC_TimeTypeDef GetTime;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_RTCEx_RTCEventCallback</span><span class="hljs-params">(RTC_HandleTypeDef *hrtc)</span>&#123;HAL_RTC_GetTime(hrtc,&amp;GetTime,RTC_FORMAT_BIN);HAL_RTC_GetDate(hrtc,&amp;GetDate,RTC_FORMAT_BIN);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Date:%02d-%02d-%02d\r\n&quot;</span>,<span class="hljs-number">2000</span>+GetDate.Year,GetDate.Month,GetDate.Date);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Time:%02d:%02d:%02d\r\n&quot;</span>,GetTime.Hours,GetTime.Minutes,GetTime.Seconds);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);&#125;<span class="hljs-comment">/* USER CODE END 1 */</span></code></pre></div><ul><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</p></li><li><p>在main.c文件中编写闹钟设置相关代码并开启相关中断</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>__HAL_RTC_SECOND_ENABLE_IT(&amp;hrtc,RTC_IT_SEC); <span class="hljs-comment">//开启秒中断</span><span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div><ul><li>编译无误后下载到开发板，串口助手每1s会打印出相应的日期和时间。</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531223357869.png"alt="image-20230531223357869" /><figcaption aria-hidden="true">image-20230531223357869</figcaption></figure><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/rtc.zip">rtc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;STM32的实时时钟RTC是一个独立的定时器,RTC模块和时钟配置系统（RCC_BDCR寄存器）是在后背区域，即在系统复位或从待机模式唤醒后RTC的设置和事件维持不变。但是在系统复位后，会自动禁止访问后备寄存器和RTC，以防止对后备区域（BKP）的意外操作。所以在要设置时间</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之低功耗</title>
    <link href="http://example.com/2023/05/29/STM32CubeMX%E4%B9%8B%E4%BD%8E%E5%8A%9F%E8%80%97/"/>
    <id>http://example.com/2023/05/29/STM32CubeMX%E4%B9%8B%E4%BD%8E%E5%8A%9F%E8%80%97/</id>
    <published>2023-05-29T08:08:37.000Z</published>
    <updated>2023-05-30T01:41:23.452Z</updated>
    
    <content type="html"><![CDATA[<p>STM32F10xxx有三种低功耗模式:</p><ul><li><strong>睡眠模式(Sleep mode)</strong>（CM3内核停止，外设包括核心外设如NVIC，SysTick等仍然运行，功耗最高）</li><li><strong>停止模式(Stopmode)</strong>（所有时钟都停止，功耗中等）</li><li><strong>待机模式(Standby mode)</strong>（1.8V内核电源关闭，功耗最低）</li></ul><p>此外，在运行模式下，为了降低功耗，可以通过降低系统时钟和关闭APB和AHB总线上未使用外设的时钟。</p><p>三种低功耗模式的区别如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529164036755.png" alt="image-20230529164036755" style="zoom:80%;" /></p><p>这一章实验主要针对待机模式进行介绍，该模式实在CM3深睡眠模式时关闭电压调节器，整个1.8V供电区域被断电，HSI/HSE振荡器也被断电，SRAM和寄存器内容丢失，仅备份的寄存器和待机电路维持供电。</p><h3 id="硬件设计">硬件设计</h3><p>使用了 KEY_UP 按键用于唤醒和进入待机模式，然后通过LED0来指示程序是否在运行。灯闪烁表示系统正常运行，灯熄灭表示进入待机模式。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528162340882.png" alt="image-20230528162340882" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528102557291.png" alt="image-20230528102557291" style="zoom: 67%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PB5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平</li><li>PA0设置为GPIO输入模式，下拉</li><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在main.c文件中添加进入待机模式函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  进入待机模式</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">enter_standby_mode</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    __HAL_RCC_APB2_FORCE_RESET();       <span class="hljs-comment">//复位所有IO口 </span>   __HAL_RCC_PWR_CLK_ENABLE();         <span class="hljs-comment">//使能PWR时钟</span>      __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);      <span class="hljs-comment">//清除Wake_UP标志</span>    HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN1);    <span class="hljs-comment">//设置WKUP用于唤醒</span>    HAL_PWR_EnterSTANDBYMode();                  <span class="hljs-comment">//进入待机模式     </span>&#125;<span class="hljs-comment">/* USER CODE END 0 */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">/* 闪烁3s后进入待机模式 */</span>    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);    HAL_Delay(<span class="hljs-number">500</span>);    enter_standby_mode();    <span class="hljs-comment">/* USER CODE END WHILE */</span>&#125;</code></pre></div><ul><li>编译无误后下载到开发板，可以看到系统运行时LED0会闪烁三次，然后进入待机模式，此时LED0熄灭。当按下KEY_UP按键或复位按键时，待机模式被唤醒，系统重新运行.</li></ul><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/low_power.zip">low_power</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;STM32F10xxx有三种低功耗模式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;睡眠模式(Sleep mode)&lt;/strong&gt;（CM3
内核停止，外设包括核心外设如NVIC，SysTick等仍然运行，功耗最高）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;停止模式(S</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之输入捕获</title>
    <link href="http://example.com/2023/05/28/STM32CubeMX%E4%B9%8B%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/"/>
    <id>http://example.com/2023/05/28/STM32CubeMX%E4%B9%8B%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/</id>
    <published>2023-05-28T14:00:00.000Z</published>
    <updated>2023-05-30T23:56:09.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="输入捕获简介">输入捕获简介</h3><p>输入捕获一般应用在两个方面，一是信号脉宽/频率的测量，二是 PWM的输入测量。</p><ul><li>脉宽/频率测量:</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529124032810.png" alt="image-20230529124032810" style="zoom:80%;" /></p><p>可以看到只需要一个捕获通道就可以根据捕获值的差值计算脉宽和频率。</p><p>捕获过程中，两次边沿捕获之间会产生N次定时器溢出，所以:</p><p>脉宽 = (N*ARR + (value2-value1))*CNT计数周期;</p><p>频率 = CNT计数周期/(N*ARR + (value3-value1));</p><ul><li>PWM输入模式时序：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529111153732.png" alt="image-20230529111153732" style="zoom: 80%;" /></p><p>如图PWM输入测量需要两个捕获通道。</p><h3 id="硬件设计">硬件设计</h3><p>通过 <strong>WK_UP</strong>按键将PA0输入高电平，然后捕获TIM5_CH1（PA0）上的高电平脉宽，并从串口打印高电平脉宽。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/30915046b8743181980a17e715c3a8b7.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>选择TIM5，设置定时器时钟源为内部时钟源、设置通道1为输入捕获模式（PA0自动被选中），NVIC设置中激活定时器中断，预分频系数设置为72-1，向上计数，自动重装载值设为0xFFFF，则计时器时钟频率为1MHz，计时器周期为1us，定时器溢出周期为65535 * 1 = 65535us</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529134108484.png"alt="image-20230529134108484" /><figcaption aria-hidden="true">image-20230529134108484</figcaption></figure><ul><li>在GPIO设置里将PA0下拉保证没有信号输入的时候电平稳定.</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529133718902.png"alt="image-20230529133718902" /><figcaption aria-hidden="true">image-20230529133718902</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>因为可能存在定时溢出的情况，所以在tim.c文件中同时编写定时器更新中断处理回调函数和输入捕获中断处理回调函数。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> pulse_edge = <span class="hljs-number">0</span>;<span class="hljs-comment">//状态变化计数值</span><span class="hljs-type">uint8_t</span> overflow_cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//定时器溢出的次数</span><span class="hljs-type">uint32_t</span> capture_value = <span class="hljs-number">0</span>;<span class="hljs-comment">//储存计数器的记录值</span><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_PeriodElapsedCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>&#123;<span class="hljs-keyword">if</span>(htim-&gt;Instance == TIM5)&#123;<span class="hljs-comment">/* 已经捕获一次上升沿，还没捕获过下降沿期间出现定时器溢出 */</span><span class="hljs-keyword">if</span>(pulse_edge == <span class="hljs-number">1</span>)&#123;overflow_cnt++;&#125;&#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_IC_CaptureCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>&#123;<span class="hljs-keyword">if</span>(htim-&gt;Instance == TIM5)&#123;<span class="hljs-comment">/* 捕获到一个上升沿，清除标志位，清空CNT，准备捕获下降沿 */</span><span class="hljs-keyword">if</span>(pulse_edge == <span class="hljs-number">0</span>)&#123;pulse_edge++;capture_value = <span class="hljs-number">0</span>;overflow_cnt = <span class="hljs-number">0</span>;__HAL_TIM_SET_COUNTER(&amp;htim5, <span class="hljs-number">0</span>);__HAL_TIM_SET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING);<span class="hljs-comment">//设置下降沿捕获</span>&#125;<span class="hljs-keyword">else</span>&#123;HAL_TIM_IC_Stop_IT(&amp;htim5,TIM_CHANNEL_1); <span class="hljs-comment">//关闭定时器5</span>pulse_edge++; <span class="hljs-comment">//进入到主函数</span>capture_value = HAL_TIM_ReadCapturedValue(&amp;htim5, TIM_CHANNEL_1); <span class="hljs-comment">//读取捕获通道的值</span>__HAL_TIM_SET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);HAL_TIM_IC_Start_IT(&amp;htim5,TIM_CHANNEL_1);  <span class="hljs-comment">//打开输入捕获</span>&#125;&#125;    &#125;<span class="hljs-comment">/* USER CODE END 1 */</span></code></pre></div><ul><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</p></li><li><p>在main.c文件中编写高电平持续时间处理代码</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>    <span class="hljs-type">uint32_t</span> pulse_width;<span class="hljs-comment">//高电平持续时间</span>    <span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> pulse_edge;<span class="hljs-comment">//状态变化时，计数值</span>    <span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> overflow_cnt;<span class="hljs-comment">//定时器溢出的次数</span>    <span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> capture_value;<span class="hljs-comment">//两个边沿之间的计数值</span>    <span class="hljs-comment">/* USER CODE END 1 */</span>    <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>    <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>    HAL_Init();    <span class="hljs-comment">/* USER CODE BEGIN Init */</span>    <span class="hljs-comment">/* USER CODE END Init */</span>    <span class="hljs-comment">/* Configure the system clock */</span>    SystemClock_Config();    <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>    <span class="hljs-comment">/* USER CODE END SysInit */</span>    <span class="hljs-comment">/* Initialize all configured peripherals */</span>    MX_GPIO_Init();    MX_USART1_UART_Init();    MX_TIM5_Init();    <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>    HAL_TIM_Base_Start_IT(&amp;htim5);<span class="hljs-comment">//打开定时器中断</span>    HAL_TIM_IC_Start_IT(&amp;htim5,TIM_CHANNEL_1);<span class="hljs-comment">//一定要开启TIM5通道1的捕获中断</span>    <span class="hljs-comment">/* USER CODE END 2 */</span>    <span class="hljs-comment">/* Infinite loop */</span>    <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">if</span>(pulse_edge == <span class="hljs-number">2</span>)        &#123;            pulse_edge = <span class="hljs-number">0</span>;            pulse_width = <span class="hljs-number">65536</span>*overflow_cnt + capture_value;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;高电平持续时间:%d ms\r\n&quot;</span>, pulse_width/<span class="hljs-number">1000</span>);        &#125;        <span class="hljs-comment">/* USER CODE END WHILE */</span>        <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>    &#125;    <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><ul><li>编译无误后下载到开发板，按下KEY_UP后，串口会打印出相应的高电平持续时间</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530233211951.png"alt="image-20230530233211951" /><figcaption aria-hidden="true">image-20230530233211951</figcaption></figure><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/input_capture.zip">input_capture</a></p><p>参考链接：http://t.csdn.cn/nf7yk</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;输入捕获简介&quot;&gt;输入捕获简介&lt;/h3&gt;
&lt;p&gt;输入捕获一般应用在两个方面，一是信号脉宽/频率的测量，二是 PWM
的输入测量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脉宽/频率测量:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.co</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之PWM输出</title>
    <link href="http://example.com/2023/05/28/STM32CubeMX%E4%B9%8BPWM%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2023/05/28/STM32CubeMX%E4%B9%8BPWM%E8%BE%93%E5%87%BA/</id>
    <published>2023-05-28T12:55:09.000Z</published>
    <updated>2023-05-29T04:19:31.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pwm-简介">PWM 简介</h3><p>脉冲宽度调制（PWM,Pulse WidthModulation）简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。PWM输出就是对外输出脉宽（即占空比）可调的方波信号，信号频率由自动重装寄存器ARR 的值决定，占空比由比较寄存器 CCR 的值决定。</p><p>PWM 模式分为两种：mode1 和 mode2，它们的区别如下：</p><table><thead><tr class="header"><th>PWM模式</th><th>计数器CNT计数方式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><strong>mode 1</strong></td><td>upcounting</td><td>CNT&lt;CCRx，通道channel有效(OCxREF=1)，否则无效(OCxREF=0)</td></tr><tr class="even"><td></td><td>downcounting</td><td>CNT&gt;CCRx，通道channel无效(OCxREF=0)，否则有效(OCxREF=1)</td></tr><tr class="odd"><td><strong>mode 2</strong></td><td>upcounting</td><td>CNT&lt;CCRx，通道channel无效(OCxREF=0)，否则有效(OCxREF=1)</td></tr><tr class="even"><td></td><td>downcounting</td><td>CNT&gt;CCRx，通道channel有效(OCxREF=1)，否则无效(OCxREF=0)</td></tr></tbody></table><p>以PWM mode 1递增计数方式为例：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529112644749.png" alt="image-20230529112644749" style="zoom:80%;" /></p><ul><li>当计数器 CNT &lt; 比较捕获寄存器 CCRx，PWM 参考信号 OCxREF输出高电平。</li><li>当计数器 CNT &gt;= 比较捕获寄存器 CCRx， PWM 参考信号 OCxREF输出低电平。</li><li>当比较捕获寄存器 CCRx &gt; 自动重载寄存器 ARR，OCxREF 保持为1。</li><li>当比较捕获寄存器 CCRx = 0，则 OCxRef 保持为 0。</li></ul><h3 id="硬件设计">硬件设计</h3><p>LED灯的呼吸灯效果可以很好的查看PWM的调节情况，查看定时器复用功能重映射，刚好TIM3第二通道可以重映射到LED0上。所以，可以通过TIM3的通道2输出PWM信号，控制LED0的亮度。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528211500355.png" alt="image-20230528211500355" style="zoom:67%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72MHz；</li><li>TIM3的时钟挂载在APB1上，因为APB1 Prescacler设置为2，所以TIM3时钟为36x2=72MHz；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528200120931.png" alt="image-20230528200120931" style="zoom:67%;" /></p><ul><li><p>激活TIM3定时器，**Timeout = (Prescaler-1)*(Period-1)/72MHz**</p><p>时钟源选择为内部时钟，设置通道2为PWM模式，选中PB5的TIM3_CH2完成重映射，预分频系数设置为72-1，向上计数，自动重装载值设为500-1，则计时器时钟频率为1MHz，计时器周期为1us，PWM周期为500 * 1 = 500us，PWM频率为1/500us =2KHz，PWM模式选择PWM1，Pulse默认为0，PWM极性设置为低电平（由于LED低电平点亮）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528213741747.png" alt="image-20230528213741747" style="zoom:80%;" /></p></li><li><p>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral ；点击GENERATE CODE，生成工程代码</p></li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在tim.c文件中可以看到TIM3的初始化相关函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_TIM3_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  TIM_ClockConfigTypeDef sClockSourceConfig = &#123;<span class="hljs-number">0</span>&#125;;  TIM_MasterConfigTypeDef sMasterConfig = &#123;<span class="hljs-number">0</span>&#125;;  TIM_OC_InitTypeDef sConfigOC = &#123;<span class="hljs-number">0</span>&#125;;  htim3.Instance = TIM3;  htim3.Init.Prescaler = <span class="hljs-number">71</span>;  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;  htim3.Init.Period = <span class="hljs-number">499</span>;  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIM_Base_Init(&amp;htim3) != HAL_OK)  &#123;    Error_Handler();  &#125;  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;  <span class="hljs-keyword">if</span> (HAL_TIM_ConfigClockSource(&amp;htim3, &amp;sClockSourceConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;  <span class="hljs-keyword">if</span> (HAL_TIM_PWM_Init(&amp;htim3) != HAL_OK)  &#123;    Error_Handler();  &#125;  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIMEx_MasterConfigSynchronization(&amp;htim3, &amp;sMasterConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;  sConfigOC.OCMode = TIM_OCMODE_PWM1;  sConfigOC.Pulse = <span class="hljs-number">0</span>;  sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIM_PWM_ConfigChannel(&amp;htim3, &amp;sConfigOC, TIM_CHANNEL_2) != HAL_OK)  &#123;    Error_Handler();  &#125;  HAL_TIM_MspPostInit(&amp;htim3);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_Base_MspInit</span><span class="hljs-params">(TIM_HandleTypeDef* tim_baseHandle)</span>&#123;  <span class="hljs-keyword">if</span>(tim_baseHandle-&gt;Instance==TIM3)  &#123;    __HAL_RCC_TIM3_CLK_ENABLE();  &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_MspPostInit</span><span class="hljs-params">(TIM_HandleTypeDef* timHandle)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-keyword">if</span>(timHandle-&gt;Instance==TIM3)  &#123;    __HAL_RCC_GPIOB_CLK_ENABLE();    <span class="hljs-comment">/**TIM3 GPIO Configuration</span><span class="hljs-comment">    PB5     ------&gt; TIM3_CH2</span><span class="hljs-comment">    */</span>    GPIO_InitStruct.Pin = GPIO_PIN_5;    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;    HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);    __HAL_AFIO_REMAP_TIM3_PARTIAL();  &#125;&#125;</code></pre></div><ul><li>在main函数中编写代码，周期性的改变CCR1的值来改变PWM占空比</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>  <span class="hljs-type">uint8_t</span> dir = <span class="hljs-number">1</span>;<span class="hljs-comment">//计数方向</span>  <span class="hljs-type">uint16_t</span> ledpwmval = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数值</span>  <span class="hljs-comment">/* USER CODE END 1 */</span>  <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>  <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>  HAL_Init();  <span class="hljs-comment">/* USER CODE BEGIN Init */</span>  <span class="hljs-comment">/* USER CODE END Init */</span>  <span class="hljs-comment">/* Configure the system clock */</span>  SystemClock_Config();  <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>  <span class="hljs-comment">/* USER CODE END SysInit */</span>  <span class="hljs-comment">/* Initialize all configured peripherals */</span>  MX_GPIO_Init();  MX_TIM3_Init();  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);<span class="hljs-comment">//开启定时器PWM输出</span>  <span class="hljs-comment">/* USER CODE END 2 */</span>  <span class="hljs-comment">/* Infinite loop */</span>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;HAL_Delay(<span class="hljs-number">10</span>);<span class="hljs-keyword">if</span>(dir)ledpwmval++;<span class="hljs-keyword">else</span>ledpwmval--;<span class="hljs-keyword">if</span>(ledpwmval &gt; <span class="hljs-number">300</span>)dir = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ledpwmval == <span class="hljs-number">0</span>)dir = <span class="hljs-number">1</span>;TIM3-&gt;CCR2 = ledpwmval;<span class="hljs-comment">//更改CCR2的值来改变PWM的占空比</span>    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>  &#125;  <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><ul><li>编译后下载到开发板，可以看到LED0由暗变亮，再由亮变暗，呈现呼吸灯的效果。</li></ul><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/pwm_out.zip">pwm_output</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pwm-简介&quot;&gt;PWM 简介&lt;/h3&gt;
&lt;p&gt;脉冲宽度调制（PWM,Pulse Width
Modulation）简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。PWM
输出就是对外输出脉宽（即占空比）可调的方波信号，信号频率</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之窗口看门狗</title>
    <link href="http://example.com/2023/05/28/STM32CubeMX%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <id>http://example.com/2023/05/28/STM32CubeMX%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97/</id>
    <published>2023-05-28T07:19:32.000Z</published>
    <updated>2023-05-29T02:22:14.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="窗口看门狗简介">窗口看门狗简介</h3><p>窗口看门狗（WWDG）通常被用来监测由外部干扰或不可预见的逻辑条件造成的应用程序背离正常的运行序列而产生的软件故障。递减计数器需要在一个有限的时间窗口中被刷新才不会产生MCU复位，否则就会产生RESET。WWDG</p><p>窗口看门狗时序图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528174707824.png" alt="image-20230528174707824" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528174924225.png" alt="image-20230528174924225" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>我们将通过USART1来打印调试信息，然后通过 LED1提示复位状态。(LED1常亮则系统正常，LED1闪烁则系统一直复位)</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M；</li><li>IWDG的时钟默认为LSI时钟；</li><li>PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528170246253.png" alt="image-20230528170246253" style="zoom:67%;" /></p><ul><li><p>激活WWDG，Timeout = 4096 x Prescaler x (上窗口值 - 下窗口值)/36MHz</p><p>WWDG挂载在APB1上，时钟为36MHz，计数器预分频值设为8，窗口寄存器设为W[6:0]= 0x5A，递减计数器刷新值设置为T[6:0] = 0x7F；根据公式算出超时时间为（4096 * 8）*（0x7F-0x3F）/ 36MHz =58.3ms；使能EWI中断，在NVIC设置中开启窗口看门狗中断</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528175822680.png" alt="image-20230528175822680" style="zoom:67%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在wwdg.c文件中可以看到独立看门狗的初始化函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_WWDG_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  hwwdg.Instance = WWDG;  hwwdg.Init.Prescaler = WWDG_PRESCALER_8;  hwwdg.Init.Window = <span class="hljs-number">0x5a</span>;  hwwdg.Init.Counter = <span class="hljs-number">0x7f</span>;  hwwdg.Init.EWIMode = WWDG_EWI_ENABLE;  <span class="hljs-keyword">if</span> (HAL_WWDG_Init(&amp;hwwdg) != HAL_OK)  &#123;    Error_Handler();  &#125;&#125;</code></pre></div><ul><li>在<strong>stm32f1xx_hal_wwdg.c</strong>文件中找到弱符号早期唤醒中断函数原型，并在wwdg.c中自定义该回调函数<code>__weak void HAL_WWDG_EarlyWakeupCallback(WWDG_HandleTypeDef *hwwdg)</code></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_WWDG_EarlyWakeupCallback</span><span class="hljs-params">(WWDG_HandleTypeDef *hwwdg)</span>&#123;HAL_WWDG_Refresh(hwwdg);<span class="hljs-comment">//在早期唤醒中断函数中喂狗</span>&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main函数中编写代码：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nWWDG Test!!!\r\n&quot;</span>);HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);<span class="hljs-comment">//熄灭LED0</span>HAL_Delay(<span class="hljs-number">500</span>);HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);<span class="hljs-comment">//点亮LED0</span>MX_WWDG_Init();<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-comment">/* Infinite loop */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nHello, WWDG...!\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">1000</span>);    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;<span class="hljs-comment">/* USER CODE END 3 */</span></code></pre></div><ul><li>实验现象：</li></ul><p>LED1常亮，且串口助手显示一直在喂狗：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528191522516.png" alt="image-20230528191522516" style="zoom:67%;" /></p><p>如果注释掉早期唤醒中断函数中的喂狗函数，则LED1闪烁且串口输出，需要<strong>注意</strong>的是，<code>MX_WWDG_Init()</code>函数需要放到LED闪烁函数之后，否则程序一直在复位，根本执行不到后面的部分：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528192419226.png" alt="image-20230528192419226" style="zoom:67%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/wwdg.zip">wwdg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;窗口看门狗简介&quot;&gt;窗口看门狗简介&lt;/h3&gt;
&lt;p&gt;窗口看门狗（WWDG）通常被用来监测由外部干扰或不可预见的逻辑条件造成的应用程序背离正常的运行序列而产生的软件故障。递减计数器需要在一个有限的时间窗口中被刷新才不会产生MCU复位，否则就会产生RESET。WWDG</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>STM32CubeMX之独立看门狗</title>
    <link href="http://example.com/2023/05/28/STM32CubeMX%E4%B9%8B%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <id>http://example.com/2023/05/28/STM32CubeMX%E4%B9%8B%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97/</id>
    <published>2023-05-28T07:18:47.000Z</published>
    <updated>2023-05-29T02:21:53.741Z</updated>
    
    <content type="html"><![CDATA[<h3 id="独立看门狗简介">独立看门狗简介</h3><p>STM32F1内部自带了 2个看门狗：独立看门狗（IWDG）和窗口看门狗（WWDG)。这一章主要来看看独立看门狗，从功能上说它在程序发生意外（程序进入死循环或跑飞）的时候，能重新回复到系统刚上电状态。</p><p>独立看门狗由内部专门的 40Khz 低速RC时钟驱动，即使主时钟发生故障，它也仍然有效。但它是在 30~60Khz之间的一个可变化的时钟，只是我们在估算的时候，以 40Khz的频率来计算，时钟有些偏差，都是可以接受的。</p><p>实际上独立看门口狗是一个递减计数器，当计时器的值减到0时，IWDG会产生一个复位信号，系统复位重新启动。为避免产生看门狗复位，则需在计数器减到0之前重载计数器,即“喂狗”。</p><p>独立看门狗功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528161307256.png" alt="image-20230528161307256" style="zoom:80%;" /></p><p>独立看门狗超时时间（40KHz的输入时钟LSI）：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528161857687.png" alt="image-20230528161857687" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>我们将通过USART1来打印调试信息，然后通过 LED0提示复位状态。(LED0常亮则系统正常，LED0闪烁则系统一直复位)</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M；</li><li>IWDG的时钟默认为LSI时钟；</li><li>PB5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528170246253.png" alt="image-20230528170246253" style="zoom:67%;" /></p><ul><li><p>激活IWDG，Timeout = (Prescaler*ReloadValue/40)ms;</p><p>IWDG的时钟为40kHz,此时设置计数器时钟为32分频，则分频后的时钟频率为1.25KHz（时钟周期为1s/1250= 0.8ms），递减基础器重载值（down-counter reloadvalue）配置为1000，即800ms不刷新IWDG，则系统复位。</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528164949027.png" alt="image-20230528164949027" style="zoom: 67%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在iwdg.c文件中可以看到独立看门狗的初始化函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_IWDG_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  hiwdg.Instance = IWDG;  hiwdg.Init.Prescaler = IWDG_PRESCALER_32;  hiwdg.Init.Reload = <span class="hljs-number">1000</span>;  <span class="hljs-keyword">if</span> (HAL_IWDG_Init(&amp;hiwdg) != HAL_OK)  &#123;    Error_Handler();  &#125;&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main函数中编写代码:</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nIWDG Test!!!\r\n&quot;</span>);HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);<span class="hljs-comment">//熄灭LED0</span>HAL_Delay(<span class="hljs-number">300</span>);HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_RESET);<span class="hljs-comment">//点亮LED0</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-comment">/* Infinite loop */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//HAL_IWDG_Refresh(&amp;hiwdg);</span>    <span class="hljs-comment">//printf(&quot;\r\nRefreshes the IWDG...!\r\n&quot;);</span>    HAL_Delay(<span class="hljs-number">500</span>); <span class="hljs-comment">//每500ms喂狗一次 &lt; 800ms</span>    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;<span class="hljs-comment">/* USER CODE END 3 */</span></code></pre></div><ul><li>实验现象：</li></ul><p>LED0常亮，且串口助手显示一直在喂狗：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528171626961.png" alt="image-20230528171626961" style="zoom:67%;" /></p><p>如果注释掉while循环里的喂狗动作，则LED0闪烁且串口输出：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528173055722.png" alt="image-20230528173055722" style="zoom:67%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/iwdg.zip">iwdg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;独立看门狗简介&quot;&gt;独立看门狗简介&lt;/h3&gt;
&lt;p&gt;STM32F1内部自带了 2
个看门狗：独立看门狗（IWDG）和窗口看门狗（WWDG)。这一章主要来看看独立看门狗，从功能上说它在程序发生意外（程序进入死循环或跑飞）的时候，能重新回复到系统刚上电状态。&lt;/p&gt;</summary>
      
    
    
    
    <category term="stm32" scheme="http://example.com/categories/stm32/"/>
    
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
</feed>
