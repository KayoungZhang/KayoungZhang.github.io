<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>stm32f1xx_hal_cortex库的使用</title>
    <link href="/2023/08/03/stm32f1xx-hal-cortex%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/03/stm32f1xx-hal-cortex%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在HAL库中，关于内核控制外设，初始化和析构的相关配置在<code>stm32f1xx_hal_cortex.c</code>文件中，下面来具体看看它怎么使用。</p><h3 id="配置nvic-interrupts-irq中断">配置NVIC interrupts (IRQ)中断</h3><ol type="1"><li>配置NVIC优先级分组。HAL_NVIC_SetPriorityGrouping()</li></ol><ul><li><p>当选择 <strong>NVIC_PRIORITYGROUP_0</strong>时，则无抢占优先级，中断优先级只由子优先级管理</p></li><li><p>中断最高到最低优先级顺序：</p><p>最低抢占优先级 -&gt; 最低子优先级 -&gt;最低硬件优先级（IRQ数字越小，优先级越高）</p></li></ul><ol start="2" type="1"><li>配置所选中断的优先级。HAL_NVIC_SetPriority()</li><li>使能所选中断。HAL_NVIC_EnableIRQ()</li><li>具体参考编程手册（programming manual）。</li></ol><h3 id="配置systick-timer">配置SysTick Timer</h3><ol type="1"><li>HAL_SYSTICK_Config() 函数调用 SysTick_Config() 函数：</li></ol><ul><li>配置 SysTick Reload 寄存器</li><li>配置 SysTick IRQ 优先级为最低（0x0F）。</li><li>复位 SysTick Counter 寄存器。</li><li>配置 SysTick Counter 时钟源为核心时钟源(HCLK)。</li><li>使能 SysTick 中断。</li><li>开启 SysTick Counter。</li></ul><ol start="2" type="1"><li>调用HAL_SYSTICK_Config()函数后，可以改变 SysTick时钟源到 HCLK_Div8。__HAL_CORTEX_SYSTICKCLK_CONFIG(SYSTICK_CLKSOURCE_HCLK_DIV8)</li><li>调用HAL_SYSTICK_Config()函数后，可以改变SysTick中断优先级。HAL_NVIC_SetPriority(SysTick_IRQn,...)</li><li>调整SysTick时基的公式：</li></ol><p>​ Reload Value = SysTick Counter 时钟(Hz) x Desired Time base (s)</p><p>​ 其中，Reload Value是HAL_SYSTICK_Config()函数中传递的参数，它的值不能超过<strong>0xFFFFFF</strong> 。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cortex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_adc库的使用</title>
    <link href="/2023/08/03/stm32f1xx-hal-adc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/03/stm32f1xx-hal-adc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>同GPIO库一样，ST官方给出了ADC外设库的使用方法，下面具体看看ADC外设库中的步骤：</p><h3 id="配置adc顶层参数">1. 配置ADC顶层参数</h3><ul><li><strong>使能ADC接口</strong><ul><li>建议在 HAL_ADC_MspInit() 函数中配置ADC时钟 （<strong>STM32F1ADC时钟频率最大14MHz</strong>）如：<ul><li>RCC_PeriphCLKInitTypeDef PeriphClkInit;</li><li>__ADC1_CLK_ENABLE();</li><li>PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;</li><li>PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2;</li><li>HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInit);</li></ul></li></ul></li><li><strong>配置ADC管脚</strong><ul><li>使能ADC GPIOs。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>在GPIO初始化函数中配置ADC管脚为 <strong>analog mode</strong>。HAL_GPIO_Init()</li></ul></li><li><strong>当使用ADC中断时：</strong><ul><li>配置ADC的NVIC：HAL_NVIC_EnableIRQ(ADCx_IRQn)</li><li>将ADC中断处理函数HAL_ADC_IRQHandler()插入到相应ADC中断向量ADCx_IRQHandler()的函数中。</li></ul></li><li><strong>当使用ADC DMA时：</strong><ul><li>配置DMA (如：DMA 通道, 正常模式或循环模式等)。HAL_DMA_Init()</li><li>配置DMA的NVIC。HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)</li><li>将ADC中断处理函数HAL_ADC_IRQHandler()插入到相应的DMA中断向量DMAx_Channelx_IRQHandler()的函数中。</li></ul></li></ul><h3 id="配置adc常规组或注入组groups-regularinjected通道等参数">2.配置ADC常规组或注入组(groups regular/injected)，通道等参数</h3><ul><li>配置ADC参数 (分辨率, 数据对齐方式等) 和 常规组或注入组参数(转换触发, 序列等)。HAL_ADC_Init()</li><li>配置常规组通道参数(通道号, 通道排列顺序等)。HAL_ADC_ConfigChannel()</li><li>当使用注入组时，配置注入组各参数。HAL_ADCEx_InjectedConfigChannel()</li><li>当使用模拟看门狗时，配置其参数(监控的通道, 阈值等)。HAL_ADC_AnalogWDGConfig()</li><li>当使用多个ADC时，配置多模式参数。HAL_ADCEx_MultiModeConfigChannel()</li></ul><h3 id="执行adc转换">3. 执行ADC转换</h3><ul><li>当需要提高转换精度时，执行ADC自动校准函数：HAL_ADCEx_Calibration_Start()。</li><li>ADC可在三种模式下转换:<strong>轮询（polling）,中断（interruption）和 DMA</strong><ul><li><strong>轮询转换</strong><ul><li>激活ADC外设，开启转换。HAL_ADC_Start()</li><li>等待转换完成。HAL_ADC_PollForConversion() 或HAL_ADCEx_InjectedPollForConversion()(注入组)</li><li>得到转换结果。HAL_ADC_GetValue() 或HAL_ADCEx_InjectedGetValue()(注入组)</li><li>停止转换并关闭ADC外设。HAL_ADC_Stop()</li></ul></li><li><strong>中断转换</strong><ul><li>激活ADC外设，开启转换。HAL_ADC_Start_IT()</li><li>等待转换完成并进入回调函数。HAL_ADC_ConvCpltCallback() 或HAL_ADCEx_InjectedConvCpltCallback()(注入组)</li><li>得到转换结果。HAL_ADC_GetValue() 或HAL_ADCEx_InjectedGetValue()(注入组)</li><li>停止转换并关闭ADC外设。HAL_ADC_Stop_IT()</li></ul></li><li><strong>DMA转换</strong><ul><li>激活ADC外设，开启转换。 HAL_ADC_Start_DMA()</li><li>等待转换完成并进入回调函数。HAL_ADC_ConvCpltCallback()或HAL_ADC_ConvHalfCpltCallback()。</li><li>转换结果由DMA自动转换到目标地址。</li><li>停止转换并关闭ADC外设。HAL_ADC_Stop_DMA()</li></ul></li><li><strong>对于多个ADC设备多方式转换</strong><ul><li>激活ADC外设从设备，开启转换。HAL_ADC_Start()</li><li>激活ADC外设主设备，开启转换。HAL_ADCEx_MultiModeStart_DMA()</li><li>等待转换完成并进入回调函数。HAL_ADC_ConvCpltCallback()或HAL_ADC_ConvHalfCpltCallback()</li><li>转换结果由DMA自动转换到目标地址。</li><li>停止转换并关闭ADC外设主设备。HAL_ADCEx_MultiModeStop_DMA()</li><li>停止转换并关闭ADC外设从设备。HAL_ADC_Stop_IT()</li></ul></li></ul></li><li>回调函数必须在用户程序中实现<ul><li>HAL_ADC_ErrorCallback()</li><li>HAL_ADC_LevelOutOfWindowCallback() (callback of analogwatchdog)</li><li>HAL_ADC_ConvCpltCallback()</li><li>HAL_ADC_ConvHalfCpltCallback()</li><li>HAL_ADCEx_InjectedConvCpltCallback()</li></ul></li></ul><h3 id="adc的析构deinitialization">4. ADC的析构(Deinitialization)</h3><ul><li>关闭ADC外设接口<ul><li>ADC外设的硬复位。 __ADCx_FORCE_RESET(), __ADCx_RELEASE_RESET()</li><li>关闭ADC时钟。如：<ul><li>PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC</li><li>PeriphClkInit.AdcClockSelection = RCC_ADCPLLCLK2_OFF</li><li>HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInit)</li></ul></li></ul></li><li>关闭ADC GPIO管脚时钟 __HAL_RCC_GPIOx_CLK_DISABLE()</li><li>当使用ADC的中断时，则关闭ADC的NVIC。HAL_NVIC_EnableIRQ(ADCx_IRQn)</li><li>当使用ADC的DMA时<ul><li>析构DMA。HAL_DMA_Init()</li><li>关闭DMA的NVIC。HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)</li></ul></li></ul><h3 id="回调函数的注册">5. 回调函数的注册</h3><ul><li><p>当 <strong>USE_HAL_ADC_REGISTER_CALLBACKS</strong>设置为1时，允许用户配置回调函数。HAL_ADC_RegisterCallback()，回调ID：</p><ul><li>ConvCpltCallback : ADC转换完成的回调</li><li>ConvHalfCpltCallback : ADC转换DMA传输过半的回调</li><li>LevelOutOfWindowCallback : ADC模拟看门狗1的回调</li><li>ErrorCallback : ADC错误的回调</li><li>InjectedConvCpltCallback : ADC注入组转换完成的回调</li><li>MspInitCallback : ADC Msp初始化的回调</li><li>MspDeInitCallback : ADC Msp析构的回调</li></ul><p>此函数以HAL外设句柄和回调ID和指向用户回调函数的指针作为参数。</p></li><li><p>函数 HAL_ADC_UnRegisterCallback()用来复位回调函数到默认的弱定义函数。</p><ul><li>ConvCpltCallback : ADC转换完成的回调</li><li>ConvHalfCpltCallback : ADC转换DMA传输过半的回调</li><li>LevelOutOfWindowCallback : ADC模拟看门狗1的回调</li><li>ErrorCallback : ADC错误的回调</li><li>InjectedConvCpltCallback : ADC注入组转换完成的回调</li><li>MspInitCallback : ADC Msp初始化的回调</li><li>MspDeInitCallback : ADC Msp析构的回调</li></ul></li><li><p>默认情况下，ADC初始化后(HAL_ADC_Init()) ,当ADC的状态是<strong>HAL_ADC_STATE_RESET</strong>时，所有的回调被设置到相应的弱函数。（MspInit 和MspDeInit除外，它们会被复位到传统弱函数）</p></li><li><p>如果MspInit或MspDeInit不为空,无论ADC在哪种状态，HAL_ADC_Init()和HAL_ADC_DeInit()函数可保持和使用用户MspInit/MspDeInit回调函数(预先注册过)。</p></li><li><p>只有ADC状态在HAL_ADC_STATE_READY时，回调函数才能注册或注销。</p></li><li><p>在调用HAL_ADC_DeInit()或HAL_ADC_Init()之前，用户可以首先注册MspInit/MspDeInit用户回调函数</p></li><li><p>当 <strong>USE_HAL_ADC_REGISTER_CALLBACKS</strong>设置为0或没有定义时，回调注册功能不可用，所有回调都被设置为相应的弱函数。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>adc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_gpio库的使用</title>
    <link href="/2023/08/03/stm32f1xx-hal-gpio%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/03/stm32f1xx-hal-gpio%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>怎么使用stm32库文件呢？在 <code>*.c</code>文件中,ST官方已经给出了使用方法，下面具体看看GPIO外设库中的特点和使用步骤：</p><h3 id="gpio外设库的特点">GPIO外设库的特点</h3><ol type="1"><li>GPIO外设库可独立配置模式：</li></ol><ul><li><strong>输入模式 Input mode</strong></li><li><strong>模拟模式 Analog mode</strong></li><li><strong>输出模式 Output mode</strong></li><li><strong>复用功能模式 Alternate function mode</strong></li><li><strong>外部中断或事件模式 External interrupt/eventlines</strong></li></ul><ol start="2" type="1"><li>复位期间和之后，复用功能和外部中断线没有被激活，I/O端口被配置为输入浮空模式。</li><li>所有的GPIO引脚内部都有弱上拉和下拉电阻，可选择激活或不激活。</li><li>在输出或复用模式，每一个I/O端口可配置为开漏或推挽模式，根据VDD电压值可选择I/O速度。</li><li>所有的端口都有外部中断和事件的功能，当使用外部中断线时，端口必须配置为输入模式，所有的可用GPIO引脚连接到16个外部中断、事件线（EXTI0~ EXTI15）。</li><li>对于互联型MCU，外部中断、事件控制器包含多达20个边沿检测器，其它类型MCU，也有19个边沿检测器，这些检测器用于产生中断、事件请求。每条输入线都能进行独立配置选择类型（事件或中断），相应的触发条件（上升沿、下降沿、上升下降沿）。每条线也可以独立屏蔽，挂起寄存器来维持中断请求线的状态。</li></ol><h3 id="gpio外设库的使用步骤">GPIO外设库的使用步骤</h3><ol type="1"><li>使能GPIO APB2时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置GPIO引脚。HAL_GPIO_Init()</li></ol><ul><li>配置IO端口模式。GPIO_InitTypeDef结构体中Mode成员。</li><li>激活上下拉电阻。GPIO_InitTypeDef结构体中Pull成员。</li><li>当输出或复用模式时，配置I/O速度。GPIO_InitTypeDef结构体中Speed成员。</li><li>当引脚用于ADC或DAC时，配置IO端口模式为模拟模式。</li><li>当外部中断、事件时，配置IO端口模式为中断或事件模式，同时触发条件选择上升沿或下降沿或上升下降沿。</li></ul><ol start="3" type="1"><li>当外部中断、事件时，配置NVICIRQ映射到EXTI线的优先级，并使能。HAL_NVIC_SetPriority()，HAL_NVIC_EnableIRQ()</li><li>获取在输入模式下引脚的电平。HAL_GPIO_ReadPin()</li><li>设置或复位输出模式下引脚的电平。HAL_GPIO_WritePin()/HAL_GPIO_TogglePin()</li><li>锁定引脚配置直到下一次复位。HAL_GPIO_LockPin()</li><li>复位期间和之后，复用功能未激活，GPIO引脚被配置为输入浮空模式（JTAG引脚除外）。</li><li>当LSE振荡器关闭时，其引脚OSC32_IN/OSC32_OUT(PC14和PC15)可作为IO口使用，LSE的优先级高于GPIO的功能。</li><li>当HSE振荡器关闭时，其引脚OSC_IN/OSC_OUT(PD0和PD1)可作为IO口使用，HSE的优先级高于GPIO的功能。</li></ol>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gpio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一款浏览器翻译插件</title>
    <link href="/2023/07/26/%E4%B8%80%E6%AC%BE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6/"/>
    <url>/2023/07/26/%E4%B8%80%E6%AC%BE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>平时查看资料，会接触到很多英文文档，偶尔一篇英语短文章，阅读起来不成问题，但一旦碰到了一篇很长的文章且通篇都是一些专业名词，此时就不太想看下去了。日前发现一款免费的浏览器翻译插件（<ahref="https://immersivetranslate.com/"><strong>沉浸式翻译</strong></a>），觉得挺实用的。</p><p>官网：https://immersivetranslate.com/</p><p>GitHub：https://github.com/immersive-translate/immersive-translate</p><h2 id="主要特性">主要特性</h2><ul><li><strong>沉浸式阅读外文网站</strong>通过智能识别网页主内容区域并进行双语对照翻译，沉浸式翻译提供了全新的外文阅读体验，因此得名“沉浸式翻译”。</li><li><strong>强大的输入框翻译</strong>，将任何网页上的输入框化身为多语言翻译器，立刻解锁谷歌搜索，ChatGPT等工具的双语实时对话体验。</li><li><strong>高效的文件翻译</strong> 一键导出双语电子书，同时支持PDF、字幕、TXT 等文件的实时双语翻译。</li><li><strong>创新的鼠标悬停翻译</strong>仅需将鼠标停留在任意网页的任意段落上，相应的译文就会立即出现在段落下方。段落在在沉浸式翻译的设计理念中被视为最小单位，保留其上下文，这样我们才能真正理解并学习外语。</li><li><strong>深度定制优化主流网站</strong> 针对Google、Twitter、Reddit、YouTube、彭博社、华尔街日报等主流网站进行优化，无论是搜索、社交还是获取资讯，都更加流畅高效。</li><li><strong>全平台支持</strong>除了各大桌面端浏览器，移动设备也可享受同样的沉浸式翻译体验。在 iOSSafari、安卓 Kiwi 浏览器等移动端浏览器上轻松实现双语浏览 Twitter,Reddit等社交媒体。</li><li><strong>支持 10+种翻译服务</strong> 在沉浸式翻译中，你可以选择超过10 种翻译服务，如Deepl、OpenAI、微软翻译、谷歌翻译、腾讯翻译等等，这份名单还在不断增加中。</li></ul><h2 id="安装">安装</h2><p>目前这款插件只支持以下几款流行的浏览器，可以根据相应的浏览器扩展组件进行安装。</p><ul><li><ahref="https://microsoftedge.microsoft.com/addons/detail/amkbmndfnliijdhojkpoglbnaaahippg">微软Edge 浏览器</a></li><li><ahref="https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh">谷歌Chrome 浏览器</a></li><li><ahref="https://addons.mozilla.org/zh-CN/firefox/addon/immersive-translate">Firefox火狐浏览器</a></li><li><ahref="https://apps.apple.com/app/immersive-translate/id6447957425">苹果Safari浏览器</a></li><li><ahref="https://immersivetranslate.com/android/">沉浸式翻译安卓浏览器</a></li><li><ahref="https://download.immersivetranslate.com/immersive-translate.user.js">通过油猴脚本安装</a></li></ul><h2 id="使用">使用</h2><p>安装插件后，浏览器右上角点击【沉浸式翻译扩展图标】，点击翻译即可进行翻译：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230726200030832.png"alt="image-20230726200030832" /><figcaption aria-hidden="true">image-20230726200030832</figcaption></figure><p>另外在网页上右键也会有相应的网页翻译选项。</p><h2 id="设置">设置</h2><p>在设置页面里我们可以进行一系列的个性化设置，如鼠标悬停翻译、翻译样式、本地PDF翻译、字幕文件翻译等。</p><p>好了，以上就是这款便携浏览器翻译插件的简要介绍，如果你也有翻译的需要，不妨赶紧试试这款插件吧，绝对不会让你失望。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始写C语言链表</title>
    <link href="/2023/07/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99C%E8%AF%AD%E8%A8%80%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/07/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99C%E8%AF%AD%E8%A8%80%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="链表的概念">链表的概念</h2><p><strong>链表（LinkedList）</strong>是一种物理存储结构上非连续、非顺序的存储结构，数据元素（<strong>节点</strong>）的逻辑顺序是通过链表中的指针链接次序实现的。</p><p>相比数组这种在定义即分配一段连续且固定空间大小的数据结构，链表可以根据需要动态分配离散的内存空间，解决了数组插入或删除元素需要移动大量元素的弊端，不过它的缺点就是需要牺牲更大的内存空间。一般链表在操作系统里面应用比较广泛。</p><h2 id="链表的结构">链表的结构</h2><p>链表由一系列 <strong>节点（node）</strong>组成，每个节点包括两个部分：</p><ul><li>数据元素的 <strong>数据域</strong></li><li>下一个节点的 <strong>指针域</strong></li></ul><p>先来认识一个完整的简单链表，如下图所示：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720131138188.png"alt="image-20230720131138188" /><figcaption aria-hidden="true">image-20230720131138188</figcaption></figure><ul><li><strong>头指针</strong>：一个普通的指针，用于指明链表的位置，永远指向链表第一个节点的位置；</li><li><strong>头节点</strong>：通常头节点不是必须的，它的存在主要是为了方便对首元节点前做插入、删除操作的目的；</li><li><strong>首元节点</strong>：链表中第一个存有数据的节点为首元节点，只是一个称谓而已，没有实际意义；</li></ul><p>头节点和头指针的主要区别：头指针只声明而没有分配存储空间，头节点需要声明并分配一个节点的实际物理内存。</p><h2 id="链表的分类">链表的分类</h2><ul><li><strong>单向链表</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720131246792.png"alt="image-20230720131246792" /><figcaption aria-hidden="true">image-20230720131246792</figcaption></figure><ul><li><strong>双向链表</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720214051358.png"alt="image-20230720214051358" /><figcaption aria-hidden="true">image-20230720214051358</figcaption></figure><ul><li><strong>环形链表</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720213847180.png"alt="image-20230720213847180" /><figcaption aria-hidden="true">image-20230720213847180</figcaption></figure><h2 id="单向链表的操作">单向链表的操作</h2><p>以上直观了解了链表的实现方式，那么怎么来创建和操作一个链表呢？首先看单向链表，我们需要定义它的数据结构，具体实现代码为：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>    <span class="hljs-type">int</span> data;       <span class="hljs-comment">//数据类型，可以把int型的data换成任意数据类型，包括结构体struct等复合类型</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//单链表的指针域</span>&#125;<span class="hljs-type">node_t</span>;</code></pre></div><h4 id="单向链表的创建">单向链表的创建</h4><p>单向链表的数据结构定义好后，就可以着手创建链表了，创建单链表的节点，主要分以下步骤:</p><ul><li>给当前的每个节点的数据结构分配空间大小</li><li>将每个节点数据清零（分配的堆内存空间不一定是干净的）</li><li>给节点初始化数据</li><li>将该节点的指针域设置为NULL</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 创建一个节点的函数 */</span><span class="hljs-type">node_t</span> *<span class="hljs-title function_">linkedlist_create</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span>&#123;<span class="hljs-type">node_t</span> *node = (<span class="hljs-type">node_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<span class="hljs-comment">//1、定义一个头指针，然后分配内存空间</span><span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc error!\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-built_in">memset</span>(node,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<span class="hljs-comment">//2、清一下内存</span>node-&gt;data = data;  <span class="hljs-comment">//3、给链表节点的数据赋值</span>node-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//4、将链表的指针域指向空</span><span class="hljs-keyword">return</span> node;&#125;</code></pre></div><h4id="遍历单向链表遍历修改查找"><strong>遍历单向链表（遍历，修改，查找）</strong></h4><p>进行遍历，修改，查找的思路极其简单，只需要建立一个指向链表L的节点，然后沿着链表L逐个向后搜索即可。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//打印链表数据</span><span class="hljs-type">void</span> <span class="hljs-title function_">linkedlist_print</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* pH)</span>&#123;  <span class="hljs-type">node_t</span> *temp = pH-&gt;next; <span class="hljs-comment">//临时指针指向第一个节点 </span>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">NULL</span> != temp)<span class="hljs-comment">//如果当前位置节点不为空</span>  &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d个元素的值为:%d\n&quot;</span>, ++i, temp-&gt;data);    temp = temp-&gt;next;  &#125;  &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//链表内容的修改，链表中值为val1的元素变为val2。</span><span class="hljs-type">node_t</span>* <span class="hljs-title function_">linkedlist_modify</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* pH,<span class="hljs-type">int</span> val1,<span class="hljs-type">int</span> val2)</span> &#123;  <span class="hljs-type">node_t</span> *p = pH-&gt;next;  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span>(p)  &#123;    <span class="hljs-keyword">if</span>(p-&gt;data == val1)    &#123;      p-&gt;data = val2;    &#125;    p = p-&gt;next;  &#125;  <span class="hljs-keyword">return</span> pH;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//p为原链表，elem表示被查找元素</span><span class="hljs-type">int</span> <span class="hljs-title function_">linkedlist_find</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* p, <span class="hljs-type">int</span> elem)</span> &#123;    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;        p = p-&gt;next;<span class="hljs-comment">//带头节点，p 指向首元节点</span>    <span class="hljs-keyword">while</span> (p) &#123;        <span class="hljs-keyword">if</span> (p-&gt;data == elem) &#123;            <span class="hljs-keyword">return</span> i;        &#125;        p = p-&gt;next;        i++;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//返回-1，表示未找到</span>&#125;</code></pre></div><h4 id="单向链表插入操作"><strong>单向链表插入操作</strong></h4><p>链表的插入操作主要有三种情况：</p><ul><li>头部插入</li><li>中部插入</li><li>尾部插入</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720201354416.png"alt="image-20230720201354416" /><figcaption aria-hidden="true">image-20230720201354416</figcaption></figure><p>不管是哪种方式，链表插入节点操作主要分为查找到第i个位置，将该位置的next指针修改为指向新插入的节点，而新插入的节点next指针指向(i+1)个位置的节点。其操作方式可以设置一个临时节点，利用循环找到第i个位置，再进行插入。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 链表的头部插入 */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">linkedlist_top_insert</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *pH , <span class="hljs-type">node_t</span> *new)</span>&#123;<span class="hljs-type">node_t</span> *p = pH ;<span class="hljs-comment">//获取当前的位置head </span>new-&gt;next = p-&gt;next ;<span class="hljs-comment">//新的节点的下一个节点设置为原来头节点的下一个节点</span>p-&gt;next = new ;<span class="hljs-comment">//原来的头节点的下一个节点设置为现在新插入的头节点 </span>&#125;<span class="hljs-comment">/* 链表的中部插入 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">linkedlist_tail_insert</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *pH , <span class="hljs-type">node_t</span> *new, <span class="hljs-type">int</span> pos)</span>&#123;<span class="hljs-type">node_t</span> *p = pH ; <span class="hljs-comment">//获取当前的位置 </span><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; pos; i++)&#123;p = p-&gt;next ;<span class="hljs-comment">//查找第pos个位置的节点 </span>&#125;p-&gt;next = new ;<span class="hljs-comment">//此时把新插入的节点赋值给这个位置 </span>&#125;<span class="hljs-comment">/* 链表的尾部插入 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">linkedlist_tail_insert</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *pH , <span class="hljs-type">node_t</span> *new)</span>&#123;<span class="hljs-type">node_t</span> *p = pH ; <span class="hljs-comment">//获取当前的位置head </span><span class="hljs-keyword">while</span>(<span class="hljs-literal">NULL</span> != p-&gt;next)<span class="hljs-comment">//如果当前位置的下一个节点不为空 </span>&#123;p = p-&gt;next ;<span class="hljs-comment">//移动到下一个节点 </span>&#125;p-&gt;next = new ;<span class="hljs-comment">//此时把新插入的节点赋值给这个位置 </span>&#125;</code></pre></div><h4 id="单向链表删除操作"><strong>单向链表删除操作</strong></h4><p>删除元素要建立一个前驱节点和一个当前节点，当找到了我们需要删除的数据时，直接使用前驱节点跳过要删除的节点指向要删除节点的后一个节点，再将原有的节点通过free函数释放掉。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720201433074.png"alt="image-20230720201433074" /><figcaption aria-hidden="true">image-20230720201433074</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//单链表的删除，在链表中删除值为val的元素</span><span class="hljs-type">node_t</span>* <span class="hljs-title function_">linkedlist_remove</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* L,<span class="hljs-type">int</span> val)</span> &#123;    <span class="hljs-type">node_t</span> *p,*pre;                   <span class="hljs-comment">//pre为前驱节点，p为查找的节点。</span>    p = L-&gt;next;         <span class="hljs-keyword">while</span>(p-&gt;data != val) &#123;              <span class="hljs-comment">//查找值为x的元素</span>        pre = p;        p = p-&gt;next;    &#125;    pre-&gt;next = p-&gt;next;          <span class="hljs-comment">//删除操作，将其前驱next指向其后继。</span>    <span class="hljs-built_in">free</span>(p);         <span class="hljs-keyword">return</span> L;&#125;</code></pre></div><h3 id="双向链表的操作">双向链表的操作</h3><p>双向链表的结构体程序如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span>&#123;</span>    <span class="hljs-type">int</span> data;           <span class="hljs-comment">//data</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> *<span class="hljs-title">pre</span>;</span>   <span class="hljs-comment">//previous node</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//next node</span>&#125;line;</code></pre></div><h4 id="双向链表的创建">双向链表的创建</h4><p>对于创建双向链表，我们需要先创建头节点再逐步的进行添加，请注意，双向链表的头节点是有数据元素的，这与一般的单链表是不同的。</p><p>开辟一段新的内存空间作为新的节点，为这个节点进行的data进行赋值，然后将已成链表的上一个节点的next指针指向自身，自身的pre指针指向上一个节点。</p><div class="code-wrapper"><pre><code class="hljs c">line* <span class="hljs-title function_">initLine</span><span class="hljs-params">(line * head)</span>&#123;    <span class="hljs-type">int</span> number,pos=<span class="hljs-number">1</span>,input_data;    <span class="hljs-comment">//三个变量分别代表节点数量，当前位置，输入的数据</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入创建节点的大小\n&quot;</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;number);    <span class="hljs-keyword">if</span>(number&lt;<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125; <span class="hljs-comment">//输入非法直接结束</span>    <span class="hljs-comment">//////头节点创建///////</span>    head=(line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(line));    head-&gt;pre=<span class="hljs-literal">NULL</span>;    head-&gt;next=<span class="hljs-literal">NULL</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入第%d个数据\n&quot;</span>,pos++);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;input_data);    head-&gt;data=input_data;      line* <span class="hljs-built_in">list</span>=head;    <span class="hljs-keyword">while</span> (pos&lt;=number) &#123;        line * body=(line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(line));        body-&gt;pre=<span class="hljs-literal">NULL</span>;        body-&gt;next=<span class="hljs-literal">NULL</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入第%d个数据\n&quot;</span>,pos++);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;input_data);        body-&gt;data=input_data;                <span class="hljs-built_in">list</span>-&gt;next=body;        body-&gt;pre=<span class="hljs-built_in">list</span>;        <span class="hljs-built_in">list</span>=<span class="hljs-built_in">list</span>-&gt;next;    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><h4 id="双向链表的遍历">双向链表的遍历</h4><p>如同单链表的遍历一样，利用next指针逐步向后进行索引即可。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">printLine</span><span class="hljs-params">(line* head)</span>&#123;    line *<span class="hljs-built_in">list</span> = head;    <span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">list</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d个数据是:%d\n&quot;</span>,pos++,<span class="hljs-built_in">list</span>-&gt;data);        <span class="hljs-built_in">list</span>=<span class="hljs-built_in">list</span>-&gt;next;    &#125;&#125;</code></pre></div><h4 id="双向链表的插入操作">双向链表的插入操作</h4><p>对于双向链表的插入操作，也有三种形式：头部插入、中部插入和尾部插入。操作方式大同小异，首先创建一个独立的节点，将其的pre指针指向所需插入位置的前一个节点，同时，其所需插入的前一个节点的next指针修改指向为该新的节点，同理，该新的节点的next指针指向原本的下一个节点，而修改下一个节点的pre指针指向创建的新节点，如下图所示：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720220211252.png"alt="image-20230720220211252" /><figcaption aria-hidden="true">image-20230720220211252</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c">line* <span class="hljs-title function_">insertLine</span><span class="hljs-params">(line* head,<span class="hljs-type">int</span> data,<span class="hljs-type">int</span> add)</span>&#123;    <span class="hljs-comment">//三个参数分别为：进行此操作的双链表，插入的数据，插入的位置</span>    <span class="hljs-comment">//新建数据域为data的节点</span>    line* temp=(line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(line));    temp-&gt;data=data;    temp-&gt;pre=<span class="hljs-literal">NULL</span>;    temp-&gt;next=<span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//插入到链表头，要特殊考虑</span>    <span class="hljs-keyword">if</span> (add==<span class="hljs-number">1</span>) &#123;        temp-&gt;next=head;        head-&gt;pre=temp;        head=temp;    &#125;<span class="hljs-keyword">else</span>&#123;        line * body=head;        <span class="hljs-comment">//找到要插入位置的前一个节点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;add<span class="hljs-number">-1</span>; i++) &#123;            body=body-&gt;next;        &#125;        <span class="hljs-comment">//判断条件为真，说明插入位置为链表尾</span>        <span class="hljs-keyword">if</span> (body-&gt;next==<span class="hljs-literal">NULL</span>) &#123;            body-&gt;next=temp;            temp-&gt;pre=body;        &#125;<span class="hljs-keyword">else</span>&#123;            body-&gt;next-&gt;pre=temp;            temp-&gt;next=body-&gt;next;            body-&gt;next=temp;            temp-&gt;pre=body;        &#125;    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><h4 id="双向链表的删除操作">双向链表的删除操作</h4><p>删除操作的过程是：首先将需要删除节点的前一个节点的next指针指向自己的下一个节点，同时将下一个节点的pre指针修改指向为自己的上一个节点，然后删除节点，释放空间。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720221311648.png"alt="image-20230720221311648" /><figcaption aria-hidden="true">image-20230720221311648</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c">line* <span class="hljs-title function_">deleteLine</span><span class="hljs-params">(line* head, <span class="hljs-type">int</span> data)</span>&#123;    <span class="hljs-comment">//输入的参数分别为进行此操作的双链表，需要删除的数据</span>    line* <span class="hljs-built_in">list</span>=head;    <span class="hljs-comment">//遍历链表</span>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">list</span>) &#123;        <span class="hljs-comment">//判断是否与此元素相等</span>        <span class="hljs-comment">//删除该点方法为将该节点前一节点的next指向该节点后一节点</span>        <span class="hljs-comment">//同时将该节点的后一节点的pre指向该节点的前一节点</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>-&gt;data==data) &#123;            <span class="hljs-built_in">list</span>-&gt;pre-&gt;next=<span class="hljs-built_in">list</span>-&gt;next;            <span class="hljs-built_in">list</span>-&gt;next-&gt;pre=<span class="hljs-built_in">list</span>-&gt;pre;            <span class="hljs-built_in">free</span>(<span class="hljs-built_in">list</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--删除成功--\n&quot;</span>);            <span class="hljs-keyword">return</span> head;        &#125;        <span class="hljs-built_in">list</span>=<span class="hljs-built_in">list</span>-&gt;next;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error:没有找到该元素，没有产生删除\n&quot;</span>);    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><p>附件：<ahref="https://gitee.com/kayoungzhang/my_codehub/blob/master/Data%20Structures%20and%20Algorithms/linkedlist.drawio">链表图形编辑源图</a></p><h4 id="参考链接">参考链接：</h4><p>https://zhuanlan.zhihu.com/p/85504177</p><p>https://www.dotcpp.com/course/ds-link/</p><p>http://data.biancheng.net/view/166.html</p><p><ahref="https://huaweicloud.csdn.net/63a56658b878a545459463d4.html?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-1-125701955-blog-123446098.235%5Ev38%5Epc_relevant_anti_t3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-1-125701955-blog-123446098.235%5Ev38%5Epc_relevant_anti_t3&amp;utm_relevant_index=2">链表基础知识详解（非常详细简单易懂）</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐几款小工具</title>
    <link href="/2023/07/16/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/07/16/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>在网上发现了几款小工具，有的时候应该会使用到，所以我就下载来使用了一番，觉得蛮好玩的，以下分享一下。</p><h2 id="关于鼠标和按键类小工具">关于鼠标和按键类小工具</h2><h3 id="按键可视化工具---keyviz">按键可视化工具 - Keyviz</h3><p><strong>官网：<ahref="https://mularahul.github.io/keyviz/">Keyviz</a> </strong></p><p>这是一款印度免费开源的按键可视化工具，可以实时显示用户当前按下的按键，用户可自定义显示按键风格、样式，非常适合录屏、演示等场合。打开软件后，当按下按键或点击鼠标，在屏幕上就会实时显示当前的按键，如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716171550372.png" alt="image-20230716171550372" style="zoom:67%;" /></p><p>另外，可根据自己的喜好进行简单的配置。</p><h3 id="按键可视化工具---keystroke-visualizer">按键可视化工具 -Keystroke Visualizer</h3><p><strong>官网：<ahref="https://vovsoft.com/software/keystroke-visualizer/">KeystrokeVisualizer</a></strong></p><p>这也是一款免费开源的按键可视化工具，这一款可以设置中文。另外设置上更简单一些。其显示如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716173232343.png" alt="image-20230716173232343" style="zoom:67%;" /></p><h3 id="按键音效工具---tickeys">按键音效工具 - Tickeys</h3><p><strong>官网：<ahref="http://www.yingdev.com/projects/tickeys">Tickeys</a></strong></p><p>这是一款中文版键盘音效工具，可以让你在敲键盘时，发出声音，有声音的节奏，会让你敲起来更带感。它有以下几种音效，可以根据自己的喜好进行设置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716174556296.png" alt="image-20230716174556296" style="zoom:67%;" /></p><p>当你快速敲击键盘按键时，伴随着悦耳的声音，明显感觉打字的速度变快了，这种感觉挺好的，哈哈。</p><h2 id="关于桌面涂鸦小工具">关于桌面涂鸦小工具</h2><h3 id="pointofix">Pointofix</h3><p><strong>官网：<ahref="https://www.pointofix.de/download.php">Pointofix</a></strong></p><p>这是一款德国免费软件，可以随时将电脑桌面当作画布，然后在桌面上进行涂写标注，在讲解演示时很是方便，国内使用的比较多。这是一款德文软件，所以需要用户在软件下载页面同时下载语言包。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716183416023.png" alt="image-20230716183416023" style="zoom:67%;" /></p><p>打开软件后，点击<strong>开始</strong>，电脑桌面就会被冻结，同时软件会伸展开，然后就可以在桌面上进行自由涂鸦标注了，若想退出来，点击软件上的<strong>退出</strong>按钮即可，同时软件会收缩成一个按钮图标，这样就不会占用屏幕空间。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716185103598.png" alt="image-20230716185103598" style="zoom:80%;" /><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716185036872.png" alt="image-20230716185036872" style="zoom: 80%;" /></p><p><strong>注意：</strong>如果使用语言包还是不能显示中文，那就在上述下载界面下载以下小工具，进行相应设置。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716185843116.png"alt="image-20230716185843116" /><figcaption aria-hidden="true">image-20230716185843116</figcaption></figure><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716190429416.png" alt="image-20230716190429416" style="zoom:80%;" /></p><h3 id="gink">gInk</h3><p>这也是一款非常优秀的屏幕标注，支持多种语言，设置比较简单，项目地址：https://github.com/geovens/gInk</p><p>镜像地址：https://gitcode.net/mirrors/geovens/gInk?utm_source=csdn_github_accelerator</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716191042266.png" alt="image-20230716191042266" style="zoom:80%;" /></p><h3 id="电子教鞭">电子教鞭</h3><p>这也是一款纯中文桌面涂鸦软件，不需要过多的设置，使用起来比较简单。下载地址：https://wwx.lanzoui.com/b08mbl9jg（密码：g18f）。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716191807139.png" alt="image-20230716191807139" style="zoom:67%;" /></p><p>打开软件后，显示界面如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716192034228.png" alt="image-20230716192034228" style="zoom:80%;" /></p><p>相较于另两款，它没有悬浮窗功能，不能收缩，打开后就会一直维持原大小，这就会占用屏幕空间，影响视觉。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>key</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender基础</title>
    <link href="/2023/07/15/Blender%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/15/Blender%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>看到有些视频讲解时使用到了动画演示，比较生动形象，这种方式更有助于我们理解所讲解的知识内容，简单的了解了一下，它们是通过一些专业的软件进行设计的，以下要介绍的Blender软件就是其中的一款。</p><h2 id="blender简介">Blender简介</h2><ul><li>Blender是一个体积小巧，但完整集成的自由开源3D创作套件，提供了大量的基础工具，包括<ahref="https://docs.blender.org/manual/zh-hans/latest/modeling/introduction.html">建模</a>、 <ahref="https://docs.blender.org/manual/zh-hans/latest/render/introduction.html">渲染</a>、 <ahref="https://docs.blender.org/manual/zh-hans/latest/animation/introduction.html">动画&amp; 绑定</a> 、 <ahref="https://docs.blender.org/manual/zh-hans/latest/video_editing/index.html">视频编辑</a>、 <ahref="https://docs.blender.org/manual/zh-hans/latest/movie_clip/index.html">视觉效果</a>、 <ahref="https://docs.blender.org/manual/zh-hans/latest/compositing/introduction.html">合成</a>、 <ahref="https://docs.blender.org/manual/zh-hans/latest/editors/uv/introduction.html">贴图</a>，以及多种类型的 <ahref="https://docs.blender.org/manual/zh-hans/latest/physics/introduction.html">模拟</a>。</li><li>跨平台，使用了OpenGL的GUI可以在所有主流平台上都表现出一致的显示效果（并且可通过Python脚本来自定义界面）。</li><li>高质量的3D架构，带来了快速且高效的工作流。</li><li>它有着活跃的社区支持， <ahref="https://www.blender.org/community">blender.org/community</a>收录了大量的站点列表。</li></ul><p>官网：https://www.blender.org/</p><p>官网用户手册：https://docs.blender.org/manual/zh-hans/latest/</p><h2 id="blender界面基础操作">Blender界面基础操作</h2><h3 id="快捷键">快捷键：</h3><p>Blender可以设置中文界面，当鼠标停留在相应的图标上会显示其对应的名称和快捷键，以下是常用的快捷键：</p><ul><li>侧栏 ---&gt; N</li><li>工具栏 ---&gt; T</li><li>旋转 ---&gt; 鼠标中键拖动(R)</li><li>缩放 ---&gt;鼠标滚轮 (S)</li><li>平移 ---&gt;Shitf + 鼠标中键拖动(G)</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715120248555.png" alt="image-20230715120248555" style="zoom:67%;" /><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715124045066.png" alt="image-20230715124045066" style="zoom: 67%;" /></p><p><strong>注意：</strong>旋转、缩放、平移的同时，按下键盘的<strong>x或y或z键</strong> 则物体会在相应的方向进行变化。</p><ul><li>四格视图 ---&gt; Ctrl + Alt + Q</li><li>其它视图（没有数字键盘则需要勾选<strong>模拟数字键盘</strong>）：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715122303901.png" alt="image-20230715122303901" style="zoom:67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715121127963.png" alt="image-20230715121127963" style="zoom:67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715123423095.png" alt="image-20230715123423095" style="zoom:67%;" /></p><p>另外，<strong>`</strong> 键可以选择不同的视图。 <strong>/</strong>键选中的物体独显示。</p><p>快捷键的修改设置：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715120553076.png" alt="image-20230715120553076" style="zoom:67%;" /></p><h3 id="游标定位和原点定位">游标定位和原点定位</h3><p><strong>游标</strong> 是物体创建时的定位点，当操作<strong>物体-&gt;吸附-&gt;游标-&gt;世界原点</strong> ，游标会回到(0, 0,0)。它的定位主要有以下两种方式：</p><ol type="1"><li>模糊定位：</li></ol><p>Shitf + 鼠标右键 ，然后选中定位位置。</p><ol start="2" type="1"><li>吸附定位(精确定位)：</li></ol><p>由 <strong>物体模式</strong> 切换到 <strong>编辑模式</strong>(按TAB键)，选中<strong>点选择模式</strong>，然后选择物体定位点，之后选择<strong>网络-&gt;吸附-&gt;游标-&gt;选中项</strong> 。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715131529396.png" alt="image-20230715131529396" style="zoom:67%;" /></p><p><strong>原点</strong>是指物体的基准点，它是物体旋转，缩放，平移的基点，默认是在物体的中心位置。它的定位设置通过选中物体，鼠标右键即可进行设置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715132804522.png" alt="image-20230715132804522" style="zoom:67%;" /></p><h2 id="插件">插件</h2><ul><li><p>按键字符显示插件 ---&gt; Screencast Keys</p></li><li><p>网格其它图形形状 ---&gt; Add Mesh:Extra Objects</p></li><li><p>布尔操作---&gt; Bool Tool</p></li></ul><p>未完待续...</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态站点生成器</title>
    <link href="/2023/07/12/%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2023/07/12/%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>静态站点生成器（Static Site Generators，简称SSG）是一种软件工具，可以快速轻松地生成静态站点，它采用模板、组件和内容源，然后生成网站所需的HTML、CSS 和 JavaScript文件，它已经改变或正在改变我们构建网站的方式。</p><p>静态站点生成器使网站加载速度更快，因为它会在用户请求之前预先构建网站所需的必要文件。它非常适合创建营销、文档和博客等网站。但不适用于想要显示经常变化的实时、动态数据的情况。</p><p>目前，有超过 350多个静态站点生成器可供选择(https://jamstack.org/generators/)，但在选择静态站点生成器时要考虑一些因素：</p><ul><li><strong>项目性质</strong></li></ul><p>我们要根据构建的项目类型选择合适的站点生成工具。例如Hugo是博客和文档的绝佳选择，而 Gatsby、Nuxt.js 和 Next.js是营销网站的绝佳选择。</p><ul><li><strong>使用方便</strong></li></ul><p>很多情况下，几乎没有时间进行深入学习，所以在选择静态站点生成器时，更多会考虑以下问题：</p><ul><li><p>SSG是用熟悉的技术构建的，还是需要学习一种新的编程语言才能正确使用它？</p></li><li><p>文档是否详细？</p></li><li><p>是否提供初学者教程和其他学习材料来帮助学习过程？</p></li><li><p>是否可以使用模板和主题来加快构建过程？</p></li><li><p><strong>开发者社区</strong></p></li></ul><p>确定 SSG是否是一个好的选择的一个好方法就是去研究它的开发者社区。开发者往往会聚集在好的工具和软件周围，因此如果它经过充分审查，可能值得考虑。开发者社区对于获得支持和帮助也很重要，遇到问题时，可以更快的得到解决。</p><ul><li><strong>成熟度和采用率</strong></li></ul><p>决定使用哪种 SSG的一个好方法是查看业内其他人使用的工具以及这些工具的成熟程度。Next.js被广泛采用的一个原因是它是一个成熟的框架，具有很多强大的功能并且有Vercel 的支持。这些因素促成了它在开发中被广泛采用。</p><p>下面是一些常用的静态站点生成器：</p><p>Next.js、Jekyll、Hugo、Hexo、GitBook、Gatsby、MkDocs、VuePress、Astro等。</p><p>参考链接：</p><p>https://www.51cto.com/article/748558.html</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>QPainter基本图形绘制用法</title>
    <link href="/2023/07/07/QPainter%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E7%94%A8%E6%B3%95/"/>
    <url>/2023/07/07/QPainter%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="qpainter概念">QPainter概念</h2><p>QPainter是用于执行绘图操作的类，它可以绘制简单的点、线，也可以绘制饼图、文本、图像等复杂的形状。</p><p>QPainter 一般在绘图事件 <strong>paintEvent()</strong>中进行绘制，当窗口需要改变或者重新绘制时，当使用<strong>repaint()</strong>和 <strong>update()</strong>后，就会自动调用成员函数 <strong>paintEvent()</strong>。</p><p>QPainter 的用法，简单的几个步骤:</p><ul><li><p>1.构造一个 <strong>QPainter</strong> 对象</p></li><li><p>2.设置画笔，画刷等</p></li><li><p>3.绘制图形</p></li><li><p>4.销毁绘图工具</p></li></ul><h2 id="qpainter主要属性">Qpainter主要属性</h2><ul><li><strong>font()</strong>用于绘制文本的字体。</li><li><strong>brush()</strong>定义用于填充形状的颜色或图案。</li><li><strong>pen()</strong>定义用于绘制的线条或边框，也可定义线条颜色。</li><li><strong>viewport()、window()、worldTransform()</strong>构成了painter的坐标转换系统。</li></ul><h2 id="qpainter绘图">Qpainter绘图</h2><p>QPainter提供了绘制大多数基本图形的函数，如drawPoint()、drawLine()、drawRect()等，所有这些函数都有多个整数和浮点版本（推荐使用浮点数版本）。下面对常用的绘图功能进行说明：</p><ul><li><strong>绘制点</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event); <span class="hljs-comment">//不使用event事件</span>    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.drawPoint(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);    painter.drawPoint(QPoint(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>));    painter.drawPoint(QPointF(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>));    QPoint points[<span class="hljs-number">3</span>] = &#123;QPoint(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>),QPoint(<span class="hljs-number">60</span>,<span class="hljs-number">60</span>),QPoint(<span class="hljs-number">70</span>,<span class="hljs-number">70</span>)&#125;;    painter.drawPoints(points, <span class="hljs-number">3</span>);&#125;</code></pre></div><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707150523540.png"alt="image-20230707150523540" /><figcaption aria-hidden="true">image-20230707150523540</figcaption></figure><ul><li><strong>绘制线</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event); <span class="hljs-comment">//不使用event事件</span>        QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.setPen(QColor(Qt::red));<span class="hljs-comment">//设置画笔颜色</span>        QLine <span class="hljs-title function_">line</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)</span>;    painter.drawLine(line);    painter.drawLine(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>);    painter.drawLine(QPoint(<span class="hljs-number">50</span>, <span class="hljs-number">0</span>), QPoint(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>));    QVector&lt;QLine&gt; vectorLine;    vectorLine &lt;&lt; QLine(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>);    vectorLine &lt;&lt; QLine(<span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">100</span>);    vectorLine &lt;&lt; QLine(<span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>);    vectorLine &lt;&lt; QLine(<span class="hljs-number">70</span>, <span class="hljs-number">0</span>, <span class="hljs-number">70</span>, <span class="hljs-number">100</span>);    vectorLine &lt;&lt; QLine(<span class="hljs-number">90</span>, <span class="hljs-number">0</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>);    painter.drawLines(vectorLine);&#125;</code></pre></div><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707151808304.png"alt="image-20230707151808304" /><figcaption aria-hidden="true">image-20230707151808304</figcaption></figure><ul><li><strong>绘制矩形</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event); <span class="hljs-comment">//不使用event事件</span>    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.setPen(QColor(<span class="hljs-number">10</span>,<span class="hljs-number">60</span>,<span class="hljs-number">200</span>));<span class="hljs-comment">//设置画笔颜色</span>    painter.setBrush(QColor(<span class="hljs-number">200</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>));<span class="hljs-comment">//设置画刷颜色</span>    painter.drawRect(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">150</span>);    QRect <span class="hljs-title function_">rect</span><span class="hljs-params">(QPoint(<span class="hljs-number">160</span>, <span class="hljs-number">160</span>),QPoint(<span class="hljs-number">220</span>,<span class="hljs-number">220</span>))</span>;    painter.drawRect(rect);&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707153153942.png" alt="image-20230707153153942" style="zoom:67%;" /></p><ul><li><strong>绘制圆弧</strong></li></ul><p>0°在时钟三点的位置，圆弧是逆时针转动，起始角度和跨度角度都必须是度数的1/16，如：整个圆的角度就是**16*360**.</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/20230707155314.png" alt="20230707155314" style="zoom: 67%;" /></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event); <span class="hljs-comment">//不使用event事件</span>    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    QRectF <span class="hljs-title function_">rectangle</span><span class="hljs-params">(<span class="hljs-number">50.0</span>, <span class="hljs-number">50.0</span>, <span class="hljs-number">60.0</span>, <span class="hljs-number">60.0</span>)</span>;    <span class="hljs-type">int</span> startAngle = <span class="hljs-number">30</span> * <span class="hljs-number">16</span>;    <span class="hljs-type">int</span> spanAngle = <span class="hljs-number">130</span> * <span class="hljs-number">16</span>;    painter.drawArc(rectangle, startAngle, spanAngle);    painter.setPen(QPen(Qt::blue,<span class="hljs-number">3</span>,Qt::DotLine));    painter.drawRect(rectangle);&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707155800251.png" alt="image-20230707155800251" style="zoom:80%;" /></p><ul><li><strong>绘制椭圆</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event);    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.setRenderHint(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<span class="hljs-comment">//抗锯齿</span>    painter.drawEllipse(QPointF(<span class="hljs-number">120</span>, <span class="hljs-number">60</span>), <span class="hljs-number">50</span>, <span class="hljs-number">20</span>);    painter.setBrush(QColor(<span class="hljs-number">255</span>, <span class="hljs-number">160</span>, <span class="hljs-number">90</span>)); <span class="hljs-comment">//设置画刷颜色</span>    painter.drawEllipse(QPointF(<span class="hljs-number">120</span>, <span class="hljs-number">140</span>), <span class="hljs-number">40</span>, <span class="hljs-number">40</span>); <span class="hljs-comment">//绘制圆</span>&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707161014066.png" alt="image-20230707161014066" style="zoom:67%;" /></p><ul><li><strong>绘制多边形</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event);    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.setRenderHint(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<span class="hljs-comment">//抗锯齿</span>    QPointF points[<span class="hljs-number">4</span>] = &#123;QPointF(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>), QPointF(<span class="hljs-number">60</span>, <span class="hljs-number">150</span>), QPointF(<span class="hljs-number">150</span>, <span class="hljs-number">160</span>), QPointF(<span class="hljs-number">220</span>, <span class="hljs-number">100</span>)&#125;;    painter.drawPolygon(points, <span class="hljs-number">4</span>);&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707161401036.png" alt="image-20230707161401036" style="zoom:67%;" /></p><ul><li><strong>绘制文本</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event);    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.setPen(QColor(<span class="hljs-number">0</span>, <span class="hljs-number">160</span>, <span class="hljs-number">230</span>));<span class="hljs-comment">//设置画笔颜色</span>    QFont font;<span class="hljs-comment">//设置字体属性</span>    font.setFamily(<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>);<span class="hljs-comment">//字体样式</span>    font.setPointSize(<span class="hljs-number">50</span>);<span class="hljs-comment">//字体点大小</span>    font.setItalic(<span class="hljs-literal">true</span>);<span class="hljs-comment">//字体斜体</span>    painter.setFont(font);    painter.drawText(rect(), Qt::AlignCenter, <span class="hljs-string">&quot;QPainter&quot;</span>);<span class="hljs-comment">//绘制文本</span>&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707162043411.png" alt="image-20230707162043411" style="zoom:67%;" /></p><ul><li><strong>绘制图像</strong></li></ul><p>绘制图像函数有<strong>drawPixmap()、drawImage()</strong>，drawPixmap在屏幕设备上更快，drawImage()在QPrinter或其他设备上可能更快。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event);    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    QPixmap pixmap;    pixmap.load(<span class="hljs-string">&quot;:/pic/a.png&quot;</span>);    painter.drawPixmap(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">150</span>, <span class="hljs-number">150</span>, pixmap);    QImage image;    image.load(<span class="hljs-string">&quot;:/pic/b.png&quot;</span>);    painter.drawImage(<span class="hljs-number">160</span>, <span class="hljs-number">0</span>, image);&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707163819634.png" alt="image-20230707163819634" style="zoom:67%;" /></p><p>工程文件：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/painter.zip">painter</a></p><p>参考链接：</p><p>http://t.csdn.cn/Q72tA</p><p>http://t.csdn.cn/acIsw</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法中的时间和空间复杂度</title>
    <link href="/2023/07/07/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2023/07/07/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="算法简介">算法简介</h2><p>所谓算法（Algorithm），即解决问题的方法。同一个问题，使用不同的算法，虽然得到的结果相同，但耗费的时间和资源肯定有所差异。</p><p><strong>注意</strong>，程序和算法是完全不同的概念。算法是解决某个问题的想法、思路；而程序是在根据算法编写出来的真正可以运行的代码。例如，要依次输出一维数组中的数据元素的值，首先想到的是使用循环结构，在这个算法的基础上，我们才开始编写程序。</p><p>程序的运行效率具体可以从 2 个方面衡量，分别为：</p><ul><li>程序的运行时间。（时间维度）</li><li>程序运行所需内存空间的大小。（空间维度）</li></ul><p>程序运行时间越短，运行期间占用的内存越少，该程序运行效率就越高，这样算法也就更好。衡量一个算法所编写出程序的运行效率在数据结构中，用<strong>时间复杂度</strong>来衡量程序运行时间的多少；用<strong>空间复杂度</strong>来衡量程序运行所需内存空间的大小。</p><h2 id="算法中复杂度的表示方法">算法中复杂度的表示方法</h2><p>在数据结构中，每条语句的执行次数，被称为该语句的频度，整段代码的总执行次数，为整段代码的频度。所以算法复杂度的一般通用表示方法是：「<strong>大O符号表示法</strong> 」，即<strong>O(频度)</strong>。大O符号表示法是一种算法复杂度的相对表示方式。</p><h2 id="时间复杂度">时间复杂度</h2><h3 id="时间复杂度概念">时间复杂度概念</h3><p>一个算法所编程序运行时间的多少，并不是在计算机上运行所消耗的时间来度量的，而是根据合理方法得到的预估值。那么，如何预估一个算法所编程序的运行时间呢？就是计算程序中每行代码的执行次数，然后用总的执行次数间接表示程序的运行时间，即：</p><p><strong>T(n) = O(f(n))</strong></p><p>其中：<strong>T(n)</strong>表示程序执行的时间；<strong>f(n)</strong>表示每行代码执行次数之和；而 <strong>O</strong> 表示 T(n) 与 f(n)成正比关系，这个公式的全称是：<strong>算法的渐进时间复杂度</strong>。</p><p>我们先来看个例子：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)     <span class="hljs-comment">//&lt;- 从 0 到 n，执行 n+1 次</span>&#123;    a++;                         <span class="hljs-comment">//&lt;- 从 0 到 n-1，执行 n 次</span>&#125;</code></pre></div><p>因此，整段代码中所有语句共执行了 (n+1)+n 次，即 <strong>2n+1</strong>次。</p><p>再看一个例子：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)           <span class="hljs-comment">// n+1次</span>&#123;     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j++)       <span class="hljs-comment">// n*(m+1)次</span>    &#123;        num++;                         <span class="hljs-comment">// n*m次</span>    &#125;&#125;</code></pre></div><p>这段代码一共执行的次数是：(2*n*m+2*n+1)。当 n、m 都无限大时，可认为n==m，则可以简化为<strong>2n²+2n+1</strong>，这就是此段程序在最坏情况下的运行频度。</p><p>在数据结构中，一般会使用 <strong>无限大的思想</strong>来简化频度表达式。可以这样简化：</p><ul><li>首先去掉常数分子。例如 <strong>2n²+2n+1</strong> 简化为<strong>2n²+2n</strong> ；</li><li>然后有多项无限大的变量的，只保留一个最高项变量,且最高项系数为1。例如<strong>2n²+2n</strong> 简化为 <strong>n²</strong>；</li></ul><p>这样，就可以得到以上两个例子的时间复杂度分别为 <strong>O(n)</strong>和 <strong>O(n²)</strong> 。</p><h3 id="常见的时间复杂度量级">常见的时间复杂度量级</h3><p>常见的时间复杂度量级有：</p><ul><li><strong>常数阶O(1)</strong></li><li><strong>对数阶O(logn)</strong></li><li><strong>线性阶O(n)</strong></li><li><strong>线性对数阶O(nlogn)</strong></li><li><strong>平方阶O(n²)</strong></li><li><strong>立方阶O(n³)</strong></li><li><strong>指数阶(2^n)</strong></li></ul><p>上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。<strong>注意</strong>，这里仅以最坏情况下的频度作为时间复杂度，而在某些实际场景中，还可以用最好情况下的频度和最坏情况下的频度的平均值来作为算法的平均时间复杂度。</p><p>下面分别举例说明：</p><ol type="1"><li><strong>常数阶O(1)</strong></li></ol><p>无论代码执行了多少行，哪怕执行上万行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1),如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;++i;j++;<span class="hljs-type">int</span> m = i + j;</code></pre></div><ol start="2" type="1"><li><strong>对数阶O(logn)</strong></li></ol><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;     <span class="hljs-comment">//执行1次</span><span class="hljs-keyword">while</span>(i&lt;n)     <span class="hljs-comment">//执行log2^n次</span>&#123;    i = i * <span class="hljs-number">2</span>; <span class="hljs-comment">//执行log2^n次</span>&#125;</code></pre></div><p>这段代码总的执行次数是 <strong>2log2^n + 1</strong>;简化：<strong>log2^n</strong>,对数的底是不确定的，这里恰好是2，一般会去掉对数的底，所以可以进一步简化：<strong>logn</strong>，即时间复杂度：<strong>O(logn)</strong>。</p><ol start="3" type="1"><li><strong>线性阶O(n)</strong></li></ol><p>如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i) <span class="hljs-comment">//执行了n次</span>&#123;   j++ = i;   <span class="hljs-comment">//执行了 n-1 次</span>&#125;</code></pre></div><p>这段代码执行了 <strong>2n-1</strong> 次，简化后，即时间复杂度<strong>O(n)</strong> 。</p><ol start="4" type="1"><li><strong>线性对数阶O(nlogn)</strong></li></ol><p>将时间复杂度为O(logn)的代码循环n遍的话，那么它的时间复杂度就是 n *O(logn)，也就是了O(nlogn)。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(m=<span class="hljs-number">1</span>; m&lt;n; m++) <span class="hljs-comment">//执行n次</span>&#123;    i = <span class="hljs-number">1</span>;       <span class="hljs-comment">//执行n次</span>    <span class="hljs-keyword">while</span>(i&lt;n)   <span class="hljs-comment">//执行 n*log2^n次</span>    &#123;        i = i * <span class="hljs-number">2</span>;  <span class="hljs-comment">//执行n*log2^n次</span>    &#125;&#125;</code></pre></div><p>这段代码执行了 <strong>2n+2nlog2^n</strong> 次，简化后，即时间复杂度<strong>O(nlogn)</strong> 。</p><ol start="5" type="1"><li><strong>平方阶O(n²)</strong></li></ol><p>如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(x=<span class="hljs-number">1</span>; i&lt;=n; x++) <span class="hljs-comment">//执行n次</span>&#123;   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-comment">//执行n*n次</span>    &#123;       j++ = i;  <span class="hljs-comment">//执行n*n次</span>    &#125;&#125;</code></pre></div><p>这段代码执行了 <strong>n+2n²</strong> 次，简化后，即时间复杂度<strong>O(n²)</strong> 。</p><ol start="6" type="1"><li><strong>立方阶O(n³)</strong></li></ol><p>O(n³)相当于三层n循环，其它的类似。</p><ol start="7" type="1"><li><strong>指数阶(2^n)</strong></li></ol><p>在递归调用程序中，会有指数阶，如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   <span class="hljs-keyword">return</span> f(n<span class="hljs-number">-1</span>) + f(n - <span class="hljs-number">1</span>);&#125;</code></pre></div><p>这里执行的次数计算: 2^0 + 2^1 + 2^2 + …… +2^n，即2^(n+1)-1,进一步简化则时间复杂度:<strong>O(2^n)</strong> 。</p><p>除此之外，其实还有<strong>平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度</strong>，有点复杂，这里这里就不展开了。</p><h2 id="空间复杂度">空间复杂度</h2><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用S(n) 来定义。和时间复杂度类似，也用 「 <strong>大O符号表示法</strong> 」来表示。</p><p>事实上，<strong>对算法的空间复杂度影响最大的，往往是程序运行过程中所申请的临时存储空间</strong>。如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> n;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];</code></pre></div><p>这段程序在运行时所申请的临时空间，并不随 n 的值而变化。而如果将第 3行代码改为<code>int a[n]</code>, 此时程序运行所申请的临时空间，和 n值有直接的关联。</p><p>所以，如果程序所占用的存储空间和输入值无关，则该程序的空间复杂度就为<strong>O(1)</strong>；反之则需要进一步判断它们之间的关系：</p><ul><li>输入值 n不断增大，程序申请的临时空间成线性增长，则程序的空间复杂度用<strong>O(n)</strong> 表示;</li><li>输入值 n 不断增大，程序申请的临时空间成 n²关系增长，则程序的空间复杂度用 <strong>O(n²)</strong> 表示；</li><li>输入值 n 不断增大，程序申请的临时空间成 n³关系增长，则程序的空间复杂度用 <strong>O(n³)</strong> 表示；</li></ul><blockquote><p><strong>在多数场景中，一个好的算法往往更注重的是时间复杂度的比较，而空间复杂度只要在一个合理的范围内就可以。空间复杂度比较常用的有：O(1)、O(n)、O(n²)</strong></p></blockquote><p>参考链接：</p><p>http://c.biancheng.net/view/8081.html</p><p>https://zhuanlan.zhihu.com/p/50479555</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora中常用HTML格式设置</title>
    <link href="/2023/07/05/Typora%E4%B8%AD%E5%B8%B8%E7%94%A8HTML%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/07/05/Typora%E4%B8%AD%E5%B8%B8%E7%94%A8HTML%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="颜色">1.颜色</h3><p>颜色的种类有很多，HTML和CSS中的颜色规格有140多个（17种标准颜色，再加130多个其它颜色）。17种标准颜色：</p><table><tr><td style="background-color:aqua">浅绿色<br>aqua</td><td style="background-color:black">黑色<br>black</td><td style="background-color:blue">蓝色<br>blue</td><td style="background-color:fuchsia">紫红色<br>fuchsia</td><td style="background-color:gray">灰色<br>gray</td><td style="background-color:green">绿色<br>green</td><td style="background-color:lime">浅绿色<br>lime</td><td style="background-color:maroon">褐红色<br>maroon</td><td style="background-color:navy">藏青色<br>navy</td></tr><tr><td style="background-color:olive">橄榄色<br>olive</td><td style="background-color:orange">橙色<br>orange</td><td style="background-color:purple">紫色<br>purple</td><td style="background-color:red">红色<br>red</td><td style="background-color:silver">银色<br>silver</td><td style="background-color:teal">青色<br>teal</td><td style="background-color:white">白色<br>white</td><td style="background-color:yellow">黄色<br>yellow</td></tr></table><ul><li><p>Hex颜色代码： &lt;p style="color:#FF0000"&gt;Red text</p></p></li><li><p>HTML颜色名称: &lt;p style="color:red"&gt;Red text</p></p></li><li><p>RGB颜色代码: &lt;p style="color:rgb(255,0,0)"&gt;Red text</p></p></li><li><p>HSL颜色代码： &lt;p style="color:hsl(0,100%,50%)"&gt;Red text</p></p><p>色相值：0-360，饱和度：0~100%，亮度：0~100% 。</p></li><li><p>Font颜色代码：&lt;font color="red"&gt;Red text</font></p><p>HTML5不再支持。 HTML 4.01 已废弃。</p><p>以上五中方式都能实现以下字体样式：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230706223845497.png" alt="image-20230706223845497"  /></p></li><li><p>RGBA颜色代码：&lt;p style="color:rgba(255,0,0,0.5)"&gt;Redtext</p></p><p>a：0~1。0表示完全透明，1表示完全不透明</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230706223917100.png"alt="image-20230706223917100" /><figcaption aria-hidden="true">image-20230706223917100</figcaption></figure></li></ul><h3 id="字体">2.字体</h3><ul><li><p>字体大小：&lt;p style="font-size:20px"&gt;20号字体</p></p><p style="font-size:20px"><p>20号字体</p></p></li><li><p>字体：&lt;p style="font-family:楷体"&gt;楷体字体</p></p><p style="font-family:楷体"><p>楷体字体</p></p></li><li><p>背景：&lt;table&gt;&lt;tdstyle="background-color:green"&gt;背景色:绿色&lt;/td&gt;&lt;/table&gt;</p><table><td style="background-color:green"><p>背景色:绿色</p></td></table></li></ul><h3 id="链接设置">3.链接设置</h3><ul><li><p>普通：&lt;a href="www.baidu.com"&gt;百度</a></p><p><a href="www.baidu.com">百度</a></p></li><li><p>颜色：&lt;a href="www.baidu.com"style="color:OrangeRed"&gt;百度</a></p><p><a href="www.baidu.com" style="color:OrangeRed">百度</a></p></li><li><p>清除下划线：&lt;a href="www.baidu.com"style="text-decoration:none"&gt;百度</a></p><p><a href="www.baidu.com" style="text-decoration:none">百度</a></p></li></ul><h3 id="其它">4.其它</h3><ul><li>换行：&lt;br&gt;</li></ul><h2 id="附录1html颜色名">附录1：HTML颜色名</h2><p>红色HTML颜色名：</p><table><tr><td style="background-color:IndianRed">IndianRed</td><td style="background-color:LightCoral">LightCoral</td><td style="background-color:Salmon">Salmon</td><td style="background-color:DarkSalmon">DarkSalmon</td><td style="background-color:LightSalmon">LightSalmon</td></tr><tr><td style="background-color:Crimson">Crimson</td><td style="background-color:Red">Red</td><td style="background-color:FireBrick">FireBrick</td><td style="background-color:DarkRed">DarkRed</td></tr></table><p>粉色HTML颜色名：</p><table><tr><td style="background-color:Pink">Pink</td><td style="background-color:LightPink">LightPink</td><td style="background-color:HotPink">HotPink</td><td style="background-color:DeepPink">DeepPink</td><td style="background-color:MediumVioletRed">MediumVioletRed</td><td style="background-color:PaleVioletRed">PaleVioletRed</td></tr></table><p>橙色HTML颜色名：</p><table><tr><td style="background-color:LightSalmon">LightSalmon</td><td style="background-color:Coral">Coral</td><td style="background-color:Tomato">Tomato</td><td style="background-color:OrangeRed">OrangeRed</td><td style="background-color:DarkOrange">DarkOrange</td><td style="background-color:Orange">Orange</td></tr></table><p>黄色HTML颜色名：</p><table><tr><td style="background-color:Gold">Gold</td><td style="background-color:Yellow">Yellow</td><td style="background-color:LightYellow">LightYellow</td><td style="background-color:LemonChiffon">LemonChiffon</td><td style="background-color:LightGoldenrodYellow">LightGoldenrodYellow</td><td style="background-color:PapayaWhip">PapayaWhip</td></tr><tr><td style="background-color:Moccasin">Moccasin</td><td style="background-color:PeachPuff">PeachPuff</td><td style="background-color:PaleGoldenrod">PaleGoldenrod</td><td style="background-color:Khaki">Khaki</td><td style="background-color:DarkKhaki">DarkKhaki</td></tr></table><p>紫色HTML颜色名：</p><table><tr><td style="background-color:Lavender">Lavender</td><td style="background-color:Thistle">Thistle</td><td style="background-color:Plum">Plum</td><td style="background-color:Violet">Violet</td><td style="background-color:Orchid">Orchid</td><td style="background-color:Fuchsia">Fuchsia</td></tr><tr><td style="background-color:MediumOrchid">MediumOrchid</td><td style="background-color:MediumPurple">MediumPurple</td><td style="background-color:RebeccaPurple">RebeccaPurple</td><td style="background-color:BlueViolet">BlueViolet</td><td style="background-color:DarkViolet">DarkViolet</td><td style="background-color:DarkOrchid">DarkOrchid</td></tr><tr><td style="background-color:DarkMagenta">DarkMagenta</td><td style="background-color:Purple">Purple</td><td style="background-color:Indigo">Indigo</td><td style="background-color:SlateBlue">SlateBlue</td><td style="background-color:DarkSlateBlue">DarkSlateBlue</td><td style="background-color:MediumSlateBlue">MediumSlateBlue</td></tr></table><p>绿色HTML颜色名：</p><table><tr><td style="background-color:GreenYellow">GreenYellow</td><td style="background-color:Chartreuse">Chartreuse</td><td style="background-color:LawnGreen">LawnGreen</td><td style="background-color:Lime">Lime</td><td style="background-color:LimeGreen">LimeGreen</td></tr><tr><td style="background-color:PaleGreen">PaleGreen</td><td style="background-color:LightGreen">LightGreen</td><td style="background-color:MediumSpringGreen">MediumSpringGreen</td><td style="background-color:SpringGreen">SpringGreen</td><td style="background-color:MediumSeaGreen">MediumSeaGreen</td></tr><tr><td style="background-color:SeaGreen">SeaGreen</td><td style="background-color:ForestGreen">ForestGreen</td><td style="background-color:Green">Green</td><td style="background-color:DarkGreen">DarkGreen</td><td style="background-color:YellowGreen">YellowGreen</td></tr><tr><td style="background-color:OliveDrab">OliveDrab</td><td style="background-color:Olive">Olive</td><td style="background-color:DarkOliveGreen">DarkOliveGreen</td><td style="background-color:MediumAquamarine">MediumAquamarine</td><td style="background-color:DarkSeaGreen">DarkSeaGreen</td></tr><tr><td style="background-color:LightSeaGreen">LightSeaGreen</td><td style="background-color:DarkCyan">DarkCyan</td><td style="background-color:Teal">Teal</td></tr></table><p>蓝色HTML颜色名：</p><table><tr><td style="background-color:Aqua">Aqua</td><td style="background-color:Cyan">Cyan</td><td style="background-color:LightCyan">LightCyan</td><td style="background-color:PaleTurquoise">PaleTurquoise</td><td style="background-color:Aquamarine">Aquamarine</td></tr><tr><td style="background-color:Turquoise">Turquoise</td><td style="background-color:MediumTurquoise">MediumTurquoise</td><td style="background-color:DarkTurquoise">DarkTurquoise</td><td style="background-color:CadetBlue">CadetBlue</td><td style="background-color:SteelBlue">SteelBlue</td></tr><tr><td style="background-color:LightSteelBlue">LightSteelBlue</td><td style="background-color:PowderBlue">PowderBlue</td><td style="background-color:LightBlue">LightBlue</td><td style="background-color:SkyBlue">SkyBlue</td><td style="background-color:LightSkyBlue">LightSkyBlue</td></tr><tr><td style="background-color:DeepSkyBlue">DeepSkyBlue</td><td style="background-color:DodgerBlue">DodgerBlue</td><td style="background-color:CornflowerBlue">CornflowerBlue</td><td style="background-color:MediumSlateBlue">MediumSlateBlue</td><td style="background-color:RoyalBlue">RoyalBlue</td></tr><tr><td style="background-color:Blue">Blue</td><td style="background-color:MediumBlue">MediumBlue</td><td style="background-color:DarkBlue">DarkBlue</td><td style="background-color:Navy">Navy</td><td style="background-color:MidnightBlue">MidnightBlue</td></tr></table><p>褐色HTML颜色名：</p><table><tr><td style="background-color:Cornsilk">Cornsilk</td><td style="background-color:BlanchedAlmond">BlanchedAlmond</td><td style="background-color:Bisque">Bisque</td><td style="background-color:NavajoWhite">NavajoWhite</td><td style="background-color:Wheat">Wheat</td><td style="background-color:BurlyWood">BurlyWood</td></tr><tr><td style="background-color:Tan">Tan</td><td style="background-color:RosyBrown">RosyBrown</td><td style="background-color:SandyBrown">SandyBrown</td><td style="background-color:Goldenrod">Goldenrod</td><td style="background-color:DarkGoldenrod">DarkGoldenrod</td><td style="background-color:Peru">Peru</td></tr><tr><td style="background-color:Chocolate">Chocolate</td><td style="background-color:SaddleBrown">SaddleBrown</td><td style="background-color:Sienna">Sienna</td><td style="background-color:Brown">Brown</td><td style="background-color:Maroon">Maroon</td></tr></table><p>白色HTML颜色名：</p><table><tr><td style="background-color:White">White</td><td style="background-color:Snow">Snow</td><td style="background-color:HoneyDew">HoneyDew</td><td style="background-color:MintCream">MintCream</td><td style="background-color:Azure">Azure</td><td style="background-color:AliceBlue">AliceBlue</td></tr><tr><td style="background-color:GhostWhite">GhostWhite</td><td style="background-color:WhiteSmoke">WhiteSmoke</td><td style="background-color:SeaShell">SeaShell</td><td style="background-color:Beige">Beige</td><td style="background-color:OldLace">OldLace</td><td style="background-color:FloralWhite">FloralWhite</td></tr><tr><td style="background-color:Ivory">Ivory</td><td style="background-color:AntiqueWhite">AntiqueWhite</td><td style="background-color:Linen">Linen</td><td style="background-color:LavenderBlush">LavenderBlush</td><td style="background-color:MistyRose">MistyRose</td></tr></table><p>灰色HTML颜色名：</p><table><tr><td style="background-color:Gainsboro">Gainsboro</td><td style="background-color:LightGray">LightGray</td><td style="background-color:Silver">Silver</td><td style="background-color:DarkGray">DarkGray</td><td style="background-color:Gray">Gray</td></tr><tr><td style="background-color:DimGray">DimGray</td><td style="background-color:LightSlateGray">LightSlateGray</td><td style="background-color:SlateGray">SlateGray</td><td style="background-color:DarkSlateGray">DarkSlateGray</td><td style="background-color:Black">Black</td></tr></table><h2 id="附录2html颜色hex值与rgb值">附录2：HTML颜色HEX值与RGB值</h2><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/material-design-color-chart.png"alt="material-design-color-chart" /><figcaption aria-hidden="true">material-design-color-chart</figcaption></figure><p><strong>链接：</strong></p><p>https://www.runoob.com/tags/html-colorname.html</p><p>https://htmlcolorcodes.com/zh/yanse-ming/</p><h2 id="附录3typora中添加自定义格式">附录3：Typora中添加自定义格式</h2><p>在Typora中为了快速设置格式，可通过快捷键软件（如<ahref="https://www.autohotkey.com/">AutoHotkey</a>）将设置的格式添加到快捷键中，也可以通过输入法的自定义短语添加格式，如下所示：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230706200028503.png"alt="image-20230706200028503" /><figcaption aria-hidden="true">image-20230706200028503</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt中标准对话框</title>
    <link href="/2023/07/02/Qt%E4%B8%AD%E6%A0%87%E5%87%86%E5%AF%B9%E8%AF%9D%E6%A1%86/"/>
    <url>/2023/07/02/Qt%E4%B8%AD%E6%A0%87%E5%87%86%E5%AF%B9%E8%AF%9D%E6%A1%86/</url>
    
    <content type="html"><![CDATA[<h5 id="标准对话框">标准对话框</h5><ul><li><p>1颜色对话框</p><ul><li>```c++ #include <QColorDialog> QColor color =QColorDialog::getColor(...); <div class="code-wrapper"><pre><code class="hljs dts">- <span class="hljs-number">2</span>文件对话框  - ```c++    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QFileDialog&gt;</span></span>    QString fileN<span class="hljs-attr">ame</span> <span class="hljs-operator">=</span> QFileDialog::getOpenFileName(...)<span class="hljs-punctuation">;</span>    QString fileSaveN<span class="hljs-attr">ame</span> <span class="hljs-operator">=</span> QFileDialog::getSaveFileName(...)<span class="hljs-punctuation">;</span>    QStringList <span class="hljs-attr">list</span> <span class="hljs-operator">=</span> QFileDialog::getOpenFileNames(...)<span class="hljs-punctuation">;</span></code></pre></div></li></ul></li><li><p>3字体对话框</p><ul><li>```c++ #include <QFontDialog> QFont font = QFontDialog::getFont(bool<em>ok, QWidget </em>parent = nullptr); <div class="code-wrapper"><pre><code class="hljs dts">- <span class="hljs-number">4</span>输入对话框  - ```c++    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QInputDialog&gt;</span></span>    QString inputT<span class="hljs-attr">ext</span> <span class="hljs-operator">=</span> QInputDialot::getText(...)<span class="hljs-punctuation">;</span>    int inputN<span class="hljs-attr">um</span> <span class="hljs-operator">=</span> QInputDialot::getInt(...)<span class="hljs-punctuation">;</span>    double inputD<span class="hljs-attr">ouble</span> <span class="hljs-operator">=</span> QInputDialot::getDouble(...)<span class="hljs-punctuation">;</span>    QString inputI<span class="hljs-attr">tem</span> <span class="hljs-operator">=</span> QInputDialot::getItem(...)<span class="hljs-punctuation">;</span></code></pre></div></li></ul></li><li><p>5消息对话框</p><ul><li>```c++ #include <QMessageBox> QMessageBox::information(...);QMessageBox::question(...); QMessageBox::warning(...);QMessageBox::critical(...); QMessageBox::about(this, "title", "<h2>Spreadsheet1.1</h2>" "<p>Copyright&amp;copy:2022 SoftwareInc." "<p>Spreadsheet is a small aplication that " "demonstrates QActionQMainWindow, QmenuBar"); <div class="code-wrapper"><pre><code class="hljs arduino">- <span class="hljs-number">6</span>进度条对话框  - ```c++    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QProgressDialog&gt;</span></span>    QProgressDialog *progress = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QProgressDialog</span>(...));    progress-&gt;<span class="hljs-built_in">setWindowModality</span>(Qt::WindowModal);</code></pre></div></li></ul></li><li><p>7向导对话框</p><ul><li>```c++ #include <QWizard> QWizard <em>wizard = new QWizard(this);QWizardPage </em>page1 = new QWizardPage(this);wizard-&gt;addPage(page1); <div class="code-wrapper"><pre><code class="hljs cpp">- <span class="hljs-number">8</span>打印对话框  - ```c++    QT += printsupport    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QPrintDialog&gt;</span></span>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QPrinter&gt;</span></span>    QPrintDialog <span class="hljs-built_in">printDialog</span>(printer, <span class="hljs-keyword">this</span>);</code></pre></div></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之表格控件QTableWidget</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E8%A1%A8%E6%A0%BC%E6%8E%A7%E4%BB%B6QTableWidget/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E8%A1%A8%E6%A0%BC%E6%8E%A7%E4%BB%B6QTableWidget/</url>
    
    <content type="html"><![CDATA[<p>QTableWidget是QT中的表格组件类,一般用来展示多行多列的数据。QTableWidget中的每一个单元格都是一个QTableWidgetItem对象。</p><h3 id="qtablewidgetitem的常用方法">QTableWidgetItem的常用方法</h3><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-title function_">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span>设置单元格中的文本。QIcon <span class="hljs-title function_">icon</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-title function_">setIcon</span><span class="hljs-params">(<span class="hljs-type">const</span> QIcon &amp;icon)</span>给单元格添加图标。QBrush <span class="hljs-title function_">background</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-title function_">setBackground</span><span class="hljs-params">(<span class="hljs-type">const</span> QBrush &amp;brush)</span>设置单元格的背景。QFont <span class="hljs-title function_">font</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   <span class="hljs-title function_">setFont</span><span class="hljs-params">(<span class="hljs-type">const</span> QFont &amp;font)</span>设置单元格中文本的字体。QBrush <span class="hljs-title function_">foreground</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-title function_">setForeground</span><span class="hljs-params">(<span class="hljs-type">const</span> QBrush &amp;brush)</span>设置单元格中字体的颜色。<span class="hljs-type">int</span> <span class="hljs-title function_">textAlignment</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-title function_">setTextAlignment</span><span class="hljs-params">(<span class="hljs-type">int</span> alignment)</span>设置单元格中文本的对齐方式。QString <span class="hljs-title function_">toolTip</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    <span class="hljs-title function_">setToolTip</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;toolTip)</span>给单元格设置提示信息。</code></pre></div><h3 id="qtablewidget控件属性和方法">QTableWidget控件属性和方法</h3><ul><li>构造 QTableWidgetItem</li></ul><div class="code-wrapper"><pre><code class="hljs c">QTableWidgetItem(<span class="hljs-type">const</span> QIcon &amp;icon, <span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">int</span> type = Type)QTableWidgetItem(<span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">int</span> type = Type)</code></pre></div><ul><li>获取和设置单元格是否可编辑</li></ul><div class="code-wrapper"><pre><code class="hljs c">QAbstractItemView::EditTriggers <span class="hljs-title function_">editTriggers</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setEditTriggers</span><span class="hljs-params">(QAbstractItemView::EditTriggers triggers)</span>QAbstractItemView::NoEditTriggers不允许编辑QAbstractItemView::CurrentChanged当前项发生更改才能编辑QAbstractItemView::DoubleClicked被双击时能编辑QAbstractItemView::SelectedClicked当单击已选中的单元格才能编辑QAbstractItemView::EditKeyPressed当在项目上按下编辑键时才能编辑。QAbstractItemView::AnyKeyPressed当在项目上按下任何键时才能编辑QAbstractItemView::AllEditTriggers包含以上所有编辑操作</code></pre></div><ul><li>获取和设置表格选择方式</li></ul><div class="code-wrapper"><pre><code class="hljs c">QAbstractItemView::SelectionBehavior <span class="hljs-title function_">selectionBehavior</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setSelectionBehavior</span><span class="hljs-params">(QAbstractItemView::SelectionBehavior behavior)</span>QAbstractItemView::SelectItems    选中单个单元格QAbstractItemView::SelectRows     选中一行QAbstractItemView::SelectColumns  选中一列</code></pre></div><ul><li>获取和设置表格选择模式</li></ul><div class="code-wrapper"><pre><code class="hljs c">QAbstractItemView::SelectionMode <span class="hljs-title function_">selectionMode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setSelectionMode</span><span class="hljs-params">(QAbstractItemView::SelectionMode mode)</span>QAbstractItemView::NoSelection  不可选择QAbstractItemView::SingleSelection  单行选择QAbstractItemView::MultiSelection 多行选择QAbstractItemView::ExtendedSelection 扩展选择，按shift键或ctrl键可以选中多行QAbstractItemView::ContiguousSelection  相邻选择，按shift键选中一个范围内的行</code></pre></div><ul><li>获取和设置指定行列位置的单元格</li></ul><div class="code-wrapper"><pre><code class="hljs c">QTableWidgetItem *<span class="hljs-title function_">item</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setItem</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column, QTableWidgetItem *item)</span></code></pre></div><ul><li>获取和设置行列数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rowCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setRowCount</span><span class="hljs-params">(<span class="hljs-type">int</span> rows)</span><span class="hljs-type">int</span> <span class="hljs-title function_">columnCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setColumnCount</span><span class="hljs-params">(<span class="hljs-type">int</span> columns)</span><span class="hljs-type">int</span> <span class="hljs-title function_">currentRow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">currentColumn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">insertRow</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">insertColumn</span><span class="hljs-params">(<span class="hljs-type">int</span> column)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">removeRow</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">removeColumn</span><span class="hljs-params">(<span class="hljs-type">int</span> column)</span>;</code></pre></div><ul><li>设置行、列头标签</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">setHorizontalHeaderLabels</span><span class="hljs-params">(<span class="hljs-type">const</span> QStringList &amp;labels)</span><span class="hljs-type">void</span> <span class="hljs-title function_">setVerticalHeaderLabels</span><span class="hljs-params">(<span class="hljs-type">const</span> QStringList &amp;labels)</span></code></pre></div><ul><li>设置列宽度</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">QHeaderView::setSectionResizeMode</span><span class="hljs-params">(QHeaderView::ResizeMode mode)</span>    HeaderView::Interactive  用户可拖动改变列宽QHeaderView::Fixed  固定列宽QHeaderView::Stretch 自适应列宽大小QHeaderView::ResizeToContents  根据内容设置列宽</code></pre></div><h3 id="信号与槽">信号与槽</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cellClicked</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span><span class="hljs-type">void</span> <span class="hljs-title function_">cellDoubleClicked</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemClicked</span><span class="hljs-params">(QTableWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemDoubleClicked</span><span class="hljs-params">(QTableWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">clearContents</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertColumn</span><span class="hljs-params">(<span class="hljs-type">int</span> column)</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertRow</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span><span class="hljs-type">void</span> <span class="hljs-title function_">removeColumn</span><span class="hljs-params">(<span class="hljs-type">int</span> column)</span><span class="hljs-type">void</span> <span class="hljs-title function_">removeRow</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span><span class="hljs-type">void</span> <span class="hljs-title function_">scrollToItem</span><span class="hljs-params">(<span class="hljs-type">const</span> QTableWidgetItem *item, QAbstractItemView::ScrollHint hint = EnsureVisible)</span></code></pre></div><h3 id="实例">实例</h3><p>新建工程，进入UI设计界面，进行如下设计：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230703221825023.png"alt="image-20230703221825023" /><figcaption aria-hidden="true">image-20230703221825023</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 首先需要设置行列数 */</span>    ui-&gt;tableWidget-&gt;setColumnCount(<span class="hljs-number">4</span>);    ui-&gt;tableWidget-&gt;setRowCount(<span class="hljs-number">1</span>);    <span class="hljs-comment">/* 添加行标签 */</span>    QStringList horizontalHeaderLabel;    horizontalHeaderLabel &lt;&lt; <span class="hljs-string">&quot;姓名&quot;</span> &lt;&lt; <span class="hljs-string">&quot;性别&quot;</span> &lt;&lt; <span class="hljs-string">&quot;年龄&quot;</span> &lt;&lt; <span class="hljs-string">&quot;籍贯&quot;</span>;    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(horizontalHeaderLabel);    <span class="hljs-comment">/* 添加初始化数据 */</span>    QTableWidgetItem *nameItem = new QTableWidgetItem(<span class="hljs-string">&quot;李彤&quot;</span>);    QTableWidgetItem *genderItem = new QTableWidgetItem(<span class="hljs-string">&quot;女&quot;</span>);    QTableWidgetItem *ageItem = new QTableWidgetItem(QString::number(<span class="hljs-number">20</span>));    QTableWidgetItem *provinceItem = new QTableWidgetItem(<span class="hljs-string">&quot;上海&quot;</span>);    ui-&gt;tableWidget-&gt;setItem(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,nameItem);    ui-&gt;tableWidget-&gt;setItem(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,genderItem);    ui-&gt;tableWidget-&gt;setItem(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,ageItem);    ui-&gt;tableWidget-&gt;setItem(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,provinceItem);    <span class="hljs-comment">/* 调节行高和列宽 */</span><span class="hljs-comment">//    ui-&gt;tableWidget-&gt;resizeRowsToContents();</span><span class="hljs-comment">//    ui-&gt;tableWidget-&gt;resizeColumnsToContents();</span>    ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setSectionResizeMode(QHeaderView::ResizeToContents);    ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setSectionResizeMode(QHeaderView::Interactive);    <span class="hljs-comment">/* 行列表头标签设置 */</span>    connect(ui-&gt;chekBox_row, &amp;QCheckBox::stateChanged, this, [=](<span class="hljs-type">int</span> state)&#123;        state = ui-&gt;chekBox_row-&gt;checkState(); <span class="hljs-comment">//获得当前checkBox状态</span>        <span class="hljs-keyword">if</span>(state == Qt::Unchecked)        &#123;            ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;hide();        &#125;        <span class="hljs-keyword">if</span>(state == Qt::Checked)        &#123;            ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;show();        &#125;    &#125;);    connect(ui-&gt;chekBox_column, &amp;QCheckBox::stateChanged, this, [=](<span class="hljs-type">int</span> state)&#123;        state = ui-&gt;chekBox_column-&gt;checkState();        <span class="hljs-keyword">if</span>(state == Qt::Unchecked)        &#123;            ui-&gt;tableWidget-&gt;verticalHeader()-&gt;hide();        &#125;        <span class="hljs-keyword">if</span>(state == Qt::Checked)        &#123;            ui-&gt;tableWidget-&gt;verticalHeader()-&gt;show();        &#125;    &#125;);    <span class="hljs-comment">/* 设置表格可编辑 */</span>    connect(ui-&gt;chekBox_editable, &amp;QCheckBox::stateChanged, this, [=](<span class="hljs-type">int</span> state)&#123;        state = ui-&gt;chekBox_editable-&gt;checkState();        <span class="hljs-keyword">if</span>(state == Qt::Unchecked)        &#123;            ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);        &#125;        <span class="hljs-keyword">if</span>(state == Qt::Checked)        &#123;            ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::DoubleClicked | QAbstractItemView::EditKeyPressed);        &#125;    &#125;);    <span class="hljs-comment">/* 交替显示背景 */</span>    connect(ui-&gt;chekBox_color, &amp;QCheckBox::stateChanged, this, [=](<span class="hljs-type">int</span> state)&#123;        state = ui-&gt;chekBox_color-&gt;checkState();        <span class="hljs-keyword">if</span>(state == Qt::Unchecked)        &#123;            ui-&gt;tableWidget-&gt;setAlternatingRowColors(<span class="hljs-literal">false</span>);        &#125;        <span class="hljs-keyword">if</span>(state == Qt::Checked)        &#123;            ui-&gt;tableWidget-&gt;setAlternatingRowColors(<span class="hljs-literal">true</span>);        &#125;    &#125;);    <span class="hljs-comment">/* 选择方式 */</span>    connect(ui-&gt;radioBtn_cell, &amp;QRadioButton::clicked, this, [=]()&#123;        <span class="hljs-keyword">if</span>(ui-&gt;radioBtn_cell-&gt;isChecked())        &#123;            ui-&gt;tableWidget-&gt;setSelectionBehavior(QAbstractItemView::SelectItems);        &#125;    &#125;);    connect(ui-&gt;radioBtn_row, &amp;QRadioButton::clicked, this, [=]()&#123;        <span class="hljs-keyword">if</span>(ui-&gt;radioBtn_row-&gt;isChecked())        &#123;            ui-&gt;tableWidget-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);        &#125;    &#125;);    connect(ui-&gt;radioBtn_column, &amp;QRadioButton::clicked, this, [=]()&#123;        <span class="hljs-keyword">if</span>(ui-&gt;radioBtn_column-&gt;isChecked())        &#123;            ui-&gt;tableWidget-&gt;setSelectionBehavior(QAbstractItemView::SelectColumns);        &#125;    &#125;);    <span class="hljs-comment">/* 添加一行 */</span>    connect(ui-&gt;btn_addRow, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> rows = ui-&gt;tableWidget-&gt;rowCount();        ui-&gt;tableWidget-&gt;setRowCount(rows + <span class="hljs-number">1</span>);    &#125;);    <span class="hljs-comment">/* 添加一列 */</span>    connect(ui-&gt;btn_addColumn, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> columns = ui-&gt;tableWidget-&gt;columnCount();        ui-&gt;tableWidget-&gt;setColumnCount(columns + <span class="hljs-number">1</span>);    &#125;);    <span class="hljs-comment">/* 插入一行 */</span>    connect(ui-&gt;btn_insertRow, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> currentRow = ui-&gt;tableWidget-&gt;currentRow();        ui-&gt;tableWidget-&gt;insertRow(currentRow);    &#125;);    <span class="hljs-comment">/* 插入一列 */</span>    connect(ui-&gt;btn_insertColumn, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> currentColumn = ui-&gt;tableWidget-&gt;currentColumn();        ui-&gt;tableWidget-&gt;insertColumn(currentColumn);    &#125;);    <span class="hljs-comment">/* 删除一行 */</span>    connect(ui-&gt;btn_deleteRow, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> currentRow = ui-&gt;tableWidget-&gt;currentRow();        ui-&gt;tableWidget-&gt;removeRow(currentRow);    &#125;);    <span class="hljs-comment">/* 删除一列 */</span>    connect(ui-&gt;btn_deleteColumn, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> currentColumn = ui-&gt;tableWidget-&gt;currentColumn();        ui-&gt;tableWidget-&gt;removeColumn(currentColumn);    &#125;);    <span class="hljs-comment">/* 清空表格内容 */</span>    connect(ui-&gt;btn_clearContens, &amp;QPushButton::clicked, this, [=]()&#123;        ui-&gt;tableWidget-&gt;clearContents();    &#125;);    <span class="hljs-comment">/* 清空表格 */</span>    connect(ui-&gt;btn_deleteAll, &amp;QPushButton::clicked, this, [=]()&#123;        ui-&gt;tableWidget-&gt;clear();    &#125;);&#125;</code></pre></div><p>效果:</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230703221332574.png" alt="image-20230703221332574" style="zoom: 80%;" /></p><p>工程文件：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/tableWidget.zip">tableWidget</a></p><p>参考链接：</p><p>http://t.csdn.cn/pwGUJ</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之列表框QListWidget</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%88%97%E8%A1%A8%E6%A1%86QListWidget/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%88%97%E8%A1%A8%E6%A1%86QListWidget/</url>
    
    <content type="html"><![CDATA[<p>QListWidget用于显示结构简单的列表，相对于父类<strong>QListView</strong>，它是“简易版”的QListView，创建和使用列表的方式更简单、门槛更低。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702185955407.png" alt="image-20230702185955407" style="zoom:67%;" /></p><p>QListWidget 类的继承关系如下：</p><p><code>QListWidget -&gt; QListView -&gt; QAbstractItemView -&gt; QAbstractScrollArea -&gt; QFrame -&gt; QWidget</code></p><h3 id="属性和方法">属性和方法</h3><ul><li>获取和设置显示模式（可以在属性窗口设置，也可以用以下代码实现）</li></ul><div class="code-wrapper"><pre><code class="hljs c">QListView::ViewMode <span class="hljs-title function_">viewMode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setViewMode</span><span class="hljs-params">(QListView::ViewMode mode)</span>QListView::ListMode  <span class="hljs-comment">//列表模式</span>QListView::IconMode  <span class="hljs-comment">//图标模式</span></code></pre></div><ul><li>添加条目</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">addItem</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;label)</span><span class="hljs-type">void</span> <span class="hljs-title function_">addItem</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">addItems</span><span class="hljs-params">(<span class="hljs-type">const</span> QStringList &amp;labels)</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">insertItem</span><span class="hljs-params">(<span class="hljs-type">int</span> row, QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertItem</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">const</span> QString &amp;label)</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertItems</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">const</span> QStringList &amp;labels)</span></code></pre></div><ul><li>删除条目</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 方法一 */</span>QListWidgetItem* item = ui-&gt;lwProvince-&gt;currentItem();ui-&gt;lwProvince-&gt;removeItemWidget(item);delete item;<span class="hljs-comment">/* 方法二 */</span><span class="hljs-type">int</span> row = ui-&gt;lwProvince-&gt;currentRow();QListWidgetItem* item = ui-&gt;lwProvince-&gt;takeItem(row);delete item;<span class="hljs-type">void</span> <span class="hljs-title function_">QListWidget::clear</span><span class="hljs-params">()</span><span class="hljs-comment">// 清空整个列表</span></code></pre></div><ul><li>信号</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">currentItemChanged</span><span class="hljs-params">(QListWidgetItem *current, QListWidgetItem *previous)</span><span class="hljs-type">void</span> <span class="hljs-title function_">currentRowChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> currentRow)</span><span class="hljs-type">void</span> <span class="hljs-title function_">currentTextChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;currentText)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemActivated</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemChanged</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemClicked</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemDoubleClicked</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemEntered</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemPressed</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemSelectionChanged</span><span class="hljs-params">()</span></code></pre></div><h3 id="实例">实例</h3><p>新建工程，进入UI设计界面，设计如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702195728641.png"alt="image-20230702195728641" /><figcaption aria-hidden="true">image-20230702195728641</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 默认选中列表 */</span>    ui-&gt;radioButton_list-&gt;setChecked(<span class="hljs-literal">true</span>);    ui-&gt;listWidget-&gt;setViewMode(QListView::ListMode);    <span class="hljs-comment">/* radioBtn与listWidget对应 */</span>    connect(ui-&gt;radioButton_list, &amp;QRadioButton::clicked, this, [=]()&#123;       ui-&gt;listWidget-&gt;setViewMode(QListView::ListMode);<span class="hljs-comment">//列表模式</span>    &#125;);    connect(ui-&gt;radioButton_icon, &amp;QRadioButton::clicked, this, [=]()&#123;        ui-&gt;listWidget-&gt;setViewMode(QListView::IconMode);<span class="hljs-comment">//图标模式</span>    &#125;);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_add_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> iconIndex = QRandomGenerator::global()-&gt;bounded(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">//产生随机数1~5</span>    QString fileName = <span class="hljs-string">&quot;:/pic/city&quot;</span> + QString::number(iconIndex) + <span class="hljs-string">&quot;.png&quot;</span>;    QIcon <span class="hljs-title function_">icon</span><span class="hljs-params">(fileName)</span>;    QString str = ui-&gt;lineEdit-&gt;text();    QListWidgetItem *item = new QListWidgetItem(icon, str);    ui-&gt;listWidget-&gt;addItem(item);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_insert_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> iconIndex = QRandomGenerator::global()-&gt;bounded(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">//产生随机数1~5</span>    QString fileName = <span class="hljs-string">&quot;:/pic/city&quot;</span> + QString::number(iconIndex) + <span class="hljs-string">&quot;.png&quot;</span>;    QIcon <span class="hljs-title function_">icon</span><span class="hljs-params">(fileName)</span>;    QString str = ui-&gt;lineEdit-&gt;text();    <span class="hljs-type">int</span> row = ui-&gt;listWidget-&gt;currentRow();    QListWidgetItem *item = new QListWidgetItem(icon, str);    ui-&gt;listWidget-&gt;insertItem(row, item);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_del_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 方法一 */</span>    QListWidgetItem *item = ui-&gt;listWidget-&gt;currentItem();    ui-&gt;listWidget-&gt;removeItemWidget(item);    delete item;    <span class="hljs-comment">/* 方法二 */</span><span class="hljs-comment">//    int row = ui-&gt;listWidget-&gt;currentRow();</span><span class="hljs-comment">//    QListWidgetItem *item = ui-&gt;listWidget-&gt;takeItem(row);</span><span class="hljs-comment">//    delete item;</span>&#125;</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702212610974.png" alt="image-20230702212610974" style="zoom:67%;" /></p><p>工程代码：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/listWidget.zip">listWidget</a></p><p>参考链接：</p><p>http://t.csdn.cn/QPdEH</p><p>http://t.csdn.cn/O8I4u</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之进度条QProgressBar</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E8%BF%9B%E5%BA%A6%E6%9D%A1QProgressBar/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E8%BF%9B%E5%BA%A6%E6%9D%A1QProgressBar/</url>
    
    <content type="html"><![CDATA[<p><strong>QProgressBar</strong>是一种横向或者纵向显示进度的控件，用来描述任务的完成情况。QProgressBar继承于QWidget。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702155213581.png" alt="image-20230702155213581" style="zoom:67%;" /></p><h3 id="主要属性和方法">主要属性和方法</h3><ul><li>获取和设置当前值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;ui-&gt;progressBar-&gt;setValue(<span class="hljs-number">30</span>);  <span class="hljs-comment">//设置当前显示值</span></code></pre></div><ul><li>获取和设置最大、最小值。如果最小值和最大值都设置为0，进度条会显示了一个繁忙指示，而不会显示当前的值。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maximum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setMaximum</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">minimum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;ui-&gt;progressBar-&gt;setMinimum(<span class="hljs-number">0</span>);  <span class="hljs-comment">//设置最小值</span>ui-&gt;progressBar-&gt;setMaximum(<span class="hljs-number">100</span>);  <span class="hljs-comment">//设置最大值</span></code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702155419973.png" alt="image-20230702155419973" style="zoom:67%;" /></p><ul><li>获取和设置滑动条的方向</li></ul><div class="code-wrapper"><pre><code class="hljs c">Qt::Orientation <span class="hljs-title function_">orientation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setOrientation</span><span class="hljs-params">(Qt::Orientation)</span>ui-&gt;progressBar-&gt;<span class="hljs-title function_">setOrientation</span><span class="hljs-params">(Qt::Horizontal)</span>;  <span class="hljs-comment">//设置显示方向</span></code></pre></div><ul><li>获取和设置进度条的文本是否显示</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isTextVisible</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setTextVisible</span><span class="hljs-params">(<span class="hljs-type">bool</span> visible)</span>ui-&gt;progressBar-&gt;<span class="hljs-title function_">setTextVisible</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>;  <span class="hljs-comment">//设置文字可见</span></code></pre></div><ul><li>获取和设置显示文字的格式，“%p%”显示百分比，“%v”显示当前值，“%m”显示总步数。缺省为“%p%”</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">format</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;format)</span>ui-&gt;progressBar-&gt;<span class="hljs-title function_">setFormat</span><span class="hljs-params">(<span class="hljs-string">&quot;%p%&quot;</span>)</span>;  <span class="hljs-comment">//设置文字显示格式</span></code></pre></div><h3 id="信号">信号</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">valueChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></code></pre></div><h3 id="实例">实例</h3><p>创建新工程，在UI设计界面，拖拽相应控件，修改控件名字，完成布局。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702154508118.png"alt="image-20230702154508118" /><figcaption aria-hidden="true">image-20230702154508118</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 通过代码设置属性 */</span>    ui-&gt;progBar_download-&gt;setRange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);    ui-&gt;progBar_download-&gt;setValue(<span class="hljs-number">0</span>); <span class="hljs-comment">//初始值为0</span>    ui-&gt;label_download-&gt;setText(<span class="hljs-string">&quot;&quot;</span>);    ui-&gt;label_copy-&gt;setText(<span class="hljs-string">&quot;&quot;</span>);    <span class="hljs-comment">/* 创建download定时器，并设置时间间隔50ms */</span>    m_timer_download = new QTimer();    m_timer_download-&gt;setInterval(<span class="hljs-number">50</span>);    <span class="hljs-comment">/* 创建copy定时器，并设置时间间隔5ms */</span>    m_timer_copy = new QTimer();    m_timer_copy-&gt;setInterval(<span class="hljs-number">5</span>);    <span class="hljs-comment">/* 点击下载按钮开启计时 */</span>    connect(ui-&gt;btn_download, &amp;QPushButton::clicked, this, [=]()&#123;        ui-&gt;progBar_download-&gt;reset(); <span class="hljs-comment">//便于重新开起下载</span>        m_timer_download-&gt;start();        ui-&gt;label_download-&gt;setText(<span class="hljs-string">&quot;下载中...&quot;</span>);    &#125;);    <span class="hljs-comment">/* 定时时间间隔到，执行槽函数 */</span>    connect(m_timer_download, &amp;QTimer::timeout, this, &amp;Widget::timer1_timeout_slot);    <span class="hljs-comment">/* 点击拷贝按钮开启计时 */</span>    connect(ui-&gt;btn_copy, &amp;QPushButton::clicked, this, [=]()&#123;        ui-&gt;progBar_copy-&gt;reset(); <span class="hljs-comment">//便于重新开起拷贝</span>        m_timer_copy-&gt;start();        ui-&gt;label_copy-&gt;setText(<span class="hljs-string">&quot;拷贝中...&quot;</span>);    &#125;);    <span class="hljs-comment">/* 定时时间间隔到，执行槽函数 */</span>    connect(m_timer_copy, &amp;QTimer::timeout, this, &amp;Widget::timer2_timeout_slot);&#125;Widget::~Widget()&#123;    delete ui;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::timer1_timeout_slot</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">if</span>(ui-&gt;progBar_download-&gt;value() == ui-&gt;progBar_download-&gt;maximum())    &#123;        this-&gt;m_timer_download-&gt;stop();<span class="hljs-comment">//下载完成，停止计时</span>        ui-&gt;label_download-&gt;setText(<span class="hljs-string">&quot;下载完成!&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;progBar_download-&gt;setValue(ui-&gt;progBar_download-&gt;value() + <span class="hljs-number">1</span>);<span class="hljs-comment">//每隔50ms值加1</span>    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::timer2_timeout_slot</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">if</span>(ui-&gt;progBar_copy-&gt;value() == ui-&gt;progBar_copy-&gt;maximum())    &#123;        this-&gt;m_timer_copy-&gt;stop();        ui-&gt;label_copy-&gt;setText(<span class="hljs-string">&quot;拷贝完成!&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;progBar_copy-&gt;setValue(ui-&gt;progBar_copy-&gt;value() + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre></div><p>效果如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702154802368.png" alt="image-20230702154802368" style="zoom:67%;" /></p><p>工程文件：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/progressBar.zip">progressBar</a></p><p>参考链接：</p><p>http://t.csdn.cn/sxHV9</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之微调框QSpinBox</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%BE%AE%E8%B0%83%E6%A1%86QSpinBox/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%BE%AE%E8%B0%83%E6%A1%86QSpinBox/</url>
    
    <content type="html"><![CDATA[<p>QSpinBox用于整数的显示和输入，QDoubleSpinBox则用于显示和输入浮点值。它们均派生自QAbstractSPinBox类，具有大多数相同的属性，只是参数类型不同（一个<code>int</code>，一个<code>double</code>）。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702162506764.png" alt="image-20230702162506764" style="zoom:67%;" /></p><p>修改微调框数值的方式包括：</p><ul><li>单击右侧的向上/向下按钮</li><li>按键盘的向上/向下键</li><li>在微调框获取焦点时，通过鼠标滚轮的上下滚动</li></ul><h3 id="属性和方法">属性和方法</h3><ul><li>获取和设置当前值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></code></pre></div><ul><li>获取和设置最大、最小值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maximum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setMaximum</span><span class="hljs-params">(<span class="hljs-type">int</span> max)</span><span class="hljs-type">int</span> <span class="hljs-title function_">minimum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span> min)</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">setRange</span><span class="hljs-params">(<span class="hljs-type">int</span> minimum, <span class="hljs-type">int</span> maximum)</span></code></pre></div><ul><li>获取和设置步长</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">singleStep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setSingleStep</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></code></pre></div><ul><li>获取和设置变化值是否循环改变</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">wrapping</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setWrapping</span><span class="hljs-params">(<span class="hljs-type">bool</span> w)</span></code></pre></div><ul><li>获取和设置是否加速数值变化速度</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isAccelerated</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setAccelerated</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></code></pre></div><ul><li>获取和设置前缀和后缀</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">prefix</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setPrefix</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;prefix)</span>QString <span class="hljs-title function_">suffix</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setSuffix</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;suffix)</span></code></pre></div><ul><li>信号</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">textChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span><span class="hljs-type">void</span> <span class="hljs-title function_">valueChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-type">void</span> <span class="hljs-title function_">valueChanged</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span></code></pre></div><h3 id="实例">实例</h3><p>创建工程，进入UI设计界面，设计如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702170608521.png"alt="image-20230702170608521" /><figcaption aria-hidden="true">image-20230702170608521</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 设置SpinBox初始属性 */</span>    ui-&gt;spinBox_weight-&gt;setSuffix(<span class="hljs-string">&quot;kg&quot;</span>); <span class="hljs-comment">//后缀</span>    ui-&gt;spinBox_weight-&gt;setRange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">//范围0~100</span>    ui-&gt;spinBox_weight-&gt;setSingleStep(<span class="hljs-number">1</span>); <span class="hljs-comment">//步长为1</span>    ui-&gt;spinBox_weight-&gt;setAccelerated(<span class="hljs-literal">true</span>); <span class="hljs-comment">//允许加速</span>    ui-&gt;spinBox_weight-&gt;setWrapping(<span class="hljs-literal">true</span>); <span class="hljs-comment">//允许循环</span>    connect(ui-&gt;doubleSpinBox_price, SIGNAL(valueChanged(<span class="hljs-type">double</span>)), this, SLOT(price_value_slot(<span class="hljs-type">double</span>)));    connect(ui-&gt;spinBox_weight, SIGNAL(valueChanged(<span class="hljs-type">int</span>)), this, SLOT(weight_value_slot(<span class="hljs-type">int</span>)));&#125;Widget::~Widget()&#123;    delete ui;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::price_value_slot</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span>&#123;    <span class="hljs-type">double</span> total = ui-&gt;spinBox_weight-&gt;value() * price;    ui-&gt;lineEdit_total-&gt;setText(QString::number(total) + <span class="hljs-string">&quot;元&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::weight_value_slot</span><span class="hljs-params">(<span class="hljs-type">int</span> weight)</span>&#123;    <span class="hljs-type">double</span> total = ui-&gt;doubleSpinBox_price-&gt;value() * weight;    ui-&gt;lineEdit_total-&gt;setText(QString::number(total) + <span class="hljs-string">&quot;元&quot;</span>);&#125;</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702173148063.png" alt="image-20230702173148063" style="zoom:67%;" /></p><p>工程代码：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/spinBox.zip">spinBox</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之滑动条QSlider</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%BB%91%E5%8A%A8%E6%9D%A1QSlider/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%BB%91%E5%8A%A8%E6%9D%A1QSlider/</url>
    
    <content type="html"><![CDATA[<p>QSlider是滑动条控件，滑动条可以在一个范围内拖动，并将其位置转换为整数。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702175627021.png" alt="image-20230702175627021" style="zoom:67%;" /></p><h3 id="属性和方法">属性和方法</h3><p>QSlider 绝大多数属性和方法都是从 <strong>QAbstractSlider</strong>继承而来。</p><ul><li>获取和设置当前值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;</code></pre></div><ul><li>获取和设置最大、最小值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maximum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setMaximum</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">minimum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setRange</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)</span></code></pre></div><ul><li>获取和设置滑动条的方向</li></ul><div class="code-wrapper"><pre><code class="hljs c">Qt::Orientation <span class="hljs-title function_">orientation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setOrientation</span><span class="hljs-params">(Qt::Orientation)</span>;</code></pre></div><ul><li>获取和设置步长</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 键盘的左右箭头 */</span><span class="hljs-type">int</span> <span class="hljs-title function_">singleStep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setSingleStep</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">/* 键盘的PageUp PageDown */</span><span class="hljs-type">int</span> <span class="hljs-title function_">pageStep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setPageStep</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;</code></pre></div><ul><li>获取和设置刻度位置</li></ul><div class="code-wrapper"><pre><code class="hljs c">QSlider::TickPosition <span class="hljs-title function_">tickPosition</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setTickPosition</span><span class="hljs-params">(QSlider::TickPosition position)</span>    QSlider::NoTicks            <span class="hljs-comment">//不显示刻度</span>QSlider::TicksBothSides     <span class="hljs-comment">//标尺两侧都显示刻度</span>QSlider::TicksAbove         <span class="hljs-comment">//标尺上方显示刻度</span>QSlider::TicksBelow         <span class="hljs-comment">//标尺下方显示刻度</span>QSlider::TicksLeft          <span class="hljs-comment">//标尺左侧显示刻度</span>QSlider::TicksRight         <span class="hljs-comment">//标尺右侧显示刻度    </span></code></pre></div><ul><li>信号</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">valueChanged</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">sliderPressed</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">sliderMoved</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">sliderReleased</span><span class="hljs-params">()</span></code></pre></div><h3 id="实例">实例</h3><p>新建工程，进入UI设计界面，设计如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702182410401.png"alt="image-20230702182410401" /><figcaption aria-hidden="true">image-20230702182410401</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 横向滑动条属性在UI界面已经设置，下面进行竖向滑动条属性设置 */</span>ui-&gt;slider_v-&gt;setRange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);ui-&gt;slider_v-&gt;setSingleStep(<span class="hljs-number">1</span>);ui-&gt;slider_v-&gt;setPageStep(<span class="hljs-number">10</span>);ui-&gt;slider_v-&gt;setTickPosition(QSlider::TicksRight);ui-&gt;slider_v-&gt;setTickInterval(<span class="hljs-number">5</span>);<span class="hljs-comment">/* 数值改变将值显示在文本框中 */</span>connect(ui-&gt;slider_h, &amp;QSlider::valueChanged, this, [=]()&#123;    <span class="hljs-type">int</span> value = ui-&gt;slider_h-&gt;value();    ui-&gt;lineEdit_value-&gt;setText(QString::number(value));&#125;);connect(ui-&gt;slider_v, &amp;QSlider::valueChanged, this, [=]()&#123;    <span class="hljs-type">int</span> value = ui-&gt;slider_v-&gt;value();    ui-&gt;lineEdit_value-&gt;setText(QString::number(value));&#125;);</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702183709747.png" alt="image-20230702183709747" style="zoom:67%;" /></p><p>工程代码：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/slider.zip">slider</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之组合框QComboBox</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%BB%84%E5%90%88%E6%A1%86QComboBox/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%BB%84%E5%90%88%E6%A1%86QComboBox/</url>
    
    <content type="html"><![CDATA[<p>Qt中组合框（QComboBox）提供了一种占用空间最小的方式，其表现形式如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701112012020.png" alt="image-20230701112012020" style="zoom:67%;" /></p><h3 id="属性">属性</h3><ul><li><code>count: const int</code> --&gt;组合框中的项目数</li><li><code>currentData : const QVariant</code> --&gt;当前项目的数据</li><li><code>currentIndex : int</code> --&gt;组合框中当前项目的索引</li><li><code>currentText : QString</code> --&gt;当前文本</li><li><code>insertPolicy : InsertPolicy</code>--&gt;插入的项目在组合框中的位置策略</li><li><code>maxCount : int</code> --&gt;组合框中允许的最大项目数</li><li><code>minimumContentsLength : int</code>--&gt;组合框的最小字符数</li><li><code>modelColumn : int</code> --&gt;模型中可见的列</li><li><code>sizeAdjustPolicy : SizeAdjustPolicy</code>--&gt;组合框大小的更改策略</li></ul><h3 id="信号">信号</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">activated</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>  <span class="hljs-comment">//当选择组合框中的项目时发送此信号。</span><span class="hljs-type">void</span> <span class="hljs-title function_">currentIndexChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>  <span class="hljs-comment">//当组合框中的 currentIndex更改时，就会发送此信号。如果组合框变空则index为 -1。 </span><span class="hljs-type">void</span> <span class="hljs-title function_">currentTextChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span>  <span class="hljs-comment">//当组合框中的项目更改时，就会发送此信号。</span><span class="hljs-type">void</span> <span class="hljs-title function_">editTextChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span> <span class="hljs-comment">//当组合框的行编辑小部件中的文本发生更改时，会发出此信号。</span></code></pre></div><h3 id="槽函数与成员函数">槽函数与成员函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>  <span class="hljs-comment">//清除组合框，删除所有项目。</span><span class="hljs-type">void</span> <span class="hljs-title function_">clearEditText</span><span class="hljs-params">()</span>  <span class="hljs-comment">//清除组合框中用于编辑的行编辑的内容。</span><span class="hljs-type">void</span> <span class="hljs-title function_">setCurrentIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>  <span class="hljs-comment">//设置当前项目索引</span><span class="hljs-type">void</span> <span class="hljs-title function_">setCurrentText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span> <span class="hljs-comment">//设置当前项目文字</span><span class="hljs-type">void</span> <span class="hljs-title function_">setEditText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span>  <span class="hljs-comment">//设置项目编辑的文字</span><span class="hljs-comment">/* 添加项目和删除项目及获取或设置项目 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">addItem</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">const</span> QVariant &amp;userData = QVariant())</span><span class="hljs-type">void</span> <span class="hljs-title function_">addItem</span><span class="hljs-params">(<span class="hljs-type">const</span> QIcon &amp;icon, <span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">const</span> QVariant &amp;userData = QVariant())</span><span class="hljs-type">void</span> <span class="hljs-title function_">addItems</span><span class="hljs-params">(<span class="hljs-type">const</span> QStringList &amp;texts)</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">insertItem</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">const</span> QVariant &amp;userData = QVariant())</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertItem</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> QIcon &amp;icon, <span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">const</span> QVariant &amp;userData = QVariant())</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertItems</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> QStringList &amp;<span class="hljs-built_in">list</span>)</span><span class="hljs-type">void</span> <span class="hljs-title function_">removeItem</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><span class="hljs-type">void</span> <span class="hljs-title function_">setInsertPolicy</span><span class="hljs-params">(QComboBox::InsertPolicy policy)</span> <span class="hljs-comment">//设置插入策略</span><span class="hljs-type">int</span> <span class="hljs-title function_">currentIndex</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>QString <span class="hljs-title function_">currentText</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">setItemText</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> QString &amp;text)</span></code></pre></div><p>这里主要说一下增加项目的方法，既可以通过以上函数增加，也可以在UI设计界面进行增加</p><ul><li>通过函数</li></ul><div class="code-wrapper"><pre><code class="hljs c">QStringList cityList = &#123;<span class="hljs-string">&quot;广州市&quot;</span>, <span class="hljs-string">&quot;深圳市&quot;</span>, <span class="hljs-string">&quot;珠海市&quot;</span>, <span class="hljs-string">&quot;东莞市&quot;</span>&#125;;<span class="hljs-comment">// 添加城市</span>ui-&gt;comboBox_province-&gt;addItem(<span class="hljs-string">&quot;广东省&quot;</span>);ui-&gt;comboBox_city-&gt;addItems(cityList);</code></pre></div><ul><li>在组合框上右键-&gt;【编辑项目…】，在打开的编辑窗口中可以增加删除条目</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701132003241.png" alt="image-20230701132003241" style="zoom:67%;" /></p><h3 id="案例">案例</h3><p>创建一个基类为QWidget的工程，如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701182531243.png"alt="image-20230701182531243" /><figcaption aria-hidden="true">image-20230701182531243</figcaption></figure><p>下面进行工程实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 创建城市列表 */</span>    gdCityList = QStringList&#123;<span class="hljs-string">&quot;广州市&quot;</span>, <span class="hljs-string">&quot;深圳市&quot;</span>, <span class="hljs-string">&quot;珠海市&quot;</span>&#125;;    hnCityList = QStringList&#123;<span class="hljs-string">&quot;郑州市&quot;</span>, <span class="hljs-string">&quot;洛阳市&quot;</span>, <span class="hljs-string">&quot;信阳市&quot;</span>&#125;;    hbCityList = QStringList&#123;<span class="hljs-string">&quot;武汉市&quot;</span>, <span class="hljs-string">&quot;黄石市&quot;</span>, <span class="hljs-string">&quot;宜昌市&quot;</span>&#125;;    sdCityList = QStringList&#123;<span class="hljs-string">&quot;济南市&quot;</span>, <span class="hljs-string">&quot;青岛市&quot;</span>, <span class="hljs-string">&quot;烟台市&quot;</span>&#125;;    zjCityList = QStringList&#123;<span class="hljs-string">&quot;杭州市&quot;</span>, <span class="hljs-string">&quot;宁波市&quot;</span>, <span class="hljs-string">&quot;温州市&quot;</span>&#125;;    <span class="hljs-comment">/* 创建大学列表 */</span>    gdUniversityList = QStringList&#123;<span class="hljs-string">&quot;中山大学&quot;</span>, <span class="hljs-string">&quot;广州大学&quot;</span>, <span class="hljs-string">&quot;深圳大学&quot;</span>, <span class="hljs-string">&quot;南方科技大学&quot;</span>&#125;;    hnUniversityList = QStringList&#123;<span class="hljs-string">&quot;郑州大学&quot;</span>, <span class="hljs-string">&quot;河南大学&quot;</span>, <span class="hljs-string">&quot;信阳师范大学&quot;</span>, <span class="hljs-string">&quot;河南科技大学&quot;</span>&#125;;    hbUniversityList = QStringList&#123;<span class="hljs-string">&quot;武汉大学&quot;</span>, <span class="hljs-string">&quot;华中科技大学&quot;</span>, <span class="hljs-string">&quot;湖北师范大学&quot;</span>, <span class="hljs-string">&quot;三峡大学&quot;</span>&#125;;    sdUniversityList = QStringList&#123;<span class="hljs-string">&quot;济南大学&quot;</span>, <span class="hljs-string">&quot;青岛大学&quot;</span>, <span class="hljs-string">&quot;青岛理工大学&quot;</span>, <span class="hljs-string">&quot;烟台大学&quot;</span>&#125;;    zjUniversityList = QStringList&#123;<span class="hljs-string">&quot;浙江大学&quot;</span>, <span class="hljs-string">&quot;杭州师范大学&quot;</span>, <span class="hljs-string">&quot;宁波大学&quot;</span>, <span class="hljs-string">&quot;温州大学&quot;</span>&#125;;    <span class="hljs-comment">/* 为comboBox_province添加省份 */</span>    ui-&gt;comboBox_province-&gt;addItem(QIcon(<span class="hljs-string">&quot;:/pic/guangdong.png&quot;</span>), <span class="hljs-string">&quot;广东省&quot;</span>);    ui-&gt;comboBox_province-&gt;addItem(QIcon(<span class="hljs-string">&quot;:/pic/henan.png&quot;</span>), <span class="hljs-string">&quot;河南省&quot;</span>);    ui-&gt;comboBox_province-&gt;addItem(QIcon(<span class="hljs-string">&quot;:/pic/hubei.png&quot;</span>), <span class="hljs-string">&quot;湖北省&quot;</span>);    ui-&gt;comboBox_province-&gt;addItem(QIcon(<span class="hljs-string">&quot;:/pic/shandong.png&quot;</span>), <span class="hljs-string">&quot;山东省&quot;</span>);    ui-&gt;comboBox_province-&gt;addItem(QIcon(<span class="hljs-string">&quot;:/pic/zhejiang.png&quot;</span>), <span class="hljs-string">&quot;浙江省&quot;</span>);    <span class="hljs-comment">/* 为comboBox_city和comboBox_school添加默认城市和学校 */</span>    ui-&gt;comboBox_province-&gt;setCurrentIndex(<span class="hljs-number">0</span>);    ui-&gt;comboBox_city-&gt;addItems(gdCityList);    ui-&gt;comboBox_school-&gt;addItems(gdUniversityList);    <span class="hljs-comment">/* 自定义槽函数，当省份改变，触发槽机制，连接信号与槽 */</span>    connect(ui-&gt;comboBox_province, SIGNAL(currentIndexChanged(<span class="hljs-type">int</span>)), this, SLOT(province_changed_slot(<span class="hljs-type">int</span>)));&#125;<span class="hljs-comment">/* 当省份改变时，城市和学校相应发生变化 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::province_changed_slot</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;    ui-&gt;comboBox_city-&gt;clear();<span class="hljs-comment">//清空之前的项目内容</span>    ui-&gt;comboBox_school-&gt;clear();    <span class="hljs-keyword">switch</span> (index)    &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            ui-&gt;comboBox_city-&gt;addItems(gdCityList);            ui-&gt;comboBox_school-&gt;addItems(gdUniversityList);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            ui-&gt;comboBox_city-&gt;addItems(hnCityList);            ui-&gt;comboBox_school-&gt;addItems(hnUniversityList);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:            ui-&gt;comboBox_city-&gt;addItems(hbCityList);            ui-&gt;comboBox_school-&gt;addItems(hbUniversityList);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:            ui-&gt;comboBox_city-&gt;addItems(sdCityList);            ui-&gt;comboBox_school-&gt;addItems(sdUniversityList);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:            ui-&gt;comboBox_city-&gt;addItems(zjCityList);            ui-&gt;comboBox_school-&gt;addItems(zjUniversityList);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 获取姓名、大学、省份、城市 */</span>    QString name = ui-&gt;comboBox_name-&gt;currentText();    QString province = ui-&gt;comboBox_province-&gt;currentText();    QString city = ui-&gt;comboBox_city-&gt;currentText();    QString university = ui-&gt;comboBox_school-&gt;currentText();    QString info = name + <span class="hljs-string">&quot; 来自于&quot;</span> + province + city + <span class="hljs-string">&quot;的&quot;</span> + university;    QMessageBox::information(this, <span class="hljs-string">&quot;学生信息&quot;</span>, info);&#125;</code></pre></div><p>效果如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701185527403.png" alt="image-20230701185527403" style="zoom:67%;" /></p><p>工程代码：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/comboBox.zip">comboBox</a></p><p>参考链接：</p><p>http://t.csdn.cn/8Aesg</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之单选按钮QradioButton与复选按钮QCheckBox</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AEQradioButton%E4%B8%8E%E5%A4%8D%E9%80%89%E6%8C%89%E9%92%AEQCheckBox/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AEQradioButton%E4%B8%8E%E5%A4%8D%E9%80%89%E6%8C%89%E9%92%AEQCheckBox/</url>
    
    <content type="html"><![CDATA[<p>QRadioButton是单选按钮，常用作表单互斥选择选项，在“多选一”的场景中使用，也就是说在一组单选按钮中，一次只能选中一个单选按钮。如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701191912177.png" alt="image-20230701191912177" style="zoom:67%;" /></p><p>QCheckBox是复选按钮，常用在”多选多“的场景中。如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701194047634.png" alt="image-20230701194047634" style="zoom:80%;" /></p><h3 id="属性和方法">属性和方法</h3><p>QRadioButton和QCheckBox的属性和方法主要继承于父类<strong>QAbstractButton</strong> 。</p><ul><li>获取和设置显示的文本</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span></code></pre></div><ul><li>获取和设置单选按钮的选中状态</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isChecked</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setChecked</span><span class="hljs-params">(<span class="hljs-type">bool</span>)</span></code></pre></div><ul><li>获取和设置自动互斥，单选按钮默认是互斥的，复选按钮默认不是互斥的。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">autoExclusive</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setAutoExclusive</span><span class="hljs-params">(<span class="hljs-type">bool</span>)</span></code></pre></div><p>单选按钮“多选一” 要满足以下两个条件：</p><ol type="1"><li>同一组的单选按钮，在同一个布局中。</li><li>单选按钮的 <code>autoExclusive</code> 属性设置为<code>true</code>，默认是使能的。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701192850832.png" alt="image-20230701192850832" style="zoom:67%;" /></p><ul><li>设置和获取复选按钮的状态</li></ul><div class="code-wrapper"><pre><code class="hljs c">Qt::CheckState <span class="hljs-title function_">checkState</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setCheckState</span><span class="hljs-params">(Qt::CheckState state)</span></code></pre></div><h3 id="信号">信号</h3><p>QRadioButton的信号与槽同样主要继承父类<strong>QAbstractButton</strong> 。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">clicked</span><span class="hljs-params">(<span class="hljs-type">bool</span> checked = <span class="hljs-literal">false</span>)</span><span class="hljs-type">void</span> <span class="hljs-title function_">pressed</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">released</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">toggled</span><span class="hljs-params">(<span class="hljs-type">bool</span> checked)</span> <span class="hljs-comment">//选中与未选中的状态变化</span></code></pre></div><p>QCheckBox的信号：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">stateChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span> <span class="hljs-comment">//选中，未选中，部分选中</span></code></pre></div><p>state的值主要有三种：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701194849109.png" alt="image-20230701194849109" style="zoom:67%;" /></p><h3 id="案例">案例</h3><p>创建一个新工程，在UI设计界面设计如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701211442724.png"alt="image-20230701211442724" /><figcaption aria-hidden="true">image-20230701211442724</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 设置国籍默认选项 */</span>    ui-&gt;radioButton_China-&gt;setChecked(<span class="hljs-literal">true</span>);    <span class="hljs-comment">/* 连接信号与槽 */</span>    connect(ui-&gt;checkBox_clibling, &amp;QCheckBox::clicked, this, &amp;Widget::checkBox_hobby_slot);    connect(ui-&gt;checkBox_playball, &amp;QCheckBox::clicked, this, &amp;Widget::checkBox_hobby_slot);    connect(ui-&gt;checkBox_reading, &amp;QCheckBox::clicked, this, &amp;Widget::checkBox_hobby_slot);    connect(ui-&gt;checkBox_swimming, &amp;QCheckBox::clicked, this, &amp;Widget::checkBox_hobby_slot);    connect(ui-&gt;btn, &amp;QPushButton::clicked,[=]()&#123;        btn_info_slot();    &#125;);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_checkBox_all_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">if</span>(ui-&gt;checkBox_all-&gt;isChecked())    &#123;        ui-&gt;checkBox_clibling-&gt;setChecked(<span class="hljs-literal">true</span>);        ui-&gt;checkBox_playball-&gt;setChecked(<span class="hljs-literal">true</span>);        ui-&gt;checkBox_reading-&gt;setChecked(<span class="hljs-literal">true</span>);        ui-&gt;checkBox_swimming-&gt;setChecked(<span class="hljs-literal">true</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;checkBox_clibling-&gt;setChecked(<span class="hljs-literal">false</span>);        ui-&gt;checkBox_playball-&gt;setChecked(<span class="hljs-literal">false</span>);        ui-&gt;checkBox_reading-&gt;setChecked(<span class="hljs-literal">false</span>);        ui-&gt;checkBox_swimming-&gt;setChecked(<span class="hljs-literal">false</span>);    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::checkBox_hobby_slot</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 获取爱好是否选中的状态 */</span>    <span class="hljs-type">bool</span> ischeck_clibling = ui-&gt;checkBox_clibling-&gt;isChecked();    <span class="hljs-type">bool</span> ischeck_playball = ui-&gt;checkBox_playball-&gt;isChecked();    <span class="hljs-type">bool</span> ischeck_reading = ui-&gt;checkBox_reading-&gt;isChecked();    <span class="hljs-type">bool</span> ischeck_swimming = ui-&gt;checkBox_swimming-&gt;isChecked();    <span class="hljs-comment">/* 全部选中 */</span>    <span class="hljs-keyword">if</span>(ischeck_clibling &amp;&amp; ischeck_playball &amp;&amp; ischeck_reading &amp;&amp; ischeck_swimming)    &#123;        ui-&gt;checkBox_all-&gt;setCheckState(Qt::Checked);    &#125;    <span class="hljs-comment">/* 全部未选中 */</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!ischeck_clibling &amp;&amp; !ischeck_playball &amp;&amp; !ischeck_reading &amp;&amp; !ischeck_swimming)    &#123;        ui-&gt;checkBox_all-&gt;setCheckState(Qt::Unchecked);    &#125;    <span class="hljs-comment">/* 部分选中 */</span>    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;checkBox_all-&gt;setCheckState(Qt::PartiallyChecked);    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::btn_info_slot</span><span class="hljs-params">()</span>&#123;    QString str;    <span class="hljs-comment">/* 性别 */</span>    str = <span class="hljs-string">&quot;性别：&quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;radioButton_male-&gt;isChecked())        str += ui-&gt;radioButton_male-&gt;text();    <span class="hljs-keyword">else</span>        str += ui-&gt;radioButton_female-&gt;text();    <span class="hljs-comment">/* 婚姻 */</span>    str += <span class="hljs-string">&quot;; 婚姻状况：&quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;radioButton_lady-&gt;isChecked())        str += ui-&gt;radioButton_lady-&gt;text();    <span class="hljs-keyword">else</span>        str += ui-&gt;radioButton_woman-&gt;text();    <span class="hljs-comment">/* 学历 */</span>    str += <span class="hljs-string">&quot;; 学历：&quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;radioButton_junior-&gt;isChecked())        str += ui-&gt;radioButton_junior-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_bachelor-&gt;isChecked())        str += ui-&gt;radioButton_bachelor-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_doctor-&gt;isChecked())        str += ui-&gt;radioButton_doctor-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_master-&gt;isChecked())        str += ui-&gt;radioButton_master-&gt;text();    <span class="hljs-comment">/* 国籍 */</span>    str += <span class="hljs-string">&quot;; 国籍：&quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;radioButton_America-&gt;isChecked())        str += ui-&gt;radioButton_America-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_China-&gt;isChecked())        str += ui-&gt;radioButton_China-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_France-&gt;isChecked())        str += ui-&gt;radioButton_France-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_German-&gt;isChecked())        str += ui-&gt;radioButton_German-&gt;text();    <span class="hljs-comment">/* 爱好 */</span>    str += <span class="hljs-string">&quot;; 爱好：&quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;checkBox_clibling-&gt;isChecked())        str += ui-&gt;checkBox_clibling-&gt;text() + <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;checkBox_playball-&gt;isChecked())        str += ui-&gt;checkBox_playball-&gt;text() + <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;checkBox_reading-&gt;isChecked())        str += ui-&gt;checkBox_reading-&gt;text() + <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;checkBox_swimming-&gt;isChecked())        str += ui-&gt;checkBox_swimming-&gt;text() + <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-comment">/* 信息输出 */</span>    QMessageBox::information(this, <span class="hljs-string">&quot;您的个人信息：&quot;</span>, str);&#125;</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701225352502.png" alt="image-20230701225352502" style="zoom:70%;" /></p><p>工程代码：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/radioBtnAndCheckBox.zip">radioBtnAndCheckBox</a></p><p>s</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之文本框QLineEdit</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%96%87%E6%9C%AC%E6%A1%86QLineEdit/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%96%87%E6%9C%AC%E6%A1%86QLineEdit/</url>
    
    <content type="html"><![CDATA[<p>QLineEdit是一个单行文本输入框,允许用户输入和编辑单行纯文本，它自带一些如撤销、重做、剪切、粘贴、拖拽等文本编辑功能。</p><h2 id="类型成员">类型成员</h2><p><strong>enum ActionPosition { LeadingPoisition, TrailingPosition}</strong></p><p>此枚举类型描述QLineEdit应该如何显示要添加的Action小部件。</p><ul><li><code>QLineEdit::LeadingPosition</code>：当使用 Qt::LeftToRight布局方向时，小部件显示在文本的左侧，当使用 Qt::RightToLeft时，小部件则显示在文本的右侧。</li><li><code>QLineEdit::TrailingPosition</code>：当使用 Qt::LeftToRight布局方向时，小部件显示在文本的右侧，当使用 Qt::RightToLeft时，小部件则显示在文本的左侧。</li></ul><p><strong>enum EchoMode { Normal, NoEcho, Password, PasswordEchoOnEdit}</strong></p><p>此枚举类型描述QLineEdit应如何显示其内容。</p><ul><li><code>QLineEdit::Normal</code> :输入时显示字符, 默认设置。</li><li><code>QLineEdit::NoEcho</code> :不显示任何输入内容。</li><li><code>QLineEdit::Password</code>：输入字符一般以<code>●</code>号表示。</li><li><code>QLineEdit::PasswordEchoOnEdit</code>：在输入时显示输入的字符，输入完成后一般以<code>●</code>号显示。</li></ul><h2 id="属性和方法">属性和方法</h2><p>QLineEdit有很多属性和方法，这里列举一些常用的：</p><ul><li>获取和设置占位字符串</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">placeholderText</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setPlaceholderText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;)</span>    <span class="hljs-comment">//设置QLineEdit 编辑行显示灰色占位符文本</span></code></pre></div><ul><li>获取和设置文本的对齐方式</li></ul><div class="code-wrapper"><pre><code class="hljs c">Qt::Alignment <span class="hljs-title function_">alignment</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setAlignment</span><span class="hljs-params">(Qt::Alignment flag)</span></code></pre></div><ul><li>获取和设置回显模式</li></ul><div class="code-wrapper"><pre><code class="hljs c">QLineEdit::EchoMode <span class="hljs-title function_">echoMode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setEchoMode</span><span class="hljs-params">(QLineEdit::EchoMode)</span></code></pre></div><ul><li>设置文本框是否可编辑</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isReadOnly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setReadOnly</span><span class="hljs-params">(<span class="hljs-type">bool</span>)</span></code></pre></div><ul><li>设置文本框是否使能</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isEnabled</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setEnabled</span><span class="hljs-params">(<span class="hljs-type">bool</span>)</span></code></pre></div><ul><li>设置和获取文本框内容格式</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">inputMask</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> <span class="hljs-title function_">setInputMask</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;inputMask)</span></code></pre></div><ul><li>信号与槽函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 信号 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">cursorPositionChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> oldPos, <span class="hljs-type">int</span> newPos)</span><span class="hljs-type">void</span> <span class="hljs-title function_">editingFinished</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">inputRejected</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">returnPressed</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">selectionChanged</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">textChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span><span class="hljs-type">void</span> <span class="hljs-title function_">textEdited</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span><span class="hljs-comment">/* 槽函数 */</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">cut</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">paste</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">redo</span><span class="hljs-params">()</span> <span class="hljs-comment">//恢复上一次操作</span><span class="hljs-type">void</span> <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;)</span><span class="hljs-type">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span> <span class="hljs-comment">//撤销上一次操作</span></code></pre></div><p>其它详细内容，参考帮助文档。</p><h2 id="应用实例">应用实例</h2><p>新建一个 lineEdit 的工程，进入UI设计界面，设计如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230629230058729.png"alt="image-20230629230058729" /><figcaption aria-hidden="true">image-20230629230058729</figcaption></figure><p>下面进行功能实现：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_print_clicked</span><span class="hljs-params">()</span>&#123;    QMessageBox::information(this, <span class="hljs-string">&quot;信息输出&quot;</span>, ui-&gt;lineEdit_content-&gt;text());&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_normal_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setEchoMode(QLineEdit::Normal);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;Normal&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_noecho_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setEchoMode(QLineEdit::NoEcho);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;NoEcho&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_password_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setEchoMode(QLineEdit::Password);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;Password&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_pwdAndEcho_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setEchoMode(QLineEdit::PasswordEchoOnEdit);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;PasswordEchoOnEdit&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_placeholder_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;请输入名字：&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_clearbtn_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setClearButtonEnabled(<span class="hljs-literal">true</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_rw_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;setReadOnly(<span class="hljs-literal">false</span>);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;ReadAndWrite&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_ro_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;setReadOnly(<span class="hljs-literal">true</span>);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;ReadOnly&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_disable_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;setEnabled(<span class="hljs-literal">false</span>);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;Disabled&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_enable_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;setEnabled(<span class="hljs-literal">true</span>);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;Enabled&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_none_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setInputMask(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_phone_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setInputMask(<span class="hljs-string">&quot;99999999999;#&quot;</span>); <span class="hljs-comment">//要求输入0-9的数字 ,未输入时显示#</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_key_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setInputMask(<span class="hljs-string">&quot;&gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;#&quot;</span>); <span class="hljs-comment">//要求输入大写字母 ,未输入时显示#</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_data_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setInputMask(<span class="hljs-string">&quot;0000-00-00&quot;</span>); <span class="hljs-comment">//要求输入0-9的数字</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_ip_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setInputMask(<span class="hljs-string">&quot;000.000.000.000;_&quot;</span>); <span class="hljs-comment">//要求输入0-9的数字,未输入时显示_</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_lineEdit_num2_editingFinished</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> sum = ui-&gt;lineEdit_num1-&gt;text().toInt() + ui-&gt;lineEdit_num2-&gt;text().toInt();    ui-&gt;lineEdit_sum-&gt;setText(QString::number(sum));&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_lineEdit_num4_textChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;arg1)</span>&#123;    <span class="hljs-type">int</span> minus = ui-&gt;lineEdit_num3-&gt;text().toInt()- arg1.toInt();    ui-&gt;lineEdit_minus-&gt;setText(QString::number(minus));&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_lineEdit_num6_returnPressed</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> multi = ui-&gt;lineEdit_num5-&gt;text().toInt() * ui-&gt;lineEdit_num6-&gt;text().toInt();    ui-&gt;lineEdit_muliti-&gt;setText(QString::number(multi));&#125;</code></pre></div><p>工程代码：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/lineEdit.zip">lineEdit</a></p><p>参考链接：</p><p>http://t.csdn.cn/eRQsV</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之标签QLabel</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%A0%87%E7%AD%BEQLabel/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%A0%87%E7%AD%BEQLabel/</url>
    
    <content type="html"><![CDATA[<h3 id="qlabel属性和方法">QLabel属性和方法</h3><p>QLabel用于显示文本或图像，它有很多属性和方法，常用的主要有：</p><ul><li>获取和设置文本</li></ul><div class="code-wrapper"><pre><code class="hljs c">String <span class="hljs-title function_">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span>;</code></pre></div><ul><li>设置标签中内容的对齐方式</li></ul><div class="code-wrapper"><pre><code class="hljs c">Qt::Alignment <span class="hljs-title function_">alignment</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setAlignment</span><span class="hljs-params">(Qt::Alignment)</span>;</code></pre></div><p><code>Qt::Alignment</code> 是一个宏，常用取值如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230628190853765.png" alt="image-20230628190853765" style="zoom:67%;" /></p><ul><li>标签内容换行</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">wordWrap</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setWordWrap</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span>;</code></pre></div><ul><li>获取和设置标签上显示的图像</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> QPixmap *<span class="hljs-title function_">pixmap</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setPixmap</span><span class="hljs-params">(<span class="hljs-type">const</span> QPixmap &amp;)</span>;</code></pre></div><ul><li>设置动图</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">setMovie</span><span class="hljs-params">(QMovie *movie)</span>;</code></pre></div><h3 id="qlabel的使用">QLabel的使用</h3><p>创建基类为QWidget的工程，进入UI设计界面，进行如下设计：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230628202616484.png"alt="image-20230628202616484" /><figcaption aria-hidden="true">image-20230628202616484</figcaption></figure><p>下面进行功能实现：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 缩放widget，标签文本允许换行 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_enableWrap_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setWordWrap(<span class="hljs-literal">true</span>);&#125;<span class="hljs-comment">/* 缩放widget，标签文本不允许换行 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_disableWrap_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setWordWrap(<span class="hljs-literal">false</span>);&#125;<span class="hljs-comment">/* 设置标签文本对齐方式 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_left_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setAlignment(Qt::AlignLeft | Qt::AlignVCenter);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_center_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setAlignment(Qt::AlignCenter);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_right_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setAlignment(Qt::AlignRight | Qt::AlignVCenter);&#125;<span class="hljs-comment">/* 弹出消息对话框信息 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_getText_clicked</span><span class="hljs-params">()</span>&#123;    QMessageBox::information(this, <span class="hljs-string">&quot;文本信息&quot;</span>, ui-&gt;label_text-&gt;text());<span class="hljs-comment">//需要添加头文件&lt;QMessageBox&gt;</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setText_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 获取当前时间并转换为字符串 */</span>    QString str = QTime::currentTime().toString(); <span class="hljs-comment">//需要添加头文件&lt;QTime&gt;</span>    ui-&gt;label_text-&gt;setText(str);    QFont font = QFont(<span class="hljs-string">&quot;宋体&quot;</span>, <span class="hljs-number">15</span>);    ui-&gt;label_text-&gt;setFont(font); <span class="hljs-comment">//设置字体</span>    ui-&gt;label_text-&gt;setAlignment(Qt::AlignCenter);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setlink_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setText(<span class="hljs-string">&quot;&lt;h1&gt;&lt;a href=\&quot;https://www.baidu.com\&quot;&gt;百度一下&lt;/a&gt;&lt;/h1&gt;&quot;</span>);    <span class="hljs-comment">/* 开启点击自动跳转到超链接地址 */</span>    ui-&gt;label_text-&gt;setOpenExternalLinks(<span class="hljs-literal">true</span>);    ui-&gt;label_text-&gt;setAlignment(Qt::AlignCenter);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_change_clicked</span><span class="hljs-params">()</span>&#123;    QPixmap pixmap;    <span class="hljs-comment">/* 首先判断图片切换的位置 */</span>    <span class="hljs-keyword">if</span>(index &gt; <span class="hljs-number">12</span>)    &#123;        index = <span class="hljs-number">1</span>;    &#125;    QString str = <span class="hljs-string">&quot;:/png/&quot;</span> + QString::number(index) + <span class="hljs-string">&quot;.png&quot;</span>; <span class="hljs-comment">//拼接图片路径</span>    index++; <span class="hljs-comment">//切换到下一张图片</span>    pixmap.load(str);    ui-&gt;label_pic-&gt;setPixmap(pixmap);    ui-&gt;label_pic-&gt;setScaledContents(<span class="hljs-literal">false</span>); <span class="hljs-comment">//不要缩放，否则拉伸导致失真</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_disp_clicked</span><span class="hljs-params">()</span>&#123;    QMovie *movie = new QMovie(<span class="hljs-string">&quot;:/png/movie.gif&quot;</span>);<span class="hljs-comment">//添加头文件&lt;QMovie&gt;</span>    movie-&gt;start(); <span class="hljs-comment">//播放动画</span>    ui-&gt;label_pic-&gt;setMovie(movie);&#125;</code></pre></div><p>工程文件：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/label.zip">label</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之按钮QPushButton</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%8C%89%E9%92%AEQPushButton/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%8C%89%E9%92%AEQPushButton/</url>
    
    <content type="html"><![CDATA[<p><code>QPushButton</code> 是 <code>Qt</code>中的按钮类，属于最常用的控件，当点击按钮时，就可执行相应的操作。</p><p>可以在UI设计界面直接拖动pushbutton来创建按钮，也可以通过代码进行new创建，如 :</p><div class="code-wrapper"><pre><code class="hljs c">QPushButton *button = new QPushButton(<span class="hljs-string">&quot;&amp;Download&quot;</span>, this);</code></pre></div><p>以上创建了一个带有文字 <code>Download</code> 的按钮，快捷键为<code>Alt + D</code>, 这里的 <strong>&amp;</strong>符号为快捷键标识。</p><h2 id="qpushbutton的属性和方法">QpushButton的属性和方法</h2><ul><li>获取和设置按钮的文本</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span></code></pre></div><ul><li>获取和设置按钮的图标</li></ul><div class="code-wrapper"><pre><code class="hljs c">QIcon <span class="hljs-title function_">icon</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setIcon</span><span class="hljs-params">(<span class="hljs-type">const</span> QIcon &amp;icon)</span></code></pre></div><ul><li>样式表可以设置包括文本颜色、背景色、边框、字体等很多样式</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 只要继承自QWidget类的控件，都有该属性</span>QString <span class="hljs-title function_">styleSheet</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setStyleSheet</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;styleSheet)</span></code></pre></div><ul><li>Signals &amp; Slots</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">clicked</span><span class="hljs-params">(<span class="hljs-type">bool</span> checked = <span class="hljs-literal">false</span>)</span> <span class="hljs-comment">//通常不需要传递这个默认参数</span><span class="hljs-type">void</span> <span class="hljs-title function_">pressed</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">released</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">toggled</span><span class="hljs-params">(<span class="hljs-type">bool</span> checked)</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">showMenu</span><span class="hljs-params">()</span> <span class="hljs-comment">//弹出菜单</span></code></pre></div><p>其它函数具体参看帮助文档。</p><h2 id="实例">实例</h2><p>新建一个基类为QWidget的工程，勾选 'Generate form'。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230626222427044.png" alt="image-20230626222427044" style="zoom:67%;" /></p><p>在UI设计界面，拖拽对应的控件，进行如下设置：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230626230434261.png"alt="image-20230626230434261" /><figcaption aria-hidden="true">image-20230626230434261</figcaption></figure><p>下面进行功能实现：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_stop_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 获取按钮文本 */</span>    QString text = ui-&gt;btn_stop-&gt;text();    <span class="hljs-comment">/* 判断处理 */</span>    <span class="hljs-keyword">if</span>(text == <span class="hljs-string">&quot;启动&quot;</span>)    &#123;        ui-&gt;btn_stop-&gt;setText(<span class="hljs-string">&quot;停止&quot;</span>);<span class="hljs-comment">// 设置文本和字体</span>        ui-&gt;btn_stop-&gt;setIcon(QIcon(<span class="hljs-string">&quot;:/stop.ico&quot;</span>));<span class="hljs-comment">// 设置图标和图标大小</span>        ui-&gt;btn_stop-&gt;setIconSize(QSize(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>));    &#125;    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;btn_stop-&gt;setText(<span class="hljs-string">&quot;启动&quot;</span>);        ui-&gt;btn_stop-&gt;setIcon(QIcon(<span class="hljs-string">&quot;:/start.ico&quot;</span>));        ui-&gt;btn_stop-&gt;setIconSize(QSize(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>));    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_connect_clicked</span><span class="hljs-params">()</span>&#123;    QString s = ui-&gt;btn_connect-&gt;text();    <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;连接&quot;</span>)    &#123;        ui-&gt;btn_connect-&gt;setText(<span class="hljs-string">&quot;断开连接&quot;</span>);        ui-&gt;btn_send-&gt;setEnabled(<span class="hljs-literal">true</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;btn_connect-&gt;setText(<span class="hljs-string">&quot;连接&quot;</span>);        ui-&gt;btn_send-&gt;setEnabled(<span class="hljs-literal">false</span>);    &#125;&#125;<span class="hljs-comment">/* 按钮信号演示 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_signal_clicked</span><span class="hljs-params">()</span>&#123;    qDebug() &lt;&lt; <span class="hljs-string">&quot;clicked...&quot;</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_signal_pressed</span><span class="hljs-params">()</span>&#123;     qDebug() &lt;&lt; <span class="hljs-string">&quot;pressed...&quot;</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_signal_released</span><span class="hljs-params">()</span>&#123;     qDebug() &lt;&lt; <span class="hljs-string">&quot;released...&quot;</span>;&#125;</code></pre></div><p>对于样式表：</p><p>在右侧的属性窗口中，或者在按钮上右键-&gt;【改变样式表…】，打开编辑样式表的对话框，设置了按钮的字体颜色和背景渐变‘RainBow’。</p><p>工程代码：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/pushButton.zip">pushButton</a></p><p>参考链接：</p><p>http://t.csdn.cn/qxhG0</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之窗口基类 QWidget</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%B1%BB%20QWidget/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%B1%BB%20QWidget/</url>
    
    <content type="html"><![CDATA[<p>QWidget 类是所有控件类的父类，Qt为此控件提供有很多属性和方法：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625220627151.png" alt="image-20230625220627151" style="zoom:80%;" /></p><p>详细内容可查看帮助文档。</p><p>下面使用一个案例来展示 <code>QWidget</code> 中常用的方法：</p><p>新建一个基类为QWidget的工程，勾选 'Generate form'。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625223310755.png" alt="image-20230625223310755" style="zoom: 67%;" /></p><p>打开ui设计文件，添加几个Push Button，并进行如下设置：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625224821724.png" alt="image-20230625224821724" style="zoom:67%;" /></p><p>运行，弹出如下窗口：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625224918704.png" alt="image-20230625224918704" style="zoom:67%;" /></p><p>下面进行功能实现，其中添加图标需要进行如下操作，首先添加资源文件，然后复制图标路径，粘贴到代码中：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625231034328.png" alt="image-20230625231034328" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625231046114.png" alt="image-20230625231046114" style="zoom:80%;" /></p><p>主要代码：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_getPosAndSize_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 获取窗口位置信息 */</span>    QRect rect = this-&gt;geometry();    <span class="hljs-comment">/* 在输出打印当前窗口位置信息，注意添加头文件&lt;QDebug&gt; */</span>    qDebug() &lt;&lt; <span class="hljs-string">&quot;左上角: &quot;</span> &lt;&lt; rect.topLeft();    qDebug() &lt;&lt; <span class="hljs-string">&quot;右上角: &quot;</span> &lt;&lt; rect.topRight();    qDebug() &lt;&lt; <span class="hljs-string">&quot;左下角: &quot;</span> &lt;&lt; rect.bottomLeft();    qDebug() &lt;&lt; <span class="hljs-string">&quot;右下角: &quot;</span> &lt;&lt; rect.bottomRight();    qDebug() &lt;&lt; <span class="hljs-string">&quot;宽度: &quot;</span> &lt;&lt; rect.width();    qDebug() &lt;&lt; <span class="hljs-string">&quot;高度: &quot;</span> &lt;&lt; rect.height();&#125;<span class="hljs-comment">/* 设置窗口大小 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setSize_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;resize(<span class="hljs-number">450</span>, <span class="hljs-number">450</span>);&#125;<span class="hljs-comment">/* 固定窗口大小 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setFixSize_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;setFixedSize(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);&#125;<span class="hljs-comment">/* 最小缩放400*400 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setMinSize_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;setMinimumSize(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>);&#125;<span class="hljs-comment">/* 最大缩放600*600 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setMaxSize_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;setMaximumSize(<span class="hljs-number">600</span>, <span class="hljs-number">600</span>);&#125;<span class="hljs-comment">/* 移动窗口到具体位置 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_move_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;move(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);&#125;<span class="hljs-comment">/* 设置窗口标题 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setTitle_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;setWindowTitle(<span class="hljs-string">&quot;QWidget测试&quot;</span>);&#125;<span class="hljs-comment">/* 设置窗口logo */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setLogo_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;setWindowIcon(QIcon(<span class="hljs-string">&quot;:/logo.png&quot;</span>));&#125;</code></pre></div><p>工程代码Gitee: <ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/QWidget.zip">QWidget</a></p><p>参考链接：</p><p>http://t.csdn.cn/xT6vf</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI绘画</title>
    <link href="/2023/06/19/AI%E7%BB%98%E7%94%BB/"/>
    <url>/2023/06/19/AI%E7%BB%98%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<p>偶然看到网上一篇文章（https://stable-diffusion-art.com/qr-code/），觉得挺炫酷，因为看到文章内有具体的操作步骤，所以我也想尝试一下，然后利用周末的两天，认真地了解和操作了一番。</p><h3 id="stable-diffusion的简介">Stable Diffusion的简介</h3><p>目前AI绘画最火的当属 <strong>Midjorney</strong> 和 <strong>StableDiffusion</strong>，<strong>Midjourney</strong>没有开源，<strong>StableDiffusion</strong> 免费开源。<strong>Stable Diffusion</strong>是StabilityAI公司于2022年提出的，它是一个基于潜在<strong>扩散模型</strong>（Latent DiffusionModels），能够根据文本描述生成高质量、高分辨率、高逼真的图像。</p><p>至于其原理，不做过多介绍，如果想深入了解，可查看：</p><p>源码：https://github.com/CompVis/stable-diffusion</p><p>论文：https://arxiv.org/pdf/2112.10752.pdf</p><p>Stable Diffusion本身没有类似exe的可直接运行的软件，好在有一些基于<code>stable-diffusion</code> 封装的 <code>webui</code>开源项目，其中，<strong>AUTOMATIC1111大神</strong> 部署的框架 <ahref="https://github.com/AUTOMATIC1111/stable-diffusion-webui">stable-diffusion-webui</a>，得到了广泛的应用。它是一套无代码、可视化的StableDiffusion集成运行环境。让我们能通过web可视化界面而不是通过命令行参数使用StableDiffusion进行绘画创作。</p><p>因为每个人的电脑环境不一样，本地部署免不了会出现各种各样的问题，如果不想折腾，可直接下载使用别人的整合包，下载了这些整合包，直接解压就可以使用，现在国内热度比较高的有两个整合包：</p><p>秋叶aaakiv4整合包：https://pan.baidu.com/s/13_B9lotU7UDcET7wYcDF7g?pwd=bang#list/path=%2F</p><p>独立研究员-星空整合包：<ahref="https://link.zhihu.com/?target=https%3A//pan.baidu.com/s/1_FYbDpkX6Q6hDVHJpCMRxA%3Fpwd%3Do852">https://pan.baidu.com/s/1_FYbDpkX6Q6hDVHJpCMRxA?pwd=o852</a></p><p>在了解之前，我是直接进行本地部署的，下面将详细介绍部署stable-diffusion-webui的具体流程。</p><h3 id="系统配置需求">系统配置需求</h3><p>Stable Diffusion是比较耗资源的，因此对电脑硬件有一定要求。</p><p>NVIDIA GPU 至少 4GB 显存，至少8GB 内存，至少 20GB可用硬盘空间，如果想要生成速度快，显卡配置自然是越高越好，显存最好也上到8G。如果本地机器配置达不到，可使用云端部署，可参考：https://b23.tv/KLk8gPg</p><h3 id="环境准备">环境准备</h3><ul><li><strong>Python</strong></li></ul><p>请注意，为保证准确性，Python版本至少为 <strong>3.10.6</strong>，<ahref="https://www.python.org/ftp/python/3.10.6/python-3.10.6-amd64.exe">点击这里直接下载</a></p><ul><li><strong>git</strong></li></ul><p>为避免不必要的麻烦，git安装时一定要勾选<strong>将PATH添加到系统环境变量中</strong></p><ul><li><strong>stable-diffusion-webui库</strong></li></ul><p>打开 <code>git bash</code> ,输入命令<code>git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git</code>,下载stable-diffusion-webui库。</p><ul><li><strong>CUDA</strong></li></ul><p><code>stable-diffusion-webui</code> 运行使用的是 GPU算力，这里我们需要安装 CUDA 驱动，打开cmd命令行，输入<code>nvidia-smi</code>, 查看电脑CUDA的版本号：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230619212839698.png" alt="image-20230619212839698" style="zoom:80%;" /></p><p>然后进入Nvidia CUDA官网：https://developer.nvidia.com/cuda-toolkit-archive，找到对应的系统版本号，下载安装。</p><ul><li><strong>模型Stable Diffusion checkpoint</strong></li></ul><p>stable-diffusion-webui需要有已经训练过的模型才能进行使用，两个常用的下载模型网站：</p><p><strong>huggingface</strong>：https://huggingface.co/</p><p><strong>civitai</strong> ：https://civitai.com/</p><p>这里下载官方模型<ahref="https://huggingface.co/CompVis/stable-diffusion-v-1-4-original/resolve/main/sd-v1-4.ckpt">sd-v1-4</a></p><ul><li><strong>网络控制扩展包ControlNet extension</strong></li></ul><p>打开 <code>git bash</code> ,输入命令<code>git clone https://github.com/Mikubill/sd-webui-controlnet.git</code>,下载sd-webui-controlnet extension.</p><h3 id="安装部署">安装部署</h3><ol type="1"><li><p>依次安装以上python和git软件，CUDA软件。</p></li><li><p>将之前下载的模型（sd-v1-4.ckpt）放到stable-diffusion-webui-diffusion下。将ControlNet extension文件夹放到stable-diffusion-webui。</p></li><li><p>打开刚刚下载的stable-diffusion-webui文件夹，找到如下bash文件，针对不同的电脑，双击不同的bat文件。</p></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230619210447451.png" alt="image-20230619210447451" style="zoom:80%;" /></p><ol start="4" type="1"><li>弹出命令窗口后，它会自动下载相关内容，<strong>注意：这一步可能会出现很多问题，根据提示，进行一一解决</strong></li></ol><p>如：提示你升级pip版本，重新打开一个命令窗口，cd进入到stable-diffusion-webui，运行命令<code>python.exe -m pip install --upgrade pip</code>升级一下pip就行。然后重新运行以上bat文件。</p><p>再如：<code>torch.cuda.OutOfMemoryError: CUDA out of memory.</code>这表示显卡内存不足，因为我电脑显存只有2GB，所以折腾很久，最后找到了解决方法，打开webui-user.bat文件，进行如下参数设置（主要是跳过cudatest和lowvram）：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230619214107835.png"alt="image-20230619214107835" /><figcaption aria-hidden="true">image-20230619214107835</figcaption></figure><p>具体参考：https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Command-Line-Arguments-and-Settings</p><ol start="5" type="1"><li>问题都解决后，会出现界面。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230619220104534.png" alt="image-20230619220104534" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230619215525485.png" alt="image-20230619215525485" style="zoom:80%;" /></p><h3 id="运用">运用</h3><p>本地部署完成，接下来就是设置不同的参数，生成不同的图像了。具体学习可查看https://b23.tv/YKS6EWl</p><p>以下是我参照最开始的网址文章进行简单的设置生成的图像：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/00000-1838255928.png" alt="00000-1838255928" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/00000-313235722.png" alt="00000-313235722" style="zoom:80%;" /></p><p>如果想生成更漂亮的图片，需要更好的电脑配置和更深层的学习，通过改变提示词、改变权重、多次生成等方式，可以让你得到想要的图片，这里我只是做简单的了解，同时记录一下本地部署AI绘图的内容。</p><p>像文章开头那种图像实现，目前市面上有很多推广应用，如 <ahref="https://hysli.io/#/mobile">Hysli.io</a> 、<ahref="https://qrbtf.com/ai">QRBTF.AI</a> 、<ahref="https://yima.me">艺码</a>等，如果你的电脑配置比较好，也有兴趣和耐心自己尝试一番，可以参考以下两篇博文：<ahref="https://antfu.me/posts/ai-qrcode-refine">Refining AI Generated QRCode</a> 和 <a href="https://antfu.me/posts/ai-qrcode-101">StableDiffusion QR Code 101</a></p><h3 id="参考链接">参考链接：</h3><p>https://www.bilibili.com/read/mobile?id=23488766</p><p>https://it.cha138.com/nginx/show-4623870.html</p><p>http://t.csdn.cn/T2uR1</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt的信号与槽机制</title>
    <link href="/2023/06/15/Qt%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/06/15/Qt%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="qt信号与槽简介">Qt信号与槽简介</h3><p>Qt对标准C++进行了扩展，引入了一些新的概念和功能，例如信号与槽机制，对象属性等。Qt中有一个预处理器，称为元对象编译器（Meta-ObjectCompiler，MOC），它会将Qt源程序在编译前先转换为标准C++兼容形式，再由C++标准编译器进行编译，所以，信号与槽机制中，必须添加宏：<strong>Q_OBJECT</strong>，这样MOC才能对信号与槽程序进行代码预处理。</p><p>信号与槽是Qt的一个核心特点，也是区别于其它框架的重要特性。Qt使用信号与槽的机制实现对象间通信，它隐藏了复杂的底层实现。与回调函数相比，应用起来会更灵活。</p><p><strong>信号（Signals）</strong>就是在指定情况下发生的事件，QtWidgets 提供了很多信号，例如 QPushButton最常见的信号就是鼠标单击时的clicked()信号，同时，我们也可以自己定义信号。</p><p><strong>槽（Slots）</strong>就是对信号响应的函数。槽就是一个函数，可以具有任何参数，也可以被直接调用。当槽函数与信号关联后，如果信号发生，那么关联的槽函数就会被执行。QtWidgets提供有很多槽函数，我们也可以自己定义槽函数。</p><p>信号与槽关联是用 QObject::connect() 函数实现的，connect() 是 QObject类的一个静态函数，而QObject 是所有 Qt类的基类，在实际调用时可以忽略前面的限定符。</p><p>一个信号可以连接多个槽，多个信号可以连接同一个槽，一个信号可以连接另外一个信号。如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230615203504152.png"alt="image-20230615203504152" /><figcaption aria-hidden="true">image-20230615203504152</figcaption></figure><p>connect函数有多重参数形式，一般使用最广的是以下三种：</p><ul><li><strong>一般参数形式</strong></li></ul><p><code>QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)</code></p><p>简化：<strong>connect(sender, SIGNAL(signal()), receiver,SLOT(slot()));</strong></p><p>这里使用宏SIGNAL()和SLOT()指定信号和槽函数，如果信号和槽带有参数，还需要注明参数类型，且参数类型要一致，如：</p><p><strong>connect(scrollBar, SIGNAL(valueChanged(int)), label,SLOT(setNum(int)));</strong></p><ul><li><strong>函数指针形式</strong></li></ul><p><code>QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &amp;signal, const QObject *receiver, const QMetaMethod &amp;method, Qt::ConnectionType type = Qt::AutoConnection)</code></p><p>简化：<strong>connect(sender, &amp;Sender::signal, receiver,&amp;Receiver::slot);</strong></p><p>如： <strong>connect(ui-&gt;lineEdit, &amp;QLineEdit::textChanged,ui-&gt;label, &amp;QLabel::setText);</strong></p><ul><li><strong>lambda 表达式形式</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Qt不传递参数lambda</span><span class="hljs-built_in">connect</span>(ui-&gt;button, &amp;QButton::clicked,[=]&#123;    <span class="hljs-built_in">qDebug</span>()&lt;&lt;<span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;test&quot;</span>);&#125;);<span class="hljs-comment">//Qt带传递参数lambda</span><span class="hljs-built_in">connect</span>(UI-&gt;button, &amp;QButton::clicked,[=](QString path)&#123;    <span class="hljs-built_in">qDebug</span>()&lt;&lt;path;&#125;);</code></pre></div><p>lamdba表达式介绍:</p><p>[] 不捕获任何变量。</p><p>[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</p><p>[&amp;, a]a以传值方式捕获，其余变量以传引用的方式在函数体中使用（a按值，其余按引用捕获）。</p><p>[a，&amp;b]a以传值方式捕获，b以传引用方式捕获（a按值捕获，b按引用捕获）。</p><p>[=]捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</p><p>[=，&amp;b] 按值捕获外部作用域中所有变量，并按引用捕获 b 变量。</p><p>[a] 仅按值捕获 a 变量，但不捕获其他变量。</p><h3 id="信号与槽的创建">信号与槽的创建</h3><p>Qt中信号与槽的创建一般有以下几种方式：</p><ul><li>在UI设计界面的控件上右键-&gt;转到槽，在ui.widget.h文件中将会通过connectSlotsByName，为每个信号/槽创建connect。如希望点击关闭按钮，窗口会关闭，操作如下：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230615214658423.png" alt="image-20230615214658423" style="zoom:80%;" /></p><p>这样，就会自动创建一个槽函数的声明和一个空的槽函数，需要自己添加相应执行的内容，这里调用的是widget的close()槽函数。<imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230615215256504.png"alt="image-20230615215256504" /></p><ul><li>通过UI设计界面中Signals &amp; SlotsEditor添加信号/槽，它们就会在系统内建立关联。如下，同样可以实现上面的功能：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230615220602008.png" alt="image-20230615220602008" style="zoom:80%;" /></p><ul><li>手动创建信号/槽。</li></ul><p>在widget.h文件中手动创建信号（signals:）或槽函数（slots:）声明，在widget.cpp文件中定义槽函数并手动创建connect函数，将信号与槽函数进行连接。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230615222721918.png" alt="image-20230615222721918" style="zoom:80%;" /></p><p>以上是Qt中信号与槽机制的基本使用方式，需要熟练掌握，另外，通过Qt的帮助文档，可以详细查看Qt已为各个类定义好的信号与槽函数。</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt Creator的使用</title>
    <link href="/2023/06/14/Qt-Creator%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/06/14/Qt-Creator%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="qt-creator的设置">Qt Creator的设置</h3><p>打开Qt Creator, 选择Tools -&gt; Options 进入设置界面：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190132386.png" alt="image-20230614190132386" style="zoom:80%;" /></p><ul><li>Environment：可以设置相应的主题和语言环境及UI颜色。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190238354.png" alt="image-20230614190238354" style="zoom:80%;" /></p><ul><li>Text Editor：可以进行相应的文本编辑设置。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190418754.png" alt="image-20230614190418754" style="zoom:80%;" /></p><ul><li>Build &amp; Run：进行编译和运行的设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190635317.png" alt="image-20230614190635317" style="zoom:80%;" /></p><h3 id="新建qt-widget项目">新建Qt Widget项目</h3><ul><li>依次点击 File -&gt; New File or Project,选择Qt WidgetApplication</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614191012944.png" alt="image-20230614191012944" style="zoom:80%;" /></p><ul><li>填写工程名和选择存储路径，选择 qmake 编译，用 qmake 生成 Makefile用于项目的编译。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614191554835.png" alt="image-20230614191554835" style="zoom:80%;" /></p><ul><li>选择基类：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614192700423.png" alt="image-20230614192700423" style="zoom:80%;" /></p><ul><li>选择目标平台的编译器：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614192942055.png" alt="image-20230614192942055" style="zoom:80%;" /></p><ul><li>可选择版本控制：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614193215345.png" alt="image-20230614193215345" style="zoom:80%;" /></p><ul><li>完成项目创建，可点击左下角绿色图标编译运行，此时会弹出一个空白框。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614193358548.png" alt="image-20230614193358548" style="zoom:80%;" /></p><h3 id="项目文件介绍">项目文件介绍</h3><ul><li>demo.pro: 项目管理文件。</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614194650370.png"alt="image-20230614194650370" /><figcaption aria-hidden="true">image-20230614194650370</figcaption></figure><p>还可以在其中设置应用程序其他信息：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#程序版本</span>VERSION = 1.0.0.0<span class="hljs-comment">#程序图标</span>RC_ICONS = client.ico<span class="hljs-comment">#公司名称</span>QMAKE_TARGET_COMPANY =<span class="hljs-string">&quot;KayoungZhang&quot;</span><span class="hljs-comment">#程序说明</span>QMAKE_TARGET_DESCRIPTION = <span class="hljs-string">&quot;TCP Client&quot;</span><span class="hljs-comment">#版权信息</span>QMAKE_TARGET_COPYRIGHT = <span class="hljs-string">&quot;Copyright(C) 2022&quot;</span><span class="hljs-comment">#程序名称</span>QMAKE_TARGET_PRODUCT = <span class="hljs-string">&quot;app&quot;</span><span class="hljs-comment">#程序语言</span><span class="hljs-comment">#0x0800代表和系统当前语言一致</span>RC_LANG = 0x0800</code></pre></div><ul><li><p>Header 分组，存放的是项目内所有的头文件*.h。</p></li><li><p>Source 分组，存放的是项目内的所有C++源码文件*.cpp。</p></li><li><p>Forms分组，存放项目内所有界面文件*.ui。双击ui文件就可以进入图形设计界面，返回时则点击左边Edit图标。</p></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614195710035.png"alt="image-20230614195710035" /><figcaption aria-hidden="true">image-20230614195710035</figcaption></figure><p>在控件区，拖拽一个<strong>Label</strong>组件到中间的设计区，编辑文字内容为：“<strong>Hello，Qt！</strong>”，选择此<strong>Lable</strong> 然后在其属性区，找到 <strong>geometry</strong>,将 <strong>Width</strong> 改为 <strong>80</strong>，<strong>Height</strong> 改为 <strong>30</strong>，然后找到<strong>font</strong>，将 <strong>Point Size</strong>设置为<strong>12</strong>，勾选 <strong>Bold</strong>。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614201322669.png"alt="image-20230614201322669" /><figcaption aria-hidden="true">image-20230614201322669</figcaption></figure><h3 id="项目的编译和运行">项目的编译和运行</h3><p>单击左窗口的 <strong>Projects</strong> 图标，查看编译工具。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614201800354.png"alt="image-20230614201800354" /><figcaption aria-hidden="true">image-20230614201800354</figcaption></figure><p>然后点击左下角编译运行：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614201932984.png" alt="image-20230614201932984" style="zoom:80%;" /></p><p>至此完成一个简单的项目创建。</p><h3 id="项目的发布">项目的发布</h3><p>当项目全部完成后，就可以进行打包发行了。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614202600194.png" alt="image-20230614202600194" style="zoom:80%;" /></p><p>选择<strong>Release</strong>后，编译运行完，打开项目工程目录，找到编译后的exe文件，双击运行，会发现运行不了，是因为缺少dll动态链接库。可以将Qt的bin目录添加到电脑系统的Path环境变量中，为了保证在其他电脑上也可以正常运行，需要找到相应的dll文件，Qt提供了一个<strong>windeployqt</strong>工具，可以自动创建可部署的文件夹，具体操作如下：</p><ol type="1"><li>将生成的exe文件复制到一个空的文件夹中。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614203121788.png" alt="image-20230614203121788" style="zoom:80%;" /></p><ol start="2" type="1"><li>打开Qt的MinGW命令行，进入刚才的文件夹，然后输入命令：<strong>windeployqt</strong>后面跟程序名。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614204728719.png" alt="image-20230614204728719" style="zoom:80%;" /></p><ol start="3" type="1"><li>可以将部分不需要的内容删除，如下所示：</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614205216379.png"alt="image-20230614205216379" /><figcaption aria-hidden="true">image-20230614205216379</figcaption></figure><ol start="4" type="1"><li><p>将精简后的程序压缩即可在其他同平台电脑运行了,也可以使用工具“单文件制作封装工具(Enigma VirtualBox)”将其打包成独立版程序。如果需要整理成一个安装程序，就需要专用工具进行打包处理，一般用到的工具有：</p><ul><li>HM NIS Edit（https://hmne.sourceforge.net/）</li><li>NSIS</li><li>Inno setup（https://jrsoftware.org/）</li></ul><p>后面再做详细介绍。</p></li></ol><p>工程文件：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/demo.zip">Qtdemo</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt开发环境的搭建</title>
    <link href="/2023/06/14/Qt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/06/14/Qt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="qt简介">Qt简介</h3><p>Qt 是一个跨平台的 C++开发库，主要用来开发图形用户界面（Graphical UserInterface，简称 GUI）程序。Qt 是跨平台的，支持Windows、Linux、macOS、Android、iOS、WinRT 等平台，将已编写好的 Qt程序移植到这些平台，只需重新编译一次源代码即可。</p><h3 id="qt-creator的下载安装">Qt Creator的下载安装</h3><p>QtCreator是Qt集成开发环境（IDE），包括C++代码编辑器，集成的GUI外观和版式设计器（QtDesigner），项目生成和管理工具，集成的上下文相关帮助系统，图形化调试器，代码管理和浏览工具等。</p><h4 id="下载qt-creator">1.下载Qt Creator</h4><p>官网地址：https://download.qt.io/</p><p>5.14及之前版本可以下载完整安装包，进行离线安装，5.15版本之后不再提供离线安装包，只能通过下载器进行在线安装。</p><p>离线版：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614174035183.png"alt="image-20230614174035183" /><figcaption aria-hidden="true">image-20230614174035183</figcaption></figure><p>在线版：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614174826980.png"alt="image-20230614174826980" /><figcaption aria-hidden="true">image-20230614174826980</figcaption></figure><p>一般从官网下载比较慢，可以通过国内镜像网站进行下载安装，国内著名的 Qt镜像网站，主要是各个高校的：</p><ul><li>中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/</li><li>清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/</li><li>中国互联网络信息中心：https://mirrors.cnnic.cn/qt/</li></ul><h4 id="安装qt-creator">2.安装Qt Creator</h4><p>这里我下载的是离线版本：qt-opensource-windows-x86-5.14.2.exe。</p><p><strong>注意：</strong>若已经安装了其他版本的Qt，请先卸载，再安装，否则会发生一些奇奇怪怪的错误。</p><ul><li>双击安装包进行安装，登录Qt账户，如果没有账号，进行注册。（断网后重新安装可跳过此步骤）</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614181334729.png" alt="image-20230614181334729" style="zoom:80%;" /></p><ul><li>选择安装路径</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614180858111.png" alt="image-20230614180858111" style="zoom:80%;" /></p><ul><li>按需选择组件，一般只需选择对应的编译环境即可，其他组件后续可以再进行补充安装。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614182944200.png" alt="image-20230614182944200" style="zoom:80%;" /></p><ul><li>完成安装</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614185126853.png" alt="image-20230614185126853" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614183307230.png" alt="image-20230614183307230" style="zoom:80%;" /></p><h3 id="参考链接">参考链接</h3><p>http://t.csdn.cn/VNaHm</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32以太网通信</title>
    <link href="/2023/06/07/STM32%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9CEthernet/"/>
    <url>/2023/06/07/STM32%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9CEthernet/</url>
    
    <content type="html"><![CDATA[<h3 id="ositcpip-和-lwip-简介">OSI、TCP/IP 和 LwIP 简介</h3><p><strong>OSI</strong>（Open System Interconnect），即开放式系统互联，一般都叫OSI参考模型。</p><p><strong>TCP/IP</strong>（Transmission Control Protocol/InternetProtocol），传输控制协议/网际协议，又名网络通讯协议，是 Internet最基本的协议、Internet 国际互联网络的基础，由网络层的 IP 协议和传输层的TCP 协议组成。TCP/IP定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。</p><p><strong>LwIP</strong>（Light weight IP），一种开源轻量级的 IP协议,占用内存少，它只需十几 KB 的 RAM 和 40K 左右的 ROM就可以运行。其网址：http://savannah.nongnu.org/projects/lwip/。</p><p><strong>MAC</strong> （Medium AccessControl），简称媒体访问控制，数据链路层的芯片称之为MAC控制器。</p><p><strong>PHY</strong>（Physical），端口物理层，物理层的芯片称之为PHY，是IEEE802.3规定的一个标准模块。IEEE定义了0~15这16个寄存器的功能，16~31这16个寄存器由厂商自行实现。</p><h3 id="网络模型">网络模型</h3><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606202025717.png"alt="image-20230606202025717" /><figcaption aria-hidden="true">image-20230606202025717</figcaption></figure><h3 id="通信实现">通信实现</h3><p>实现以太网通信硬件电路一般情况是SOC+MAC+PHY+网络变压器+RJ45，如下图：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230512193517675.png"alt="image-20230512193517675" /><figcaption aria-hidden="true">image-20230512193517675</figcaption></figure><p>通信硬件主要部分：MAC和PHY。对于内置MAC的SOC，其外部必须搭配一个PHY芯片。内部没有MAC的SOC芯片，就需要使用外置的MAC+PHY一体芯片了。具体实现有以下几种方式：</p><ul><li><strong>SOC（集成MAC层），外接一个PHY芯片（比如DM9162，LAN8720等），网络变压器和RJ45，总计4个器件，需单片机需处理TCP/IP协议栈。</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230512192817057.png"alt="image-20230512192817057" /><figcaption aria-hidden="true">image-20230512192817057</figcaption></figure><ul><li><p><strong>SOC，外加一个MAC和PHY集成一体芯片（包含MAC和PHY，比如DM9000、ENC28J60等），外加RJ45（集成网络变压器），总计3个电子器件，需单片机处理TCP/IP协议栈</strong>。</p></li><li><p><strong>SOC，外加一个MAC和PHY集成一体芯片（包含MAC+PHY+TCP/IP协议栈，如W5500,CH9121,CH395等），外加RJ45（集成网络变压器），总计3个电子器件，无需详细了解TCP/IP协议栈，开发方便。</strong></p></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230512192748527.png"alt="image-20230512192748527" /><figcaption aria-hidden="true">image-20230512192748527</figcaption></figure><ul><li><strong>SOC，加一个MAC芯片和一个PHY芯片，外加RJ45（集成网络变压器），总共4个器件。需单片机需处理TCP/IP协议栈。此方式使用较少。</strong></li></ul><p>其中：</p><p>MII/RMII接口用来传输网络数据，MIDO接口用来读写PHY的内部寄存器。</p><p><strong>MII</strong>(Media IndependentInterface)，介质独立接口，它是IEEE-802.3定义的以太网标准接口，用于以太网MAC连接PHY芯片。</p><p><strong>RMII</strong>(Reduced Media IndependentInterface)，精简的介质独立接口。</p><p><strong>MDIO</strong>(Management DataInput/Output)，管理数据输入输出接口，是一个两线串行接口，一根MDIO数据线，一根MDC时钟线。可以通过MDIO和MDC这两根线访问PHY芯片的任意一个寄存器。</p><p>网络变压器用于隔离以及滤波等，现在很多RJ45座子内部已经集成了网络变压器，比如最常用的HR911105A就是内置网络变压器的RJ45座。RJ45座子上一般有两个灯，绿灯亮表示网络正常，黄色闪烁说明正在进行网络通信。PHY芯片会有两个引脚来控制这两个灯。</p><h4 id="参考链接">参考链接：</h4><p>https://www.jianshu.com/p/bb363a41afcf</p><p>https://xie.infoq.cn/article/29110ce061176979d5d61959b</p><p>https://mp.weixin.qq.com/s/Wys9IgAgimCgHmVvvywK3w</p><p>http://t.csdn.cn/qLH6F</p><p>http://t.csdn.cn/Ob4tg</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之USB</title>
    <link href="/2023/06/06/STM32CubeMX%E4%B9%8BUSB/"/>
    <url>/2023/06/06/STM32CubeMX%E4%B9%8BUSB/</url>
    
    <content type="html"><![CDATA[<h3 id="usb简介">USB简介</h3><p>USB（Universal Serial BUS）通用串行总线，是一个外部总线标准。USB接口支持设备的即插即用和热插拔功能。</p><p>标准 USB 共四根线组成,除 VCC/GND 外,另外为D+,D-，这两根数据线采用的是差分电压的方式进行数据传输的。在 USB主机上，D-和 D+都是接了 15K的电阻到低的，所以在没有设备接入的时候，D+、D-均是低电平。而在 USB设备中，如果是高速设备，则会在 D+上接一个 1.5K 的电阻到VCC，而如果是低速设备，则会在 D-上接一个 1.5K 的电阻到VCC。这样当设备接入主机的时候，主机就可以判断是否有设备接入，并能判断设备是高速设备还是低速设备。</p><p>STM32F103 的 MCU 自带 USB 从控制器，符合 USB 规范的通信连接；PC主机和微控制器之间的数据传输是通过共享一专用的数据缓冲区来完成的，该数据缓冲区能被USB外设直接访问。这块专用数据缓冲区的大小由所使用的端点数目和每个端点最大的数据分组大小所决定，每个端点最大可使用512 字节缓冲区（专用的 512 字节，和 CAN 共用），最多可用于 16 个单向或 8个双向端点。USB 模块同 PC 主机通信，根据 USB规范实现令牌分组的检测，数据发送/接收的处理，和握手分组的处理。整个传输的格式由硬件完成，其中包括CRC 的生成和校验。</p><p>USB功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606220817086.png" alt="image-20230606220817086" style="zoom:80%;" /></p><p>整个 USB 通信的详细过程是很复杂的，要正常使用 STM32F1 的USB，就得编写 USB 驱动，好在ST 官方提供了一套完整的 USB驱动库，通过这个库，我们可以很方便的实现USB功能，而不需要详细了解 USB的整个驱动，大大缩短了我们的开发时间和精力。</p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606221327095.png" alt="image-20230606221327095" style="zoom:80%;" /></p><p>利用 STM32 自带的 USB 功能,连接电脑 USB,虚拟出一个USB串口，实现电脑和开发板的数据通信。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>激活USB，参数默认即可。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606222512234.png" alt="image-20230606222512234" style="zoom:80%;" /></p><ul><li>RCC设置外接HSE，主时钟设置为72M，USB时钟设置为48M。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606222338962.png" alt="image-20230606222338962" style="zoom:80%;" /></p><ul><li>在中间件中选择 <code>USB_DEVICE</code> 设置，在<code>Class For FS IP</code> 设备类别选择<code>Communication Device Class（Virtual Port Com）</code>虚拟串口，参数保持默认。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606222858420.png" alt="image-20230606222858420" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在usbd_cdc_if.c文件中找到发送和接收函数，其中，发生函数可以在外调用，接收函数则是自动触发，为了在串口助手中回送数据，需要在接收函数中添加发送函数。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  Data received over USB OUT endpoint are sent over CDC interface</span><span class="hljs-comment">  *         through this function.</span><span class="hljs-comment">  *</span><span class="hljs-comment">  *         @note</span><span class="hljs-comment">  *         This function will issue a NAK packet on any OUT packet received on</span><span class="hljs-comment">  *         USB endpoint until exiting this function. If you exit this function</span><span class="hljs-comment">  *         before transfer is complete on CDC interface (ie. using DMA controller)</span><span class="hljs-comment">  *         it will result in receiving more data while previous ones are still</span><span class="hljs-comment">  *         not sent.</span><span class="hljs-comment">  *</span><span class="hljs-comment">  * @param  Buf: Buffer of data to be received</span><span class="hljs-comment">  * @param  Len: Number of data received (in bytes)</span><span class="hljs-comment">  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">int8_t</span> <span class="hljs-title function_">CDC_Receive_FS</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* Buf, <span class="hljs-type">uint32_t</span> *Len)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 6 */</span>  USBD_CDC_SetRxBuffer(&amp;hUsbDeviceFS, &amp;Buf[<span class="hljs-number">0</span>]);  USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS);  CDC_Transmit_FS(Buf, *Len);<span class="hljs-comment">//添加回送函数</span>  <span class="hljs-keyword">return</span> (USBD_OK);  <span class="hljs-comment">/* USER CODE END 6 */</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  CDC_Transmit_FS</span><span class="hljs-comment">  *         Data to send over USB IN endpoint are sent over CDC interface</span><span class="hljs-comment">  *         through this function.</span><span class="hljs-comment">  *         @note</span><span class="hljs-comment">  *</span><span class="hljs-comment">  *</span><span class="hljs-comment">  * @param  Buf: Buffer of data to be sent</span><span class="hljs-comment">  * @param  Len: Number of data to be sent (in bytes)</span><span class="hljs-comment">  * @retval USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">CDC_Transmit_FS</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* Buf, <span class="hljs-type">uint16_t</span> Len)</span>&#123;  <span class="hljs-type">uint8_t</span> result = USBD_OK;  <span class="hljs-comment">/* USER CODE BEGIN 7 */</span>  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;  <span class="hljs-keyword">if</span> (hcdc-&gt;TxState != <span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">return</span> USBD_BUSY;  &#125;  USBD_CDC_SetTxBuffer(&amp;hUsbDeviceFS, Buf, Len);  result = USBD_CDC_TransmitPacket(&amp;hUsbDeviceFS);  <span class="hljs-comment">/* USER CODE END 7 */</span>  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><ul><li>在main.c函数中添加测试代码：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;usbd_cdc_if.h&quot;</span></span><span class="hljs-comment">/* USER CODE END Includes */</span><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint8_t</span> usb_send_buffer[] = <span class="hljs-string">&quot;This is USB Virtual Test.\r\n&quot;</span>;<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;CDC_Transmit_FS(usb_send_buffer, <span class="hljs-keyword">sizeof</span>(usb_send_buffer));HAL_Delay(<span class="hljs-number">1000</span>);<span class="hljs-comment">/* USER CODE END WHILE */</span><span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;</code></pre></div><ul><li>编译正常，下载到开发板，将USB连接线连接电脑和开发板的USBSLAVE口，打开串口助手，选择出现的虚拟端口号，串口不停的发送数据，当从串口助手发送数据时，也会回显到串口助手上。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606235349209.png" alt="image-20230606235349209" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606235715688.png" alt="image-20230606235715688" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/usb.zip">usb</a></p><h4 id="参考链接">参考链接：</h4><p>http://t.csdn.cn/ZrHap</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之FatFs文件系统</title>
    <link href="/2023/05/31/STM32CubeMX%E4%B9%8BFatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/05/31/STM32CubeMX%E4%B9%8BFatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="fatfs-文件系统">FatFs 文件系统</h3><p>文件系统是为了存储和管理数据，而在存储介质中建立的一种组织结构，这些结构包括操作系统引导区、目录和文件。常见的windows 下的文件系统格式包括FAT32、NTFS、exFAT。在使用文件系统前，要先对存储介质进行格式化。</p><p>使用文件系统时，数据都以文件的形式存储。写入新文件时，先在目录中创建一个文件索引，它指示了文件存放的物理地址，再把数据存储到该地址中。当需要读取数据时，可以从目录中找到该文件的索引，进而在相应的地址中读取出数据。</p><p>FatFs 就是一个完全免费开源，面向小型嵌入式系统的一种通用的 FAT文件系统。它完全是由 ANSI C 语言编写并且完全独立于底层的 I/O介质。因此它可以很容易地不加修改地移植到其他的处理器当中，如8051、PIC、AVR、SH、Z80、H8、ARM 等。FatFs 支持 FAT12、FAT16、FAT32等格式。</p><p>FatFs 文件系统官网：http://elm-chan.org/fsw/ff/00index_e.html</p><p>FatFs 模块的层次结构如下图示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531201529949.png" alt="image-20230531201529949" style="zoom:80%;" /></p><p>一般只需要编写最底层驱动代码，它包括存储媒介读／写接口（diskI/O）和供给文件创建修改时间的实时时钟等。</p><p>FatFs源码相关文件如下表示，移植时，一般只需要修改2个文件（即<strong>ffconf.h</strong>和<strong>diskio.c</strong>）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531202042461.png" alt="image-20230531202042461" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>使用FatFs 文件系统对SD卡进行相关操作，并使用串口1来打印调试信息。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531193736005.png" alt="image-20230531193736005" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活CRC；</li><li>激活SDIO，选择4线SD模式，使能硬件流控，分频因子设为4，其余默认设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531195623706.png" alt="image-20230531195623706" style="zoom:80%;" /></p><ul><li>打开FATFS文件系统，按下图配置，其余默认值</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531215923184.png" alt="image-20230531215923184" style="zoom:80%;" /></p><ul><li>增大堆空间</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531220058287.png" alt="image-20230531220058287" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在main.c中添加测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint32_t</span> wr_size;                <span class="hljs-comment">/* File write counts */</span><span class="hljs-type">uint32_t</span> rd_size;                 <span class="hljs-comment">/* File read counts */</span><span class="hljs-type">uint8_t</span> wr_buffer[] = <span class="hljs-string">&quot;This is STM32 working with FatFs.&quot;</span>; <span class="hljs-comment">/* File write buffer */</span><span class="hljs-type">uint8_t</span> rd_buffer[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;                   <span class="hljs-comment">/* File read buffers */</span><span class="hljs-type">char</span> *filename = <span class="hljs-string">&quot;STM32cubemx.txt&quot;</span>; <span class="hljs-comment">/* File will be open */</span><span class="hljs-type">char</span> *sensor_file = <span class="hljs-string">&quot;Sensor.txt&quot;</span>; <span class="hljs-comment">/* File will be create */</span><span class="hljs-type">char</span> sensor_buffer[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">/* 写入的数据缓存*/</span><span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fatfs_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">/* 1.挂载SD卡，进行格式化测试 */</span>retSD = f_mount(&amp;SDFatFS,SDPath,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(retSD == FR_NO_FILESYSTEM)<span class="hljs-comment">/* SD卡没有文件系统 */</span>  &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡还没有文件系统，即将进行格式化...\r\n&quot;</span>);retSD = f_mkfs(SDPath, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 格式化 */</span><span class="hljs-keyword">if</span>(retSD == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡格式化成功。\r\n&quot;</span>);retSD = f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 格式化后，先取消挂载 */</span>retSD = f_mount(&amp;SDFatFS, SDPath, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 重新挂载 */</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡格式化失败。\r\n&quot;</span>);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);&#125;  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(retSD != FR_OK) <span class="hljs-comment">/* SD卡挂载出现其它错误，打印错误码 */</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡挂载失败。%d \r\n&quot;</span>, retSD);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">/* SD卡挂载成功 */</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件系统挂载成功，可以进行读写测试!!!\r\n&quot;</span>);&#125;<span class="hljs-comment">/* 2.文件系统测试，写测试 */</span>  <span class="hljs-keyword">if</span>(f_open(&amp;SDFile, filename, FA_CREATE_ALWAYS | FA_WRITE) == FR_OK)  &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 打开文件成功，开始写入指定数据...\r\n&quot;</span>);retSD = f_write(&amp;SDFile, wr_buffer, <span class="hljs-keyword">sizeof</span>(wr_buffer), &amp;wr_size);<span class="hljs-comment">/* 将指定存储区内容写入到文件内 */</span><span class="hljs-keyword">if</span>(retSD == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 成功写入 %d 字节数据。\r\n&quot;</span>, wr_size);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 写入的数据 : %s\r\n&quot;</span>, wr_buffer);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件写入失败，错误码： %d\r\n&quot;</span>, retSD);&#125;f_close(&amp;SDFile);<span class="hljs-comment">/* 不再读写，关闭文件 */</span>  &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件打开失败。\r\n&quot;</span>);&#125;<span class="hljs-comment">/* 3.文件系统测试，读测试 */</span><span class="hljs-keyword">if</span>(f_open(&amp;SDFile, filename, FA_OPEN_EXISTING | FA_READ) == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 打开文件成功，开始读取数据...\r\n&quot;</span>);retSD = f_read(&amp;SDFile, rd_buffer, <span class="hljs-keyword">sizeof</span>(rd_buffer), &amp;rd_size);<span class="hljs-comment">/* 读取数据 */</span><span class="hljs-keyword">if</span>(retSD == FR_OK) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 成功读取 %d 字节数据。\r\n&quot;</span>, rd_size);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 读取的数据: %s\r\n&quot;</span>, rd_buffer);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 读取文件失败，错误码： %d\r\n&quot;</span>, retSD);&#125;f_close(&amp;SDFile);<span class="hljs-comment">/* 不再读写，关闭文件 */</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件打开失败。\r\n&quot;</span>);&#125;<span class="hljs-comment">/* 4.文件系统测试，创建文件 */</span><span class="hljs-keyword">if</span>(f_open(&amp;SDFile,sensor_file,FA_CREATE_ALWAYS|FA_WRITE) == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; %s 文件创建成功。\r\n&quot;</span>, sensor_file);<span class="hljs-comment">/* 首先写入项目栏参数 */</span><span class="hljs-built_in">sprintf</span>(sensor_buffer, <span class="hljs-string">&quot;Item\tTemp\tHumi\tLight\r\n&quot;</span>);f_write(&amp;SDFile, sensor_buffer, <span class="hljs-built_in">strlen</span>(sensor_buffer), &amp;wr_size);    <span class="hljs-comment">/* 然后写入具体数据 */</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<span class="hljs-built_in">sprintf</span>(sensor_buffer, <span class="hljs-string">&quot;%d\t%d\t%d\t%d\r\n&quot;</span>,i + <span class="hljs-number">1</span>, i + <span class="hljs-number">20</span>, i + <span class="hljs-number">30</span>, i + <span class="hljs-number">40</span>);f_write(&amp;SDFile,sensor_buffer, <span class="hljs-built_in">strlen</span>(sensor_buffer), &amp;wr_size);f_sync(&amp;SDFile);&#125;f_close(&amp;SDFile);  &#125;  f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 不再使用文件系统，取消挂载文件系统 */</span>&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>编译无误下载到开发板后，串口打印出如下信息：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230605205919074.png" alt="image-20230605205919074" style="zoom:80%;" /></p><p>将SD卡插入PC后，可以看到SD卡里建立了2个文件：Sensor.txt和STM32cubemx.txt，打开文件后可以看到写入的数据</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230605210046746.png" alt="image-20230605210046746" style="zoom: 67%;" /></p><p>工程代码Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/fatfs_sd.zip">fatfs</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之SDIO_SD卡</title>
    <link href="/2023/05/31/STM32CubeMX%E4%B9%8BSDIO_SD%E5%8D%A1/"/>
    <url>/2023/05/31/STM32CubeMX%E4%B9%8BSDIO_SD%E5%8D%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="sd卡介绍">SD卡介绍</h3><p>SD卡（Secure Digital Memory Card）即：安全数码卡。</p><p>根据容量大小，有下面几种分类：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531172428049.png" alt="image-20230531172428049" style="zoom:80%;" /></p><p>关于SD卡其他介绍，可参考 <ahref="https://www.baidu.com/link?url=sXgupcfG8fflzEDeeUlhH7psACkhlMJWwL8aFDGca27sSn-LNEp_vK-jAyAPEjvk&amp;wd=&amp;eqid=c46ac4b50003b4c30000000664771096">SD卡通识篇</a></p><p>SD卡物理结构：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531182505470.png"alt="image-20230531182505470" /><figcaption aria-hidden="true">image-20230531182505470</figcaption></figure><table><thead><tr class="header"><th>SD卡寄存器</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>CID（Card identification number）</td><td>SD卡唯一识别码</td></tr><tr class="even"><td>RCA（Relative card address）</td><td>SD卡本地系统相对地址</td></tr><tr class="odd"><td>DSR（Driver Stage Register）</td><td>配置SD卡输出驱动</td></tr><tr class="even"><td>CSD（Card Specific Data）</td><td>SD卡操作状态特定信息</td></tr><tr class="odd"><td>SCR（SD Configuration Register）</td><td>SD卡特殊信息性能配置</td></tr><tr class="even"><td>OCR（Operation conditions Register）</td><td>SD卡操作状态信息</td></tr><tr class="odd"><td>SSR（SD Status）</td><td>SD卡属性信息</td></tr><tr class="even"><td>CSR（Card Status）</td><td>SD卡的状态</td></tr></tbody></table><p>SD卡初始化流程：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531190032444.png"alt="image-20230531190032444" /><figcaption aria-hidden="true">image-20230531190032444</figcaption></figure><h3 id="sdio-简介">SDIO 简介</h3><p>SDIO ，全称： Secure Digital Input andOutput，即安全数字输入输出接口。STM32的SDIO控制器支持多媒体卡（MMC卡）、SD存储卡、SDI/O卡和CE-ATA设备。</p><p>SDIO框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531192743598.png" alt="image-20230531192743598" style="zoom:80%;" /></p><p>其中，SDIO 适配器</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531193038925.png" alt="image-20230531193038925" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>插上SD卡，开机的初始化 SD 卡，如果 SD卡初始化完成，则串口1打印初始化成功，没初始化成功，则打印初始化失败。然后打印SD卡相关信息，最后写入和读取SD 卡扇区 0 的数据，通过串口1发送到电脑。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531193736005.png" alt="image-20230531193736005" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活SDIO，选择4线SD模式，使能硬件流控，分频因子设为4，其余默认设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531195623706.png" alt="image-20230531195623706" style="zoom:80%;" /></p><ul><li>最好激活CRC功能，以避免后续读写SD卡报CRC校验错误</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531195739768.png" alt="image-20230531195739768" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击 GENERATE CODE，生成工程代码。</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在sdio.c文件下可以看到sdio初始化函数，同时在该文件下添加显示SD卡信息函数,并在sdio.h头文件中声明。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-comment">//显示SD卡信息函数</span><span class="hljs-type">void</span> <span class="hljs-title function_">Show_SDMMC_Info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;HAL_SD_CardCIDTypeDef SDCard_CID;HAL_SD_CardInfoTypeDef SDCard_INFO;<span class="hljs-type">uint64_t</span> CardCap;<span class="hljs-comment">//SD卡容量</span>HAL_SD_GetCardCID(&amp;hsd,&amp;SDCard_CID);<span class="hljs-comment">//获取CID</span>HAL_SD_GetCardInfo(&amp;hsd,&amp;SDCard_INFO);<span class="hljs-comment">//获取SD卡信息</span><span class="hljs-keyword">switch</span>(SDCard_INFO.CardType)<span class="hljs-comment">//SD卡类型</span>&#123;<span class="hljs-keyword">case</span> CARD_SDSC:<span class="hljs-keyword">if</span>(SDCard_INFO.CardVersion == CARD_V1_X)      &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Type: SDSC V1\r\n&quot;</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(SDCard_INFO.CardVersion == CARD_V2_X)      &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Type: SDSC V2\r\n&quot;</span>);&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> CARD_SDHC_SDXC:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Type: SDHC\r\n&quot;</span>);<span class="hljs-keyword">break</span>;&#125;CardCap = (<span class="hljs-type">uint64_t</span>)(SDCard_INFO.LogBlockNbr)*(<span class="hljs-type">uint64_t</span>)(SDCard_INFO.LogBlockSize)/<span class="hljs-number">1024</span>/<span class="hljs-number">1024</span>;<span class="hljs-comment">//计算SD卡容量(单位：MB)</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card ManufacturerID: %d\r\n&quot;</span>,SDCard_CID.ManufacturerID);<span class="hljs-comment">//制造商ID</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card RelativeAddress: %d\r\n&quot;</span>,SDCard_INFO.RelCardAdd);<span class="hljs-comment">//卡相对地址</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LogicBlockNumber: %d\r\n&quot;</span>,SDCard_INFO.LogBlockNbr);<span class="hljs-comment">//逻辑块数量</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LogBlockSize: %d\r\n&quot;</span>,SDCard_INFO.LogBlockSize);<span class="hljs-comment">//逻辑块大小</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Capacity: %d MB\r\n&quot;</span>,(<span class="hljs-type">uint32_t</span>)CardCap);<span class="hljs-comment">//显示容量</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card BlockSize: %d\r\n&quot;</span>,SDCard_INFO.BlockSize);<span class="hljs-comment">//块大小</span>&#125;<span class="hljs-comment">/* USER CODE END 1 */</span></code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main.c文件中编写SD卡读写测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-comment">/* USER CODE END Includes */</span><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> Buffer_Tx[<span class="hljs-number">256</span>],Buffer_Rx[<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-type">uint32_t</span> i;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span> Show_SDMMC_Info();<span class="hljs-comment">/* 准备好数据 */</span><span class="hljs-comment">//  memset(Buffer_Tx,0x15,sizeof(Buffer_Tx));</span><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)&#123;    Buffer_Tx[i] = i;&#125;<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">/* 擦除SD卡 */</span>    <span class="hljs-keyword">if</span>(HAL_SD_Erase(&amp;hsd,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) == HAL_OK)    &#123;        <span class="hljs-keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) != HAL_SD_CARD_TRANSFER);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nErase Block Success!\r\n&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nErase Block Failed!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">100</span>);    <span class="hljs-comment">/* 向SD卡写数据 */</span>        <span class="hljs-keyword">if</span>(HAL_SD_WriteBlocks(&amp;hsd,Buffer_Tx,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0xffffffff</span>) == HAL_OK)    &#123;        <span class="hljs-keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) != HAL_SD_CARD_TRANSFER);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Write Block Success!\r\n&quot;</span>);        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">sizeof</span>(Buffer_Tx); i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02x:%02d  &quot;</span>, i, Buffer_Tx[i]);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Write Block Failed!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">100</span>);    <span class="hljs-comment">/* 读取SD卡数据 */</span>    <span class="hljs-keyword">if</span>(HAL_SD_ReadBlocks(&amp;hsd,Buffer_Rx,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0xffffffff</span>) == HAL_OK)    &#123;        <span class="hljs-keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) != HAL_SD_CARD_TRANSFER);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nRead Block Success!\r\n&quot;</span>);        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">sizeof</span>(Buffer_Rx); i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02x:%02d  &quot;</span>, i, Buffer_Rx[i]);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nRead Block Failed!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">2000</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，插入SD卡，打开串口助手，显示SD卡信息及其他数据</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230602185047037.png"alt="image-20230602185047037" /><figcaption aria-hidden="true">image-20230602185047037</figcaption></figure><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/sdio.zip">sdio</a></p><h3 id="参考链接">参考链接：</h3><p>https://www.sdcard.org/downloads/pls/</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之内存管理</title>
    <link href="/2023/05/31/STM32CubeMX%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/31/STM32CubeMX%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>STM32F103ZET6内部有64KB的SRAM内存，加上外扩的128KB容量的SRAM后，可使用的内存还是比较多的。内存管理是指软件运行时对计算机内存资源的分配和使用的技术，其最主要的目的是如何高效、快速的分配，并且在适当的时候释放和回收内存资源。</p><p>这里介绍一种比较简单的内存管理方法：分块式内存管理，其实现原理如下图示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531163251884.png" alt="image-20230531163251884" style="zoom:80%;" /></p><p>内存管理表的项值代表的意义为：该项值代表该项对应的内存块已经被占用，其数值则代表被连续占用的内存块数。比如某项值为10，那么说明包括本项对应的内存块在内，总共分配了10 个内存块给外部的某个指针。</p><p><strong>分配原理</strong>：当指针p调用malloc申请内存的时候，先判断p要分配的内存块数（m），然后从第n项开始，向下查找，直到找到m块连续的空内存块（即对应内存管理表项为0），然后将这m个内存管理表项的值都设置为m（标记被占用），最后把剩下空内存块的地址返回指针p，完成一次分配。注意，如果当内存不够的时候（找到最后也没找到连续的m块空闲内存），则返回NULL给p，表示分配失败。</p><p><strong>释放原理</strong>：当p申请的内存用完，需要释放的时候，调用free函数实现。free函数先判断p指向的内存地址所对应的内存块，然后找到对应的内存管理表项目，得到p所占用的内存块数目m（内存管理表项目的值就是所分配内存块的数目），将这m个内存管理表项目的值都清零，标记释放，完成一次内存释放。</p><p><strong>注意</strong>：申请的内存在用完以后，一定要释放。</p><h3 id="硬件设计">硬件设计</h3><p>KEY0 用于申请内存，每次申请 2K 字节内存。KEY1用于写数据到申请到的内存里面。KEY2用于释放内存。UART1用来显示内存状态及内存使用率.</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PE2/PE3/PE4设置为GPIO输入模式、上拉；PA0设置为GPIO输入模式，下拉；</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>添加内存管理驱动文件malloc.c和malloc.h，可直接移植正点原子代码。</li><li>添加按键驱动文件key.c和key.h,可参照前面按键输入一章。</li><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main.c文件下添加相应的头文件，编写内存管理测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> key=<span class="hljs-number">0</span>, i=<span class="hljs-number">0</span>, *p=<span class="hljs-number">0</span>; <span class="hljs-type">uint8_t</span> paddr[<span class="hljs-number">8</span>];<span class="hljs-type">uint8_t</span> sramx=<span class="hljs-number">0</span>;<span class="hljs-comment">//默认为内部sram</span><span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-comment">/* 初始化内部内存池 */</span>my_mem_init(SRAMIN);<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    key = key_scan(<span class="hljs-number">0</span>);    <span class="hljs-keyword">switch</span>(key)    &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> KEY0_PRES:            &#123;                p = mymalloc(sramx, <span class="hljs-number">2048</span>); <span class="hljs-comment">//创建2k 字节空间并写入内容</span>                <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)                &#123;                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2K byte space create success!\r\n&quot;</span>);                    <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span>*)p, <span class="hljs-string">&quot;Memory Malloc Test%03d&quot;</span>,i); <span class="hljs-comment">//写入内容</span>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\r\n&quot;</span>, p);                &#125;                <span class="hljs-keyword">break</span>;            &#125;           <span class="hljs-keyword">case</span> KEY1_PRES:            &#123;                <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)                &#123;                    <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span>*)paddr, <span class="hljs-string">&quot;Create space Addr:0X%08X&quot;</span>, (<span class="hljs-type">uint32_t</span>)p);<span class="hljs-comment">//显示p的地址</span>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\r\n&quot;</span>, paddr);                &#125;                <span class="hljs-keyword">break</span>;            &#125;        <span class="hljs-keyword">case</span> KEY2_PRES:            &#123;                myfree(sramx, p); <span class="hljs-comment">//释放内存</span>                p = <span class="hljs-number">0</span>;                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2K byte space is free now!\r\n&quot;</span>);                <span class="hljs-keyword">break</span>;            &#125;        <span class="hljs-keyword">case</span> WKUP_PRES:            &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Internal RAM usage：%d%%\r\n&quot;</span>,my_mem_perused(SRAMIN)); <span class="hljs-comment">//显示内部内存使用率</span>                i++;            &#125;    &#125;  &#125;</code></pre></div><ul><li>编译无误下载到开发板后，KEY0 用于申请内存，每次申请 2K字节内存，并写入内容，KEY1 显示写入的内容，KEY2用于释放内存，KEY_UP显示内部内存使用率。串口助手显示内存状态及内存使用率.</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230602235006078.png" alt="image-20230602235006078" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/mem_management.zip">mem_management</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之外部SRAM</title>
    <link href="/2023/05/31/STM32CubeMX%E4%B9%8B%E5%A4%96%E9%83%A8SRAM/"/>
    <url>/2023/05/31/STM32CubeMX%E4%B9%8B%E5%A4%96%E9%83%A8SRAM/</url>
    
    <content type="html"><![CDATA[<h3 id="外部sramxm8a51216简介">外部SRAM(XM8A51216)简介</h3><p>STM32F103ZET6芯片自带64K字节的SRAM，对一般应用已经足够了，但在一些对内存要求高的场合，就需要添加外部SRAM了，开发板上带有一颗1M 字节（512K x 16bit）容量的 SRAM 芯片：IS62WV51216BLL；</p><p>其逻辑功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604164952473.png" alt="image-20230604164952473" style="zoom:80%;" /></p><p>芯片操作控制表：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531153007310.png" alt="image-20230531153007310" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531134019640.png" alt="image-20230531134019640" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531083826527.png" alt="image-20230531083826527" style="zoom:80%;" /></p><p>实验使用 FSMC BANK1的第<strong>3</strong>区来控制IS62WV51216BLL，将外部 SRAM 容量大小显示在LCD 上延时一段时间，显示预存在外部 SRAM 的数据。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活FSMC，选中Bank1，片选为NE3（即Bank1的第3区），存储器类型选为SRAM，数据宽度设为16位,勾选Byte enable。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531161352775.png" alt="image-20230531161352775" style="zoom:80%;" /></p><ul><li>在FSMC配置菜单中，使能存储器写，根据SRAM驱动芯片的数据参数设置地址建立时间、数据保存时间、总线周转阶段持续时间（设置为0），模式A</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531162647366.png" alt="image-20230531162647366" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>添加IS62WV51216BLL芯片驱动文件sram.c和sram.h</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief在指定地址(WriteAddr+Bank1_SRAM3_ADDR)开始,连续写入n个字节.</span><span class="hljs-comment">  * @parampBuffer:字节指针</span><span class="hljs-comment">  * @param  WriteAddr:要写入的地址</span><span class="hljs-comment">  * @param  n:要写入的字节数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fsmc_sram_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pBuffer,<span class="hljs-type">uint32_t</span> WriteAddr,<span class="hljs-type">uint32_t</span> n)</span>&#123;<span class="hljs-keyword">while</span>(n--)&#123;*(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>*)(Bank1_SRAM3_ADDR+WriteAddr)=*pBuffer;WriteAddr++;pBuffer++;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief在指定地址((WriteAddr+Bank1_SRAM3_ADDR))开始,连续读出n个字节.</span><span class="hljs-comment">  * @parampBuffer:字节指针</span><span class="hljs-comment">  * @param  ReadAddr:要读出的起始地址</span><span class="hljs-comment">  * @param  n:要读出的字节数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fsmc_sram_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pBuffer,<span class="hljs-type">uint32_t</span> ReadAddr,<span class="hljs-type">uint32_t</span> n)</span>&#123;<span class="hljs-keyword">while</span>(n--)&#123;*pBuffer++=*(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>*)(Bank1_SRAM3_ADDR+ReadAddr);ReadAddr++;&#125;&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main.c文件下编写SRAM测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fsmc_sram_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> writeData = <span class="hljs-number">0xf0</span>, readData;<span class="hljs-type">uint16_t</span> cap = <span class="hljs-number">0</span>;<span class="hljs-comment">//SRAM 容量大小</span><span class="hljs-type">uint32_t</span> addr;  <span class="hljs-comment">/* 以1024字节为单位计算，IS62WV51216的容量为1MB */</span><span class="hljs-keyword">for</span>(addr = <span class="hljs-number">1024</span>; addr &lt;= <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; addr += <span class="hljs-number">1024</span>)&#123;  fsmc_sram_write(&amp;writeData, addr, <span class="hljs-number">1</span>);  fsmc_sram_read(&amp;readData, addr, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(readData == writeData)&#123;cap++;<span class="hljs-comment">//如果相同表示写入/读出成功，容量加1KB</span>readData = <span class="hljs-number">0</span>; <span class="hljs-comment">//读出的值清零 </span>&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;External SRAM Memory Size: %dKB\r\n&quot;</span>, cap);&#125;<span class="hljs-comment">/* USER CODE END 0 */</span><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> write_string[] = <span class="hljs-string">&quot;This is SRAM testing...&quot;</span>;<span class="hljs-type">uint8_t</span> textlen = <span class="hljs-keyword">sizeof</span>(write_string);<span class="hljs-type">uint8_t</span> read_buf[textlen];<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_Delay(<span class="hljs-number">100</span>);fsmc_sram_test();<span class="hljs-comment">//打印SRAM大小</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    fsmc_sram_write(write_string, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(write_string));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SRAM_Write:%s\r\n&quot;</span>, write_string);    HAL_Delay(<span class="hljs-number">1000</span>);    fsmc_sram_read(read_buf, <span class="hljs-number">0</span>, textlen);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SRAM_Read:%s\r\n&quot;</span>, read_buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，串口助手打印出外部SRAM大小：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604181111942.png" alt="image-20230604181111942" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/sram.zip">sram</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之FSMC_TFTLCD</title>
    <link href="/2023/05/30/STM32CubeMX%E4%B9%8BFSMC-TFTLCD/"/>
    <url>/2023/05/30/STM32CubeMX%E4%B9%8BFSMC-TFTLCD/</url>
    
    <content type="html"><![CDATA[<h3 id="tftlcd简介">TFTLCD简介</h3><p>TFT-LCD（thin film transistor-liquid crystaldisplay）即薄膜晶体管液晶显示器。液晶显示屏的每一个像素上都设置有一个薄膜晶体管（TFT），每个像素都可以通过点脉冲直接控制。</p><p>常用的通信模式有6800模式和8080模式，本例程使用8080并口模式（简称80并口），8080接口有5条基本的控制线和多条数据线（8/9/16/18位）：</p><ul><li><p>CS：TFTLCD 片选信号。</p></li><li><p>WR：向 TFTLCD 写入数据。</p></li><li><p>RD：从 TFTLCD 读取数据。</p></li><li><p>RST：硬复位 TFTLCD。</p></li><li><p>RS：命令/数据标志（0，读写命令；1，读写数据）。</p></li><li><p>D[15：0]：16 位双向数据线。</p></li></ul><p>实验中使用的LCD是正点原子TFTLCD，其内部控制芯片ILI9341，其功能框图如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531102629121.png" alt="image-20230531102629121"  /></p><p><strong>ILI9341 部分重要命令</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082242026.png" alt="image-20230606082242026" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082317721.png" alt="image-20230606082317721" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082349293.png" alt="image-20230606082349293" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082521224.png" alt="image-20230606082521224" style="zoom:80%;" /></p><p><strong>8080时序图：</strong></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531103103667.png"alt="image-20230531103103667" /><figcaption aria-hidden="true">image-20230531103103667</figcaption></figure><p>一般 TFTLCD 模块的使用流程：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531103242060.png" alt="image-20230531103242060" style="zoom:80%;" /></p><p>其中，其中硬复位和初始化序列，只需要执行一次。</p><p>例如点操作流程：</p><ul><li>画点：设置坐标 → 写 GRAM 指令 → 写入颜色数据 → LCD 上显示颜色；</li><li>读点：设置坐标 → 读 GRAM 指令 → 读取颜色数据 →获取到对应点的颜色；</li></ul><p>设置TFT液晶显示通常需要以下几个步骤：</p><ul><li><p>设置STM32F1与TFTLCD模块连接的IO口，将与TFTLCD模块相连的IO口进行初始化，以便驱动LCD，ILI9341的 8080 通讯接口时序可以由 STM32 普通 I/O接口进行模拟，但这样效率太低，STM32 提供了一种特别的控制方法——使用 FSMC接口实现 8080接口时序。</p></li><li><p>初始化TFTLCD模块，向LCD控制器写入一系列的设置值（比如RGB格式、LCD显示方向、伽马校准等），这部分代码一般LCD厂商会提供，初始化之后LCD才可以正常使用。</p></li><li><p>通过函数将字符和数字显示到TFTLCD模块上，点操作只是一个点的处理，因此需要设计一个函数来多次使用这个步骤以实现字符和数字的显示。</p></li></ul><h3 id="fsmc-简介">FSMC 简介</h3><p>FSMC（Flexible Static MemoryController即灵活的静态存储控制器）是STM32系列采用的一种新型存储器扩展技术，能够连接同步、异步存储器和16位PC存储卡，STM32通过FSMC可以与SRAM、ROM、PSRAM、NORFlash和NAND Flash等存储器的引脚直接相连。</p><h4 id="stm32f1的fsmc内部框图">STM32F1的FSMC内部框图</h4><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530152947731.png" alt="image-20230530152947731" style="zoom:80%;" /></p><p>从上图我们可以看出，STM32 的 FSMC 将外部设备分为 3 类：NOR/PSRAM设备、NAND设备、PC卡设备。他们共用地址、数据总线等信号，具有不同的片选(NE[4:1])以区分不同的设备。</p><h4 id="fsmc-存储器划分">FSMC 存储器划分</h4><p>FSMC 将外部存储器划分固定大小为 256M 字节的四个存储块,如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530155325449.png" alt="image-20230530155325449" style="zoom:80%;" /></p><ul><li><strong>NOR/PSRAM块</strong>有四个区：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531083826527.png" alt="image-20230531083826527" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531084817727.png" alt="image-20230531084817727" style="zoom:80%;" /></p><ul><li><strong>NAND Flash块和PC Card块</strong>：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531091707020.png" alt="image-20230531091707020" style="zoom:80%;" /></p><p>​ 其中，NAND Flash有三个区：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531091542061.png" alt="image-20230531091542061" style="zoom:80%;" /></p><h4 id="传输时序模式">传输时序模式</h4><ul><li><p>NOR Flash/PSRAM 控制器 <strong>异步</strong> 传输时序模式：</p><ul><li><p><strong>Mode 1</strong> - SRAM/PSRAM (CRAM)</p></li><li><p><strong>Mode A</strong> - SRAM/PSRAM (CRAM) 输出使能触发</p></li><li><p><strong>Mode 2/B</strong> - NOR Flash</p></li><li><p><strong>Mode C</strong> - NOR Flash 输出使能触发</p></li><li><p><strong>Mode D</strong> - 扩展地址异步传输</p></li><li><p><strong>Muxed mode</strong> - NOR Flash复合异步传输</p></li></ul></li><li><p>NAND Flash和PC Card只有一种异步传输时序模式：</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531095320326.png" alt="image-20230531095320326" style="zoom:80%;" /></p><p>本实验中使用的TFTLCD采用Mode A模式连接到STM32 FSMC上，其ModeA读写时序如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531100226860.png" alt="image-20230531100226860" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531100246088.png" alt="image-20230531100246088" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531113726434.png" alt="image-20230531113726434" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530152024061.png" alt="image-20230530152024061" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>设置PB0为GPIO输出模式，上拉，高速，默认低电平。（背光控制信号）</li><li>选择FSMC，选中Bank1，片选为NE4（即Bank1的第4区），存储器类型选为LCDInterface，LCD寄存器选择（RS）设置为A10，数据宽度设为16位</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531114601180.png" alt="image-20230531114601180" style="zoom:80%;" /></p><ul><li>在FSMC配置菜单中，使能存储器写，根据LCD驱动芯片的数据参数设置地址建立时间、数据保存时间、总线周转阶段持续时间（设置为0），模式A</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531115913269.png" alt="image-20230531115913269" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>创建TFTLCD驱动文件tftlcd.c和tftlcd.h,部分代码如下，详细代码见工程。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* LCD重要参数集 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">uint16_t</span> width;     <span class="hljs-comment">/* LCD 宽度 */</span>    <span class="hljs-type">uint16_t</span> height;    <span class="hljs-comment">/* LCD 高度 */</span><span class="hljs-type">uint16_t</span> lcd_id;    <span class="hljs-comment">/* lcd id */</span>    <span class="hljs-type">uint8_t</span> dir;        <span class="hljs-comment">/* 横屏还是竖屏控制：0，竖屏；1，横屏。 */</span>&#125;<span class="hljs-type">lcd_dev_t</span>;<span class="hljs-comment">/* LCD背光控制 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_BL(x)   do&#123; x ? \</span><span class="hljs-meta">                      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET) : \</span><span class="hljs-meta">                      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET); \</span><span class="hljs-meta">                     &#125;while(0)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSMC_ADDR_CMD  ((uint32_t*)0x6C000000)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSMC_ADDR_DATA ((uint32_t*)0x6C000800) </span><span class="hljs-comment">/******************************************************************************************/</span><span class="hljs-comment">/* LCD 属性,根据使用的屏幕改变其属性 */</span><span class="hljs-comment">/** ---------------------------------</span><span class="hljs-comment"> * | LCD ID Type | Width or Height |</span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> * |    9343     |     240*320     | </span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> * | 5510/1963   |     480*800     |</span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> * |    5310     |     320*480     |</span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_WIDTH       240</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_HEIGHT      320</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_VERTICAL    0  </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_HORIZONTAL  1</span><span class="hljs-comment">/* LCD device ID */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_9341    (0X9341)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_8552    (0X8552)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_5510    (0X5510)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_1963    (0X1963)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_5310    (0X5310)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_7789    (0x7789)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_5761    (0X5761)</span><span class="hljs-comment">/******************************************************************************************/</span><span class="hljs-comment">/* ILI9341、SSD1963、ST7789、NT35310 command */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD9341_READ_ID   0xd3     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD7789_READ_ID   0x04     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5310_READ_ID   0xd4     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1963_READ_ID   0xa1     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_SCAN_DIR       0x36     <span class="hljs-comment">//scanning direction of frame memory.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_DISPLAY_ON     0x29     <span class="hljs-comment">//Display on</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_DISPLAY_OFF    0x28     <span class="hljs-comment">//Display off</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_ADDR_COLUMN    0x2a     <span class="hljs-comment">//X坐标 Column Address Set</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_ADDR_PAGE      0x2b     <span class="hljs-comment">//Y坐标 Page Address Set </span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_WR_GRAM        0x2c     <span class="hljs-comment">//Memory Write</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_RD_GRAM        0x2e     <span class="hljs-comment">//Memory Read</span></span><span class="hljs-comment">/* NT5510 command */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_READ_IDH       0xC500     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_READ_IDL       0xC501     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_SCAN_DIR       0x3600     <span class="hljs-comment">//scanning direction of frame memory.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_DISPLAY_ON     0x2900     <span class="hljs-comment">//Display on</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_DISPLAY_OFF    0x2800     <span class="hljs-comment">//Display off</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_ADDR_COLUMN    0X2A00     <span class="hljs-comment">//X坐标 Column Address Set</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_ADDR_PAGE      0X2B00     <span class="hljs-comment">//Y坐标 Page Address Set </span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_WR_GRAM        0X2C00     <span class="hljs-comment">//Memory Write</span></span><span class="hljs-comment">/* 屏幕扫描方向定义 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> L2R_U2D         0           <span class="hljs-comment">/* 从左到右,从上到下, 默认的扫描方向 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> L2R_D2U         1           <span class="hljs-comment">/* 从左到右,从下到上 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> R2L_U2D         2           <span class="hljs-comment">/* 从右到左,从上到下 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> R2L_D2U         3           <span class="hljs-comment">/* 从右到左,从下到上 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> U2D_L2R         4           <span class="hljs-comment">/* 从上到下,从左到右 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> U2D_R2L         5           <span class="hljs-comment">/* 从上到下,从右到左 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> D2U_L2R         6           <span class="hljs-comment">/* 从下到上,从左到右 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> D2U_R2L         7           <span class="hljs-comment">/* 从下到上,从右到左 */</span></span><span class="hljs-comment">/******************************************************************************************/</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_data</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> value)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_cmd</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> cmd)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_write_reg</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> cmd, <span class="hljs-type">uint16_t</span> value)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;                        <span class="hljs-comment">/* 初始化LCD */</span> <span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_clear</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> color)</span>;     <span class="hljs-comment">/* LCD清屏 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_draw_line</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x1, <span class="hljs-type">uint16_t</span> y1, <span class="hljs-type">uint16_t</span> x2, <span class="hljs-type">uint16_t</span> y2, <span class="hljs-type">uint16_t</span> color)</span>;     <span class="hljs-comment">/* 画直线 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_draw_rectangle</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x1, <span class="hljs-type">uint16_t</span> y1, <span class="hljs-type">uint16_t</span> x2, <span class="hljs-type">uint16_t</span> y2, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-comment">/* 画矩形 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_char</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">char</span> chr, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">uint8_t</span> mode, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_num</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> len, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_xnum</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> len, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">uint8_t</span> mode, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_string</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">uint16_t</span> width, <span class="hljs-type">uint16_t</span> height, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">char</span> *p, <span class="hljs-type">uint16_t</span> color)</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 定义一个LCD结构体变量 */</span><span class="hljs-type">lcd_dev_t</span> lcddev = &#123;.width = LCD_WIDTH,.height = LCD_HEIGHT,.dir = LCD_VERTICAL  <span class="hljs-comment">/* 默认为竖屏 */</span>&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD写数据</span><span class="hljs-comment"> * @param       data: 要写入的数据</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_data</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> value)</span>&#123;    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_DATA) = value;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD写指令</span><span class="hljs-comment"> * @param       cmd: lcd指令</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_cmd</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> cmd)</span>&#123;    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_CMD) = cmd;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD读数据</span><span class="hljs-comment"> * @param       无</span><span class="hljs-comment"> * @retval      读取到的数据</span><span class="hljs-comment"> */</span><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">lcd_rd_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-keyword">return</span> (*( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_DATA));&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD写寄存器</span><span class="hljs-comment"> * @param       cmd:指令</span><span class="hljs-comment"> * @param       data:要写入的数据</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_write_reg</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> cmd, <span class="hljs-type">uint16_t</span> value)</span>&#123;    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_CMD) = cmd;       <span class="hljs-comment">/* 写入要写的指令 */</span>    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_DATA) = value;    <span class="hljs-comment">/* 写入数据 */</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       初始化LCD</span><span class="hljs-comment"> * @note        该初始化函数可以初始化各种型号的LCD(详见本.c文件最前面的描述)</span><span class="hljs-comment"> * @param       无</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* 获取屏幕id */</span>  lcddev.lcd_id = lcd_read_id();  <span class="hljs-comment">/* 显示之前必须lcd芯片初始化 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_7789)    &#123;        lcd_ex_st7789_reginit();    <span class="hljs-comment">/* 执行ST7789初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_9341)    &#123;        lcd_ex_ili9341_reginit();   <span class="hljs-comment">/* 执行ILI9341初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5310)    &#123;        lcd_ex_nt35310_reginit();   <span class="hljs-comment">/* 执行NT35310初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5510)    &#123;        lcd_ex_nt35510_reginit();   <span class="hljs-comment">/* 执行NT35510初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_1963)    &#123;        lcd_ex_ssd1963_reginit();   <span class="hljs-comment">/* 执行SSD1963初始化 */</span>        lcd_ssd_set_backlight(<span class="hljs-number">100</span>); <span class="hljs-comment">/* 背光设置为最亮 */</span>    &#125;    <span class="hljs-comment">/* 设置屏幕大小、方向及扫描方向 */</span>  lcd_set_scan_dir(L2R_U2D);    <span class="hljs-comment">/* 开背光 */</span>    LCD_BL(<span class="hljs-number">1</span>);       <span class="hljs-comment">/* 清屏 */</span>    lcd_clear(WHITE);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       读取屏幕id</span><span class="hljs-comment"> * @param       None</span><span class="hljs-comment"> * @retval      屏幕id</span><span class="hljs-comment"> */</span><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">lcd_read_id</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* 尝试9341 ID的读取 */</span>    lcd_wr_cmd(LCD9341_READ_ID);    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* dummy read */</span>    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读到0X00 */</span>    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读取93 */</span>    lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;    lcddev.lcd_id |= lcd_rd_data(); <span class="hljs-comment">/* 读取41 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_9341)    <span class="hljs-comment">/* 不是 9341 , 尝试看看是不是 ST7789 */</span>    &#123;        lcd_wr_cmd(LCD7789_READ_ID);        lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* dummy read */</span>        lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* 读到0X85 */</span>        lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* 读取0X85 */</span>        lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;        lcddev.lcd_id |= lcd_rd_data();     <span class="hljs-comment">/* 读取0X52 */</span>                <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_8552)        <span class="hljs-comment">/* 将8552的ID转换成7789 */</span>        &#123;            lcddev.lcd_id = LCD_7789;        &#125;        <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_7789)        <span class="hljs-comment">/* 也不是ST7789, 尝试是不是 NT35310 */</span>        &#123;            lcd_wr_cmd(LCD5310_READ_ID);            lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* dummy read */</span>            lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读回0X01 */</span>            lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读回0X53 */</span>            lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;            lcddev.lcd_id |= lcd_rd_data(); <span class="hljs-comment">/* 这里读回0X10 */</span>            <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_5310)    <span class="hljs-comment">/* 也不是NT35310,尝试看看是不是NT35510 */</span>            &#123;                <span class="hljs-comment">/* 发送秘钥（厂家提供,照搬即可） */</span>                lcd_write_reg(<span class="hljs-number">0xF000</span>, <span class="hljs-number">0x0055</span>);                lcd_write_reg(<span class="hljs-number">0xF001</span>, <span class="hljs-number">0x00AA</span>);                lcd_write_reg(<span class="hljs-number">0xF002</span>, <span class="hljs-number">0x0052</span>);                lcd_write_reg(<span class="hljs-number">0xF003</span>, <span class="hljs-number">0x0008</span>);                lcd_write_reg(<span class="hljs-number">0xF004</span>, <span class="hljs-number">0x0001</span>);                                lcd_wr_cmd(LCD5510_READ_IDH);           <span class="hljs-comment">/* 读取ID高8位 */</span>                lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* 读回0X55 */</span>                lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;                lcd_wr_cmd(LCD5510_READ_IDL);           <span class="hljs-comment">/* 读取ID低8位 */</span>                lcddev.lcd_id |= lcd_rd_data();     <span class="hljs-comment">/* 读回0X10 */</span>                HAL_Delay(<span class="hljs-number">5</span>);                                <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_5510)        <span class="hljs-comment">/* 也不是NT5510,尝试看看是不是SSD1963 */</span>                &#123;                    lcd_wr_cmd(LCD1963_READ_ID);                    lcddev.lcd_id = lcd_rd_data();                    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读回0X57 */</span>                    lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;                    lcddev.lcd_id |= lcd_rd_data(); <span class="hljs-comment">/* 读回0X61 */</span>                    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5761)lcddev.lcd_id = LCD_1963; <span class="hljs-comment">/* SSD1963读回的ID是5761H,为方便区分,我们强制设置为1963 */</span>                &#125;            &#125;        &#125;    &#125;<span class="hljs-keyword">return</span> lcddev.lcd_id;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       设置LCD的自动扫描方向(对RGB屏无效)</span><span class="hljs-comment"> * @note</span><span class="hljs-comment"> *              9341/5310/5510/1963/7789等IC已经实际测试</span><span class="hljs-comment"> *              注意:其他函数可能会受到此函数设置的影响(尤其是9341),</span><span class="hljs-comment"> *              所以,一般设置为L2R_U2D即可,如果设置为其他扫描方式,可能导致显示不正常.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param       dir:0~7,代表8个方向</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_set_scan_dir</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> dir)</span>&#123;    <span class="hljs-type">uint16_t</span> regval = <span class="hljs-number">0</span>;    <span class="hljs-type">uint16_t</span> dirreg = <span class="hljs-number">0</span>;    <span class="hljs-type">uint16_t</span> temp;    <span class="hljs-comment">/* 横屏时，对1963不改变扫描方向！其他IC改变扫描方向！竖屏时1963改变方向，其他IC不改变扫描方向 */</span>    <span class="hljs-keyword">if</span> ((lcddev.dir == LCD_HORIZONTAL &amp;&amp; lcddev.lcd_id != LCD_1963) || (lcddev.dir == LCD_VERTICAL &amp;&amp; lcddev.lcd_id == LCD_1963))    &#123;        <span class="hljs-keyword">switch</span> (dir)   <span class="hljs-comment">/* 方向转换 */</span>        &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: dir = <span class="hljs-number">6</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: dir = <span class="hljs-number">7</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: dir = <span class="hljs-number">4</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: dir = <span class="hljs-number">5</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: dir = <span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: dir = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: dir = <span class="hljs-number">3</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: dir = <span class="hljs-number">2</span>; <span class="hljs-keyword">break</span>;        &#125;    &#125;<span class="hljs-comment">/* 根据扫描方式 设置 0X36/0X3600 寄存器 bit 5,6,7 位的值 */</span><span class="hljs-keyword">switch</span> (dir)&#123;<span class="hljs-keyword">case</span> L2R_U2D:<span class="hljs-comment">/* 从左到右,从上到下 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> L2R_D2U:<span class="hljs-comment">/* 从左到右,从下到上 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> R2L_U2D:<span class="hljs-comment">/* 从右到左,从上到下 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> R2L_D2U:<span class="hljs-comment">/* 从右到左,从下到上 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> U2D_L2R:<span class="hljs-comment">/* 从上到下,从左到右 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> U2D_R2L:<span class="hljs-comment">/* 从上到下,从右到左 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> D2U_L2R:<span class="hljs-comment">/* 从下到上,从左到右 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> D2U_R2L:<span class="hljs-comment">/* 从下到上,从右到左 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;&#125;dirreg = LCD_SCAN_DIR;  <span class="hljs-comment">/* 对绝大部分驱动IC, 由0X36寄存器控制 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5510)    &#123;        dirreg = LCD5510_SCAN_DIR;    <span class="hljs-comment">/* 对于5510, 和其他驱动ic的寄存器有差异 */</span>    &#125;     <span class="hljs-comment">/* 9341 &amp; 7789 要设置BGR位 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_9341 || lcddev.lcd_id == LCD_7789)    &#123;        regval |= <span class="hljs-number">0X08</span>;    &#125;lcd_write_reg(dirreg, regval);<span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_1963)   <span class="hljs-comment">/* 1963不做坐标处理 */</span>&#123;<span class="hljs-keyword">if</span> (regval &amp; <span class="hljs-number">0X20</span>)&#123;<span class="hljs-keyword">if</span> (lcddev.width &lt; lcddev.height)   <span class="hljs-comment">/* 交换X,Y */</span>&#123;temp = lcddev.width;lcddev.width = lcddev.height;lcddev.height = temp;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (lcddev.width &gt; lcddev.height)   <span class="hljs-comment">/* 交换X,Y */</span>&#123;temp = lcddev.width;lcddev.width = lcddev.height;lcddev.height = temp;&#125;&#125;&#125;<span class="hljs-comment">/* 设置显示区域(开窗)大小 */</span><span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5510)&#123;lcd_wr_cmd(LCD5510_ADDR_COLUMN);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_COLUMN + <span class="hljs-number">1</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_COLUMN + <span class="hljs-number">2</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_cmd(LCD5510_ADDR_COLUMN + <span class="hljs-number">3</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE + <span class="hljs-number">1</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE + <span class="hljs-number">2</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE + <span class="hljs-number">3</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);&#125;<span class="hljs-keyword">else</span>&#123;lcd_wr_cmd(LCD_ADDR_COLUMN);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);lcd_wr_cmd(LCD_ADDR_PAGE);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       清屏函数</span><span class="hljs-comment"> * @param       color: 要清屏的颜色</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_clear</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> color)</span>&#123;    <span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>;    <span class="hljs-type">uint32_t</span> totalpoint = lcddev.width;    totalpoint *= lcddev.height;    <span class="hljs-comment">/* 得到总点数 */</span>    lcd_set_cursor(<span class="hljs-number">0x00</span>, <span class="hljs-number">0x0000</span>);   <span class="hljs-comment">/* 设置光标位置 */</span>  <span class="hljs-keyword">if</span>(lcddev.lcd_id == LCD_5510)&#123;  lcd_wr_cmd(LCD5510_WR_GRAM);        <span class="hljs-comment">/* 开始写入GRAM */</span>&#125;<span class="hljs-keyword">else</span>&#123;  lcd_wr_cmd(LCD_WR_GRAM);        <span class="hljs-comment">/* 开始写入GRAM */</span>&#125;    <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; totalpoint; index++)    &#123;  lcd_wr_data(color);    &#125;&#125;</code></pre></div><ul><li>在main.c文件下编写TFTLCD测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./Lcd/tftlcd.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">/* USER CODE END Includes */</span><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> x = <span class="hljs-number">0</span>;<span class="hljs-type">uint8_t</span> dev_id[<span class="hljs-number">12</span>];<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>lcd_init();                                         <span class="hljs-comment">/* 初始化LCD */</span><span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)dev_id, <span class="hljs-string">&quot;LCD ID:%04X&quot;</span>, lcddev.lcd_id);  <span class="hljs-comment">/* 将LCD ID打印到lcd_id数组 */</span><span class="hljs-comment">//printf(&quot;LCD ID:%x\r\n&quot;, lcddev.lcd_id); /* 打印LCD ID 此处没有初始化串口，无法打印 */</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">switch</span> (x)    &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: lcd_clear(WHITE);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: lcd_clear(BLACK);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: lcd_clear(BLUE);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: lcd_clear(RED);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: lcd_clear(MAGENTA);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: lcd_clear(GREEN);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: lcd_clear(CYAN);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: lcd_clear(YELLOW);  <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: lcd_clear(BRRED);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: lcd_clear(GRAY);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: lcd_clear(LGRAY);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: lcd_clear(BROWN);<span class="hljs-keyword">break</span>;    &#125;    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">240</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&quot;STM32&quot;</span>, RED);    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">80</span>, <span class="hljs-number">240</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&quot;TFTLCD TEST&quot;</span>, GREEN);    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">110</span>, <span class="hljs-number">240</span>, <span class="hljs-number">16</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;KayoungZhang&quot;</span>, GREEN);    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">130</span>, <span class="hljs-number">240</span>, <span class="hljs-number">16</span>, <span class="hljs-number">16</span>, (<span class="hljs-type">char</span> *)dev_id, RED); <span class="hljs-comment">/* 显示LCD ID */</span>    <span class="hljs-keyword">if</span> (x++ == <span class="hljs-number">12</span>)        x = <span class="hljs-number">0</span>;    HAL_Delay(<span class="hljs-number">1000</span>); <span class="hljs-comment">//1s轮换一次画面</span>&#125;</code></pre></div><ul><li>编译无误下载到开发板后，LCD屏循环显示相应的文字</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604142633939.png" alt="image-20230604142633939" style="zoom: 50%;" /><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604142703634.png" alt="image-20230604142703634" style="zoom: 50%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/tftlcd.zip">tftlcd</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之SPI_Flash</title>
    <link href="/2023/05/30/STM32CubeMX%E4%B9%8BSPI-Flash/"/>
    <url>/2023/05/30/STM32CubeMX%E4%B9%8BSPI-Flash/</url>
    
    <content type="html"><![CDATA[<h3 id="spi-简介">SPI 简介</h3><p>SPI全称Serial PeripheralInterface，即串行外围设备接口。它是Motorola首先在其MC68HCXX系列处理器上定义的。SPI是一种高速的、全双工、同步通讯总线。</p><p>标准的SPI需要四根信号线：</p><p><strong>SS（SlaveSelect）</strong>：从设备选择，也称片选，master通过拉低slave的片选信号选择slave<strong>SCK（SerialClock）</strong>：传输时钟的信号线，时钟信号由master产生，类似于I2C的SCL<strong>MOSI（Master Out SlaveIn）</strong>：master输出，slave输入，由master向slave发送数据的通道<strong>MISO（Master In SlaveOut）</strong>：master输入，slave输出，由slave向master发送数据的通道</p><p>通常一个master主设备可以连接多个slave从设备，同一时刻只有一个slave可以与master通信，通过片选信号来进行区别，还有一种类似菊花链的连接方式，可自行了解。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2294744-20220112223510175-1577265499.jpg"alt="SPI多从机示意图" /><figcaption aria-hidden="true">SPI多从机示意图</figcaption></figure><p>SPI的工作基于移位寄存器，工作过程就像一个环形传送带，由master逐位将数据放在传送带上，并驱动传送带将数据传送到slave，同时slave也会同步地逐位将数据传送给master。简单的理解:可以认为是数据交换，外设的写操作和读操作时同步完成的，如果只进行写操作，主设备只需要忽略接收到的字节，如果主设备要进行读操作，就必须发送一个空字节来引发从设备的传输。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2294744-20220112223510132-1684027745.jpg"alt="SPI移位原理" /><figcaption aria-hidden="true">SPI移位原理</figcaption></figure><p>SPI总线根据时钟极性（CPOL）和时钟相位（CPHA）的配置不同，可以有四种工作方式：</p><ul><li><strong>mode 0：CPOL = 0，CPHA = 0；</strong></li></ul><p>时钟空闲时为低电平，第一个上升沿采样，第一个下降沿传输数据</p><ul><li><strong>mode 1：CPOL = 0，CPHA = 1；</strong></li></ul><p>时钟空闲时为低电平，第一个上升沿传输数据，第一个下降沿采样</p><ul><li><strong>mode 2：CPOL = 1，CPHA = 0；</strong></li></ul><p>时钟空闲时为高电平，第一个下降沿采样，第一个上升沿传输数据</p><ul><li><strong>mode 3：CPOL = 1，CPHA = 1；</strong></li></ul><p>时钟空闲时为高电平，第一个下降沿传输数据，第一个上升沿采样</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530135814179.png" alt="image-20230530135814179" style="zoom:80%;" /></p><p>STM32内部集成有 SPI 控制器，其内部框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530132423592.png" alt="image-20230530132423592" style="zoom:80%;" /></p><h3 id="w25qxx芯片简介">W25QXX芯片简介</h3><p>外部flash使用比较多的是华邦公司推出的W25QXX系列spiflash芯片，开发板上使用的flash是W25Q128。</p><p>它的容量为128M-bit（16M字节），它分为256个块(Block)（块大小为64KB），每个块又分为16个扇区(Sector)（扇区大小为4KB），最小擦除单位为一个扇区即4KB，因此在选择芯片的时候必须要有4K以上的SRAM（可以开辟4K的缓冲区）。</p><p>W25Q128 flash框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530141712311.png" alt="image-20230530141712311"  /></p><p>其常用指令如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530141512789.png" alt="image-20230530141512789"  /></p><h3 id="硬件设计">硬件设计</h3><p>我们将使用 STM32 的 SPI2 来读取外部 SPI FLASH芯片（W25Q128），向flash写入数据，然后读出来，并使用串口打印出来。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530142337023.png" alt="image-20230530142337023" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>PB12设置为GPIO推挽输出模式、默认高电平输出、上拉、高速（片选引脚）</li><li>激活SPI2，不开启NSS，数据长度8位，MSB先输出，分频因子256，CPOL为HIGH，CPHA为第二个边沿，不开启CRC检验，NSS为软件控制</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530145350108.png" alt="image-20230530145350108" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li><p>在spi.c文件下可以看到SPI2的初始化函数，片选管脚的初始化在gpio.c中。</p></li><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</p></li><li><p>在工程中创建w25qxx文件夹，并编写flash驱动文件：w25qxx.c和w25qxx.h,注意添加头文件及路径，部分重要的函数如下：</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  使用SPI2发送一个字节的数据并返回读取的一字节数据</span><span class="hljs-comment"> * @param  byte：要发送的数据</span><span class="hljs-comment"> * @retval 返回接收到的数据</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">spi2_rd_wr_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> TxData)</span>&#123;<span class="hljs-type">uint8_t</span> Rxdata;HAL_SPI_TransmitReceive(&amp;hspi2,&amp;TxData,&amp;Rxdata,<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>);        <span class="hljs-keyword">return</span> Rxdata;              <span class="hljs-comment">//返回收到的数据</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  读取flash id</span><span class="hljs-comment"> * @param  None.</span><span class="hljs-comment"> * @retval Temp: 返回的ID值</span><span class="hljs-comment"> */</span><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">w25qxx_readID</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint16_t</span> Temp = <span class="hljs-number">0</span>;W25QXX_CS_LOW();  <span class="hljs-comment">/* Send &quot;RDID &quot; instruction */</span>spi2_rd_wr_byte(W25X_ManufactDeviceID);<span class="hljs-comment">//发送读取ID命令    </span>spi2_rd_wr_byte(Dummy_Byte);     spi2_rd_wr_byte(Dummy_Byte);     spi2_rd_wr_byte(Dummy_Byte);  Temp|=spi2_rd_wr_byte(Dummy_Byte)&lt;&lt;<span class="hljs-number">8</span>;  Temp|=spi2_rd_wr_byte(Dummy_Byte); W25QXX_CS_HIGH();    <span class="hljs-keyword">return</span> Temp;&#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  擦除FLASH扇区</span><span class="hljs-comment">  * @param  SectorAddr：要擦除的扇区地址</span><span class="hljs-comment">  * @retval 无</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_erase_sector</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> SectorAddr)</span>   &#123;  w25qxx_write_enable();                  <span class="hljs-comment">//SET WEL  </span>w25qxx_wait_busy();   W25QXX_CS_LOW();                            <span class="hljs-comment">//使能器件   </span>spi2_rd_wr_byte(W25X_SectorErase);   <span class="hljs-comment">//发送扇区擦除指令 </span><span class="hljs-keyword">if</span>(W25QXX_TYPE==W25Q256)                <span class="hljs-comment">//如果是W25Q256的话地址为4字节的，要发送最高8位</span>&#123;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((SectorAddr)&gt;&gt;<span class="hljs-number">24</span>)); &#125;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((SectorAddr)&gt;&gt;<span class="hljs-number">16</span>));  <span class="hljs-comment">//发送24bit地址    </span>spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((SectorAddr)&gt;&gt;<span class="hljs-number">8</span>));   spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)SectorAddr);  W25QXX_CS_HIGH();                            <span class="hljs-comment">//取消片选           </span>w25qxx_wait_busy();       <span class="hljs-comment">//等待擦除完成</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  对FLASH写入数据，调用本函数写入数据前需要先擦除扇区</span><span class="hljs-comment">  * @param pBuffer，要写入数据的指针</span><span class="hljs-comment">  * @param  WriteAddr，写入地址</span><span class="hljs-comment">  * @param  NumByteToWrite，写入数据长度</span><span class="hljs-comment">  * @retval 无</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer, <span class="hljs-type">uint32_t</span> WriteAddr, <span class="hljs-type">uint16_t</span> NumByteToWrite)</span>&#123;<span class="hljs-type">uint8_t</span> NumOfPage = <span class="hljs-number">0</span>, NumOfSingle = <span class="hljs-number">0</span>, Addr = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, temp = <span class="hljs-number">0</span>;Addr = WriteAddr % W25X_PageSize;   <span class="hljs-comment">//mod运算求余，若writeAddr是W25X_PageSize整数倍，运算结果Addr值为0</span>count = W25X_PageSize - Addr;<span class="hljs-comment">//差count个数据值，刚好可以对齐到页地址</span>NumOfPage =  NumByteToWrite / W25X_PageSize; <span class="hljs-comment">//计算出要写多少整数页</span>NumOfSingle = NumByteToWrite % W25X_PageSize; <span class="hljs-comment">//mod运算求余，计算出剩余不满一页的字节数</span><span class="hljs-comment">/* Addr=0,则WriteAddr 刚好按页对齐 aligned  */</span><span class="hljs-keyword">if</span> (Addr == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (NumOfPage == <span class="hljs-number">0</span>) <span class="hljs-comment">// NumByteToWrite &lt; W25X_PageSize</span>&#123;   w25qxx_page_write(pBuffer, WriteAddr, NumByteToWrite);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">while</span> (NumOfPage--)<span class="hljs-comment">//先把整数页都写了</span>&#123;w25qxx_page_write(pBuffer, WriteAddr, W25X_PageSize);WriteAddr +=  W25X_PageSize;pBuffer += W25X_PageSize;&#125;w25qxx_page_write(pBuffer, WriteAddr, NumOfSingle);<span class="hljs-comment">//若有多余的不满一页的数据，把它写完</span>&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">/* WriteAddr 不能按页对齐 */</span>&#123;<span class="hljs-keyword">if</span> (NumOfPage == <span class="hljs-number">0</span>) <span class="hljs-comment">//NumByteToWrite &lt; W25X_PageSize</span>&#123;<span class="hljs-keyword">if</span> (NumOfSingle &gt; count) <span class="hljs-comment">//当前页剩余的count个位置比NumOfSingle小，写不完</span>&#123;temp = NumOfSingle - count;w25qxx_page_write(pBuffer, WriteAddr, count);<span class="hljs-comment">//先写满当前页</span>WriteAddr +=  count;pBuffer += count;w25qxx_page_write(pBuffer, WriteAddr, temp);<span class="hljs-comment">//再写剩余的数据</span>&#125;<span class="hljs-keyword">else</span> &#123;w25qxx_page_write(pBuffer, WriteAddr, NumByteToWrite);&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/*地址不对齐多出的count分开处理，不加入这个运算*/</span>NumByteToWrite -= count;NumOfPage =  NumByteToWrite / W25X_PageSize;NumOfSingle = NumByteToWrite % W25X_PageSize;w25qxx_page_write(pBuffer, WriteAddr, count);WriteAddr +=  count;pBuffer += count;<span class="hljs-keyword">while</span> (NumOfPage--)<span class="hljs-comment">//把整数页都写了</span>&#123;w25qxx_page_write(pBuffer, WriteAddr, W25X_PageSize);WriteAddr +=  W25X_PageSize;pBuffer += W25X_PageSize;&#125;<span class="hljs-keyword">if</span> (NumOfSingle != <span class="hljs-number">0</span>)<span class="hljs-comment">//若有多余的不满一页的数据，把它写完</span>&#123;w25qxx_page_write(pBuffer, WriteAddr, NumOfSingle);&#125;&#125;&#125;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief   读取FLASH数据</span><span class="hljs-comment">  * @param   pBuffer，存储读出数据的指针</span><span class="hljs-comment">  * @param   ReadAddr，读取地址</span><span class="hljs-comment">  * @param   NumByteToRead，读取数据长度</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer,<span class="hljs-type">uint32_t</span> ReadAddr,<span class="hljs-type">uint16_t</span> NumByteToRead)</span>   &#123;     W25QXX_CS_LOW();                            <span class="hljs-comment">//使能器件   </span>spi2_rd_wr_byte(W25X_ReadData);      <span class="hljs-comment">//发送读取命令  </span><span class="hljs-keyword">if</span>(W25QXX_TYPE==W25Q256)                <span class="hljs-comment">//如果是W25Q256的话地址为4字节的，要发送最高8位</span>&#123;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((ReadAddr)&gt;&gt;<span class="hljs-number">24</span>));    &#125;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((ReadAddr)&gt;&gt;<span class="hljs-number">16</span>));   <span class="hljs-comment">//发送24bit地址    </span>spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((ReadAddr)&gt;&gt;<span class="hljs-number">8</span>));   spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)ReadAddr);<span class="hljs-comment">/* 读取数据 */</span><span class="hljs-keyword">while</span> (NumByteToRead--)&#123;*pBuffer = spi2_rd_wr_byte(Dummy_Byte);<span class="hljs-comment">/* 指向下一个字节缓冲区 */</span>pBuffer++;&#125;W25QXX_CS_HIGH();            &#125;</code></pre></div><ul><li>在main.c文件下编写SPI测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> wData[<span class="hljs-number">255</span>];<span class="hljs-type">uint8_t</span> rData[<span class="hljs-number">255</span>];<span class="hljs-type">uint32_t</span> i;<span class="hljs-type">uint16_t</span> flash_id = <span class="hljs-number">0</span>;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>flash_id = w25qxx_readID();<span class="hljs-keyword">if</span>(flash_id == W25Q128)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash type is W25Q128. ID: %#X \r\n&quot;</span>, flash_id);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash type is unknown. ID: %#X \r\n&quot;</span>, flash_id);&#125;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)&#123;    wData[i] = i;    rData[i] = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 写入数据，写入之前必须擦除 */</span>w25qxx_erase_sector(<span class="hljs-number">0</span>);w25qxx_write(wData, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">/* 读取数据 */</span>    w25qxx_read(rData, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);     <span class="hljs-comment">/* 打印数据 */</span>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02X &quot;</span>, rData[i]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">2000</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，串口助手每隔1秒打印读取的数据信息。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230602214324217.png" alt="image-20230602214324217" style="zoom:80%;" /></p><p>工程文件Gitee： <ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/spi_flash.zip">spi_flash</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之I2C_EEPROM</title>
    <link href="/2023/05/30/STM32CubeMX%E4%B9%8BI2C-EEPROM/"/>
    <url>/2023/05/30/STM32CubeMX%E4%B9%8BI2C-EEPROM/</url>
    
    <content type="html"><![CDATA[<h3 id="i2c-简介">I2C 简介</h3><p>I2C（Inter-IntegratedCircuit）总线是由PHILIPS公司开发的由数据线SDA和时钟线SCL构成的两线式串行总线，用于连接微控制器及其外围I2C设备。</p><p>在物理层结构框图上：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9f8e02deafc832aa7db61065c5a469b8f2d0f1d4.png@831w_276h_progressive.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>它有如下特点：</p><ul><li><p>在一个 I2C 通讯总线中，可连接多个 I2C设备，支持多个通讯主机及多个通讯从机。每个连接到总线的设备都有一个独立的地址，主机利用这个地址进行不同设备之间的访问；</p></li><li><p>总线通过上拉电阻接到电源。当 I2C设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。</p></li><li><p>多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p></li><li><p>有三种传输模式，标准模式（100kbit/s）、快速模式（400kbit/s）、高速模式（3.4Mbit/s多数I2C设备不支持）</p></li><li><p>连接到相同总线的 I2C 设备数量受到总线的最大电容 400pF限制。</p></li></ul><p>在I2C协议层上：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/1487d890ccbbd39731bc795c2c18b007b6f09e6f.png@831w_236h_progressive.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>I2C总线在传送数据的过程中共有三种类型信号：</p><ul><li>开始信号:SCL为高电平时，SDA由高电平向低电平跳变，开始传送数据</li><li>结束信号:SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据</li><li>应答信号:接收数据的IC在接收到8位数据后，向发送数据的IC发出特定的低电平脉冲，表示已经收到数据。</li></ul><p>I2C总线寻址按照从机地址可分为7位和10位（寻址字节）寻址两种，D7~D1位组成从机的地址，D0位是数据传送方向（0表示主机向从机写数据/1表示主机由从机读数据）</p><h3 id="eeprom简介">EEPROM简介</h3><p>EEPROM芯片具有掉电后存储内容不丢失的功能，所以一般用来存储参数数据，比较常用的AT24C02芯片，内部含有256个字节，具有I2C通讯接口。</p><p>AT24C02芯片的器件地址为7位，高4位固定为1010，低3位有上表中的A0/A1/A2引脚的电平决定，还有一位（最低位R/W）用来选择读写方向。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530124753089.png"alt="image-20230530124753089" /><figcaption aria-hidden="true">image-20230530124753089</figcaption></figure><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530122039619.png" alt="image-20230530122039619" style="zoom:80%;" /></p><p>通过向AT24C02写入特定的数据，然后断电从其中读取数据，通过串口1打印出来。</p><h3 id="软件设计">软件设计</h3><p>I2C程序可以通过gpio模拟的方式编写，但STM32集成有I2C控制器，所以可以直接通过其I2C控制器进行程序的控制。</p><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活I2C1，选择标准传输模式，选择7位寻址地址，其余默认设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601204436710.png" alt="image-20230601204436710" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li><p>在i2c.c文件下可以看到I2C1初始化函数;</p></li><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</p></li><li><p>添加AT24C02驱动文件24cxx.c和24cxx.h,并添加头文件和头文件路径，主要代码如下：</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief   从EEPROM里面读取一块数据   </span><span class="hljs-comment">  *@param     pBuffer:存放从EEPROM读取的数据的缓冲区指针</span><span class="hljs-comment">  *@param     WriteAddr:接收数据的EEPROM的地址</span><span class="hljs-comment">  * @param     NumByteToWrite:要从EEPROM读取的字节数</span><span class="hljs-comment">  * @retval  无</span><span class="hljs-comment">  */</span><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">at24cxx_BufferRead</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer, <span class="hljs-type">uint8_t</span> ReadAddr, <span class="hljs-type">uint16_t</span> NumByteToRead)</span>&#123;HAL_StatusTypeDef status = HAL_OK;status=HAL_I2C_Mem_Read(&amp;hi2c1,EEPROM_ADDRESS,ReadAddr, I2C_MEMADD_SIZE_8BIT, (<span class="hljs-type">uint8_t</span> *)pBuffer, NumByteToRead,<span class="hljs-number">1000</span>);<span class="hljs-keyword">return</span> status;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief     将缓冲区中的数据写到I2C EEPROM中  </span><span class="hljs-comment">  *@param     pBuffer:缓冲区指针</span><span class="hljs-comment">  *@param     WriteAddr:写地址</span><span class="hljs-comment">  * @param     NumByteToWrite:写的字节数</span><span class="hljs-comment">  * @retval    无</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">at24cxx_BufferWrite</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer, <span class="hljs-type">uint8_t</span> WriteAddr, <span class="hljs-type">uint16_t</span> NumByteToWrite)</span>&#123;  <span class="hljs-type">uint8_t</span> NumOfPage = <span class="hljs-number">0</span>, NumOfSingle = <span class="hljs-number">0</span>, Addr = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;  Addr = WriteAddr % EEPROM_PAGESIZE;  count = EEPROM_PAGESIZE - Addr;  NumOfPage =  NumByteToWrite / EEPROM_PAGESIZE;  NumOfSingle = NumByteToWrite % EEPROM_PAGESIZE;   <span class="hljs-comment">/* If WriteAddr is I2C_PageSize aligned  */</span>  <span class="hljs-keyword">if</span>(Addr == <span class="hljs-number">0</span>)   &#123;    <span class="hljs-comment">/* If NumByteToWrite &lt; I2C_PageSize */</span>    <span class="hljs-keyword">if</span>(NumOfPage == <span class="hljs-number">0</span>)     &#123;      at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);    &#125;    <span class="hljs-comment">/* If NumByteToWrite &gt; I2C_PageSize */</span>    <span class="hljs-keyword">else</span>      &#123;      <span class="hljs-keyword">while</span>(NumOfPage--)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, EEPROM_PAGESIZE);         WriteAddr +=  EEPROM_PAGESIZE;        pBuffer += EEPROM_PAGESIZE;      &#125;      <span class="hljs-keyword">if</span>(NumOfSingle!=<span class="hljs-number">0</span>)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);      &#125;    &#125;  &#125;  <span class="hljs-comment">/* If WriteAddr is not I2C_PageSize aligned  */</span>  <span class="hljs-keyword">else</span>   &#123;    <span class="hljs-comment">/* If NumByteToWrite &lt; I2C_PageSize */</span>    <span class="hljs-keyword">if</span>(NumOfPage== <span class="hljs-number">0</span>)     &#123;      at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);    &#125;    <span class="hljs-comment">/* If NumByteToWrite &gt; I2C_PageSize */</span>    <span class="hljs-keyword">else</span>    &#123;      NumByteToWrite -= count;      NumOfPage =  NumByteToWrite / EEPROM_PAGESIZE;      NumOfSingle = NumByteToWrite % EEPROM_PAGESIZE;            <span class="hljs-keyword">if</span>(count != <span class="hljs-number">0</span>)      &#123;          at24cxx_PageWrite(pBuffer, WriteAddr, count);        WriteAddr += count;        pBuffer += count;      &#125;             <span class="hljs-keyword">while</span>(NumOfPage--)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, EEPROM_PAGESIZE);        WriteAddr +=  EEPROM_PAGESIZE;        pBuffer += EEPROM_PAGESIZE;        &#125;      <span class="hljs-keyword">if</span>(NumOfSingle != <span class="hljs-number">0</span>)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);       &#125;    &#125;  &#125;  &#125;</code></pre></div><ul><li>在main.c中添加测试代码：</li></ul><p>AT24C02的2Kbit分为32页，每页8个字节。而EEPROM也可以按页写入，本例使用了按页写入的方式，分32次写入。注意每次写入完毕需要延时5ms，是AT24C02芯片的要求；读取数据没有页的限制，可以一次全部读取256个字节</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> WriteBuf[<span class="hljs-number">256</span>];<span class="hljs-type">uint8_t</span> ReadBuf[<span class="hljs-number">256</span>];<span class="hljs-type">uint16_t</span> i;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">256</span>; i++)&#123; <span class="hljs-comment">//初始化写数据缓冲区</span>    WriteBuf[i] = i;&#125;<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    at24cxx_BufferWrite(WriteBuf, <span class="hljs-number">0x00</span>, <span class="hljs-number">256</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EEPROM 24C02 write Test OK!\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">3000</span>); <span class="hljs-comment">//延时3s</span>    <span class="hljs-comment">/* EEPROM读取没有页限制，可以一次读取256个字节 */</span>    at24cxx_BufferRead(ReadBuf, <span class="hljs-number">0x00</span>, (<span class="hljs-type">uint16_t</span>)<span class="hljs-number">256</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>;i++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02X &quot;</span>,ReadBuf[i]);    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(WriteBuf,ReadBuf,<span class="hljs-number">256</span>) == <span class="hljs-number">0</span>)    &#123;<span class="hljs-comment">//通过内存比较，判断读取和写入的数据是否相同</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nEEPROM 24C02 Read Test OK!\r\n&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nEEPROM 24C02 Read Test False!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">500</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，同时串口助手打印出相应信息</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601220435162.png" alt="image-20230601220435162" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/i2c_eeprom.zip">i2c_eeprom</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之MCU内部温度传感器</title>
    <link href="/2023/05/29/STM32CubeMX%E4%B9%8BMCU%E5%86%85%E9%83%A8%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    <url>/2023/05/29/STM32CubeMX%E4%B9%8BMCU%E5%86%85%E9%83%A8%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>STM32F103 有一个内部的温度传感器，可以用来测量 CPU及周围的温度(TA)。该温度传感器在内部和 ADCx_IN16输入通道相连接，此通道把传感器输出的电压转换成数字值,这也属于ADC。此温度传感器官方推荐采样时间是17.1 µs。</p><p>其内部框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530101309912.png" alt="image-20230530101309912" style="zoom:80%;" /></p><p><strong>温度公式： = (V25 - VSENSE) / Avg_Slope + 25 °C</strong></p><p>其中：</p><ul><li>V25 为 25°C时VSENSE的电压值（典型值：1.43V）</li><li>Avg_Slope 为温度与Vsense曲线的平均斜率（典型值为4.3 mV/°C）</li></ul><p>在datasheet电气特性章节中看到：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210530101608931.png"alt="image-20210530101608931" /><figcaption aria-hidden="true">image-20210530101608931</figcaption></figure><h3 id="硬件设计">硬件设计</h3><p>本实验通过ADC1通道16采集内部温度，将采样的AD值和转换后的温度值通过USART1串口打印出来</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活ADC1温度传感器通道，设置右对齐，关闭扫描、连续及间断模式，使能regularconversion，设置软件触发、设置采样时间239.5个周期（239.5/12MHz=19.96us）</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210530103255512.png"alt="image-20210530103255512" /><figcaption aria-hidden="true">image-20210530103255512</figcaption></figure><ul><li>RCC设置外接HSE，时钟设置为72M，ADC预分频因子设置为6，ADC_CLK为12MHz</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210530090558085.png"alt="image-20210530090558085" /><figcaption aria-hidden="true">image-20210530090558085</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在主函数while循环中添加如下测试程序</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint16_t</span> ad_value = <span class="hljs-number">0</span>;<span class="hljs-type">float</span> voltage = <span class="hljs-number">0.0f</span>, temperature = <span class="hljs-number">0.0f</span>;<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;HAL_ADC_Start(&amp;hadc1);<span class="hljs-comment">//启动ADC转换</span>HAL_ADC_PollForConversion(&amp;hadc1,<span class="hljs-number">10</span>);<span class="hljs-comment">//等待转换完成，10ms表示超时时间</span>ad_value = HAL_ADC_GetValue(&amp;hadc1);<span class="hljs-comment">//读取ADC转换数据（12位数据）</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN16 ADC value: %d\r\n&quot;</span>, ad_value);voltage = ad_value*(<span class="hljs-number">3.3</span>/<span class="hljs-number">4096</span>);<span class="hljs-comment">//AD值乘以分辨率即为电压值</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN16 VOL value: %.2fV\r\n&quot;</span>, voltage);temperature = (<span class="hljs-number">1.43</span> - voltage)/<span class="hljs-number">0.0043</span> + <span class="hljs-number">25</span>;<span class="hljs-comment">//根据公式算出温度值</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MCU Internal Temperature: %.2f ℃\r\n&quot;</span>, temperature);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);HAL_Delay(<span class="hljs-number">1000</span>);&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>编译无误后下载到开发板，串口助手每隔1秒打印读取的温度数据</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601084339509.png" alt="image-20230601084339509" style="zoom:80%;" /></p><p>工程文件Gitee： <ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/adc_inter_temp.zip">adc_inter_temp</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之DAC</title>
    <link href="/2023/05/29/STM32CubeMX%E4%B9%8BDAC/"/>
    <url>/2023/05/29/STM32CubeMX%E4%B9%8BDAC/</url>
    
    <content type="html"><![CDATA[<p>DAC（digital to analogconverter）即数模转换器，它可以将数字信号转换为模拟信号.在常见的数字信号系统中，大部分传感器信号被转化成电压信号，而ADC把电压模拟信号转换成易于计算机存储、处理的数字编码，由计算机处理完成后，再由DAC输出电压模拟信号来驱动某些执行器件，使人类易于感知。如音频信号的采集和还原就是这样的一个过程。</p><p>STM32F1的DAC模块是12位电压输出型DAC。可以配置为8位或12位模式，在12位模式下，数据可以设置为左对齐或右对齐。它有2个输出通道，2个通道可以独立地进行转换。</p><p>DAC通道框图如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530105255132.png" alt="image-20230530105255132" style="zoom:80%;" /></p><p><strong>DAC的转换公式</strong>：<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530105432369.png" alt="image-20230530105432369" style="zoom:80%;" /></p><p>DOR：DAC数据输出寄存器值；</p><h3 id="硬件设计">硬件设计</h3><p>本实验通过 DAC 通道1输出模拟电压，用KEY1用来增加DAC输入值，WK_UP用来减少DAC输入值，然后使用USART1将输出的电压值打印出来</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530111127269.png" alt="image-20230530111127269" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PE3设置为GPIO输入模式、上拉；PA0设置为GPIO输入模式，下拉；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601203040597.png" alt="image-20230601203040597" style="zoom:80%;" /></p><ul><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活DAC_OUT1，关闭输出缓冲，不使用触发功能</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601132917195.png" alt="image-20230601132917195" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generateperipheral initialization as a pair of ‘.c/.h’ files perperipheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>因为使用到按键功能，所以移植之前用到的按键输入工程中Key文件,记得添加头文件和路径（#include"key.h"）。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601175003752.png" alt="image-20230601175003752" style="zoom:80%;" /></p><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main.c文件下编写DAC测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint16_t</span> dac_val;<span class="hljs-comment">//读取的DAC值</span><span class="hljs-type">float</span> dac_vol;<span class="hljs-comment">//转换后的电压值</span><span class="hljs-type">uint16_t</span> dac_setval = <span class="hljs-number">0</span>;<span class="hljs-comment">//DAC设置值</span><span class="hljs-type">uint8_t</span> key = <span class="hljs-number">0</span>;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_DAC_Start(&amp;hdac,DAC_CHANNEL_1);<span class="hljs-comment">//开启DAC通道1</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    key = key_scan(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(key == KEY1_PRES)    &#123;        <span class="hljs-keyword">if</span>(dac_setval &gt; <span class="hljs-number">4000</span>)            dac_setval = <span class="hljs-number">0</span>;        dac_setval += <span class="hljs-number">200</span>;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key == WKUP_PRES)    &#123;        <span class="hljs-keyword">if</span>(dac_setval &lt; <span class="hljs-number">200</span>)            dac_setval = <span class="hljs-number">4000</span>;        dac_setval -= <span class="hljs-number">200</span>;    &#125;    HAL_DAC_SetValue(&amp;hdac,DAC_CHANNEL_1,DAC_ALIGN_12B_R,dac_setval);    <span class="hljs-keyword">if</span>(key == KEY1_PRES || key == WKUP_PRES)    &#123;        dac_val = HAL_DAC_GetValue(&amp;hdac,DAC_CHANNEL_1);<span class="hljs-comment">//其值=dac_setval</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DAC_OUT1 DAC value: %d\r\n&quot;</span>,dac_val);        dac_vol = (<span class="hljs-type">float</span>)dac_val * (<span class="hljs-number">3.3</span>/<span class="hljs-number">4096</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DAC_OUT1 VOL value: %.2fV\r\n&quot;</span>,dac_vol);    &#125;    HAL_Delay(<span class="hljs-number">10</span>);&#125;</code></pre></div><ul><li>编译无误后下载到开发板，打印出DAC通道1的DAC值和电压值，按下按键，DAC值和电压值发生变化。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601202614101.png" alt="image-20230601202614101" style="zoom:80%;" /></p><p>工程文件Gitee： <ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/dac.zip">dac</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之ADC</title>
    <link href="/2023/05/29/STM32CubeMX%E4%B9%8BADC/"/>
    <url>/2023/05/29/STM32CubeMX%E4%B9%8BADC/</url>
    
    <content type="html"><![CDATA[<h3 id="adc简介">ADC简介</h3><p>ADC（analog to digitalconverter）即模数转换器，它可以将模拟量信号转换为数字信号，按照转换原理主要分为逐次逼近型、双积分型、电压频率转换型三种。</p><p>STM32 的 ADC 是 12 位逐次逼近型的模拟数字转换器。它有 18个通道，可测量 16 个外部和 2 个内部信号源。各通道的 A/D转换模式有单次、连续、扫描或间断模式。ADC的转换结果可以以左对齐或右对齐方式存储在 16位数据寄存器中。ADC时钟挂载在APB2上，最大14MHz。</p><p>单个ADC功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530083701000.png" alt="image-20230530083701000" style="zoom:80%;" /></p><p>STM32 将 ADC 的转换分为 2 个通道组：规则通道组和注入通道组。STM32 其ADC 的规则通道组最多包含 16 个转换，而注入通道组最多包含 4 个通道。</p><p>ADC 的转换时间可以由以下公式计算：Time = 采样时间 + 12.5个周期；</p><p>ADC能3种产生相应中断：规则转换与注入转换结束、模拟看门狗事件、DMA请求；</p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530084243966.png" alt="image-20230530084243966" style="zoom:80%;" /></p><p>通过ADC1通道1（PA1）采样外部电压值，将采样的AD值和转换后的电压值通过USART1串口打印出来。如上图，可以将不同的电压（0~3.3V）连接到连接座上。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活ADC1通道1，设置右对齐，关闭扫描、连续及间断模式，使能regularconversion，设置软件触发、设置采样时间1.5个周期</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530090516872.png" alt="image-20230530090516872" style="zoom:80%;" /></p><ul><li>RCC设置外接HSE，时钟设置为72M，ADC预分频因子设置为6，ADC_CLK为12MHz</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530090558085.png"alt="image-20230530090558085" /><figcaption aria-hidden="true">image-20230530090558085</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper periapheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在主函数while循环中添加如下测试程序，ADC1是12位转换精度，因此电压分辨率为：3.3/(2^12)= 3.3/4096</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint16_t</span> ad_value = <span class="hljs-number">0</span>;<span class="hljs-type">float</span> voltage = <span class="hljs-number">0.0f</span>;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    HAL_ADC_Start(&amp;hadc1);<span class="hljs-comment">//启动ADC转换</span>    HAL_ADC_PollForConversion(&amp;hadc1,<span class="hljs-number">10</span>);<span class="hljs-comment">//等待转换完成，10ms表示超时时间</span>    ad_value = HAL_ADC_GetValue(&amp;hadc1);<span class="hljs-comment">//读取ADC转换数据（12位数据）</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN1 ADC value: %d\r\n&quot;</span>,ad_value);    voltage = ad_value*(<span class="hljs-number">3.3</span>/<span class="hljs-number">4096</span>);<span class="hljs-comment">//AD值乘以分辨率即为电压值</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN1 VOL value: %.2fV\r\n&quot;</span>,voltage);    HAL_Delay(<span class="hljs-number">1000</span>);&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>编译无误后下载到开发板，通过接口接入不同的电压（0~3.3），获取的AD转换值和电压值将变化，并通过串口打印出来</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531225347273.png" alt="image-20230531225347273" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/adc.zip">adc</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之RTC</title>
    <link href="/2023/05/29/STM32CubeMX%E4%B9%8BRTC/"/>
    <url>/2023/05/29/STM32CubeMX%E4%B9%8BRTC/</url>
    
    <content type="html"><![CDATA[<p>STM32的实时时钟RTC是一个独立的定时器,RTC模块和时钟配置系统（RCC_BDCR寄存器）是在后背区域，即在系统复位或从待机模式唤醒后RTC的设置和事件维持不变。但是在系统复位后，会自动禁止访问后备寄存器和RTC，以防止对后备区域（BKP）的意外操作。所以在要设置时间之前，要先取消备份区域写保护。</p><p>RTC的功能框图如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529212612816.png" alt="image-20230529212612816" style="zoom:80%;" /></p><p>RTC由两个主要部分组成：第一部分（APB1接口）用来和APB1总线相连；另一部分（RTC核心）由一组可编程计数器组成，分为两个主要模块，第一个模块是RTC的预分频模块，可编程产生1秒的RTC时间基准TR_CLK，第二个模块是一个32位的可编程计数器（RTC_CNT），可被初始化为当前的系统时间。</p><h3 id="硬件设计">硬件设计</h3><p>RTC 属于 STM32F1内部资源，本实验通过RTC的秒中断来持续输出时间通过串口1打印出来，并通过设置闹钟中断实现一个闹钟提醒。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li><p>RCC设置中开启外部高速晶振（HSE）以及外部低速晶振（LSE）；</p></li><li><p>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</p></li><li><p>激活时钟源，激活日历，选择RTCOutput，设置初始日期和时间，在NVIC中使能RTC全局中断。</p></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529222921310.png"alt="image-20230529222921310" /><figcaption aria-hidden="true">image-20230529222921310</figcaption></figure><ul><li>时钟树设置HCLK为72MHz，RTC时钟为32.768KHz</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529223151558.png" alt="image-20230529223151558" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在rtc.c文件中编写秒中断处理回调函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-comment">/* 定义日期和时间结构体 */</span>RTC_DateTypeDef GetDate;RTC_TimeTypeDef GetTime;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_RTCEx_RTCEventCallback</span><span class="hljs-params">(RTC_HandleTypeDef *hrtc)</span>&#123;HAL_RTC_GetTime(hrtc,&amp;GetTime,RTC_FORMAT_BIN);HAL_RTC_GetDate(hrtc,&amp;GetDate,RTC_FORMAT_BIN);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Date:%02d-%02d-%02d\r\n&quot;</span>,<span class="hljs-number">2000</span>+GetDate.Year,GetDate.Month,GetDate.Date);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Time:%02d:%02d:%02d\r\n&quot;</span>,GetTime.Hours,GetTime.Minutes,GetTime.Seconds);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);&#125;<span class="hljs-comment">/* USER CODE END 1 */</span></code></pre></div><ul><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</p></li><li><p>在main.c文件中编写闹钟设置相关代码并开启相关中断</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>__HAL_RTC_SECOND_ENABLE_IT(&amp;hrtc,RTC_IT_SEC); <span class="hljs-comment">//开启秒中断</span><span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div><ul><li>编译无误后下载到开发板，串口助手每1s会打印出相应的日期和时间。</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531223357869.png"alt="image-20230531223357869" /><figcaption aria-hidden="true">image-20230531223357869</figcaption></figure><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/rtc.zip">rtc</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之低功耗</title>
    <link href="/2023/05/29/STM32CubeMX%E4%B9%8B%E4%BD%8E%E5%8A%9F%E8%80%97/"/>
    <url>/2023/05/29/STM32CubeMX%E4%B9%8B%E4%BD%8E%E5%8A%9F%E8%80%97/</url>
    
    <content type="html"><![CDATA[<p>STM32F10xxx有三种低功耗模式:</p><ul><li><strong>睡眠模式(Sleep mode)</strong>（CM3内核停止，外设包括核心外设如NVIC，SysTick等仍然运行，功耗最高）</li><li><strong>停止模式(Stopmode)</strong>（所有时钟都停止，功耗中等）</li><li><strong>待机模式(Standby mode)</strong>（1.8V内核电源关闭，功耗最低）</li></ul><p>此外，在运行模式下，为了降低功耗，可以通过降低系统时钟和关闭APB和AHB总线上未使用外设的时钟。</p><p>三种低功耗模式的区别如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529164036755.png" alt="image-20230529164036755" style="zoom:80%;" /></p><p>这一章实验主要针对待机模式进行介绍，该模式实在CM3深睡眠模式时关闭电压调节器，整个1.8V供电区域被断电，HSI/HSE振荡器也被断电，SRAM和寄存器内容丢失，仅备份的寄存器和待机电路维持供电。</p><h3 id="硬件设计">硬件设计</h3><p>使用了 KEY_UP 按键用于唤醒和进入待机模式，然后通过LED0来指示程序是否在运行。灯闪烁表示系统正常运行，灯熄灭表示进入待机模式。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528162340882.png" alt="image-20230528162340882" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528102557291.png" alt="image-20230528102557291" style="zoom: 67%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PB5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平</li><li>PA0设置为GPIO输入模式，下拉</li><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在main.c文件中添加进入待机模式函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  进入待机模式</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">enter_standby_mode</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    __HAL_RCC_APB2_FORCE_RESET();       <span class="hljs-comment">//复位所有IO口 </span>   __HAL_RCC_PWR_CLK_ENABLE();         <span class="hljs-comment">//使能PWR时钟</span>      __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);      <span class="hljs-comment">//清除Wake_UP标志</span>    HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN1);    <span class="hljs-comment">//设置WKUP用于唤醒</span>    HAL_PWR_EnterSTANDBYMode();                  <span class="hljs-comment">//进入待机模式     </span>&#125;<span class="hljs-comment">/* USER CODE END 0 */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">/* 闪烁3s后进入待机模式 */</span>    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);    HAL_Delay(<span class="hljs-number">500</span>);    enter_standby_mode();    <span class="hljs-comment">/* USER CODE END WHILE */</span>&#125;</code></pre></div><ul><li>编译无误后下载到开发板，可以看到系统运行时LED0会闪烁三次，然后进入待机模式，此时LED0熄灭。当按下KEY_UP按键或复位按键时，待机模式被唤醒，系统重新运行.</li></ul><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/low_power.zip">low_power</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之输入捕获</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8B%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8B%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="输入捕获简介">输入捕获简介</h3><p>输入捕获一般应用在两个方面，一是信号脉宽/频率的测量，二是 PWM的输入测量。</p><ul><li>脉宽/频率测量:</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529124032810.png" alt="image-20230529124032810" style="zoom:80%;" /></p><p>可以看到只需要一个捕获通道就可以根据捕获值的差值计算脉宽和频率。</p><p>捕获过程中，两次边沿捕获之间会产生N次定时器溢出，所以:</p><p>脉宽 = (N*ARR + (value2-value1))*CNT计数周期;</p><p>频率 = CNT计数周期/(N*ARR + (value3-value1));</p><ul><li>PWM输入模式时序：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529111153732.png" alt="image-20230529111153732" style="zoom: 80%;" /></p><p>如图PWM输入测量需要两个捕获通道。</p><h3 id="硬件设计">硬件设计</h3><p>通过 <strong>WK_UP</strong>按键将PA0输入高电平，然后捕获TIM5_CH1（PA0）上的高电平脉宽，并从串口打印高电平脉宽。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/30915046b8743181980a17e715c3a8b7.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>选择TIM5，设置定时器时钟源为内部时钟源、设置通道1为输入捕获模式（PA0自动被选中），NVIC设置中激活定时器中断，预分频系数设置为72-1，向上计数，自动重装载值设为0xFFFF，则计时器时钟频率为1MHz，计时器周期为1us，定时器溢出周期为65535 * 1 = 65535us</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529134108484.png"alt="image-20230529134108484" /><figcaption aria-hidden="true">image-20230529134108484</figcaption></figure><ul><li>在GPIO设置里将PA0下拉保证没有信号输入的时候电平稳定.</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529133718902.png"alt="image-20230529133718902" /><figcaption aria-hidden="true">image-20230529133718902</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>因为可能存在定时溢出的情况，所以在tim.c文件中同时编写定时器更新中断处理回调函数和输入捕获中断处理回调函数。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> pulse_edge = <span class="hljs-number">0</span>;<span class="hljs-comment">//状态变化计数值</span><span class="hljs-type">uint8_t</span> overflow_cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//定时器溢出的次数</span><span class="hljs-type">uint32_t</span> capture_value = <span class="hljs-number">0</span>;<span class="hljs-comment">//储存计数器的记录值</span><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_PeriodElapsedCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>&#123;<span class="hljs-keyword">if</span>(htim-&gt;Instance == TIM5)&#123;<span class="hljs-comment">/* 已经捕获一次上升沿，还没捕获过下降沿期间出现定时器溢出 */</span><span class="hljs-keyword">if</span>(pulse_edge == <span class="hljs-number">1</span>)&#123;overflow_cnt++;&#125;&#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_IC_CaptureCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>&#123;<span class="hljs-keyword">if</span>(htim-&gt;Instance == TIM5)&#123;<span class="hljs-comment">/* 捕获到一个上升沿，清除标志位，清空CNT，准备捕获下降沿 */</span><span class="hljs-keyword">if</span>(pulse_edge == <span class="hljs-number">0</span>)&#123;pulse_edge++;capture_value = <span class="hljs-number">0</span>;overflow_cnt = <span class="hljs-number">0</span>;__HAL_TIM_SET_COUNTER(&amp;htim5, <span class="hljs-number">0</span>);__HAL_TIM_SET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING);<span class="hljs-comment">//设置下降沿捕获</span>&#125;<span class="hljs-keyword">else</span>&#123;HAL_TIM_IC_Stop_IT(&amp;htim5,TIM_CHANNEL_1); <span class="hljs-comment">//关闭定时器5</span>pulse_edge++; <span class="hljs-comment">//进入到主函数</span>capture_value = HAL_TIM_ReadCapturedValue(&amp;htim5, TIM_CHANNEL_1); <span class="hljs-comment">//读取捕获通道的值</span>__HAL_TIM_SET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);HAL_TIM_IC_Start_IT(&amp;htim5,TIM_CHANNEL_1);  <span class="hljs-comment">//打开输入捕获</span>&#125;&#125;    &#125;<span class="hljs-comment">/* USER CODE END 1 */</span></code></pre></div><ul><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</p></li><li><p>在main.c文件中编写高电平持续时间处理代码</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>    <span class="hljs-type">uint32_t</span> pulse_width;<span class="hljs-comment">//高电平持续时间</span>    <span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> pulse_edge;<span class="hljs-comment">//状态变化时，计数值</span>    <span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> overflow_cnt;<span class="hljs-comment">//定时器溢出的次数</span>    <span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> capture_value;<span class="hljs-comment">//两个边沿之间的计数值</span>    <span class="hljs-comment">/* USER CODE END 1 */</span>    <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>    <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>    HAL_Init();    <span class="hljs-comment">/* USER CODE BEGIN Init */</span>    <span class="hljs-comment">/* USER CODE END Init */</span>    <span class="hljs-comment">/* Configure the system clock */</span>    SystemClock_Config();    <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>    <span class="hljs-comment">/* USER CODE END SysInit */</span>    <span class="hljs-comment">/* Initialize all configured peripherals */</span>    MX_GPIO_Init();    MX_USART1_UART_Init();    MX_TIM5_Init();    <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>    HAL_TIM_Base_Start_IT(&amp;htim5);<span class="hljs-comment">//打开定时器中断</span>    HAL_TIM_IC_Start_IT(&amp;htim5,TIM_CHANNEL_1);<span class="hljs-comment">//一定要开启TIM5通道1的捕获中断</span>    <span class="hljs-comment">/* USER CODE END 2 */</span>    <span class="hljs-comment">/* Infinite loop */</span>    <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">if</span>(pulse_edge == <span class="hljs-number">2</span>)        &#123;            pulse_edge = <span class="hljs-number">0</span>;            pulse_width = <span class="hljs-number">65536</span>*overflow_cnt + capture_value;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;高电平持续时间:%d ms\r\n&quot;</span>, pulse_width/<span class="hljs-number">1000</span>);        &#125;        <span class="hljs-comment">/* USER CODE END WHILE */</span>        <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>    &#125;    <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><ul><li>编译无误后下载到开发板，按下KEY_UP后，串口会打印出相应的高电平持续时间</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530233211951.png"alt="image-20230530233211951" /><figcaption aria-hidden="true">image-20230530233211951</figcaption></figure><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/input_capture.zip">input_capture</a></p><p>参考链接：http://t.csdn.cn/nf7yk</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之PWM输出</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8BPWM%E8%BE%93%E5%87%BA/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8BPWM%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="pwm-简介">PWM 简介</h3><p>脉冲宽度调制（PWM,Pulse WidthModulation）简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。PWM输出就是对外输出脉宽（即占空比）可调的方波信号，信号频率由自动重装寄存器ARR 的值决定，占空比由比较寄存器 CCR 的值决定。</p><p>PWM 模式分为两种：mode1 和 mode2，它们的区别如下：</p><table><thead><tr class="header"><th>PWM模式</th><th>计数器CNT计数方式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><strong>mode 1</strong></td><td>upcounting</td><td>CNT&lt;CCRx，通道channel有效(OCxREF=1)，否则无效(OCxREF=0)</td></tr><tr class="even"><td></td><td>downcounting</td><td>CNT&gt;CCRx，通道channel无效(OCxREF=0)，否则有效(OCxREF=1)</td></tr><tr class="odd"><td><strong>mode 2</strong></td><td>upcounting</td><td>CNT&lt;CCRx，通道channel无效(OCxREF=0)，否则有效(OCxREF=1)</td></tr><tr class="even"><td></td><td>downcounting</td><td>CNT&gt;CCRx，通道channel有效(OCxREF=1)，否则无效(OCxREF=0)</td></tr></tbody></table><p>以PWM mode 1递增计数方式为例：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529112644749.png" alt="image-20230529112644749" style="zoom:80%;" /></p><ul><li>当计数器 CNT &lt; 比较捕获寄存器 CCRx，PWM 参考信号 OCxREF输出高电平。</li><li>当计数器 CNT &gt;= 比较捕获寄存器 CCRx， PWM 参考信号 OCxREF输出低电平。</li><li>当比较捕获寄存器 CCRx &gt; 自动重载寄存器 ARR，OCxREF 保持为1。</li><li>当比较捕获寄存器 CCRx = 0，则 OCxRef 保持为 0。</li></ul><h3 id="硬件设计">硬件设计</h3><p>LED灯的呼吸灯效果可以很好的查看PWM的调节情况，查看定时器复用功能重映射，刚好TIM3第二通道可以重映射到LED0上。所以，可以通过TIM3的通道2输出PWM信号，控制LED0的亮度。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528211500355.png" alt="image-20230528211500355" style="zoom:67%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72MHz；</li><li>TIM3的时钟挂载在APB1上，因为APB1 Prescacler设置为2，所以TIM3时钟为36x2=72MHz；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528200120931.png" alt="image-20230528200120931" style="zoom:67%;" /></p><ul><li><p>激活TIM3定时器，**Timeout = (Prescaler-1)*(Period-1)/72MHz**</p><p>时钟源选择为内部时钟，设置通道2为PWM模式，选中PB5的TIM3_CH2完成重映射，预分频系数设置为72-1，向上计数，自动重装载值设为500-1，则计时器时钟频率为1MHz，计时器周期为1us，PWM周期为500 * 1 = 500us，PWM频率为1/500us =2KHz，PWM模式选择PWM1，Pulse默认为0，PWM极性设置为低电平（由于LED低电平点亮）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528213741747.png" alt="image-20230528213741747" style="zoom:80%;" /></p></li><li><p>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral ；点击GENERATE CODE，生成工程代码</p></li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在tim.c文件中可以看到TIM3的初始化相关函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_TIM3_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  TIM_ClockConfigTypeDef sClockSourceConfig = &#123;<span class="hljs-number">0</span>&#125;;  TIM_MasterConfigTypeDef sMasterConfig = &#123;<span class="hljs-number">0</span>&#125;;  TIM_OC_InitTypeDef sConfigOC = &#123;<span class="hljs-number">0</span>&#125;;  htim3.Instance = TIM3;  htim3.Init.Prescaler = <span class="hljs-number">71</span>;  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;  htim3.Init.Period = <span class="hljs-number">499</span>;  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIM_Base_Init(&amp;htim3) != HAL_OK)  &#123;    Error_Handler();  &#125;  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;  <span class="hljs-keyword">if</span> (HAL_TIM_ConfigClockSource(&amp;htim3, &amp;sClockSourceConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;  <span class="hljs-keyword">if</span> (HAL_TIM_PWM_Init(&amp;htim3) != HAL_OK)  &#123;    Error_Handler();  &#125;  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIMEx_MasterConfigSynchronization(&amp;htim3, &amp;sMasterConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;  sConfigOC.OCMode = TIM_OCMODE_PWM1;  sConfigOC.Pulse = <span class="hljs-number">0</span>;  sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIM_PWM_ConfigChannel(&amp;htim3, &amp;sConfigOC, TIM_CHANNEL_2) != HAL_OK)  &#123;    Error_Handler();  &#125;  HAL_TIM_MspPostInit(&amp;htim3);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_Base_MspInit</span><span class="hljs-params">(TIM_HandleTypeDef* tim_baseHandle)</span>&#123;  <span class="hljs-keyword">if</span>(tim_baseHandle-&gt;Instance==TIM3)  &#123;    __HAL_RCC_TIM3_CLK_ENABLE();  &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_MspPostInit</span><span class="hljs-params">(TIM_HandleTypeDef* timHandle)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-keyword">if</span>(timHandle-&gt;Instance==TIM3)  &#123;    __HAL_RCC_GPIOB_CLK_ENABLE();    <span class="hljs-comment">/**TIM3 GPIO Configuration</span><span class="hljs-comment">    PB5     ------&gt; TIM3_CH2</span><span class="hljs-comment">    */</span>    GPIO_InitStruct.Pin = GPIO_PIN_5;    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;    HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);    __HAL_AFIO_REMAP_TIM3_PARTIAL();  &#125;&#125;</code></pre></div><ul><li>在main函数中编写代码，周期性的改变CCR1的值来改变PWM占空比</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>  <span class="hljs-type">uint8_t</span> dir = <span class="hljs-number">1</span>;<span class="hljs-comment">//计数方向</span>  <span class="hljs-type">uint16_t</span> ledpwmval = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数值</span>  <span class="hljs-comment">/* USER CODE END 1 */</span>  <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>  <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>  HAL_Init();  <span class="hljs-comment">/* USER CODE BEGIN Init */</span>  <span class="hljs-comment">/* USER CODE END Init */</span>  <span class="hljs-comment">/* Configure the system clock */</span>  SystemClock_Config();  <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>  <span class="hljs-comment">/* USER CODE END SysInit */</span>  <span class="hljs-comment">/* Initialize all configured peripherals */</span>  MX_GPIO_Init();  MX_TIM3_Init();  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);<span class="hljs-comment">//开启定时器PWM输出</span>  <span class="hljs-comment">/* USER CODE END 2 */</span>  <span class="hljs-comment">/* Infinite loop */</span>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;HAL_Delay(<span class="hljs-number">10</span>);<span class="hljs-keyword">if</span>(dir)ledpwmval++;<span class="hljs-keyword">else</span>ledpwmval--;<span class="hljs-keyword">if</span>(ledpwmval &gt; <span class="hljs-number">300</span>)dir = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ledpwmval == <span class="hljs-number">0</span>)dir = <span class="hljs-number">1</span>;TIM3-&gt;CCR2 = ledpwmval;<span class="hljs-comment">//更改CCR2的值来改变PWM的占空比</span>    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>  &#125;  <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><ul><li>编译后下载到开发板，可以看到LED0由暗变亮，再由亮变暗，呈现呼吸灯的效果。</li></ul><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/pwm_out.zip">pwm_output</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之窗口看门狗</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97/</url>
    
    <content type="html"><![CDATA[<h3 id="窗口看门狗简介">窗口看门狗简介</h3><p>窗口看门狗（WWDG）通常被用来监测由外部干扰或不可预见的逻辑条件造成的应用程序背离正常的运行序列而产生的软件故障。递减计数器需要在一个有限的时间窗口中被刷新才不会产生MCU复位，否则就会产生RESET。WWDG</p><p>窗口看门狗时序图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528174707824.png" alt="image-20230528174707824" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528174924225.png" alt="image-20230528174924225" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>我们将通过USART1来打印调试信息，然后通过 LED1提示复位状态。(LED1常亮则系统正常，LED1闪烁则系统一直复位)</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M；</li><li>IWDG的时钟默认为LSI时钟；</li><li>PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528170246253.png" alt="image-20230528170246253" style="zoom:67%;" /></p><ul><li><p>激活WWDG，Timeout = 4096 x Prescaler x (上窗口值 - 下窗口值)/36MHz</p><p>WWDG挂载在APB1上，时钟为36MHz，计数器预分频值设为8，窗口寄存器设为W[6:0]= 0x5A，递减计数器刷新值设置为T[6:0] = 0x7F；根据公式算出超时时间为（4096 * 8）*（0x7F-0x3F）/ 36MHz =58.3ms；使能EWI中断，在NVIC设置中开启窗口看门狗中断</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528175822680.png" alt="image-20230528175822680" style="zoom:67%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在wwdg.c文件中可以看到独立看门狗的初始化函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_WWDG_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  hwwdg.Instance = WWDG;  hwwdg.Init.Prescaler = WWDG_PRESCALER_8;  hwwdg.Init.Window = <span class="hljs-number">0x5a</span>;  hwwdg.Init.Counter = <span class="hljs-number">0x7f</span>;  hwwdg.Init.EWIMode = WWDG_EWI_ENABLE;  <span class="hljs-keyword">if</span> (HAL_WWDG_Init(&amp;hwwdg) != HAL_OK)  &#123;    Error_Handler();  &#125;&#125;</code></pre></div><ul><li>在<strong>stm32f1xx_hal_wwdg.c</strong>文件中找到弱符号早期唤醒中断函数原型，并在wwdg.c中自定义该回调函数<code>__weak void HAL_WWDG_EarlyWakeupCallback(WWDG_HandleTypeDef *hwwdg)</code></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_WWDG_EarlyWakeupCallback</span><span class="hljs-params">(WWDG_HandleTypeDef *hwwdg)</span>&#123;HAL_WWDG_Refresh(hwwdg);<span class="hljs-comment">//在早期唤醒中断函数中喂狗</span>&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main函数中编写代码：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nWWDG Test!!!\r\n&quot;</span>);HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);<span class="hljs-comment">//熄灭LED0</span>HAL_Delay(<span class="hljs-number">500</span>);HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);<span class="hljs-comment">//点亮LED0</span>MX_WWDG_Init();<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-comment">/* Infinite loop */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nHello, WWDG...!\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">1000</span>);    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;<span class="hljs-comment">/* USER CODE END 3 */</span></code></pre></div><ul><li>实验现象：</li></ul><p>LED1常亮，且串口助手显示一直在喂狗：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528191522516.png" alt="image-20230528191522516" style="zoom:67%;" /></p><p>如果注释掉早期唤醒中断函数中的喂狗函数，则LED1闪烁且串口输出，需要<strong>注意</strong>的是，<code>MX_WWDG_Init()</code>函数需要放到LED闪烁函数之后，否则程序一直在复位，根本执行不到后面的部分：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528192419226.png" alt="image-20230528192419226" style="zoom:67%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/wwdg.zip">wwdg</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之独立看门狗</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8B%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8B%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97/</url>
    
    <content type="html"><![CDATA[<h3 id="独立看门狗简介">独立看门狗简介</h3><p>STM32F1内部自带了 2个看门狗：独立看门狗（IWDG）和窗口看门狗（WWDG)。这一章主要来看看独立看门狗，从功能上说它在程序发生意外（程序进入死循环或跑飞）的时候，能重新回复到系统刚上电状态。</p><p>独立看门狗由内部专门的 40Khz 低速RC时钟驱动，即使主时钟发生故障，它也仍然有效。但它是在 30~60Khz之间的一个可变化的时钟，只是我们在估算的时候，以 40Khz的频率来计算，时钟有些偏差，都是可以接受的。</p><p>实际上独立看门口狗是一个递减计数器，当计时器的值减到0时，IWDG会产生一个复位信号，系统复位重新启动。为避免产生看门狗复位，则需在计数器减到0之前重载计数器,即“喂狗”。</p><p>独立看门狗功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528161307256.png" alt="image-20230528161307256" style="zoom:80%;" /></p><p>独立看门狗超时时间（40KHz的输入时钟LSI）：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528161857687.png" alt="image-20230528161857687" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>我们将通过USART1来打印调试信息，然后通过 LED0提示复位状态。(LED0常亮则系统正常，LED0闪烁则系统一直复位)</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M；</li><li>IWDG的时钟默认为LSI时钟；</li><li>PB5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528170246253.png" alt="image-20230528170246253" style="zoom:67%;" /></p><ul><li><p>激活IWDG，Timeout = (Prescaler*ReloadValue/40)ms;</p><p>IWDG的时钟为40kHz,此时设置计数器时钟为32分频，则分频后的时钟频率为1.25KHz（时钟周期为1s/1250= 0.8ms），递减基础器重载值（down-counter reloadvalue）配置为1000，即800ms不刷新IWDG，则系统复位。</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528164949027.png" alt="image-20230528164949027" style="zoom: 67%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在iwdg.c文件中可以看到独立看门狗的初始化函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_IWDG_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  hiwdg.Instance = IWDG;  hiwdg.Init.Prescaler = IWDG_PRESCALER_32;  hiwdg.Init.Reload = <span class="hljs-number">1000</span>;  <span class="hljs-keyword">if</span> (HAL_IWDG_Init(&amp;hiwdg) != HAL_OK)  &#123;    Error_Handler();  &#125;&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>UseMicroLIB</strong>选项。</li><li>在main函数中编写代码:</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nIWDG Test!!!\r\n&quot;</span>);HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);<span class="hljs-comment">//熄灭LED0</span>HAL_Delay(<span class="hljs-number">300</span>);HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_RESET);<span class="hljs-comment">//点亮LED0</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-comment">/* Infinite loop */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//HAL_IWDG_Refresh(&amp;hiwdg);</span>    <span class="hljs-comment">//printf(&quot;\r\nRefreshes the IWDG...!\r\n&quot;);</span>    HAL_Delay(<span class="hljs-number">500</span>); <span class="hljs-comment">//每500ms喂狗一次 &lt; 800ms</span>    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;<span class="hljs-comment">/* USER CODE END 3 */</span></code></pre></div><ul><li>实验现象：</li></ul><p>LED0常亮，且串口助手显示一直在喂狗：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528171626961.png" alt="image-20230528171626961" style="zoom:67%;" /></p><p>如果注释掉while循环里的喂狗动作，则LED0闪烁且串口输出：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528173055722.png" alt="image-20230528173055722" style="zoom:67%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/iwdg.zip">iwdg</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之定时器中断</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="定时器中断简介">定时器中断简介</h3><p>STM32 的定时器功能十分强大，有 TIME1 和 TIME8 等高级定时器，也有TIME2~TIME5 等通用定时器，还有 TIME6 和TIME7等基本定时器。这一章主要介绍通用定时器，是一个通过可编程预分频器（PSC）驱动的16 位自动装载计数器（CNT）构成。STM32的通用定时器可以被用于：测量输入信号的脉冲长度(输入捕获)或者产生输出波形(输出比较和PWM)等。</p><p>通用定时器功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528194943205.png" alt="image-20230528194943205" style="zoom:67%;" /></p><h3 id="硬件设计">硬件设计</h3><p>通过 TIM3 的中断来控制 LED1 的亮灭。TIM3属于MCU内部资源，只需要软件设置即可正常工作。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72MHz；</li><li>TIM3的时钟挂载在APB1上，因为APB1 Prescacler设置为2，所以TIM3时钟为36x2=72MHz；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528200120931.png" alt="image-20230528200120931" style="zoom:67%;" /></p><ul><li><p>PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</p></li><li><p>激活TIM3定时器，**Timeout = (Prescaler-1)*(Period-1)/72MHz**</p><p>时钟源选择为内部时钟，PSC预分频设置为7200-1，向上计数，自动重装载值(ARR)设置为10000-1，在NVIC设置中激活TIM3定时器中断；根据公式可算出：计数器时钟CK_CNT= 72M/7200 = 10000Hz，计时器中断时间为 ARR/10000 = 1s</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528200912377.png" alt="image-20230528200912377" style="zoom: 67%;" /></p></li><li><p>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ filesper peripheral ；点击GENERATE CODE，生成工程代码</p></li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在 tim.c 文件中可以看到定时器3的初始化函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_TIM3_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  TIM_ClockConfigTypeDef sClockSourceConfig = &#123;<span class="hljs-number">0</span>&#125;;  TIM_MasterConfigTypeDef sMasterConfig = &#123;<span class="hljs-number">0</span>&#125;;  htim3.Instance = TIM3;  htim3.Init.Prescaler = <span class="hljs-number">7199</span>;  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;  htim3.Init.Period = <span class="hljs-number">9999</span>;  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;  <span class="hljs-keyword">if</span> (HAL_TIM_Base_Init(&amp;htim3) != HAL_OK)  &#123;    Error_Handler();  &#125;  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;  <span class="hljs-keyword">if</span> (HAL_TIM_ConfigClockSource(&amp;htim3, &amp;sClockSourceConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIMEx_MasterConfigSynchronization(&amp;htim3, &amp;sMasterConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;&#125;</code></pre></div><ul><li>找到弱符号周期运行回调函数原型，并在tim.c中自定义该回调函数<code>__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</code></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_PeriodElapsedCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>&#123;    <span class="hljs-keyword">if</span>(htim == &amp;htim3)    &#123;        HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);<span class="hljs-comment">//LED1状态每1s翻转一次</span>    &#125;&#125;</code></pre></div><ul><li>在main.c中启动TIM3：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_TIM_Base_Start_IT(&amp;htim3); <span class="hljs-comment">//启动TIM3</span><span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div><p>编译下载到开发板，可以看到LED1每1s状态翻转一次，达到预期效果。</p><p>工程文件Gitee: <ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/tim3.zip">tim3</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之UART</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8BUART/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8BUART/</url>
    
    <content type="html"><![CDATA[<h3 id="串口简介">串口简介</h3><p>STM32F103ZET6 最多可提供 5路串口，有分数波特率发生器、支持同步单线通信和半双工单线通讯、支持LIN、支持调制解调器操作、智能卡协议和 IrDA SIR ENDEC 规范、具有DMA等。</p><p>我们通常使用的是异步通信，异步通信规定传输的数据格式由起始位（startbit）、数据位（data bit）、奇偶校验位（parity bit）和停止位（stopbit）组成。在进行传输之前，双方一定要使用相同的波特率，波特率就是每秒钟传输的数据位数。串口通讯有HAL库轮询，中断，DMA 三种通信模式：</p><ul><li><strong>轮询方式</strong>：CPU不断查询IO设备，如设备有请求则加以处理。例如CPU不断查询串口是否传输完成，如传输超过则返回超时错误。轮询方式会占用CPU处理时间，效率较低。</li><li><strong>中断控制方式</strong>：当I/O操作完成时，输入输出设备控制器通过中断请求线向处理器发出中断信号，处理器收到中断信号之后，转到中断处理程序，对数据传送工作进行相应的处理。</li><li><strong>直接内存存取技术（DMA）方式</strong>：所谓直接传送，即在内存与IO设备间传送一个数据块的过程中，不需要CPU的任何中间干涉，只需要CPU在过程开始时向设备发出“传送块数据”的命令，然后通过中断来得知过程是否结束和下次操作是否准备就绪。</li></ul><h3 id="硬件设计">硬件设计</h3><p>战舰开发板板载了 1 个 USB和 2 个 RS232串口。通过CH340芯片把串口1与PC的USB口进行连接，实现串口传输。我们将利用串口1不停的打印信息到电脑上，同时接收从串口发过来的数据，把发送过来的数据直接送回给电脑。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528133425092.png" alt="image-20230528133425092" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528134337560.png"alt="image-20230528134337560" /><figcaption aria-hidden="true">image-20230528134337560</figcaption></figure><ul><li>若使用中断方式，还需要开启串口中断</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528134456998.png"alt="image-20230528134456998" /><figcaption aria-hidden="true">image-20230528134456998</figcaption></figure><ul><li>若使用直接内存存取（DMA）方式，除以上步骤外（串口中断要开启，否则程序只能发送一次数据，且不能判断DMA传输是否完成，USART一直处于busy状态）还需要设置DMA传输方向、通道、优先级、数据长度以及指针递增与否</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528134749373.png"alt="image-20230528134749373" /><figcaption aria-hidden="true">image-20230528134749373</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated periphera initialization as a pair of ‘.c/.h’ filesper IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm软件编程">MDK-ARM软件编程</h4><p>在生成的usart.c文件中，软件已经帮我们实现了UART1和GPIO的初始化操作，以下只看轮询方式初始化函数。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_USART1_UART_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN USART1_Init 0 */</span>  <span class="hljs-comment">/* USER CODE END USART1_Init 0 */</span>  <span class="hljs-comment">/* USER CODE BEGIN USART1_Init 1 */</span>  <span class="hljs-comment">/* USER CODE END USART1_Init 1 */</span>  huart1.Instance = USART1;  huart1.Init.BaudRate = <span class="hljs-number">115200</span>;  huart1.Init.WordLength = UART_WORDLENGTH_8B;  huart1.Init.StopBits = UART_STOPBITS_1;  huart1.Init.Parity = UART_PARITY_NONE;  huart1.Init.Mode = UART_MODE_TX_RX;  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;  huart1.Init.OverSampling = UART_OVERSAMPLING_16;  <span class="hljs-keyword">if</span> (HAL_UART_Init(&amp;huart1) != HAL_OK)  &#123;    Error_Handler();  &#125;  <span class="hljs-comment">/* USER CODE BEGIN USART1_Init 2 */</span>  <span class="hljs-comment">/* USER CODE END USART1_Init 2 */</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_MspInit</span><span class="hljs-params">(UART_HandleTypeDef* uartHandle)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-keyword">if</span>(uartHandle-&gt;Instance==USART1)  &#123;  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspInit 0 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspInit 0 */</span>    <span class="hljs-comment">/* USART1 clock enable */</span>    __HAL_RCC_USART1_CLK_ENABLE();    __HAL_RCC_GPIOA_CLK_ENABLE();    <span class="hljs-comment">/**USART1 GPIO Configuration</span><span class="hljs-comment">    PA9     ------&gt; USART1_TX</span><span class="hljs-comment">    PA10     ------&gt; USART1_RX</span><span class="hljs-comment">    */</span>    GPIO_InitStruct.Pin = GPIO_PIN_9;    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);    GPIO_InitStruct.Pin = GPIO_PIN_10;    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;    GPIO_InitStruct.Pull = GPIO_NOPULL;    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspInit 1 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspInit 1 */</span>  &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_MspDeInit</span><span class="hljs-params">(UART_HandleTypeDef* uartHandle)</span>&#123;  <span class="hljs-keyword">if</span>(uartHandle-&gt;Instance==USART1)  &#123;  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspDeInit 0 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspDeInit 0 */</span>    <span class="hljs-comment">/* Peripheral clock disable */</span>    __HAL_RCC_USART1_CLK_DISABLE();    <span class="hljs-comment">/**USART1 GPIO Configuration</span><span class="hljs-comment">    PA9     ------&gt; USART1_TX</span><span class="hljs-comment">    PA10     ------&gt; USART1_RX</span><span class="hljs-comment">    */</span>    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_9|GPIO_PIN_10);  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspDeInit 1 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspDeInit 1 */</span>  &#125;&#125;</code></pre></div><p>打印输出会使用到printf函数，若要printf输出到串口，需要将fputc函数里面的输出指向串口(重定向)，在<code>usart.c</code>文件中重定向<code>fputc</code>函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span>&#123;HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span>*)&amp;ch, <span class="hljs-number">1</span>, <span class="hljs-number">0xffff</span>);<span class="hljs-keyword">return</span> ch;&#125;</code></pre></div><p>同时需要勾选 <strong>Use MicroLIB</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528140811005.png" alt="image-20230528140811005" style="zoom:80%;" /></p><p>下面在main函数中针对UART1三种操作方式进行编写程序：</p><ul><li>轮询方式</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    HAL_UART_Transmit(&amp;huart1, <span class="hljs-string">&quot;HAL_UART_Transmit Test...&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-number">0xffff</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n uart test...\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">500</span>);    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;</code></pre></div><p>实验现象：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528141728742.png" alt="image-20230528141728742" style="zoom:80%;" /></p><ul><li>中断方式</li></ul><p>在<strong>stm32f1xx_hal_uart.c</strong>文件中找到弱符号中断接收完成回调函数原型，并在usart.c中自定义该回调函数<code>__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</code></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> RxMsg[<span class="hljs-number">20</span>];<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_RxCpltCallback</span><span class="hljs-params">(UART_HandleTypeDef *huart)</span>&#123;<span class="hljs-keyword">if</span>(huart-&gt;Instance == USART1)&#123;HAL_UART_Transmit(&amp;huart1,RxMsg,<span class="hljs-number">10</span>,<span class="hljs-number">0xffff</span>);<span class="hljs-comment">//将接收的数据通过串口1发送回去</span>HAL_UART_Receive_IT(&amp;huart1,RxMsg,<span class="hljs-number">10</span>);<span class="hljs-comment">//再次开启接收中断</span>&#125;&#125;</code></pre></div><p>在<strong>main.c</strong>中添加以下代码： <div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint8_t</span> TxMsg[] = <span class="hljs-string">&quot;\r\n*****USART communication based on IT*****\r\n&quot;</span>;<span class="hljs-type">uint8_t</span> RxMsg[<span class="hljs-number">20</span>];<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_UART_Transmit_IT(&amp;huart1,TxMsg,<span class="hljs-keyword">sizeof</span>(TxMsg)); <span class="hljs-comment">//开启发送数据中断</span>HAL_UART_Receive_IT(&amp;huart1,RxMsg,<span class="hljs-number">10</span>); <span class="hljs-comment">//开启接收数据中断</span><span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div></p><p>使用串口助手发送10个字符，串口助手回显发送的数据；串口要发够10个字符才会触发中断；超过10个字符，串口只会发送10个字符（<strong>注意</strong>不要勾选‘发送新行’）</p><p>实验现象：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528144050587.png" alt="image-20230528144050587" style="zoom:80%;" /></p><ul><li>DMA方式</li></ul><p>在 main.c中添加如下代码：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint8_t</span> TxMsg[] = <span class="hljs-string">&quot;\r\n*****USART communication based on DMA*****\r\n&quot;</span>;<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    HAL_UART_Transmit_DMA(&amp;huart1,TxMsg,<span class="hljs-keyword">sizeof</span>(TxMsg));    HAL_Delay(<span class="hljs-number">500</span>);    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;<span class="hljs-comment">/* USER CODE END 3 */</span></code></pre></div><p>另外需要<strong>注意</strong>,软件会将DMA初始化函数放到uart初始化函数后面，这样无法实现DMA寄存器设置，无法实现功能。必须将MX_DMA_Init函数放在UARTDMA配置之前调用。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Initialize all configured peripherals */</span>MX_DMA_Init();MX_GPIO_Init();MX_USART1_UART_Init();<span class="hljs-comment">/* USER CODE BEGIN 2 */</span></code></pre></div><p>实验现象：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528150421728.png" alt="image-20230528150421728" style="zoom:80%;" /></p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/uart.zip">uart</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之EXTI</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8BEXTI/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8BEXTI/</url>
    
    <content type="html"><![CDATA[<h3 id="exti介绍">EXTI介绍</h3><p>STM32F103 的外部中断/事件控制器支持19个外部中断/事件请求（互联网型产品支持20个）。每个中断设有状态位，每个中断/事件都有独立的触发和屏蔽设置。</p><p>STM32F103的19个外部中断为：</p><ul><li>EXTI线0~15：对应外部IO口的输入中断</li><li>EXTI线16：连接到PVD输出</li><li>EXTI线17：连接到RTC闹钟事件</li><li>EXTI线18：连接到USB唤醒事件</li><li>EXTI线19：连接到以太网唤醒事件（互联网型产品）</li></ul><p>其中112个GPIO通过以下方式映射到16个外部中断/事件线上：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528115852770.png" alt="image-20230528115852770" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528102842722.png"alt="image-20230528102842722" /><figcaption aria-hidden="true">image-20230528102842722</figcaption></figure><p>这一章主要是通过外部中断的方式，用开发板上的4个按钮（KEY_UP、KEY0、KEY1 和 KEY2）来控制板上的 2 个 LED（DS0 和DS1）和蜂鸣器。</p><ul><li>KEY_UP 控制蜂鸣器，按一次叫，再按一次停；</li><li>KEY2 控制 DS0，按一次亮，再按一次灭；</li><li>KEY1 控制 DS1，效果同 KEY2；</li><li>KEY0 则同时控制 DS0 和 DS1，按一次，他们的状态就翻转一次。</li></ul><p><strong>注意</strong>：KEY0、KEY1 和 KEY2外部没有上下拉电阻，所以需要在MCU内部设置上下拉。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx配置">STM32CubeMx配置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PA0设置为<strong>GPIO外部中断上升沿触发模式</strong>、下拉；</li><li>PE2/PE3/PE4设置为<strong>GPIO外部中断下降沿触发模式</strong>、上拉；</li><li>PB8设置为GPIO推挽输出模式、上拉、高速、默认输出电平为低电平；</li><li>PB5和PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528122534347.png" alt="image-20230528122534347"  /></p><ul><li>在NVIC(嵌套向量中断控制器)中，勾选EXIT Line0/2/3/4interrupt，使能PA0和PE2/3/4中断。右边两个选项设置抢占优先级和响应优先级</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528123030801.png"alt="image-20230528123030801" /><figcaption aria-hidden="true">image-20230528123030801</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated periphera initialization as a pair of ‘.c/.h’ filesper IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在gpio.c文件中可以看到gpio初始化函数。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_GPIO_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">/* GPIO Ports Clock Enable */</span>  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(BEEP_GPIO_Port, BEEP_Pin, GPIO_PIN_RESET);  <span class="hljs-comment">/*Configure GPIO pins : PE2 PE3 PE4 */</span>  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4;  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;  GPIO_InitStruct.Pull = GPIO_PULLUP;  HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED1_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(LED1_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PA0 */</span>  GPIO_InitStruct.Pin = GPIO_PIN_0;  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;  GPIO_InitStruct.Pull = GPIO_PULLDOWN;  HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pins : PBPin PBPin */</span>  GPIO_InitStruct.Pin = LED0_Pin|BEEP_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);  <span class="hljs-comment">/* EXTI interrupt init*/</span>  HAL_NVIC_SetPriority(EXTI0_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);  HAL_NVIC_EnableIRQ(EXTI0_IRQn);  HAL_NVIC_SetPriority(EXTI2_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);  HAL_NVIC_EnableIRQ(EXTI2_IRQn);  HAL_NVIC_SetPriority(EXTI3_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);  HAL_NVIC_EnableIRQ(EXTI3_IRQn);  HAL_NVIC_SetPriority(EXTI4_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  HAL_NVIC_EnableIRQ(EXTI4_IRQn);&#125;</code></pre></div><p>在<strong>stm32f1xx_hal_gpio.c</strong>文件中找到GPIOEXTI弱符号中断回调函数原型，并在gpio.c中自定义该回调函数<code>__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)</code></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span>&#123;HAL_Delay(<span class="hljs-number">10</span>);<span class="hljs-comment">/* PA0 -&gt; EXTI0 */</span><span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_0)&#123;HAL_GPIO_TogglePin(BEEP_GPIO_Port, BEEP_Pin);&#125;<span class="hljs-comment">/* PE2 -&gt; EXTI2 */</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_2)&#123;HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);&#125;<span class="hljs-comment">/* PE3 -&gt; EXTI3 */</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_3)&#123;HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);&#125;<span class="hljs-comment">/* PE4 -&gt; EXTI4 */</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_4)&#123;HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);&#125;&#125;<span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div><p>main.c函数不需要添加任何代码，编译下载，跟按键输入一章同样的现象，获得预期目标。</p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/exti.zip">exti</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之按键输入</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8B%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8B%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>上一节介绍了GPIO的输出使用，这一节介绍一下GPIO的输入，GPIO口作为输入使用的时候，是通过读取GPIOx_IDR寄存器内容来获得IO口的状态。</p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528102842722.png"alt="image-20230528102842722" /><figcaption aria-hidden="true">image-20230528102842722</figcaption></figure><p>通过开发板上的4 个按钮（KEY_UP、KEY0、KEY1 和 KEY2）来控制板上的 2 个LED（DS0 和 DS1）和蜂鸣器。</p><ul><li>KEY_UP 控制蜂鸣器，按一次叫，再按一次停；</li><li>KEY2 控制 DS0，按一次亮，再按一次灭；</li><li>KEY1 控制 DS1，效果同 KEY2；</li><li>KEY0 则同时控制 DS0 和 DS1，按一次，他们的状态就翻转一次。</li></ul><p><strong>注意</strong>：KEY0、KEY1 和 KEY2外部没有上下拉电阻，所以需要在MCU内部设置上下拉。必须初始化WK_UP键（PA0），否则其它按键不能正常使用，属于开发板的bug吧，这个问题折腾好久。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PA0设置为GPIO输入模式、下拉；</li><li>PE2/PE3/PE4设置为GPIO输入模式、上拉；</li><li>PB8设置为GPIO推挽输出模式、上拉、高速、默认输出电平为低电平；</li><li>PB5和PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528104919285.png"alt="image-20230528104919285" /><figcaption aria-hidden="true">image-20230528104919285</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated periphera initialization as a pair of ‘.c/.h’ filesper IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm软件编程">MDK-ARM软件编程</h4><ol type="1"><li>在gpio.c文件中可以看到各GPIO管脚的初始化函数</li></ol><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_GPIO_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">/* GPIO Ports Clock Enable */</span>  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(BEEP_GPIO_Port, BEEP_Pin, GPIO_PIN_RESET);  <span class="hljs-comment">/*Configure GPIO pins : PEPin PEPin PEPin */</span>  GPIO_InitStruct.Pin = KEY2_Pin|KEY1_Pin|KEY0_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;  GPIO_InitStruct.Pull = GPIO_PULLUP;  HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED1_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(LED1_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = WK_UP_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;  GPIO_InitStruct.Pull = GPIO_PULLDOWN;  HAL_GPIO_Init(WK_UP_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pins : PBPin PBPin */</span>  GPIO_InitStruct.Pin = LED0_Pin|BEEP_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);&#125;</code></pre></div><ol start="2" type="1"><li>在工程的应用文件目录下创建key文件夹，并在文件夹中创建key.c和key.h文件，然后编写按键相关函数</li></ol><ul><li>key.h文件：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _KEY_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> _KEY_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f1xx.h&quot;</span></span><span class="hljs-comment">//下面的方式是通过直接操作HAL库函数方式读取IO</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0        HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_4)  <span class="hljs-comment">//KEY0按键PE4</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1        HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_3)  <span class="hljs-comment">//KEY1按键PE3</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY2        HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_2) <span class="hljs-comment">//KEY2按键PE2</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WK_UP       HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0)  <span class="hljs-comment">//WKUP按键PA0</span></span><span class="hljs-comment">//定义按键按下时的键值</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_PRES 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_PRES2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY2_PRES3</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_PRES   4</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">key_scan</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> mode)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><ul><li>key.c文件：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;key.h&quot;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief按键处理函数,返回按键值(注意此函数有响应优先级,KEY0&gt;KEY1&gt;KEY2&gt;WK_UP!!)</span><span class="hljs-comment">  * @parammode:0 不支持连续按；1 支持连续按</span><span class="hljs-comment">  * @retval按键值</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">key_scan</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> mode)</span>&#123;    <span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> key_up=<span class="hljs-number">1</span>;     <span class="hljs-comment">//按键松开标志</span>    <span class="hljs-keyword">if</span>(mode==<span class="hljs-number">1</span>)key_up=<span class="hljs-number">1</span>;    <span class="hljs-comment">//支持连按</span>    <span class="hljs-keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="hljs-number">0</span>||KEY1==<span class="hljs-number">0</span>||KEY2==<span class="hljs-number">0</span>||WK_UP==<span class="hljs-number">1</span>))    &#123;        HAL_Delay(<span class="hljs-number">10</span>);<span class="hljs-comment">//按键消抖</span>        key_up=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(KEY0==<span class="hljs-number">0</span>)       <span class="hljs-keyword">return</span> KEY0_PRES;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY1==<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> KEY1_PRES;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY2==<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> KEY2_PRES;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(WK_UP==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> WKUP_PRES;              &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY0==<span class="hljs-number">1</span>&amp;&amp;KEY1==<span class="hljs-number">1</span>&amp;&amp;KEY2==<span class="hljs-number">1</span>&amp;&amp;WK_UP==<span class="hljs-number">0</span>)key_up=<span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//无按键按下</span>&#125;</code></pre></div><ul><li>在main.c函数中编写相关程序</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>  <span class="hljs-type">uint8_t</span> key;  <span class="hljs-comment">/* USER CODE END 1 */</span>  <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>  <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>  HAL_Init();  <span class="hljs-comment">/* USER CODE BEGIN Init */</span>  <span class="hljs-comment">/* USER CODE END Init */</span>  <span class="hljs-comment">/* Configure the system clock */</span>  SystemClock_Config();  <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>  <span class="hljs-comment">/* USER CODE END SysInit */</span>  <span class="hljs-comment">/* Initialize all configured peripherals */</span>  MX_GPIO_Init();  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>  <span class="hljs-comment">/* USER CODE END 2 */</span>  <span class="hljs-comment">/* Infinite loop */</span>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>key = key_scan(<span class="hljs-number">0</span>);<span class="hljs-keyword">switch</span>(key)    &#123;<span class="hljs-keyword">case</span> WKUP_PRES:&#123;<span class="hljs-comment">/* 控制蜂鸣器 */</span>HAL_GPIO_TogglePin(BEEP_GPIO_Port, BEEP_Pin);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> KEY2_PRES:&#123;<span class="hljs-comment">/* LED0 */</span>HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> KEY1_PRES:&#123;<span class="hljs-comment">/* LED1 */</span>HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> KEY0_PRES:&#123;<span class="hljs-comment">/* LED0 &amp; LED1 */</span>HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);<span class="hljs-keyword">break</span>;&#125;    &#125;HAL_Delay(<span class="hljs-number">10</span>);  &#125;  <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><ol start="3" type="1"><li>程序验证</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528114108663.png" alt="image-20230528114108663" style="zoom:80%;" /></p><p>注意添加头文件，设置下载器选项，编译下载程序，分别按下按键，现象和预期一致，达到了实验目的。</p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/key.zip">key</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之LED闪烁</title>
    <link href="/2023/05/27/STM32CubeMX%E4%B9%8BLED%E9%97%AA%E7%83%81/"/>
    <url>/2023/05/27/STM32CubeMX%E4%B9%8BLED%E9%97%AA%E7%83%81/</url>
    
    <content type="html"><![CDATA[<p>下面结合正点原子战舰开发板，对多个外设介绍，并编程实验。</p><p>开发板使用的MCU是STM32F103ZET6，进入ST官网，下载其相关资料。<ahref="https://www.st.com/en/microcontrollers-microprocessors/stm32f103ze.html#documentation">STM32F103ZE</a></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527225335619.png"alt="image-20230527225335619" /><figcaption aria-hidden="true">image-20230527225335619</figcaption></figure><h3 id="gpio口简介">GPIO口简介</h3><p>每个GPIO端口有两个32位配置寄存器（GPIOx_CRL和GPIOx_CRH），两个32位数据寄存器（GPIOx_IDR和GPIOx_ODR），一个32位置位/复位寄存器（GPIOx_BSRR），一个16位复位寄存器（GPIOx_BRR）和一个32位锁定寄存器（GPIOx_LCKR）。在HAL库中，GPIO端口的每个位可以由软件分别配置成多种模式：</p><ul><li>浮空输入模式</li><li>开漏输出模式</li><li>复用推挽模式</li><li>复用输入模式</li><li>模拟模式</li><li>上升沿触发中断模式</li><li>下降沿触发中断模式</li><li>上升沿/下降沿触发中断模式</li><li>上升沿触发事件模式</li><li>下降沿触发事件模式</li><li>上升沿/下降沿触发事件模式</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527225635350.png" alt="image-20230527225635350" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">1. STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PB5和PE5设置为GPIO推挽输出模式、上拉、低速、默认输出电平为高电平</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527232409961.png" alt="image-20230527232409961"  /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARMV5；勾选Generated periphera initialization as a pair of ‘.c/.h’ filesper IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="keil工程代码的编写">2.keil工程代码的编写</h4><ul><li>CubeMX已经帮我们完成gpio初始化的过程。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_GPIO_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">/* GPIO Ports Clock Enable */</span>  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED1_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  HAL_GPIO_Init(LED1_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED0_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  HAL_GPIO_Init(LED0_GPIO_Port, &amp;GPIO_InitStruct);&#125;</code></pre></div><ul><li>我们只需要在main.c函数中编写LED闪烁程序即可（<strong>注意编写的程序应该在相应的USERCODE范围内，否则再次使用CubeMX修改配置时，USERCODE范围之外的程序会被清除</strong>）</li></ul><p>在<strong>stm32f1xx_hal_gpio.h</strong>库文件中,找到可以改变引脚电平的API函数</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_WritePin</span><span class="hljs-params">(GPIO_TypeDef *GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin, GPIO_PinState PinState)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_TogglePin</span><span class="hljs-params">(GPIO_TypeDef *GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span>;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527234410653.png" alt="image-20230527234410653" style="zoom:80%;" /></p><ul><li>下载程序</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527235236622.png" alt="image-20230527235236622" style="zoom:80%;" /></p><p>可以看到两个LED不停的闪烁。</p><p>工程文件Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/led.zip">LED</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之开发环境的搭建</title>
    <link href="/2023/05/27/STM32CubeMX%E4%B9%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/05/27/STM32CubeMX%E4%B9%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>在ST公司推出HAL库之前，开发SMT32一般使用的是标准库，但后来为了便于移植程序，官方不再更新STM32标准库，而大力推崇HAL库，伴随HAL库的兴起，ST推出了STM32CubeMX开发工具，它是STM32芯片图形化配置工具，允许用户使用图形化向导生成C初始化代码，极大限度内减少了工程师的工作量，转而把工作重点放在项目逻辑层、应用层的实现。另外，ST也同时推出一整套IDE软件STM32CubeIDE，本章不做过多介绍。</p><p>HAL 的全称是：<strong>Hardware Abstraction Layer(硬件抽象层)</strong>，HAL位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化。它是一个由ST公司基于硬件抽象层而设计的软件函数包，由程序、数据结构、宏等组成，包括了微控制器所有外设的性能特征。此外HAL函数库包括每一个外设的驱动描述和应用实例，为开发者访问底层硬件提供了一个中间API，所以说通过使用 HAL库，工程师不需要花过多精力去深入掌握底层硬件细节，就可以应用STM32的每个外设，实现快速二次开发的目的。</p><h3 id="smt32开发环境的搭建">SMT32开发环境的搭建</h3><p><strong>友情提醒：全程下载安装过程中尽量不要使用中文目录，防止个别异常情况发生。</strong></p><h4 id="一keil-mdk-arm软件的安装">一、Keil MDK-ARM软件的安装</h4><ol type="1"><li>获取Keil MDK-ARM软件：<ahref="https://developer.arm.com/Tools%20and%20Software/Keil%20MDK">官网</a></li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527210314137.png"alt="image-20230527210314137" /><figcaption aria-hidden="true">image-20230527210314137</figcaption></figure><p>可以安装社区版，免费正版使用一年，需要进行注册才能下载，为了学习可以在网上查找其他方式进行安装。</p><ol start="2" type="1"><li>获取STM32芯片设备安装包：<ahref="https://www.keil.arm.com/devices/?q=&amp;vendor=stmicroelectronics&amp;core=Cortex-M3&amp;sort_by=">官网</a></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527210938403.png" alt="image-20230527210938403"  /></p><p>选择对应的厂商和内核版本，进行相应下载即可。</p><ol start="3" type="1"><li>安装keil软件和STM32设备安装包</li></ol><h4 id="二stm32cubemx软件的安装">二、STM32CubeMX软件的安装</h4><p>安装STM32CubeMX必须具备的条件：</p><ul><li>JRE（Java Runtime Environment）：JAVA运行环境。</li><li>STM32CubeMX软件：生成初始化代码的地方。</li><li>HAL库PACK包：F0、F1、F3、H7等Cortex内核，都需要对应的PACK包安装。</li></ul><ol type="1"><li>安装JRE：JRE官网下载链接：https://www.java.com/en/download/manual.jsp</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527212452472.png" alt="image-20230527212452472" style="zoom:80%;" /></p><ol start="2" type="1"><li>获取STM32CubeMX：<ahref="https://www.st.com/en/development-tools/stm32cubemx.html">官网</a></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527211706175.png" alt="image-20230527211706175"  /></p><ol start="3" type="1"><li>获取HAL库 PACK包，由两种方式：</li></ol><ul><li>通过STM32CubeMX软件进行安装</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527213020674.png" alt="image-20230527213020674" style="zoom: 67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527213741351.png" alt="image-20230527213741351" style="zoom: 80%;" /></p><ul><li>下载离线PACK包，然后通过STM32CubeMX软件进行安装：<ahref="https://www.st.com/en/development-tools/stm32cubemx.html#tools-software">官网</a></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527214001528.png" alt="image-20230527214001528" style="zoom: 67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527213852127.png" alt="image-20230527213852127" style="zoom:80%;" /></p><h4 id="三stm32cubemx使用">三、STM32CubeMX使用</h4><ul><li>新建工程，选择对应开发MCU</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527214446420.png" alt="image-20230527214446420"  /></p><ul><li>RCC设置，选择HSE（外部高速时钟）为Crystal/CeramicResonator（晶振/陶瓷谐振器）</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527214726370.png" alt="image-20230527214726370"  /></p><ul><li>时钟配置，STM32F103最高时钟为72M</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527215030571.png" alt="image-20230527215030571"  /></p><ul><li>功能外设配置，以PA0/PA1为例，设置GPIO引脚相关参数</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527215605956.png" alt="image-20230527215605956"  /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527215826116.png"alt="image-20230527215826116" /><figcaption aria-hidden="true">image-20230527215826116</figcaption></figure><ul><li>工程设置并生成Keil工程</li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527220345421.png"alt="image-20230527220345421" /><figcaption aria-hidden="true">image-20230527220345421</figcaption></figure><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530093411899.png"alt="image-20230530093411899" /><figcaption aria-hidden="true">image-20230530093411899</figcaption></figure><ul><li>点击OpenProject，打开keil工程，至此就配置好了工程外设初始化；在gpio.c文件中可以看到PA0/PA1管脚的初始化函数；至此用户可以根据自已的需求编写应用程序</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527221407553.png" alt="image-20230527221407553" style="zoom: 80%;" /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527222104592.png"alt="image-20230527222104592" /><figcaption aria-hidden="true">image-20230527222104592</figcaption></figure><h4 id="参考链接">参考链接：</h4><p><a href="http://t.csdn.cn/dnLul">STM32CubeMX系列</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典运放电路的分析与计算</title>
    <link href="/2023/05/27/%E7%BB%8F%E5%85%B8%E8%BF%90%E6%94%BE%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/05/27/%E7%BB%8F%E5%85%B8%E8%BF%90%E6%94%BE%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>基本运放电路是模拟电路的学习重点，复杂的模拟电路很多都是由基本运放电路组成的。在运放电路中，一般运用运放的“虚短”和“虚断”来进行分析，然后应用欧姆定律等电流电压关系，即可得输入输出的关系。</p><p><strong>“虚短”</strong>是指在分析运算放大器处于线性状态时，可把两输入端视为等电位（<strong>V+= V-</strong>），这一特性称为虚假短路，简称虚短。显然不能将两输入端真正短路。</p><p><strong>“虚断”</strong>是指在分析运放处于线性状态时，可以把两输入端视为等效开路（<strong>ib-= ib+ =0</strong>），这一特性称为虚假开路，简称虚断。显然不能将两输入端真正断路。（差模输入电阻无穷大）</p><p>以下详细看看基本运放电路：</p><ul><li><strong>反向运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527131553159.png" alt="image-20230527131553159" style="zoom:80%;" /></p><ul><li><strong>同向运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527133057553.png" alt="image-20230527133057553" style="zoom:80%;" /></p><ul><li><strong>反相求和运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527134531510.png" alt="image-20230527134531510" style="zoom:80%;" /></p><ul><li><strong>同相求和运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527140528733.png" alt="image-20230527140528733" style="zoom:80%;" /></p><ul><li><strong>减法运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527141757901.png" alt="image-20230527141757901" style="zoom:80%;" /></p><ul><li><strong>积分电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527143345994.png" alt="image-20230527143345994" style="zoom:80%;" /></p><ul><li><strong>微分电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527144506543.png" alt="image-20230527144506543" style="zoom:80%;" /></p><ul><li><strong>差分运算电路</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527155455519.png"alt="image-20230527155455519" /><figcaption aria-hidden="true">image-20230527155455519</figcaption></figure><ul><li><strong>电流检测电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527163159557.png" alt="image-20230527163159557" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527163453552.png" alt="image-20230527163453552" style="zoom:80%;" /></p><ul><li><strong>电压检测电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527175438392.png" alt="image-20230527175438392" style="zoom:80%;" /></p><p>以上是基本的运放电路及分析，掌握了基本的运放电路分析方法，对于复杂的运放电路，可以进行拆解分析，在实际应用中要做到举一反三。</p><p><strong>参考链接：</strong></p><p>http://t.csdn.cn/xbhB9</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几种常用的电平转换方法</title>
    <link href="/2023/05/26/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%B5%E5%B9%B3%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/"/>
    <url>/2023/05/26/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%B5%E5%B9%B3%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在电路设计时，有时会遇到电压域不匹配的问题，如外部接口芯片为1.8V供电，而MCU为3.3V供电。这时候就需要进行电平转换才能通讯。下面总结几种常用的电平转换电路。</p><h3 id="二极管电平转换电路">二极管电平转换电路</h3><p>一些通讯模块（4G、NB模块等）的串口是1.8V电平，与常用MCU的3.3V，这时就需要电平转换。需要注意转换的方向，高电压端和低电压端不可调换。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526230229375.png" alt="image-20230526230229375" style="zoom:80%;" /></p><p>当TX为低电平时，D1导通，RX被拉低；</p><p>当TX为高电平3.3V时，D1截止，RX被拉高到1.8V高电平;</p><h3 id="三极管电平转换电路">三极管电平转换电路</h3><ul><li>IC为1.8V电平，MCU为3.3V电平。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526232323959.png" alt="image-20230526232323959" style="zoom:80%;" /></p><p>当TXD为低电平时，Q1导通，RXD被拉低；</p><p>当TXD为高电平1.8V时，Q1截止，RXD被拉到高电平。</p><ul><li>将外接的信号转化为稳定的高低电平。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526232932554.png" alt="image-20230526232932554" style="zoom:80%;" /></p><p>当输入 S_IN 为低电平时，三极管 Q1关断，三极管 Q2 基极为高电平，导致Q2 导通，输出端 S_OUT被拉低，实现两端都为低电平。</p><p>当输入 S_IN 为高电平 (VDD_EXT) 时，三极管 Q1导通，三极管Q2关断，输出端 S_OUT 被 R4 拉高到VDD_MCU，实现两端都为高电平。</p><p>❤️三极管电平转换电路，便宜实用，但是只能单向转化。而且不适用于波特率过高的应用（大概大于400Kbps 就不建议用了）。</p><h3 id="mos管电平转换电路">MOS管电平转换电路</h3><p>在使用I2C、SPI等接口做不同电压域通讯时，就需要用到双向的电平转换电路。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526233821002.png" alt="image-20230526233821002" style="zoom:80%;" /></p><p>取SDA数据线进行分析：</p><p>当SDA1输出高电平时：MOS管Q1的Vgs =0，MOS管关闭，SDA2被电阻R3上拉到5V。</p><p>当SDA1输出低电平时：MOS管Q1的Vgs =3.3V，大于导通电压，MOS管导通，SDA2通过MOS管被拉到低电平。</p><p>当SDA2输出高电平时：MOS管Q1的Vgs不变，MOS维持关闭状态，SDA1被电阻R2上拉到3.3V。</p><p>当SDA2输出低电平时：MOS管不导通，但是它有体二极管，MOS管里的体二极管把SDA1拉低到低电平，此时Vgs约等于3.3V，MOS管导通，进一步拉低了SDA1的电压。</p><h3 id="电平转换芯片">电平转换芯片</h3><p>在一些高速通讯的场合，就需要用到专用的电平转换芯片。芯片有很多种，单向电平转换、带方向控制的双向电平转换、自动双向电平转换等。如SN74LVC4245A、TXS0108EPWR。</p><p>❤️成本相对前面较高，但是速度快，双向并且能够自动检测方向，高速低速场合都适用。</p><p>如果对成本不敏感，电平转换芯片是最稳定可靠的方式。</p><h3 id="参考链接">参考链接</h3><p>http://t.csdn.cn/9Tvhd</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PT100测温电路总结分析</title>
    <link href="/2023/05/25/PT100%E6%B5%8B%E6%B8%A9%E7%94%B5%E8%B7%AF%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/"/>
    <url>/2023/05/25/PT100%E6%B5%8B%E6%B8%A9%E7%94%B5%E8%B7%AF%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>PT100温度传感器是一种以铂(Pt)作成的电阻式温度传感器，属于正电阻系数,其电阻和温度变化的关系为：<strong>R=R0(1+αT)其中α=0.003851,Ro 为 100Ω(在 0℃的电阻值),T 为摄氏温度</strong>。</p><p>PT100测温采样电路主要有电桥法、恒流源法、集成芯片法等，分别介绍如下：</p><h3 id="一惠斯通电桥法">一、惠斯通电桥法</h3><p>惠斯通电桥（<strong>Wheatstonebridge</strong>）又称为惠斯登电桥，是一种测量工具，用来精确测量电阻器的电阻值。它的拓扑图如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526091948810.png"alt="image-20230526091948810" /><figcaption aria-hidden="true">image-20230526091948810</figcaption></figure><p>在实际使用中，一般会将电阻的变化量转化为电压的变化，我们通常将其中三个电阻值固定，而将另外一个电阻换成热敏电阻、压敏电阻、PT100等，这时候就可以用电桥来测物理量了。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-22233.png"alt="image-22233" /><figcaption aria-hidden="true">image-22233</figcaption></figure><p>如果将PT100接入电桥，PT100的阻值发生变化导致ΔV发生变化，通过差分运放放大后送入AD转换芯片或直接进入单片机的AD采样部分，再对照PT100的电阻-温度对应表就可以知道当前温度了。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230114357429.png"alt="image-20230114357429" /><figcaption aria-hidden="true">image-20230114357429</figcaption></figure><p><strong>恒压源：</strong></p><p>这里采用TL431通过分压产生+4.096V恒压源，也可通过REF3140作为基准源。</p><p><strong>电桥部分：</strong></p><p>因为PT100厚膜铂电阻温度传感器允许通过的工作<em>电流</em>为:<em>≦5mA</em>，所以电桥部分电阻阻值需要注意。RP2电位器主要作用是调节温度的下限，设计中可以设置为固定值。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-202305150017095.png"alt="image-202305150017095" /><figcaption aria-hidden="true">image-202305150017095</figcaption></figure><p><strong>RF部分：</strong></p><p>参考AD623芯片手册进行滤波干扰处理。</p><p><strong>放大电路：</strong></p><p>RG阻值可改变放大倍数G，RG = 100 kΩ/(G − 1) ，它们的关系如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-202306142609555.png"alt="image-202306142609555" /><figcaption aria-hidden="true">image-202306142609555</figcaption></figure><p>运算放大器还可以用AD620、AD627、OP07、MCP355X等芯片。</p><p><strong>应用</strong></p><p>比如VCC电压为 <strong>+5V</strong>，设置运放增益为<strong>100</strong>，则最大输入电压为 <strong>50mV(5V/100)</strong>.</p><p>运算放大器反向端电压：V- = 4.096*RP2/(2500+RP2)</p><p>运算放大器同向端电压：V+ = V- + 50mV;</p><p>则通过分压原理，PT100最大阻值：R = (2500*V+) / (4.096-V+);</p><p>譬如设置最低温度下限为 <strong>-50℃</strong>，则对应PT100阻值:<strong>80.31Ω</strong>，为了电桥平衡，设置RP2为<strong>80.31Ω</strong>，由以上公式PT100最大阻值R=<strong>113.23Ω</strong>，对应的温度：<strong>30.4℃</strong>。则温度测试的范围（-50~30.4℃），可通过调小运放增益来扩宽温度的范围。（电阻的取值要根据市面上相近的阻值来确定，计算的阻值不见得有）</p><h3 id="二恒流源法">二、恒流源法</h3><p>参考<ahref="https://blog.csdn.net/z3y3m3/article/details/86225594">PT100恒流源测温电路</a></p><h3 id="三芯片集成法">三、芯片集成法</h3><p>集成芯片测PT100，市面有很多，如ADS1120、MAX31865、HX712、HX717、CS1237、TM7711等，查看其芯片手册，一般都会有典型应用线路。</p><h3 id="参考链接">参考链接</h3><p><ahref="PT100/PT1000温度采集电路方案">PT100/PT1000温度采集电路方案</a></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pcb layout 审核表</title>
    <link href="/2023/05/25/pcb-layout-%E5%AE%A1%E6%A0%B8%E8%A1%A8/"/>
    <url>/2023/05/25/pcb-layout-%E5%AE%A1%E6%A0%B8%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>PCB设计完成需要进行综合检查，除了设计软件设定的规则外，还需要手动确认一些其它重要的信息。</p><h3 id="结构">结构</h3><ul><li><p>PCB中的定位孔位置大小是否和结构的要求一致，旁边是否有挨得太近的器件（保留间距大于1mm）；</p></li><li><p>接插件的型号，方向，顺序是否和要求一致，位置是否合理；</p></li><li><p>母板，子板的连接座的方向，顺序是否一致，位置是否合理；</p></li><li><p>新器件的封装，脚位定义，电气连接都需校对；</p></li></ul><h3 id="原理图和pcb">原理图和PCB</h3><ul><li>确保从原理图导入的网表无误（务必在审核PCB时实际导入，核对）；</li><li>核对PCB的板层设置是否合理；</li></ul><h3 id="电源">电源</h3><ul><li>电源线路要求尽量短，粗，考虑温升；</li><li>关掉敷铜层和走线，点亮地网络，检查地过孔是否足够；</li><li>IC的散热焊盘上是否有多过孔接地；</li></ul><h3 id="usb">USB</h3><ul><li>USB的脚位排序是否正确（VBUS/DM/DP/GND）；</li><li>USB DM,DP走线是否满足差分要求，不要有节点；</li><li>请注意DM，DP走线是否和其它数据线平行（临层平行）</li><li>HOST端口的电源走线宽度是否满足要求；</li></ul><h3 id="wifi">WIFI</h3><ul><li>WIFI天线是否进行包地处理；</li><li>WIFI的接地检查；模块是否可靠接地，模块的散热焊盘不能全敷铜接地；</li><li>晶体Layout检查；晶体电路下方必须铺地，且下面的其它层尽量只走控制线，最好铺地；</li></ul><h3 id="audio">Audio</h3><ul><li>电源的滤波电容是否靠近IC电源管脚，电源线是否有数据线干扰；</li><li>音频IC的下方不能走数据线；</li><li>音频的输入，输出走线（包括MIC）是否包地，是否有高频干扰信号，临层是否有电源层和数字信号；</li><li>如音频线的走线比较长（100mil以上)，建议左右声道中间隔地；</li><li>I2S走线是否分组，在同一区域布线，各数据线是否等长；</li></ul><h3 id="sd">SD</h3><ul><li>SDIO走线是否为一组，在同一区域布线，各数据和CLK等长，CLK尽量包地；</li><li>SD卡座电源管脚位置放置10uF的电容；</li><li>检查SD卡脚位的正确性；</li></ul><h3 id="sdram">SDRAM</h3><ul><li>DDR的走线分四组：数据线（DQ，DM，DQS），地址线，命令线，CLK线。</li></ul><ol start="2" type="1"><li>DQS走线位置应在组内的DQ中间；</li><li>DQS与时钟不要相邻；</li><li>地址/命令/控制信号采用T型拓扑方式，分叉点到DDR芯片两端的长度须尽量等长（若不等长，可走蛇形线使两端等长）；</li><li>蛇形线的中心间距至少3倍线宽；</li></ol><ul><li>尽量拉大数据线与数据线的距离；相邻层的数据线避免正对并行；</li><li>DDR的数据线尽量走PCB的表层，方便阻抗匹配；</li><li>CLK差分对之间是否有端接电阻；</li></ul><h3 id="camera">Camera</h3><ul><li>电源的滤波电容是否靠近相应的IC电源管脚，电源走线是否受到数据线干扰；</li><li>数据线分组，Layout在同一区域，需要控制数据线的等长，误差在500mil之内；</li><li>CLKin/out信号串电阻并电容，复位信号高低电平；</li><li>CLKin和CLKout应包地处理，不要其它数据线相互平行（注意临层平行）；</li></ul><h3 id="lcd">LCD</h3><ul><li>核对LCD座的封装，脚位顺序，屏的插入方式；</li><li>LCD的走线分组，Layout在同一区域，需要控制数据线和CLK的线的等长，误差在500mil之内，特别是有HDMI和RK1000S时；</li><li>LCD的clk最好能包地，串磁珠，并电容；CLK的参考层最好不要换；</li><li>TMDS信号是否按差分线要求Layout；</li><li>LCD的数据线最好的方式是走中间层，尽量少走外层；</li><li>LCD部分的走线和器件需要屏蔽（包括LVDS IC，HDMI IC）</li><li>LCD的FPC位置下面的表层PCB上要留有接地的漏铜区，便于FPC包屏蔽材料接地(如需过EMI测试，LCD一定会要可靠接地）；</li></ul><h3 id="hdmi">HDMI</h3><ul><li>数据线是否分组，同一区域布线，是否等长（误差不超过500mil），CLK上需要串串磁珠并电容到地；</li><li>电源的滤波电容是否靠近IC电源管脚，电源走线是否避开数据线；</li><li>TMDS信号是否按差分线要求Layout；</li><li>HDMI走线和器件需严控屏蔽；</li></ul><h3 id="g">3G</h3><ul><li>电源的走线宽度是否足够宽；滤波电容是否靠近相应的电源管脚；</li><li>3G整机需要有严格的屏蔽（RF电路和数字电路分开屏蔽）；</li><li>3G通话要注意结构上喇叭和MIC位置的处理，喇叭和MIC要有各自的腔体；</li><li>天线的Layout检查；</li></ul><h3 id="gps">GPS</h3><ul><li>电源和滤波电容的位置；</li><li>是否有有严格的屏蔽（RF电路和数字电路分开屏蔽）,所有的具有数字信号的器件都有要求，如Code,LCD,LVDS,HDMI，并且LCD的FPC，摄像头的FPC，喇叭连接线附近都要预留漏铜区便于相关连接线屏蔽接地；</li><li>GPS的天线位置是否合理，和金属部件的距离是否有6mm以上的距离；</li></ul><h3 id="compass">Compass</h3><ul><li>尽量不要放在屏蔽壳内(如有必要，需采用)；</li><li>周围是否大电流的数据线；</li><li>是否和磁感器件，软铁材料保持需要的距离（喇叭，SD卡座）</li></ul><h3 id="测试点检查">测试点检查</h3><ul><li>是否放置如下测试点：开机键；USB口；触摸屏；电池座，耳机座，DC座;外响焊点；</li><li>测试点直径需要0.8mm，测试点与测试点的距离不能小于1.25mm，测试点与器件的距离不能小于0.2mm；</li></ul><h3 id="发热器件">发热器件</h3><ul><li>发热器件应该放置在利于散热的位置上,且注意不要放置在对温度敏感的器件旁边；</li><li>不同发热器件的距离最好能拉开距离，尽量保持在20mm以上；</li></ul><h3 id="其它">其它</h3><ul><li>WIFI天线不能放在手能握住的地方，避免客户使用机器的时候信号不好；</li><li>调试口是否接出；</li><li>PCB的版本和日期是否标识清晰；</li><li>如果有其它器件，请参考它们的Layout规格；</li></ul><p>以上部分摘录自PCB联盟网，PCB设计完成后，对照审核表进行详细检查，可以避免PCB设计的错误，另外，“<ahref="https://dfm.elecfans.com/viewer/?tid=DFM-dh">华秋DFM</a>”软件可检查PCB的可制造性，它可自动分析PCB的设计缺陷。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230525180738659.png" alt="image-20230525180738659" style="zoom:80%;" /></p><p><a href="https://gitee.com/kayoungzhang/my_codehub.git">PCB layoutchecklist</a></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PCB layout rules</title>
    <link href="/2023/05/24/PCB-layout-rules/"/>
    <url>/2023/05/24/PCB-layout-rules/</url>
    
    <content type="html"><![CDATA[<p>PCB设计过程中，器件的整体布局和关键信号的layout至关重要，布局得当，信号线layout顺畅，就会在后续设计开发过程中，减少不必要的麻烦，相反，布局不当，layout失误，一是影响PCB整体的美观程度，二是在测试应用中带来诸多麻烦。为了减少不必要的设计麻烦，下面介绍一些常用的PCB设计的布局和layout规则：</p><h3 id="pcb布局">PCB布局</h3><ul><li>首先对结构有限高或位置要求的器件进行摆放。布局要美观，器件间尽量对齐。</li><li>PCB整体布局要考虑散热，电源，模拟、数字电路和高速、中速、低速电路等要分开布局。强电流、高电压、强辐射元件要远离弱电流、低电压、敏感器件。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524194603654.png" alt="image-20230524194603654" style="zoom:80%;" /></p><ul><li><p>以每个功能电路的核心组件为中心，围绕它进行布局，尽量减少和缩短各零件间的引线和连接。</p></li><li><p>高压元器件和低压元器件之间最好要有较宽的电气隔离带。</p></li><li><p>布局要考虑布线通道和空间，预估电源通道，不要来回绕。</p></li><li><p>接口保护器件尽量靠近接口摆放，采用一字型布局。信号转换芯片靠近插接口放置。</p></li><li><p>插拔器件或板边连接器周围3mm范围内尽量不布置SMD，以防止连接器插拔时产生的应力损伤器件。</p></li><li><p>器件摆放要外围留有足够的焊接空间，考虑后期可手动焊接。</p></li><li><p>有极性或方向性的插件器件在布局上方向一致，排列整齐。</p></li><li><p>对于会产生磁场的元件，如变压器、扬声器、电感等，布局时应注意减少磁力线对印制导线的切割，相邻元件磁场方向应相互垂直，减少彼此之间的耦合。</p></li></ul><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524222945408.png" /></p><ul><li><p>晶振不要放置到PCB板边，滤波电容与晶体采用π型滤波方式摆放。</p></li><li><p>元器件的编号应该紧靠元器件的边框布置，大小统一，方向整齐，不与元器件、过孔和焊盘重叠。</p></li><li><p>滤波电容尽量靠近芯片管脚，容值越小，越靠近管脚且先经过电容再进入芯片。</p></li></ul><h3 id="pcb-layout">PCB layout</h3><ul><li>首先对重要的信号或要求比较严格的信号进行走线，信号线的过孔尽量少，信号线与其回路构成的环面积要尽可能小，环面积越小，对外的辐射越少，接收外界的干扰也越小。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524202049996.png" alt="image-20230524202049996" style="zoom:80%;" /></p><ul><li>输入/输出端导线尽量避免相邻平行，最好加地线隔离，以免发生耦合。</li><li>电源部分尽量采用铺铜方式，保证载流得当。</li><li>CHIP器件走线和焊盘连接要避免不对称走线。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524214904856.png" alt="image-20230524214904856" style="zoom:80%;" /></p><ul><li>贴片焊盘上不要有过孔，走线避免出现直角或锐角。</li><li>对于密间距的IC，走线从焊盘出线时，宽度不能比焊盘宽。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524214930539.png" alt="image-20230524214930539" style="zoom:80%;" /></p><p>以上是设计中常用的规则，应该还有其它常用的规则，后续遇到了再进行添加。</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pcb设计之重要信号线layout注意事项</title>
    <link href="/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%87%8D%E8%A6%81%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%87%8D%E8%A6%81%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>这一篇主要看看pcb设计中重要信号线的layout注意事项：</p><ul><li><strong>差分信号线尽量在一起同一层走线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521104356728.png" alt="image-20230521104356728" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521104659980.png" alt="image-20230521104659980" style="zoom:80%;" /></p><ul><li><strong>差分间距无法满足20mil，最好进行包地</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521104926751%20-%20%E5%89%AF%E6%9C%AC.png"alt="image-20230521104926751 - 副本" /><figcaption aria-hidden="true">image-20230521104926751 -副本</figcaption></figure><ul><li><strong>usb按90欧姆差分阻抗进行走线，等长处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520105039307.png" alt="image-20230520105039307" style="zoom:80%;" /></p><ul><li><strong>usb打孔换层应在旁边放置地过孔回流</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105612441%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105612441 - 副本" style="zoom:80%;" /></p><ul><li><strong>网口按100欧姆差分阻抗走线，等长处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105139287%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105139287 - 副本" style="zoom:80%;" /></p><ul><li><strong>LVDS差分信号包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105447526%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105447526 - 副本" style="zoom:80%;" /></p><ul><li><strong>差分线等长处理不易幅度过大</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105746352%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105746352 - 副本" style="zoom:80%;" /></p><ul><li><strong>DDR所有的走线都应该在ddr的电源分割区域内，且分割区域不能有其他信号线</strong></li></ul><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps1%20-%20%E5%89%AF%E6%9C%AC.jpg" /></p><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps2%20-%20%E5%89%AF%E6%9C%AC.jpg" /></p><ul><li><strong>DDR走线要保证同组同层，不要表层一部分，内层一部分</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521110154465%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521110154465 - 副本" style="zoom:80%;" /></p><ul><li><strong>DDR布线要满足3W原则</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521110323383%20-%20%E5%89%AF%E6%9C%AC.png" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pcb设计之普通信号线layout注意事项</title>
    <link href="/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%99%AE%E9%80%9A%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%99%AE%E9%80%9A%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>这一篇主要看普通信号线的layout注意事项：</p><ul><li><strong>走线不要出现直角锐角</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215258665.png" alt="image-20230520215258665" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215440544.png" alt="image-20230520215440544" style="zoom:80%;" /></p><ul><li><strong>走线不要超过焊盘宽度，应以焊盘同宽出线，可出完焊盘后立即加粗</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215531104.png" alt="image-20230520215531104" style="zoom:80%;" /></p><ul><li><strong>尽量减少环路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215751818.png" alt="image-20230520215751818" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215820652.png" alt="image-20230520215820652" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520222742879.png" alt="image-20230520222742879" style="zoom:80%;" /></p><ul><li><strong>7个地焊盘只有两个地孔，最多最多三个焊盘一个过孔</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520102020202.jpg" alt="img" style="zoom:80%;" /></p><ul><li><strong>所有层中间间距拉开一点，加到15mil~20mil</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215958770.png" alt="image-20230520215958770" style="zoom:80%;" /></p><ul><li><strong>走线不要压到电源内缩层</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/20230520102020203.jpg"alt="20230520102020203" /><figcaption aria-hidden="true">20230520102020203</figcaption></figure><ul><li><strong>走线优化，拉直。</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520102541420.jpg" alt="img" style="zoom:80%;" /></p><ul><li><strong>不要从IC狭窄处走线，影响焊接</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520220316490.png" alt="image-20230520220316490" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520220340784.png"alt="image-20230520220340784" /><figcaption aria-hidden="true">image-20230520220340784</figcaption></figure><ul><li><strong>电源处有多少过孔，地焊盘周边也打同样数量过孔，便于回流</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520220556496.png" alt="image-20230520220556496" style="zoom:80%;" /></p><ul><li><strong>走线间距太小容易串扰，需满足3W原则</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20220520220712824.png" alt="image-20230520220712824" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20220520221701707.png" alt="image-20230520221701707" style="zoom:80%;" /></p><ul><li><strong>预留地回流的通道</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20220520220803115.png" alt="image-20230520220803115" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520231118917.png" alt="image-20210520231118917" style="zoom:80%;" /></p><ul><li><strong>可以一同走的线，避免单独绕环线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221029160.png" alt="image-20210520221029160" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221053269.png" alt="image-20210520221053269" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223724436.png" alt="image-20210520223724436" style="zoom:80%;" /></p><ul><li><strong>铺铜的地方就不要再走细线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221230603.png" alt="image-20210520221230603" style="zoom:80%;" /></p><ul><li><strong>焊盘之间的窄小铜皮使用cutout进行去除，避免手动焊接短路风险</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221545131.png" alt="image-20210520221545131" style="zoom:80%;" /></p><ul><li><strong>相邻层走线不要重叠</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221806754.png" alt="image-20210520221806754" style="zoom:80%;" /></p><ul><li><strong>不要横向连接多个焊盘，容易造成不良焊接，可以先焊盘各自拉线出来，再两两相连</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222136579.png" alt="image-20210520222136579" style="zoom:80%;" /></p><ul><li><strong>走线能短则短</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222412740.png" alt="image-20210520222412740" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223011614.png" alt="image-20210520223011614" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225850852.png" alt="image-20210520225850852" style="zoom:80%;" /></p><ul><li><strong>走线不要太靠板边</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222521807.png" alt="image-20210520222521807" style="zoom:80%;" /></p><ul><li><strong>高压跟低压部分的间距最少保持5mm的间距</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222521890.jpg" alt="image-20210520222521890" style="zoom:80%;" /></p><ul><li><strong>合理布局</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223236635.png" alt="image-20210520223236635" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223544644.png" alt="image-20210520223544644" style="zoom:80%;" /></p><ul><li><strong>管脚之间阻焊层相连，需要修改Rule规则阻焊外扩距离</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225318763.png" alt="image-20210520225318763" style="zoom:80%;" /></p><ul><li><strong>走线不要太绕</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225618301.png" alt="image-20210520225618301" style="zoom:80%;" /></p><ul><li><p><strong>晶振采用Π型滤波模式，且对信号线进行包地处理，晶振下面不要走线</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233516091.png" alt="image-20210520233516091" style="zoom:80%;" /></p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225725174.png" alt="image-20210520225725174" style="zoom:80%;" /></p><ul><li><strong>电感中间不要有铜皮，且不要走线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230103302.png" alt="image-20210520230103302" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230711630.png" alt="image-20210520230711630" style="zoom:80%;" /></p><ul><li><strong>光耦所有层中间要挖空隔开，不要走线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230201233.png" alt="image-20210520230201233" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102742621.png" alt="image-20210521102742621" style="zoom:80%;" /></p><ul><li><strong>GPRS模块下面需要打回流地过孔，一方面为了散热，一方面利于信号</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230429986.png" alt="image-20210520230429986" style="zoom:80%;" /></p><ul><li><strong>尽量减少打孔换层</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230555960.png" alt="image-20210520230555960" style="zoom:80%;" /></p><ul><li><strong>多排走线不要并排打孔，容易造成地平面隔离，影响完整性</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520231520271.png" alt="image-20210520231520271" style="zoom:80%;" /></p><ul><li><strong>相同模块尽量保持一致，比较美观</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520231649818.png" alt="image-20210520231649818" style="zoom:80%;" /></p><ul><li><strong>过孔需要盖油</strong></li></ul><p><strong>低版本：</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520232756374.png" alt="image-20210520232756374" style="zoom:80%;" /></p><p><strong>高版本：</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520232709864.png" alt="image-20210520232709864" style="zoom:80%;" /></p><ul><li><strong>不可将过孔打在焊盘上</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520232908468.png" alt="image-20210520232908468" style="zoom:80%;" /></p><ul><li><strong>过孔焊盘直径应为孔径2倍(+/- 2mil)</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233133110.png" alt="image-20210520233133110" style="zoom:80%;" /></p><ul><li><strong>丝印文字常用字宽与字高比例：4/25mil 5/30mil 6/45mil,丝印不要放到阻焊层上</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233730194.png" alt="image-20210520233730194"  /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233755149.png" alt="image-20210520233755149" style="zoom:80%;" /></p><ul><li><strong>继电器下面不要走线，且部分走线要加粗</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521101637502.png" alt="image-20210521101637502" style="zoom:80%;" /></p><ul><li><strong>FM天线部分下面不要走线，且要包地处理</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521101821828.png"alt="image-20210521101821828" /><figcaption aria-hidden="true">image-20210521101821828</figcaption></figure><ul><li><strong>WIFI模块下面要挖空处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102020202.png" alt="image-20210521102020202" style="zoom:80%;" /></p><ul><li><strong>喇叭走线需要包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102222760.png" alt="image-20210521102222760" style="zoom:80%;" /></p><ul><li><strong>天线模块下面要挖空，天线走线要控制50欧姆阻抗</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102541420.png" alt="image-20210521102541420" style="zoom:80%;" /></p><ul><li><strong>网口部分要挖空处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102851161.png" alt="image-20210521102851161" style="zoom:80%;" /></p><ul><li><strong>射频部分严格按照阻抗要求走线，转弯部分用圆弧走线，包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/Imge-16846362511801.jpg" alt="Imge-16846362511801" style="zoom:80%;" /></p><ul><li><strong>时钟信号不要离干扰源太近，距离普通信号线要大于20mil，最好做包地处理</strong></li></ul><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-16846364276462.jpg"alt="image-16846364276462" /><figcaption aria-hidden="true">image-16846364276462</figcaption></figure><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-16846364395533.jpg"alt="image-16846364395533" /><figcaption aria-hidden="true">image-16846364395533</figcaption></figure><ul><li><strong>MIC属于模拟信号，要类差分走线，包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521103714413.png" alt="image-20210521103714413" style="zoom:80%;" /></p><ul><li><strong>模拟信号加粗处理，部分进行包地</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521103853551.png" alt="image-20210521103853551" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521103923788.png" alt="image-20210521103923788" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pcb设计之电源layout注意事项</title>
    <link href="/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%94%B5%E6%BA%90layout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%94%B5%E6%BA%90layout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>pcb设计中，在layout时需要遵循一定规范，才会避免设计出不合格的pcb板，下面几篇文章主要总结一下layout过程中常见的问题，本篇是关于电源layout，内容主要来源自pcb联盟网论坛。</p><ul><li><strong>电源滤波电容尽量靠近IC管脚放置。</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205025967.png" alt="image-20230520205025967" style="zoom:80%;" /></p><ul><li><strong>电源走线载流过小，加大铺铜宽度，保证载流量</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205236535.png" alt="image-20230520205236535" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205310933.png"alt="image-20230520205310933" /><figcaption aria-hidden="true">image-20230520205310933</figcaption></figure><ul><li><strong>电源分割线20mil以上，分割的区域尽量宽</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205632526.png" alt="image-20230520205632526" style="zoom:80%;" /></p><ul><li><strong>芯片电源输出口先经过去耦电容再给其他元件供电</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520210452461.png" alt="image-20230520210452461" style="zoom:80%;" /></p><ul><li><strong>对于输入和输出，滤波电容遵循先大电容，后小电容放置</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520210844679.png" alt="image-20230520210844679" style="zoom:80%;" /></p><ul><li><strong>电源的反馈信号要接到最后一个滤波电容之后</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211057631.png" alt="image-20230520211057631" style="zoom:80%;" /></p><ul><li><strong>多个滤波电容应该放置到一起，且先大后小摆放</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211345243.png" alt="image-20230520211345243" style="zoom:80%;" /></p><ul><li><strong>电源路径不能过细，需要满足过载量，一般20mil线宽通1A电流</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211653288.png" alt="image-20230520211653288" style="zoom:80%;" /></p><ul><li><strong>电源输入和输出尽量L型或一字型布局</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211931150.png" alt="image-20230520211931150" style="zoom:80%;" /></p><ul><li><strong>电源线不要绕成圈</strong></li></ul><p><img src= "https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520212159692.png" alt="image-20230520212159692" style="zoom:80%;" /></p><ul><li><strong>高压部分走线要加粗，且不能从变压器中间穿</strong></li></ul><p><img src= "https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520212345079.png" alt="image-20230520212345079" style="zoom:80%;" /></p><ul><li><strong>电源层铺铜尽量保证完整性</strong></li></ul><p><img src= "https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520234104774.png" alt="image-20230520234104774" style="zoom:80%;" /></p><ul><li><strong>电源分割</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123010522.png" alt="image-20230521123010522" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123053217.png" alt="image-20230521123053217" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123123868.png" alt="image-20230521123123868" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123147836.png" alt="image-20230521123147836" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123209186.png" alt="image-20230521123209186" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Altium Designer软件应用常见问题</title>
    <link href="/2023/05/19/Altium-Designer%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/19/Altium-Designer%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>使用AltiumDesigner时，有时候会碰到一些不常见的问题，以下总结几个，后续发现了问题，再增加。</p><ul><li><strong>高版本AD无法寻找系统设置项</strong></li></ul><p>解决方法：</p><p>高版本在软件右上角有个设置图标即是设置项或 Tools -&gt;Preferences.</p><ul><li><strong>在低版本AD，PCB中拖动元件，元件不显示。</strong></li></ul><p>解决方法：</p><ol type="1"><li>Preferences -&gt; PCB Editor -&gt; Display -&gt; 去掉Use AlphaBlending对勾。</li><li>Preferences -&gt; PCB Editor -&gt; Display -&gt; 选中Use DirectX ifpossible。</li></ol><ul><li><strong>在PCB中元器件随时绿色报错，影响视觉。</strong></li></ul><p>解决方法：</p><ol type="1"><li>Tools -&gt; Design Rule Check -&gt;除了Electrical，其他项对勾都去掉。</li><li>Design-&gt;Rules -&gt; Electrical Clearance -&gt; 设置Minimumclearance 5mil.</li><li>快捷键T -&gt; M，复位报错。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519231617128.png" alt="image-20230519231617128" style="zoom:80%;" /></p><ul><li><strong>原理图导入PCB中，总是有元件无法导入，可能是footprint的uniqueID相同。</strong></li></ul><p>解决方法：复位零件ID。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519230324234.png"alt="image-20230519230324234" /><figcaption aria-hidden="true">image-20230519230324234</figcaption></figure><ul><li><strong>低版本AD中，原理图导出pdf文件，中文字体不显示/乱码</strong></li></ul><p>解决方法：</p><p>打开Preference界面，System-&gt;General，将系统字体改为中文；如果还不显示，可能原理图之前的文字没有修正过来，需要手动修改。</p><ul><li><strong>PCB编辑界面左上角悬浮框怎么取消</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519231723071.png" alt="image-20230519231723071" style="zoom: 80%;" /></p><p>解决方法：</p><p>按快捷键Shift+H，可以选择打开或者关闭抬头显示；</p><p>按快捷键Shift+G，抬头跟随鼠标移动，再次按下Shift+G即可固定。</p><ul><li><strong>原理图库引脚上面一横怎么添加的（表示低电平有效）</strong></li></ul><p>解决方法：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519232255161.png" alt="image-20230519232255161" style="zoom:80%;" /></p><ul><li><strong>pcb设计中某个零件需要铺铜，铺完后发现不理想，不想重新铺铜，怎么操作。</strong></li></ul><p>解决方法：</p><ol type="1"><li>低版本，使用快捷键 M + G进行修铜即可。</li><li>高版本，直接通过鼠标选择边框进行修改，然后重新铺铜。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519234223510.png" alt="image-20230519234223510" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Altium Designer Gerber Files 生成步骤</title>
    <link href="/2023/05/18/Altium-Designer-Gerber-Files-%E7%94%9F%E6%88%90%E6%AD%A5%E9%AA%A4/"/>
    <url>/2023/05/18/Altium-Designer-Gerber-Files-%E7%94%9F%E6%88%90%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<p>pcblayout完成后，然后就可以发送到PCB板厂进行生产制造了，一般为了保密性质，发送给厂商的是GerberFiles文件，所以，就需要生成GerberFiles。以下说一下AltiumDesigner生成GerberFiles的具体的操作步骤：</p><p>生成Gerber文件前，需要设置PCB原点，工艺边，定位孔，钻孔描述(drill层放置'.legend')，尺寸标注(一般为mechanic1、2层)。但是对于普通PCB设计者来说，这些不是必须要设置的。</p><ol type="1"><li><p>打开Gerber Setup，Files -&gt; Fabrication Outputs -&gt; GerberFiles</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps1.jpg" alt="img"  /></p></li><li><p>勾选要生成Gerber文件层面，在右侧Mechanical列表中选择要加载到各个Gerber层的机械尺寸信息。勾选左侧的Mechanical1，则在光绘文件GM1单层显示，勾选右侧的Mechanical1则每层都会加入机械层信息，“Include unconnected mid-layerpads”项仅限于包含了中间层的PCB 文件输出Gerber 时使能。</p></li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps2.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="3" type="1"><li>勾选Drill层</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps3.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="4" type="1"><li>勾选光圈</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps4.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="5" type="1"><li>设置影像大小</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps5.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="6" type="1"><li>生成钻孔文件，Files -&gt; Fabrication Outputs -&gt; NC Drillfiles</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps6.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="7" type="1"><li>生成测试网表，Files -&gt; Fabrication Outputs -&gt; Test PointReport</li></ol><p><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps7.jpg" /></p><ol start="8" type="1"><li>生成SMT贴片零件位置表，Files -&gt; Assembly Outputs -&gt; Generatespick and place files</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps8.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="9" type="1"><li>生成SMT贴片零件PCB组装图，Files -&gt; Smart PDF</li></ol><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps9.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps10.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps11.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>将前面7个步骤生成的文件打包发送给pcb板厂就可以制造PCB了，如果还需要贴片，就需要第8步和第9步生成的组装文件了。</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Altium Designer 快捷键汇总</title>
    <link href="/2023/05/17/Altium-Designer-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/"/>
    <url>/2023/05/17/Altium-Designer-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>最近新项目需要设计电路和PCB，刚好结合之前整理的AltiumDesigner快捷键汇总一下：</p><ul><li><h4 id="对齐">对齐</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>A</td><td>弹出对齐对话框</td></tr><tr class="even"><td>A+L</td><td>向左对齐</td></tr><tr class="odd"><td>A+R</td><td>向右对齐</td></tr><tr class="even"><td>A+D</td><td>横向等间距</td></tr><tr class="odd"><td>A+T</td><td>向上对齐</td></tr><tr class="even"><td>A+B</td><td>向下对齐</td></tr><tr class="odd"><td>A+S</td><td>纵向等间距</td></tr></tbody></table><ul><li><h4 id="元件调整">元件调整</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>M</td><td>元件调整</td></tr><tr class="even"><td>N</td><td>飞线的显示与隐藏</td></tr><tr class="odd"><td>M+S</td><td>器件任意位置移动</td></tr><tr class="even"><td>A+P</td><td>调整位号位置</td></tr><tr class="odd"><td>F11</td><td>选中器件，按下F11</td></tr><tr class="even"><td>E+A</td><td>特殊粘贴</td></tr></tbody></table><ul><li><h4 id="选择">选择</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>S+I</td><td>框选</td></tr><tr class="even"><td>S+O</td><td>反选</td></tr><tr class="odd"><td>S+L</td><td>线选</td></tr><tr class="even"><td>S+N</td><td>选择网络</td></tr><tr class="odd"><td>S+C</td><td>选中直接相连的网络</td></tr><tr class="even"><td>J+C</td><td>查询与搜索器件</td></tr><tr class="odd"><td>J+N</td><td>查询与搜索网络</td></tr><tr class="even"><td>S+T</td><td>切换选择</td></tr></tbody></table><ul><li><h4 id="设置">设置</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>D+C</td><td>进入Class设置</td></tr><tr class="even"><td>D+R</td><td>PCB 规则设置</td></tr><tr class="odd"><td>T+D</td><td>DRC检查</td></tr><tr class="even"><td>T+M</td><td>复位DRC检查</td></tr><tr class="odd"><td>O+B</td><td>PCB板选项设置</td></tr><tr class="even"><td>G</td><td>设置栅格属性</td></tr><tr class="odd"><td>T+N</td><td>器件位号重新编排</td></tr><tr class="even"><td>T+P</td><td>进行系统设置</td></tr></tbody></table><ul><li><h4 id="显示">显示</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>shift+E</td><td>可捕获至中点</td></tr><tr class="even"><td>shift+H</td><td>坐标信息的隐藏与显示</td></tr><tr class="odd"><td>shift+D</td><td>切换悬浮的坐标显示风格</td></tr><tr class="even"><td>shift+S</td><td>单层切换显示</td></tr><tr class="odd"><td>shift+M</td><td>PCB的洞察力镜头</td></tr><tr class="even"><td>shift+空格</td><td>切换走线模式</td></tr><tr class="odd"><td>Ctrl+L</td><td>图层控制</td></tr><tr class="even"><td>Ctrl+D</td><td>Object的隐藏与显示</td></tr><tr class="odd"><td>Ctrl+G</td><td>栅格设置</td></tr><tr class="even"><td>*</td><td>层切换</td></tr><tr class="odd"><td>V+B</td><td>板子翻转</td></tr><tr class="even"><td>L</td><td>器件正反面放置</td></tr><tr class="odd"><td>O+G</td><td>背景和格点设置(PCB与原理图通用)</td></tr></tbody></table><ul><li><h4 id="走线">走线</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>shift+R</td><td>切换走线模式</td></tr><tr class="even"><td>shift+G</td><td>显示走线长度</td></tr><tr class="odd"><td>shift+E</td><td>切换捕获栅格模式</td></tr><tr class="even"><td>E+K</td><td>截断走线</td></tr><tr class="odd"><td>*或-或+</td><td>走线时切换到其他层(自动加过孔)</td></tr><tr class="even"><td>[</td><td>走线时可单独显示要连接的地方高亮</td></tr><tr class="odd"><td>E+D</td><td>连续删线</td></tr><tr class="even"><td>Shift+W</td><td>走线时，设置走线的线宽</td></tr><tr class="odd"><td>Shift+V</td><td>走线时，设置焊盘大小</td></tr><tr class="even"><td>U+M</td><td>AD17 多根相同间距走线，先选中，再U+M走线</td></tr><tr class="odd"><td>T+T+M</td><td>选中多根线，然后同时走线</td></tr><tr class="even"><td>Ctrl+点击焊盘</td><td>同一网络快速走线</td></tr><tr class="odd"><td>Ctrl+H</td><td>高显</td></tr><tr class="even"><td>Ctrl+W</td><td>可视化间距显示(AD16版本以上才有此功能)</td></tr></tbody></table><ul><li><h4 id="功能">功能</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>Alt+点击GND</td><td>全部与GND相连的线高亮（单个网络高亮）</td></tr><tr class="even"><td>T+E</td><td>泪滴增加与移除</td></tr><tr class="odd"><td>P+Y</td><td>分离铜皮（按Tab可以设置线宽）</td></tr><tr class="even"><td>D+S+D</td><td>快速定义板框</td></tr><tr class="odd"><td>Ctrl+M</td><td>测量尺寸</td></tr><tr class="even"><td>Ctrl+Q或Q</td><td>改变单位（mm/mil）</td></tr></tbody></table><p>另外，以前学习凡亿教育课程，因为在设计时常用的操作就那几个，所以可以将常用快捷键设置为单个按键，这样在设计时就可快速方便的进行操作，提高了效率，方法是：<strong>按住Ctrl键不放，点击软件各功能选择图标，然后就可设置惯用的快捷键</strong>，主要有以下几个：</p><table><thead><tr class="header"><th>快捷键</th><th>功能设置</th><th>快捷键</th><th>功能设置</th></tr></thead><tbody><tr class="odd"><td>F2</td><td><strong>电气走线</strong></td><td>Alt+F2</td><td>差分走线</td></tr><tr class="even"><td>F3</td><td><strong>放置过孔</strong></td><td>Alt+F3</td><td>放置fill</td></tr><tr class="odd"><td>F4</td><td><strong>敷铜</strong></td><td>Alt+F4</td><td><strong>重新敷铜</strong></td></tr><tr class="even"><td>F5</td><td>颜色开关</td><td></td><td></td></tr><tr class="odd"><td>F6</td><td><strong>矩形框放置器件</strong></td><td></td><td></td></tr><tr class="even"><td>F7</td><td>原理图与layout交互映射</td><td></td><td></td></tr></tbody></table><table><thead><tr class="header"><th>快捷键</th><th>功能设置</th><th>快捷键</th><th>功能设置</th></tr></thead><tbody><tr class="odd"><td>`</td><td><strong>删除</strong></td><td>Alt+`</td><td><strong>删除物理连接</strong></td></tr><tr class="even"><td>1</td><td>选择物理连接</td><td>Alt+1</td><td>显示长度</td></tr><tr class="odd"><td>2</td><td><strong>线选</strong></td><td>Alt+2</td><td>测量中心距</td></tr><tr class="even"><td>3</td><td><strong>框选</strong></td><td>Alt+3</td><td>移动选择</td></tr><tr class="odd"><td>4</td><td>单线等长(蛇形线)</td><td>Alt+4</td><td>差分等长</td></tr><tr class="even"><td>5</td><td><strong>保持原间距走线</strong></td><td>Alt+5</td><td>等间距走线</td></tr><tr class="odd"><td>6</td><td>坐标移动</td><td></td><td></td></tr><tr class="even"><td>7</td><td><strong>修铜</strong></td><td>Alt+7</td><td>M+G</td></tr></tbody></table><table><thead><tr class="header"><th>小键盘数字键</th><th>功能设置</th></tr></thead><tbody><tr class="odd"><td><strong>1</strong></td><td><strong>左对齐</strong></td></tr><tr class="even"><td><strong>2</strong></td><td><strong>下对齐</strong></td></tr><tr class="odd"><td><strong>3</strong></td><td><strong>右对齐</strong></td></tr><tr class="even"><td><strong>4</strong></td><td><strong>水平等间距</strong></td></tr><tr class="odd"><td><strong>5</strong></td><td><strong>上对齐</strong></td></tr><tr class="even"><td><strong>6</strong></td><td><strong>垂直等间距</strong></td></tr><tr class="odd"><td><strong>7</strong></td><td><strong>器件位号排列</strong></td></tr></tbody></table><p>以上加粗部分是常用功能，可根据自己的需要灵活更改。</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>crc校验及其实现</title>
    <link href="/2023/05/15/crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/05/15/crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>在通信领域传输数据时，为了避免接收到错误的数据，一般会对源数据和接收到的数据进行特定的校验处理，如果一致，则说明传输正确，否则传输发生了错误。常用的校验算法有奇偶校验、校验和、CRC等，这里主要看看CRC校验。</p><h3 id="crc简介">CRC简介</h3><p>循环冗余校验（Cyclic Redundancy Check，CRC），它是利用除法及余数的原理来作错误侦测的，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。具体原理参考：</p><p><ahref="https://www.cnblogs.com/liushui-sky/p/9962123.html">CRC码计算及校验原理的最通俗诠释</a></p><h3 id="crc参数模型">CRC参数模型</h3><p>一个完整的CRC参数模型应该包含以下信息：WIDTH，POLY，INIT，REFIN，REFOUT，XOROUT。</p><ul><li>NAME：参数模型名称。</li><li>WIDTH：宽度，即生成的CRC数据位宽，如CRC-8，生成的CRC为8位</li><li>POLY：十六进制多项式，省略最高位1，如 x8 + x2 + x + 1，二进制为10000 0111，省略最高位1，转换为十六进制为0x07。</li><li>INIT：CRC初始值，和WIDTH位宽一致。</li><li>REFIN：true或false，在进行计算之前，原始数据是否翻转，如原始数据：0x34= 0011 0100，如果REFIN为true，进行翻转之后为0010 1100 = 0x2c</li><li>REFOUT：true或false，运算完成之后，得到的CRC值是否进行翻转，如计算得到的CRC值：0x97= 1001 0111，如果REFOUT为true，进行翻转之后为11101001 = 0xE9。</li><li>XOROUT：计算结果与此参数进行异或运算后得到最终的CRC值，和WIDTH位宽一致。</li></ul><p>通常如果只给了一个多项式，其他的没有说明则：INIT=0x00，REFIN=false，REFOUT=false，XOROUT=0x00。</p><p>常用的21个标准CRC参数模型：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230515215944403.png" alt="image-20230515215944403" style="zoom:80%;" /></p><p>CRC校验在电子通信领域非常常用，可以说有通信存在的地方，就有CRC校验：</p><ul><li>美信(MAXIM)的芯片DS2401/DS18B20，都是使用的CRC-8/MAXIM模型</li><li>SD卡或MMC使用的是CRC-7/MMC模型</li><li>Modbus通信使用的是CRC-16/MODBUS参数模型</li><li>USB协议中使用的CRC-5/USB和CRC-16/USB模型</li><li>STM32自带的硬件CRC计算模块使用的是CRC-32模型</li></ul><h3 id="crc计算的程序实现">CRC计算的程序实现</h3><p>CRC的程序实现，网上有很多比较完备的开源CRC计算库，可以直接使用，没有必要重复造轮子。</p><ul><li>https://github.com/whik/crc-lib-c</li><li><a href="https://www.libcrc.org/">LibCRC – Open Source CRC Libraryin C</a></li></ul><h3 id="crc计算工具">CRC计算工具</h3><ul><li><ahref="http://www.geshe.com/zh-cn/products/gtoolbox">格西CRC计算器</a></li><li>http://www.ip33.com/crc.html</li><li>https://www.lammertbies.nl/comm/info/crc-calculation</li></ul><h3 id="参考链接">参考链接</h3><p><ahref="http://www.wangchaochao.top/2020/09/20/Principle-and-implementation-of-CRC/">CRC校验原理及其实现</a></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>crc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssd3as压力传感器的开发设计</title>
    <link href="/2023/05/14/ssd3as%E5%8E%8B%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/14/ssd3as%E5%8E%8B%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>spi通讯在开发过程中会经常用到，譬如下面介绍的数字压力传感器SSD系列，在传输压力值时就可以通过spi协议进行通讯。</p><h3 id="产品特点">产品特点</h3><ul><li>中压量程： 7Kpa ~ 1Mpa</li><li>供电：3.3V / 5V可选</li><li>输出：SPI / I2C，压力14位，温度，11位</li><li>温度补偿：-10 ~ 50℃</li></ul><h3 id="引脚定义">引脚定义</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514211435154.png" alt="image-20230514211435154" style="zoom:80%;" /></p><h3 id="压力类型">压力类型</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514211828407.png" alt="image-20230514211828407" style="zoom:80%;" /></p><h3 id="压力公式">压力公式</h3><p>此传感器可模拟输出和数字输出，这里只对数字输出进行处理。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514211610619.png" alt="image-20230514211610619" style="zoom:80%;" /></p><h3 id="输出百分比">输出百分比</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514212122812.png" alt="image-20230514212122812" style="zoom:80%;" /></p><h3 id="spi协议">SPI协议</h3><p>此传感器可以SPI传输，也可I2C传输，这里主要使用gpio模拟SPI进行传输。</p><p>网上关于SPI的讲解有很多，搜集了网上的资料，可参考<ahref="http://t.csdn.cn/Fv29I">SPI协议详解</a> 和 <ahref="http://t.csdn.cn/gF3lX">spi时序图怎么分析，怎么看懂spi时序图</a>，这两篇博客写的特别清楚，详细介绍了spi协议的具体内容。</p><ol type="1"><li>spi通过时钟极性（CPOL）和时钟相位（CPHA）控制两个spi设备进行数据传输，所以共有四种模式。</li><li>spi协议适用一主多从的工作场景，通过片选引脚可控制不同的从设备。</li><li>spi传输的实质是主从设备交换数据，也就是你发一个数据必然会收到一个数据，你要收一个数据也要发一个数据（一般是0x00）。</li><li>spi进行数据传输时是从最高位MSB到最低位LSB。</li></ol><h3 id="spi模式与时序">SPI模式与时序</h3><p>CPOL=0 表示SCLK在空闲时为低电平。</p><p>CPOL=1 表示SCLK在空闲时为高电平。</p><p>CPHA=0 数据是在第一个跳变沿的时候就会被采集。</p><p>CPHA=1 数据是在第二个跳变沿的时候才会被采集。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514215453741.png" alt="image-20230514215453741" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514215552736.png" alt="image-20230514215552736" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514215213595.png" alt="image-20230514215213595" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514215320573.png" alt="image-20230514215320573" style="zoom:80%;" /></p><h3 id="程序实现">程序实现</h3><p>spi模块：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SPI_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">uint16_t</span>;<span class="hljs-comment">/* spi pin definition */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_SS      P10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_CLK     P12</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_MISO    P11</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_MOSI    P13</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">spi_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode0</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode1</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode2</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode3</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">* @file     spi.c</span><span class="hljs-comment">* @author   Kayoung</span><span class="hljs-comment">* @version  V1.1</span><span class="hljs-comment">* @date     20221015</span><span class="hljs-comment">* @brief    gpio模拟spi四种驱动函数.</span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">* @attention spi原理：http://t.csdn.cn/gF3lX</span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">*/</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * =================================================</span><span class="hljs-comment">  * |    模式   | CPOL(时钟极性)  |CPHA（时钟相位）|</span><span class="hljs-comment">  * =================================================</span><span class="hljs-comment">  * |MODE0(常用) |       0   |        0       |</span><span class="hljs-comment">  * -------------------------------------------------</span><span class="hljs-comment">  * |MODE1  |       0    |        1       |</span><span class="hljs-comment">  *-------------------------------------------------</span><span class="hljs-comment">  * |MODE2  |       1    |        0       | </span><span class="hljs-comment">  *-------------------------------------------------</span><span class="hljs-comment">  * |MODE3(常用) |   1   |        1       |</span><span class="hljs-comment">  *=================================================</span><span class="hljs-comment">  * MODE0：SCK空闲时为低电平，数据在SCK上升沿被采样，下降沿输出</span><span class="hljs-comment">　* MODE1：SCK空闲时为低电平，数据在SCK下降沿被采样，上升沿输出</span><span class="hljs-comment">　* MODE2：SCK空闲时为高电平，数据在SCK下降沿被采样，上升沿输出</span><span class="hljs-comment">　* MODE3：SCK空闲时为高电平，数据在SCK上升沿被采样，下降沿输出</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spi.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;intrins.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">Delay1us</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;_nop_();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefspi初始化</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">spi_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;SPI_CLK = <span class="hljs-number">0</span>;SPI_SS = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  gpio 模拟spi,SPI模式0,CPOL=0，CPHA=0, MSB first，上升沿采样</span><span class="hljs-comment">  * @param  send_byte: 发送的一字节数据</span><span class="hljs-comment">  * @retvalread_dat:读取的一字节数据</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode0</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span>&#123;<span class="hljs-type">uint8_t</span> i, read_dat = <span class="hljs-number">0</span>;SPI_SS = <span class="hljs-number">0</span>; <span class="hljs-comment">//选择从设备</span>SPI_CLK = <span class="hljs-number">0</span>; <span class="hljs-comment">//空闲SCLK为0</span>Delay1us();<span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++ )&#123;<span class="hljs-comment">/* 接收数据 */</span>SPI_CLK = <span class="hljs-number">1</span>;   <span class="hljs-comment">//拉高时钟，上升沿采样</span>read_dat &lt;&lt;= <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span>(SPI_MISO) read_dat++; <span class="hljs-comment">//若从从机接收到高电平，数据自加一</span>Delay1us();<span class="hljs-comment">/* 发送数据 */</span>SPI_CLK = <span class="hljs-number">0</span>; <span class="hljs-keyword">if</span>(send_byte &amp; <span class="hljs-number">0x80</span>) <span class="hljs-comment">//下降沿输出数据</span>SPI_MOSI = <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span>                    SPI_MOSI = <span class="hljs-number">0</span>;  send_byte &lt;&lt;= <span class="hljs-number">1</span>;Delay1us();&#125;SPI_SS = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放从设备</span><span class="hljs-keyword">return</span> read_dat;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  gpio 模拟spi,SPI模式1,CPOL=0，CPHA=1, MSB first，下降沿采样</span><span class="hljs-comment">  * @param  send_byte: 发送的一字节数据</span><span class="hljs-comment">  * @retvalread_dat:读取的一字节数据</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode1</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span> &#123;<span class="hljs-type">uint8_t</span> i, read_dat = <span class="hljs-number">0</span>;SPI_SS = <span class="hljs-number">0</span>; <span class="hljs-comment">//选择从设备</span>    SPI_CLK = <span class="hljs-number">0</span>; <span class="hljs-comment">//空闲状态SCLK为0</span>Delay1us();<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)   &#123;<span class="hljs-comment">/* 发送数据 */</span>SPI_CLK = <span class="hljs-number">1</span>;     <span class="hljs-comment">//上升沿输出数据</span><span class="hljs-keyword">if</span>(send_byte &amp; <span class="hljs-number">0x80</span>)SPI_MOSI = <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span>      SPI_MOSI = <span class="hljs-number">0</span>;   send_byte &lt;&lt;= <span class="hljs-number">1</span>;    Delay1us();<span class="hljs-comment">/* 接收数据 */</span>SPI_CLK = <span class="hljs-number">0</span>;     <span class="hljs-comment">//拉低时钟，下降沿采样</span>read_dat &lt;&lt;= <span class="hljs-number">1</span>;     <span class="hljs-keyword">if</span>(SPI_MISO)read_dat++;     <span class="hljs-comment">//若从从机接收到高电平，数据自加一</span>Delay1us();&#125;SPI_SS = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放从设备</span><span class="hljs-keyword">return</span> (read_dat);     &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  gpio 模拟spi,SPI模式2,CPOL=1，CPHA=0, MSB first，下降沿采样</span><span class="hljs-comment">  * @param  send_byte: 发送的一字节数据</span><span class="hljs-comment">  * @retvalread_dat:读取的一字节数据</span><span class="hljs-comment">  */</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode2</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span> &#123;    <span class="hljs-type">uint8_t</span> i, read_dat = <span class="hljs-number">0</span>;SPI_SS = <span class="hljs-number">0</span>; <span class="hljs-comment">//选择从设备 </span>SPI_CLK = <span class="hljs-number">1</span>; <span class="hljs-comment">//空闲状态SCLK为1</span>Delay1us();<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)     &#123;<span class="hljs-comment">/* 接收数据 */</span>SPI_CLK = <span class="hljs-number">0</span>;     <span class="hljs-comment">//拉低时钟采样</span>read_dat &lt;&lt;= <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(SPI_MISO)read_dat++;     <span class="hljs-comment">//若从从机接收到高电平，数据自加一</span>Delay1us();<span class="hljs-comment">/* 发送数据 */</span>SPI_CLK = <span class="hljs-number">1</span>;     <span class="hljs-comment">//拉高时钟</span><span class="hljs-keyword">if</span>(send_byte &amp; <span class="hljs-number">0x80</span>) <span class="hljs-comment">//上升沿输出数据</span>SPI_MOSI = <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span>      SPI_MOSI = <span class="hljs-number">0</span>;   send_byte &lt;&lt;= <span class="hljs-number">1</span>;     Delay1us();&#125;SPI_SS = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放从设备</span><span class="hljs-keyword">return</span> (read_dat);     &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  gpio 模拟spi,SPI模式3,CPOL=1，CPHA=1, MSB first，上升沿采样</span><span class="hljs-comment">  * @param  send_byte: 发送的一字节数据</span><span class="hljs-comment">  * @retvalread_dat:读取的一字节数据</span><span class="hljs-comment">  */</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode3</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span> &#123;<span class="hljs-type">uint8_t</span> i, read_dat = <span class="hljs-number">0</span>;SPI_SS = <span class="hljs-number">0</span>; <span class="hljs-comment">//选择从设备</span>SPI_CLK = <span class="hljs-number">1</span>;<span class="hljs-comment">//空闲状态SCLK为1</span>Delay1us();<span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++ )&#123;<span class="hljs-comment">/* 发送数据 */</span>SPI_CLK = <span class="hljs-number">0</span>;    <span class="hljs-comment">//下降沿输出数据</span><span class="hljs-keyword">if</span>(send_byte &amp; <span class="hljs-number">0x80</span>)SPI_MOSI = <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span>                    SPI_MOSI = <span class="hljs-number">0</span>;  send_byte &lt;&lt;= <span class="hljs-number">1</span>;Delay1us();<span class="hljs-comment">/* 接收数据 */</span>SPI_CLK = <span class="hljs-number">1</span>;   <span class="hljs-comment">//拉高时钟采样</span>read_dat &lt;&lt;= <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span>(SPI_MISO) read_dat++; <span class="hljs-comment">//若从从机接收到高电平，数据自加一</span>Delay1us();&#125;SPI_SS = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放从设备</span><span class="hljs-keyword">return</span> read_dat;&#125;</code></pre></div><p>传感器模块:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SSD3AS_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SSD3AS_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spi.h&quot;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><span class="hljs-class">&#123;</span>SENSOR_AP = <span class="hljs-number">0</span>,   <span class="hljs-comment">//绝压</span>SENSOR_GP,       <span class="hljs-comment">//表压</span>SENSOR_DP        <span class="hljs-comment">//差压</span>&#125;sensor_type_e;<span class="hljs-comment">/*******BASE值默认情况下改为0，根据上电初始状态显示数值确定具体值*********/</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_DP_BASE  35</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_GP_BASE  2.42</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_AP_BASE  0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_DP_MAX2500</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_DP_MIN-2500</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_GP_MAX1000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_GP_MIN0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_AP_MAX120000UL</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_AP_MIN0</span> <span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ssd_get_value</span><span class="hljs-params">(<span class="hljs-type">float</span>* pressure, <span class="hljs-type">float</span>* temperature, sensor_type_e sensor_type)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">/************************* End of File ***************************/</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">* @file     ssd3as.c</span><span class="hljs-comment">* @author   Kayoung</span><span class="hljs-comment">* @version  V1.0</span><span class="hljs-comment">* @date     20201015</span><span class="hljs-comment">* @brief    压力传感器SPI通讯函数.</span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">* @attention </span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">*/</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ssd3as.h&quot;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment">* @brief  读取传感器压力值和温度值。</span><span class="hljs-comment">* @param  pressure: 读取的压力值。</span><span class="hljs-comment">* @param  temperature: 读取的温度值。</span><span class="hljs-comment">* @param  sensor_type: 压力传感器类型</span><span class="hljs-comment">* @retval None</span><span class="hljs-comment">* @attention 传感器的温度读出来有问题，应该跟传感器有关。</span><span class="hljs-comment">*/</span><span class="hljs-type">void</span> <span class="hljs-title function_">ssd_get_value</span><span class="hljs-params">(<span class="hljs-type">float</span>* pressure, <span class="hljs-type">float</span>* temperature, sensor_type_e sensor_type)</span>&#123;<span class="hljs-type">uint16_t</span> buf[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;   <span class="hljs-comment">//用于存放压力AD值和温度AD值</span><span class="hljs-type">uint16_t</span> pressure_data = <span class="hljs-number">0</span>, temprature_data = <span class="hljs-number">0</span>;<span class="hljs-type">uint8_t</span> i;  <span class="hljs-comment">/* readout value from sensor by spi */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)  &#123;buf[i] = soft_spi_rw_mode0(<span class="hljs-number">0x00</span>);&#125;pressure_data = (buf[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-number">8</span> | buf[<span class="hljs-number">1</span>]) &amp; <span class="hljs-number">0x3fff</span>; <span class="hljs-comment">//14位压力值</span>temprature_data = (buf[<span class="hljs-number">2</span>]&lt;&lt;<span class="hljs-number">8</span> | buf[<span class="hljs-number">3</span>]) &amp; <span class="hljs-number">0x7ff</span>; <span class="hljs-comment">//11位温度值</span><span class="hljs-comment">/* 计算压力值 */</span><span class="hljs-comment">/* 1.A-type输出10%~90%    2.B-type输出5%~95%*/</span><span class="hljs-keyword">if</span>(pressure_data &gt; <span class="hljs-number">16383</span>*<span class="hljs-number">0.1</span> &amp;&amp; pressure_data &lt; <span class="hljs-number">16383</span>*<span class="hljs-number">0.9</span>) &#123;<span class="hljs-keyword">switch</span>(sensor_type)&#123;<span class="hljs-keyword">case</span>(SENSOR_AP):&#123;*pressure = (pressure_data - <span class="hljs-number">1638.3</span>) * (PRESSURE_AP_MAX - PRESSURE_AP_MIN) / <span class="hljs-number">13106.4</span> \+ PRESSURE_AP_MIN - PRESSURE_AP_BASE; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span>(SENSOR_GP):&#123;*pressure = (pressure_data - <span class="hljs-number">1638.3</span>) * (PRESSURE_GP_MAX - PRESSURE_GP_MIN) / <span class="hljs-number">13106.4</span> \+ PRESSURE_GP_MIN - PRESSURE_GP_BASE; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span>(SENSOR_DP):&#123;*pressure = (pressure_data - <span class="hljs-number">1638.3</span>) * (PRESSURE_DP_MAX - PRESSURE_DP_MIN) / <span class="hljs-number">13106.4</span> \+ PRESSURE_DP_MIN - PRESSURE_DP_BASE; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>;&#125;&#125;  <span class="hljs-comment">/* 计算温度值 */</span>*temperature = temprature_data * <span class="hljs-number">200.0</span> / <span class="hljs-number">2047.0</span> - <span class="hljs-number">50.0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ssd3as.h&quot;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">Delay500ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">22</span>;j = <span class="hljs-number">3</span>;k = <span class="hljs-number">227</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-type">float</span> preesure = <span class="hljs-number">0.0f</span>, temperature = <span class="hljs-number">0.0f</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;uart1_init();spi_init();<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//ssd_get_value(&amp;preesure, &amp;temperature, SENSOR_AP);</span><span class="hljs-comment">//printf(&quot;pressure: %.2fkPa \r\n&quot;, preesure/1000.0);</span>ssd_get_value(&amp;preesure, &amp;temperature, SENSOR_GP);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pressure: %.2fPa \r\n&quot;</span>, preesure);Delay500ms();&#125;&#125;</code></pre></div><p>连接大气压传感器效果如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2023-05-14_184805.png"alt="2023-05-14_184805" /><figcaption aria-hidden="true">2023-05-14_184805</figcaption></figure><p>连接表压传感器，改变压力，效果如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2023-05-14_185549.png"alt="2023-05-14_185549" /><figcaption aria-hidden="true">2023-05-14_185549</figcaption></figure><p>工程文件：<ahref="https://gitee.com/kayoungzhang/my_codehub/raw/master/pressure/pressureTest.zip">pressure</a></p><h3 id="参考链接">参考链接</h3><p><ahref="http://www.sensedz.com/product/html/?141.html">SSD系列数字压力传感器</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sensor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ads1120温度传感器的开发设计</title>
    <link href="/2023/05/09/ads1120%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/09/ads1120%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>前面介绍了ds18b20单总线测量温度，一般应用在环境温度的测量，但开发过程中，针对高低温，宽范围的温度测量，此时用到最多的传感器一般是热电阻(RTDs)和热电偶，如PT100系列热电阻，K-type热电偶。在电路上通过放大器将测量的小信号放大输出，就可以得到测量的温度数据，当然比较简单的做法是使用集成芯片进行处理，像MAX6675，ADS1120，ADS1220等等，之前项目我选用的是ads1120芯片，下面详细介绍一下它的具体情况。</p><h3 id="芯片特性">芯片特性</h3><ul><li>电压： 2.3 V ~ 5.5 V</li><li>SPI接口 (<strong>Mode 1： CPOL=0，CPHA=1</strong>）</li><li>PGA: 1 V/V ~ 128 V/V</li><li>采样率: 最大 2kSPS</li><li>输入：4个单端输入口或两个差分输入口</li><li>16 位无噪声分辨率（20SPS 时）</li><li>内部基准电压： 2.048-V，漂移：5 ppm/°C</li><li>功耗：1.4mW</li><li>采用单周期稳定数字滤波器，在 20SPS 时实现 50Hz 和 60Hz 谐波抑制</li><li>双匹配可编程电流源：50μA 至 1.5mA</li></ul><h3 id="功能框图">功能框图</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511191841945.png" alt="image-20230511191841945"  /></p><h3 id="pga共模电压要求">PGA共模电压要求</h3><p>为了始终处于 PGA的线性工作范围内，输入信号必须满足以下要求。可参考datasheet具体实例。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511202038516.png"alt="image-20230511202038516" /><figcaption aria-hidden="true">image-20230511202038516</figcaption></figure><h3 id="电压基准">电压基准</h3><p>该器件集成了 <strong>2.048V</strong>低漂移电压基准。提供两对差分基准输入（REFP0/REFN0 和 REFP1/REFN1）。基准源通过配置寄存器的两位 (VREF[1:0])进行选择。默认选择内部基准。上电后、退出掉电模式或由外部基准源切换至内部基准后，内部基准电压在25µs 内即可完全稳定。</p><p>差分基准输入支持自由选择共模基准电压。REFP0 和 REFN0为专用基准输入，而 REFP1 和 REFN1 分别与输入 AIN0 和 AIN3共享。所有基准输入均在内部进行缓冲，以提高输入阻抗。因此，使用外部基准时，通常无需额外使用基准缓冲器。</p><p>在多数情况下，转换结果与基准源稳定性成正比。转换结果将反映电压基准的所有噪声和漂移。</p><h3 id="激励电流源">激励电流源</h3><p>该器件为 RTD 应用提供两个匹配的可编程激励电流源(IDAC)。使用配置寄存器的相应位 (IDAC[2:0])可通过编程方式将电流源输出电流设定为10μA、50μA、100μA、250μA、500μA、1000μA 或1500μA。每个电流源均可与所有模拟输入 (AINx) 及所有专用基准输入（REFP0 和REFN0）相连。两电流源还可与同一引脚相连。IDAC的路由通过配置寄存器的位（I1MUX[2:0]，I2MUX[2:0]）进行配置。</p><h3 id="电路设计">电路设计</h3><p>参考芯片datasheet的应用电路，我采用如下兼容设计，可自由切换外接热电偶和3线制PT100。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511194947821.png"alt="image-20230511194947821" /><figcaption aria-hidden="true">image-20230511194947821</figcaption></figure><h3 id="pcb设计">PCB设计</h3><p>主要是模拟和数字地的隔离，电源引脚必须通过低 ESR陶瓷电容旁路至接地。旁路电容的最佳位置应尽可能靠近电源引脚。采用差分连接的模拟输入之间必须放置差分电容。适用于差分测量的最佳输入组合包括：AIN0、AIN1和 AIN2、AIN3，必须选择高品质差分电容。C0G (NPO)电容属性稳定且具备低噪声特性，这是最适用的陶瓷贴片电容。对热电偶输入连接周围的覆铜区域进行热隔离，以构建热性能稳定的冷端。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511203153776.png" alt="image-20230511203153776" style="zoom: 80%;" /></p><h3 id="温度传感器">温度传感器</h3><p>ADS1120 集成了一个精密温度传感器。通过将配置寄存器的 TS 位置 1可使能温度传感器模式。。温度数据以 <strong>14</strong> 位结果呈现，与 24位转换结果左对齐。负数以二进制补码形式表示。数字代码转换温度公式：如果MSB 为 0，将十进制代码乘以 0.03125°C 即可获得结果。如果 MSB =1，则将结果减 1 后对所有位取补码。之后将结果乘以 –0.03125°C。</p><p>示例：器件回读 0960h: 0960h 的 MSB = 0。</p><p>0960h · 0.03125°C = 2400 · 0.03125°C = 75°C</p><p>示例：器件回读 3CE0h: 3CE0h 的 MSB = 1。</p><p>减 1 后对结果取补码：3CE0h → 0320h （C320h &amp; 3FFFh）</p><p>0320h · (–0.03125°C) = 800 · (–0.03125°C) = –25°C</p><h3 id="数据格式">数据格式</h3><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511203020170.png"alt="image-20230511203020170" /><figcaption aria-hidden="true">image-20230511203020170</figcaption></figure><h3 id="指令">指令</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511192136721.png" alt="image-20230511192136721"  /></p><h3 id="寄存器">寄存器</h3><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511192406483.png"alt="image-20230511192406483" /><figcaption aria-hidden="true">image-20230511192406483</figcaption></figure><h3 id="程序实现">程序实现</h3><p>程序中只实现了基本的温度测量功能，可根据需求添加其他功能，另外，芯片的配置函数根据电路的不同也需要进行相应修改。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ADS1120_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-comment">/* spi 引脚定义 */</span>sbit ADS1120_RDY = P1^<span class="hljs-number">1</span>;sbit ADS1120_CS  = P1^<span class="hljs-number">4</span>;sbit ADS1120_SDI = P1^<span class="hljs-number">5</span>;sbit ADS1120_SDO = P1^<span class="hljs-number">6</span>;sbit ADS1120_CLK = P1^<span class="hljs-number">7</span>;<span class="hljs-comment">/* 传感器类型 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><span class="hljs-class">&#123;</span>PT100 = <span class="hljs-number">0</span>, <span class="hljs-comment">//pt100</span>K_TYPE,   <span class="hljs-comment">//k-type</span>INTER     <span class="hljs-comment">//internal temperature sensor</span>&#125;sensor_e;<span class="hljs-comment">/********************ADS1120 Definitions**********************/</span><span class="hljs-comment">/* ADS1120 Command Definitions */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_RESET         0x06</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_START         0x08</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_POWERDOWN     0x02</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_RDATA         0x10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_RREG          0x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_WREG          0x40</span><span class="hljs-comment">/* ADS1120 Register Definitions */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_0_REGISTER    0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_1_REGISTER    0x01</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_2_REGISTER    0x02</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_3_REGISTER    0x03</span><span class="hljs-comment">/* ADS1120 Register 0 Definition */</span><span class="hljs-comment">/** ---------------------------------------------------------------</span><span class="hljs-comment">  * | Bit7 | Bit6 | Bit5 | Bit4 | Bit3 | Bit2 | Bit1 |    Bit0    |</span><span class="hljs-comment">  * ---------------------------------------------------------------</span><span class="hljs-comment">  * |         MUX[3:0]          |      GAIN[2:0]     | PGA_BYPASS |</span><span class="hljs-comment">  * ---------------------------------------------------------------</span><span class="hljs-comment">  */</span><span class="hljs-comment">/* Define MUX */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_MUX_0_1   0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_MUX_3_2   0x70</span><span class="hljs-comment">/* Define GAIN */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_1      0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_2      0x02</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_4      0x04</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_8      0x06</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_16     0x08</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_32     0x0a</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_64     0x0c</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_128    0x0e</span><span class="hljs-comment">/* Define PGA_BYPASS */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_PGA_ENABLE  0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_PGA_DISABLE 0x01</span><span class="hljs-comment">/* ADS1120 Register 1 Definition */</span><span class="hljs-comment">/** ---------------------------------------------------------</span><span class="hljs-comment">  * | Bit7 | Bit6 | Bit5 | Bit4 | Bit3 | Bit2 | Bit1 | Bit0 |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  * |       DR[2:0]      |  MODE[1:0]  |  CM  |  TS  |  BCS |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  */</span><span class="hljs-comment">/* Define DR (data rate) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_20       0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_45       0x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_90       0x40</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_175      0x60</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_330      0x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_600      0xa0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_1000     0xc0</span><span class="hljs-comment">/* Define MODE of Operation */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_MODE_NORMAL 0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_MODE_DUTY   0x08</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_MODE_TURBO  0x10</span><span class="hljs-comment">/* Define CM (conversion mode) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_SS          0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_CC          0x04</span><span class="hljs-comment">/* Define TS (internal temperature sensor) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_TEMP_SENSOR 0x02</span><span class="hljs-comment">/* Define BCS (burnout current source) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_BCS         0x01</span><span class="hljs-comment">/* ADS1120 Register 2 Definition */</span><span class="hljs-comment">/** ---------------------------------------------------------</span><span class="hljs-comment">  * | Bit7 | Bit6 | Bit5 | Bit4 | Bit3 | Bit2 | Bit1 | Bit0 |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  * |  VREF[1:0]  |  50/60[1:0] | PSW  |      IDAC[2:0]     |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  */</span><span class="hljs-comment">/* Define VREF */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_VREF_INT0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_VREF_00x40</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_VREF_10x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_VREF_SUPPLY0xc0</span><span class="hljs-comment">/* Define 50/60 (filter response) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_REJECT_OFF0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_REJECT_BOTH0x10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_REJECT_500x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_REJECT_600x30</span><span class="hljs-comment">/* Define PSW (low side power switch) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_PSW_AUTO0x08</span><span class="hljs-comment">/* Define IDAC (IDAC current) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_OFF       0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_50        0x02</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_100       0x03</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_250       0x04</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_500       0x05</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_1000      0x06</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_1500      0x07</span><span class="hljs-comment">/* ADS1120 Register 3 Definition */</span><span class="hljs-comment">/** ---------------------------------------------------------</span><span class="hljs-comment">  * | Bit7 | Bit6 | Bit5 | Bit4 | Bit3 | Bit2 | Bit1  | Bit0 |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  * |      I1MUX[2:0]    |      I2MUX[2:0]    | DRDYM |  0   |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  */</span><span class="hljs-comment">/* Define I1MUX (IDAC1 routing configuration) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_OFF     0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_AIN0    0x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_AIN1    0x40</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_AIN2    0x60</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_AIN3    0x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_REFP0   0xa0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_REFN0   0xc0</span><span class="hljs-comment">/* Define I2MUX (IDAC2 routing configuration) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_OFF     0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_AIN0    0x04</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_AIN1    0x08</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_AIN2    0x0c</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_AIN3    0x10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_REFP0   0x14</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_REFN0   0x18</span><span class="hljs-comment">/* define DRDYM (DRDY mode) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DRDY_MODE     0x02</span><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> cold_compensation;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">spi_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_confiuration</span><span class="hljs-params">(sensor_e sensor_type)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_get_average_temp</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, sensor_e sensor_type)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_thermocouple_compensation</span><span class="hljs-params">(<span class="hljs-type">int</span>* voltage)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  * @file    ads1120.c </span><span class="hljs-comment">  * @version V1.0.0</span><span class="hljs-comment">  * @date    2023.03.08</span><span class="hljs-comment">  * @author  Kayoung</span><span class="hljs-comment">  * @brief   PT100或K型热电偶SPI传输温度</span><span class="hljs-comment">  * @details  </span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  * @attention </span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ads1120.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;intrins.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-type">int</span> cold_compensation = <span class="hljs-number">0</span>;<span class="hljs-comment">//热电偶冷端补偿值</span><span class="hljs-comment">/* 函数申明 */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode1</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byte)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_wr_reg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, <span class="hljs-type">uint8_t</span> num, <span class="hljs-type">uint8_t</span>* p_data)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">Delay1us</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;_nop_();&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Delay100ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">5</span>;j = <span class="hljs-number">52</span>;k = <span class="hljs-number">195</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  MCU SPI initial</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">spi_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;ADS1120_RDY = <span class="hljs-number">1</span>;ADS1120_CS  = <span class="hljs-number">1</span>;ADS1120_SDI = <span class="hljs-number">0</span>;ADS1120_SDO = <span class="hljs-number">0</span>;ADS1120_CLK = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120 initial config</span><span class="hljs-comment">  * @param  sensor_type: 传感器类型</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_confiuration</span><span class="hljs-params">(sensor_e sensor_type)</span>&#123;<span class="hljs-comment">/* ads1120 register configuration */</span><span class="hljs-type">uint8_t</span> config[<span class="hljs-number">4</span>] =&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">switch</span> (sensor_type)&#123;<span class="hljs-keyword">case</span> PT100:&#123;<span class="hljs-comment">/* PT100 configuration */</span>config[<span class="hljs-number">0</span>] = ADS1120_MUX_0_1 | ADS1120_GAIN_8; <span class="hljs-comment">/* register 0 configuration */</span>config[<span class="hljs-number">1</span>] = ADS1120_DR_20 | ADS1120_CC; <span class="hljs-comment">/* register 1 configuration */</span>config[<span class="hljs-number">2</span>] = ADS1120_VREF_0 | ADS1120_REJECT_BOTH | ADS1120_IDAC_500; <span class="hljs-comment">/* register 2 configuration */</span>config[<span class="hljs-number">3</span>] = ADS1120_IDAC1_AIN2 | ADS1120_IDAC2_AIN3; <span class="hljs-comment">/* register 3 configuration */</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> K_TYPE:&#123;<span class="hljs-comment">/* K-type Thermocouple configuration */</span>config[<span class="hljs-number">0</span>] = ADS1120_MUX_0_1 | ADS1120_GAIN_32; <span class="hljs-comment">/* register 0 configuration */</span>config[<span class="hljs-number">1</span>] = ADS1120_DR_20 | ADS1120_CC; <span class="hljs-comment">/* register 1 configuration */</span>config[<span class="hljs-number">2</span>] = ADS1120_VREF_INT | ADS1120_REJECT_BOTH | ADS1120_IDAC_OFF; <span class="hljs-comment">/* register 2 configuration */</span>config[<span class="hljs-number">3</span>] = ADS1120_IDAC1_OFF | ADS1120_IDAC2_OFF; <span class="hljs-comment">/* register 3 configuration */</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> INTER:&#123;<span class="hljs-comment">/* ads1120 internal temperature sensor configuration */</span>config[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 0 configuration */</span>config[<span class="hljs-number">1</span>] = ADS1120_CC | ADS1120_TEMP_SENSOR; <span class="hljs-comment">/* register 1 configuration */</span>config[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 2 configuration */</span>config[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 3 configuration */</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>;&#125;ADS1120_CS = <span class="hljs-number">0</span>;soft_spi_rw_mode1(ADS1120_RESET); <span class="hljs-comment">// reset ads1120</span>Delay100ms();ads1120_wr_reg(ADS1120_0_REGISTER, <span class="hljs-number">0x04</span>, config); <span class="hljs-comment">//config ads1120 register</span>Delay100ms();soft_spi_rw_mode1(ADS1120_START); <span class="hljs-comment">//start conversation</span>ADS1120_CS = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  gpio 模拟spi，只支持SPI模式1,CPOL=0，CPHA=1, MSB first下降沿采样</span><span class="hljs-comment">  * @param  byte: 发送的一字节数据</span><span class="hljs-comment">  * @paramread_dat:读取的一字节数据</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode1</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byte)</span> &#123;<span class="hljs-type">uint8_t</span> i,read_dat=<span class="hljs-number">0</span>; <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)     <span class="hljs-comment">// 循环8次</span>&#123;<span class="hljs-comment">/* 发送数据 */</span>ADS1120_CLK = <span class="hljs-number">1</span>;     <span class="hljs-comment">//拉高时钟</span><span class="hljs-keyword">if</span>(byte &amp; <span class="hljs-number">0x80</span>)ADS1120_SDI = <span class="hljs-number">1</span>;  <span class="hljs-comment">//若最到位为高，则输出高</span><span class="hljs-keyword">else</span>      ADS1120_SDI = <span class="hljs-number">0</span>;   <span class="hljs-comment">//若最到位为低，则输出低</span>byte &lt;&lt;= <span class="hljs-number">1</span>;     <span class="hljs-comment">// 低一位移位到最高位</span>Delay1us();<span class="hljs-comment">/* 接收数据 */</span>ADS1120_CLK = <span class="hljs-number">0</span>;     <span class="hljs-comment">//拉低时钟</span>read_dat &lt;&lt;= <span class="hljs-number">1</span>;     <span class="hljs-comment">//数据左移</span><span class="hljs-keyword">if</span>(ADS1120_SDO)read_dat++;     <span class="hljs-comment">//若从从机接收到高电平，数据自加一</span>Delay1us();&#125;<span class="hljs-keyword">return</span> (read_dat);     <span class="hljs-comment">//返回数据</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120读寄存器</span><span class="hljs-comment">  * @param  addr：寄存器开始地址</span><span class="hljs-comment">  *@paramnum：读取的字节数</span><span class="hljs-comment">  *@paramp_data：读取的数据指针</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_rd_reg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, <span class="hljs-type">uint8_t</span> num, <span class="hljs-type">uint8_t</span>* p_data)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">/* send the command byte */</span>soft_spi_rw_mode1(ADS1120_RREG | (((addr &lt;&lt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x0c</span>) |((num - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x03</span>)));  <span class="hljs-comment">/* get the register content */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;*p_data++ = soft_spi_rw_mode1(<span class="hljs-number">0x00</span>);&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120写寄存器</span><span class="hljs-comment">  * @param  addr：寄存器开始地址</span><span class="hljs-comment">  *@paramnum：写入的字节数</span><span class="hljs-comment">  *@paramp_data：写入数据的指针</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_wr_reg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, <span class="hljs-type">uint8_t</span> num, <span class="hljs-type">uint8_t</span>* p_data)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">/* send the command byte */</span>soft_spi_rw_mode1(ADS1120_WREG | (((addr &lt;&lt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x0c</span>) |((num - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x03</span>)));  <span class="hljs-comment">/* send the register content */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;soft_spi_rw_mode1(*p_data++);&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120读取转换数据</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval result：读取到的两字节数据</span><span class="hljs-comment">  */</span><span class="hljs-type">long</span> <span class="hljs-title function_">ads1120_rd_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;  <span class="hljs-comment">/* assert CS to start transfer */</span>ADS1120_CS = <span class="hljs-number">0</span>;Delay1us();  <span class="hljs-comment">/* send the command byte */</span>  soft_spi_rw_mode1(ADS1120_RDATA);<span class="hljs-comment">//read conversation data</span><span class="hljs-comment">//while(ADS1120_RDY); //等待数据到来</span>result = soft_spi_rw_mode1(<span class="hljs-number">0x00</span>);result = (result &lt;&lt; <span class="hljs-number">8</span>) | soft_spi_rw_mode1(<span class="hljs-number">0x00</span>);<span class="hljs-comment">/* sign extend data */</span>  <span class="hljs-keyword">if</span> (result &amp; <span class="hljs-number">0x8000</span>)result |= <span class="hljs-number">0xffff0000</span>;<span class="hljs-comment">//result = (~result) &amp; 0x7fff;</span><span class="hljs-comment">//uart1_send_byte(result &gt;&gt; 8);</span><span class="hljs-comment">//uart1_send_byte(result);</span>Delay1us();ADS1120_CS = <span class="hljs-number">1</span>;  <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120获取温度</span><span class="hljs-comment">  * @param  temperature：获取的温度值</span><span class="hljs-comment">  * @param  sensor_type: 传感器类型</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_get_temperature</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, sensor_e sensor_type)</span>&#123;<span class="hljs-type">long</span> value = <span class="hljs-number">0</span>;<span class="hljs-type">float</span> voltage = <span class="hljs-number">0.0f</span>;value = ads1120_rd_data();<span class="hljs-keyword">switch</span> (sensor_type)&#123;<span class="hljs-keyword">case</span> PT100:&#123;<span class="hljs-comment">/* PT100 */</span>voltage = (<span class="hljs-type">float</span>)(value * <span class="hljs-number">1.65f</span> / <span class="hljs-number">8</span> / <span class="hljs-number">32768</span>);*temperature = (voltage * <span class="hljs-number">2000</span> - <span class="hljs-number">100</span>)/<span class="hljs-number">0.385f</span>;<span class="hljs-comment">//IDAC_500uA, PT100每升高1℃，阻值增加0.385 ohm</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> K_TYPE:&#123;<span class="hljs-comment">/* K-type thermocouple */</span><span class="hljs-comment">//uart1_send_byte(calibration_value &gt;&gt; 8);</span><span class="hljs-comment">//uart1_send_byte(calibration_value);</span>voltage = (<span class="hljs-type">float</span>)(value * <span class="hljs-number">62.5</span> / <span class="hljs-number">32</span>  + cold_compensation); <span class="hljs-comment">//voltage=value*2.048f/32/32768*1000000;转换为uV</span>*temperature = (<span class="hljs-type">float</span>)(voltage / <span class="hljs-number">41.0</span>);<span class="hljs-comment">//K-type赛贝克系数：41℃/uV</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> INTER:&#123;<span class="hljs-comment">/* ads1120 internal temperature sensor 14bit left-data */</span>value = (value &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x3fff</span>;<span class="hljs-keyword">if</span>(value &amp; <span class="hljs-number">0x2000</span>) <span class="hljs-comment">//negative temp</span>&#123;value = (~(value - <span class="hljs-number">1</span>))&amp;<span class="hljs-number">0x1fff</span>;*temperature =(<span class="hljs-type">float</span>)(value * (<span class="hljs-number">-0.03125f</span>));&#125;<span class="hljs-keyword">else</span>&#123;*temperature =(<span class="hljs-type">float</span>)(value * <span class="hljs-number">0.03125f</span>);<span class="hljs-comment">//postive temp</span>&#125;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120平均温度</span><span class="hljs-comment">  * @param  temperature：温度平均值</span><span class="hljs-comment">  * @param  sensor_type: 传感器类型</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_get_average_temp</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, sensor_e sensor_type)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-type">float</span> sum = <span class="hljs-number">0.0</span>; <span class="hljs-comment">//温度和</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)&#123;ads1120_get_temperature(temperature, sensor_type);sum += *temperature;&#125;*temperature = (<span class="hljs-type">float</span>)(sum / <span class="hljs-number">8.0</span>);sum = <span class="hljs-number">0.0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120 K型热电偶冷端补偿</span><span class="hljs-comment">  * @param  voltage：获取冷端电压值的指针（单位：uV）</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_thermocouple_compensation</span><span class="hljs-params">(<span class="hljs-type">int</span>* voltage)</span>&#123;<span class="hljs-comment">/* ads1120 register configuration */</span><span class="hljs-type">uint8_t</span> config[<span class="hljs-number">4</span>] =&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<span class="hljs-type">float</span> temp = <span class="hljs-number">0</span>;<span class="hljs-comment">/* ads1120 internal temperature sensor configuration */</span>config[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 0 configuration */</span>config[<span class="hljs-number">1</span>] = ADS1120_TEMP_SENSOR; <span class="hljs-comment">/* register 1 configuration */</span>config[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 2 configuration */</span>config[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 3 configuration */</span>ADS1120_CS = <span class="hljs-number">0</span>;soft_spi_rw_mode1(ADS1120_RESET); <span class="hljs-comment">// reset ads1120</span>Delay100ms();ads1120_wr_reg(ADS1120_0_REGISTER, <span class="hljs-number">0x04</span>, config); <span class="hljs-comment">//config ads1120 register</span>Delay100ms();soft_spi_rw_mode1(ADS1120_START); <span class="hljs-comment">//start conversation</span><span class="hljs-comment">//  soft_spi_rw_mode1(ADS1120_RDATA);//read conversation data</span><span class="hljs-keyword">while</span>(ADS1120_RDY); <span class="hljs-comment">//等待数据到来</span>result = soft_spi_rw_mode1(<span class="hljs-number">0x00</span>);result = (result &lt;&lt; <span class="hljs-number">8</span>) | soft_spi_rw_mode1(<span class="hljs-number">0x00</span>);ADS1120_CS = <span class="hljs-number">1</span>;result = (result &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x3fff</span>; <span class="hljs-comment">//14bit postive temp</span><span class="hljs-keyword">if</span>(result &amp; <span class="hljs-number">0x2000</span>) <span class="hljs-comment">//negative temp</span>&#123;result = (~(result - <span class="hljs-number">1</span>))&amp;<span class="hljs-number">0x1fff</span>;temp =(<span class="hljs-type">float</span>)(result * (<span class="hljs-number">-0.03125f</span>));&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">//postive temp</span>&#123;temp =(<span class="hljs-type">float</span>)(result * <span class="hljs-number">0.03125f</span>);&#125;<span class="hljs-comment">/* 根据表格数据得出电压与温度关系式：https://srdata.nist.gov/its90/main/its90_main_page.html */</span>*voltage = (<span class="hljs-type">int</span>)(<span class="hljs-number">40.309</span> * temp - <span class="hljs-number">5.3031</span>); <span class="hljs-comment">//NIST- its90 温度与电压关系式（单位：uV）</span><span class="hljs-keyword">return</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ads1120.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-type">float</span> temperature = <span class="hljs-number">0.0f</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">gpio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">//M1  M0</span><span class="hljs-comment">//0   0     准双向口</span><span class="hljs-comment">//0   1     推挽输出</span><span class="hljs-comment">//1   0     高阻输入</span><span class="hljs-comment">//1   1     开漏</span><span class="hljs-comment">/* SPI引脚设置 */</span>P1M1 = <span class="hljs-number">0x42</span>;<span class="hljs-comment">//M1 0100 0010</span>P1M0 = <span class="hljs-number">0xb0</span>;<span class="hljs-comment">//M0 1011 0000</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Delay1000ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">43</span>;j = <span class="hljs-number">6</span>;k = <span class="hljs-number">203</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;uart1_init();gpio_init();    spi_init();<span class="hljs-comment">//ads1120_confiuration(INTER); //芯片内部温度</span>ads1120_confiuration(PT100); <span class="hljs-comment">//PT100</span><span class="hljs-comment">//ads1120_confiuration(K_TYPE); //K-type热电偶</span><span class="hljs-comment">//ads1120_thermocouple_compensation(&amp;cold_compensation);//热电偶冷端补偿</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//ads1120_get_average_temp(&amp;temperature, INTER);</span>ads1120_get_average_temp(&amp;temperature, PT100);<span class="hljs-comment">//ads1120_get_average_temp(&amp;temperature, K_TYPE);</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;temperature is %.3f℃\r\n&quot;</span>, temperature);Delay1000ms();&#125;&#125;</code></pre></div><p>效果：</p><p>内部温度传感器测量效果：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511200919371.png"alt="image-20230511200919371" /><figcaption aria-hidden="true">image-20230511200919371</figcaption></figure><p>外接PT100传感器测量的温度效果：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511201148501.png"alt="image-20230511201148501" /><figcaption aria-hidden="true">image-20230511201148501</figcaption></figure><p>工程代码：https://gitee.com/kayoungzhang/my_codehub/raw/master/ads1120/ads1120.zip</p><h3 id="参考链接">参考链接</h3><p><ahref="https://www.ti.com/product/ADS1120?keyMatch=ADS1120&amp;tisearch=search-everything&amp;usecase=GPN#hardware-development">ads1120datasheet</a></p><p>https://www.ti.com/lit/zip/sbac227</p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTD</tag>
      
      <tag>热电偶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ds1302实时时钟芯片的开发</title>
    <link href="/2023/05/05/ds1302%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E8%8A%AF%E7%89%87%E7%9A%84%E5%BC%80%E5%8F%91/"/>
    <url>/2023/05/05/ds1302%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E8%8A%AF%E7%89%87%E7%9A%84%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>DS1302芯片作为实时时钟使用，在开发过程中，使用比较频繁，时钟芯片PCF8563也有使用，这里主要写写DS1302这款芯片的开发设计。</p><h3 id="特点">特点</h3><ul><li>电压：2.0V ~ 5.5V</li><li>提供年、月、日、时、分、秒、星期等信息</li><li>31 字节数据静态RAM</li><li>通过简单的串行口与单片机进行通信</li></ul><h3 id="应用电路">应用电路</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230505182519782.png" alt="image-20230505182519782" style="zoom:67%;" /></p><table><thead><tr class="header"><th>引脚</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>Vcc2</td><td>主电源</td></tr><tr class="even"><td>Vcc1</td><td>备用电源，如纽扣电池CR2032</td></tr><tr class="odd"><td>X1、X2</td><td>外接32.768khz晶振</td></tr><tr class="even"><td>CE</td><td>控制信号</td></tr><tr class="odd"><td>I/O</td><td>串行接口数据线</td></tr><tr class="even"><td>SCLK</td><td>串行接口时钟线</td></tr></tbody></table><h3 id="指令寄存器">指令寄存器</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230505184339517.png" alt="image-20230505184339517" style="zoom: 67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230505185956240.png" alt="image-20230505185956240" style="zoom:67%;" /></p><h2 id="bcd码">BCD码</h2><p>BCD码（Binary CodedDecimal‎），用4位二进制数来表示1位十进制数，所以4位二进制表示的数字最大到<strong>9</strong> 。例：0001 0011表示13，1000 0101表示85，00011010不合法。在十六进制中的体现：0x13表示13，0x85表示85，0x1A不合法</p><p><code>BCD码转十进制：DEC=BCD/16*10+BCD%16; （2位BCD）</code></p><p><code>十进制转BCD码：BCD=DEC/10*16+DEC%10; （2位BCD）</code></p><p>DS1302写数据时需要将十进制数据转为BCD码的形式，读数据时需要将BCD码转为十进制数据形式。</p><h2 id="通信时序">通信时序</h2><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230505194024970.png" alt="image-20230505194024970" style="zoom:67%;" /></p><p><strong>注意：</strong>读时序时，发送完命令字的MSB位后，马上就读出数据，所以每个脉冲提前半拍。</p><h3 id="程序实现">程序实现</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DS1302_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DS1302_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-comment">/* pin definition */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DS1302_IO  P34</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DS1302_SCLKP36</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DS1302_CE  P35</span><span class="hljs-comment">/* register of rtc read address command */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_SECOND_READ   0x81</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_MINUTE_READ   0x83</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_HOUR_READ     0x85</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_DATE_READ     0x87</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_MONTH_READ    0x89</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_DAY_READ      0x8b  <span class="hljs-comment">//week</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_YEAR_READ     0x8d</span><span class="hljs-comment">/* register of rtc write address command */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_SECOND_WRITE   0x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_MINUTE_WRITE   0x82</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_HOUR_WRITE     0x84</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_DATE_WRITE     0x86</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_MONTH_WRITE    0x88</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_DAY_WRITE      0x8a</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_YEAR_WRITE     0x8c</span><span class="hljs-comment">/* write protect */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_WR_PROTECT_READ    0x8f</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_WR_PROTECT_WRITE   0x8e</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITE_PROTECT_ENABLE   0x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITE_PROTECT_DISABLE  0x00</span><span class="hljs-comment">/* 年 月 日 时 分 秒 周 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> year; <span class="hljs-comment">//0~99</span><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> month;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> date;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hour;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> minute;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> second;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> day;&#125;<span class="hljs-type">tm_t</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_read_time</span><span class="hljs-params">(<span class="hljs-type">tm_t</span>* p_tm)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_write_time</span><span class="hljs-params">(<span class="hljs-type">tm_t</span>* p_tm)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ************************************************</span><span class="hljs-comment">  * @file     ds1302.c</span><span class="hljs-comment">  * @author  Kayoung</span><span class="hljs-comment">  * @version  V1.0</span><span class="hljs-comment">  * @date     20220327</span><span class="hljs-comment">  * @brief    ds1302时钟driver</span><span class="hljs-comment">  **********************************************</span><span class="hljs-comment">  */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ds1302.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-comment">/* BCD转十进制DEC： DEC = BCD/16*10 + BCD%16;(2位BCD)</span><span class="hljs-comment">   十进制DEC转BCD： BCD = DEC/10*16 + DEC%10;(2位BCD)</span><span class="hljs-comment">*/</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief   ds1302初始化</span><span class="hljs-comment">  * @param   None</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;DS1302_SCLK = <span class="hljs-number">0</span>;DS1302_CE = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief 向ds1302写入一个字节</span><span class="hljs-comment">  * @param command: 命令字</span><span class="hljs-comment">  * @param   wr_data: 待写入的字节</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_wrbyte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> command, <span class="hljs-type">uint8_t</span> wr_data)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//循环变量</span>DS1302_CE = <span class="hljs-number">1</span>;<span class="hljs-comment">/* 先写入command */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<span class="hljs-comment">//LSB to MSB</span>&#123;DS1302_IO = command &amp; (<span class="hljs-number">0x01</span>&lt;&lt;i);DS1302_SCLK = <span class="hljs-number">1</span>; <span class="hljs-comment">//51单片机速率慢，此处不需要延时，上升沿写入命令</span>DS1302_SCLK = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 再写入data */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<span class="hljs-comment">//LSB to MSB</span>&#123;DS1302_IO = wr_data &amp; (<span class="hljs-number">0x01</span>&lt;&lt;i);DS1302_SCLK = <span class="hljs-number">1</span>; <span class="hljs-comment">//51单片机速率慢，此处不需要延时,上升沿写入数据</span>DS1302_SCLK = <span class="hljs-number">0</span>;&#125;DS1302_CE = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief ds1302读出一个字节</span><span class="hljs-comment">  * @param command: 命令字</span><span class="hljs-comment">  * @retval  recv_byte: 接收的字节</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ds1302_rdbyte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> command)</span>&#123;<span class="hljs-type">uint8_t</span> recv_byte = <span class="hljs-number">0</span>;<span class="hljs-type">uint8_t</span> i;<span class="hljs-comment">//循环变量</span>DS1302_CE = <span class="hljs-number">1</span>;<span class="hljs-comment">/* 先发送命令 */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<span class="hljs-comment">//LSB to MSB</span>&#123;DS1302_IO = command &amp; (<span class="hljs-number">0x01</span> &lt;&lt; i);DS1302_SCLK = <span class="hljs-number">0</span>;DS1302_SCLK = <span class="hljs-number">1</span>;<span class="hljs-comment">//上升沿写入命令</span>&#125;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++)<span class="hljs-comment">//LSB to MSB</span>&#123;DS1302_SCLK = <span class="hljs-number">1</span>;<span class="hljs-comment">//下降沿读出数据</span>DS1302_SCLK = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(DS1302_IO)&#123;recv_byte |= (<span class="hljs-number">0x01</span> &lt;&lt; i);&#125;&#125;DS1302_CE = <span class="hljs-number">0</span>;DS1302_IO = <span class="hljs-number">0</span>;  <span class="hljs-comment">//解决读取时间是ff的问题</span><span class="hljs-keyword">return</span> recv_byte;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief ds1302设置时间</span><span class="hljs-comment">  * @param p_tm: 时间结构体指针</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_write_time</span><span class="hljs-params">(<span class="hljs-type">tm_t</span>* p_tm)</span>&#123;ds1302_wrbyte(REG_WR_PROTECT_WRITE, WRITE_PROTECT_DISABLE);<span class="hljs-comment">//关闭写保护</span><span class="hljs-comment">/* 十进制转BCD码 */</span>ds1302_wrbyte(REG_YEAR_WRITE, (p_tm-&gt;year / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;year % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_MONTH_WRITE, (p_tm-&gt;month / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;month % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_DATE_WRITE, (p_tm-&gt;date / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;date % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_HOUR_WRITE, (p_tm-&gt;hour / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;hour % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_MINUTE_WRITE, (p_tm-&gt;minute / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;minute % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_SECOND_WRITE, (p_tm-&gt;second / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;second % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_DAY_WRITE, (p_tm-&gt;day / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;day % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_WR_PROTECT_WRITE, WRITE_PROTECT_ENABLE);<span class="hljs-comment">//打开写保护</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief ds1302读取时间</span><span class="hljs-comment">  * @param p_tm: 时间结构体指针</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_read_time</span><span class="hljs-params">(<span class="hljs-type">tm_t</span>* p_tm)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> temp;<span class="hljs-comment">/* BCD码转十进制 */</span>temp = ds1302_rdbyte(REG_YEAR_READ);p_tm-&gt;year = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_MONTH_READ);p_tm-&gt;month = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_DATE_READ);p_tm-&gt;date = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_HOUR_READ);p_tm-&gt;hour = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_MINUTE_READ);p_tm-&gt;minute = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_SECOND_READ);p_tm-&gt;second = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_DAY_READ);p_tm-&gt;day = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;<span class="hljs-comment">//printf(&quot;%#x&quot;, temp);</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ds1302.h&quot;</span></span><span class="hljs-comment">/* 初始化时间：2022年03月27日17时20分50秒周七，存储格式是用BCD码 */</span><span class="hljs-type">tm_t</span> default_time = &#123;<span class="hljs-number">22</span>,<span class="hljs-number">3</span>,<span class="hljs-number">27</span>,<span class="hljs-number">17</span>,<span class="hljs-number">20</span>,<span class="hljs-number">50</span>,<span class="hljs-number">7</span>&#125;;<span class="hljs-type">tm_t</span> tm; <span class="hljs-comment">//存储读取的时间</span><span class="hljs-type">void</span> <span class="hljs-title function_">Delay1000ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">43</span>;j = <span class="hljs-number">6</span>;k = <span class="hljs-number">203</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;uart1_init();ds1302_init();<span class="hljs-comment">/* 设置时间 */</span>ds1302_write_time(&amp;default_time);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">/* 读取时间 */</span>ds1302_read_time(&amp;tm);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-%d-%d &quot;</span>, (tm.year + <span class="hljs-number">2000</span>), tm.month, tm.date);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:%d:%d 周%d&quot;</span>,tm.hour, tm.minute, tm.second, tm.day);<span class="hljs-comment">//不能放到同一个printf中，否则周期乱码</span>Delay1000ms();&#125;&#125;</code></pre></div><p>效果图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230508203331455.png" alt="image-20230508203331455" style="zoom:80%;" /></p><p>工程代码：<ahref="https://gitee.com/kayoungzhang/my_codehub.git">ds1302</a></p><h3 id="参考链接">参考链接</h3><p>https://wendy.blog.csdn.net/article/details/124249444</p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ds1302</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sht3x温湿度传感器的开发设计</title>
    <link href="/2023/04/30/sht3x%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/04/30/sht3x%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>国内市场碰到的温湿度传感器一般都采用的是瑞士公司Sensirion生产的，像SHT2x 和 SHT3x和 SHTCx和SHT4x等系列温湿度传感器。下面介绍一下其经典的数字温湿度传感器<ahref="https://sensirion.com/cn/products/product-catalog/SHT31-DIS-B">SHT31-DIS-B</a>。</p><h3 id="特点">特点</h3><ul><li><p>电源电压：2.4 - 5.5V</p></li><li><p>相对湿度范围：0 - 100%RH 相对湿度精度：2%RH</p></li><li><p>工作温度范围：-40 - 125°C 温度精度：0.2°C</p></li><li><p>接口：I²C</p></li><li><p>尺寸 (长x宽x高)：2.5 x 2.5 x 0.9 mm³</p></li></ul><h3 id="引脚定义及其典型线路应用">引脚定义及其典型线路应用</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230429191808155.png" alt="image-20230429191808155" style="zoom: 67%;" /><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230430092336215.png" alt="image-20230430092336215" style="zoom:67%;" /></p><h3 id="获取芯片序列号">获取芯片序列号</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230429195521345.png" alt="image-20230429195521345" style="zoom: 67%;" /></p><h3 id="单次采集模式时序">单次采集模式时序</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230429194522708.png" alt="image-20230429194522708" style="zoom: 80%;" /></p><h3 id="周期性采集模式时序">周期性采集模式时序</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230430185828051.png" alt="image-20230430185828051" style="zoom:67%;" /></p><p><strong>注意</strong>：灰色块是传感器发送。</p><h3 id="计算公式">计算公式</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230429235908382.png" alt="image-20230429235908382" style="zoom:67%;" /></p><h3 id="代码实现">代码实现</h3><ul><li>I2C代码部分：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __BSP_I2C_H__</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __BSP_I2C_H__</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">uint16_t</span>;<span class="hljs-comment">/* 引脚定义 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_SCLP23</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_SDAP24</span><span class="hljs-comment">/* I2C acknowledge status */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span>  ACK  = <span class="hljs-number">0</span>,  NACK = <span class="hljs-number">1</span>,&#125;ack_e;<span class="hljs-comment">/* 函数声明 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2c_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2c_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2c_stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2c_delay</span> <span class="hljs-params">(<span class="hljs-type">uint8_t</span> t)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2c_rd_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* recv_byte, ack_e ack_status)</span>;<span class="hljs-keyword">extern</span> ack_e <span class="hljs-title function_">i2c_wr_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> write_byte)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">crc8_calc</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *crcdata, <span class="hljs-type">uint8_t</span> size)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/*END OF FILE*/</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> ******************************************************************************</span><span class="hljs-comment"> * @file    bsp_i2c.c</span><span class="hljs-comment"> * @author  Kayoung</span><span class="hljs-comment"> * @version V1.1</span><span class="hljs-comment"> * @date    20201106</span><span class="hljs-comment"> * @brief   gpio软件模拟i2c</span><span class="hljs-comment"> ******************************************************************************</span><span class="hljs-comment"> * @attention </span><span class="hljs-comment"> ******************************************************************************</span><span class="hljs-comment"> */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_i2c.h&quot;</span></span><span class="hljs-comment">/* Generator polynomial for CRC8 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLYNOMIAL  0x31 <span class="hljs-comment">// P(x) = x^8 + x^5 + x^4 + 1 = 00110001 ，省略了最高位1</span></span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefcrc8计算</span><span class="hljs-comment">  * @paramcrcdata：数据指针</span><span class="hljs-comment">  * @param  size：数据长度</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">crc8_calc</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *crcdata, <span class="hljs-type">uint8_t</span> size)</span>&#123;<span class="hljs-type">uint8_t</span> Bit;        <span class="hljs-comment">// bit mask</span><span class="hljs-type">uint8_t</span> crc = <span class="hljs-number">0xFF</span>; <span class="hljs-comment">// calculated checksum</span><span class="hljs-type">uint8_t</span> byteCtr;    <span class="hljs-comment">// byte counter</span>    <span class="hljs-comment">// calculates 8-Bit checksum with given polynomial </span>  <span class="hljs-keyword">for</span>(byteCtr = <span class="hljs-number">0</span>; byteCtr &lt; size; byteCtr++)  &#123;    crc ^= (crcdata[byteCtr]);    <span class="hljs-keyword">for</span>(Bit = <span class="hljs-number">8</span>; Bit &gt; <span class="hljs-number">0</span>; --Bit)    &#123;      <span class="hljs-keyword">if</span>(crc &amp; <span class="hljs-number">0x80</span>) crc = (crc &lt;&lt; <span class="hljs-number">1</span>) ^ POLYNOMIAL;      <span class="hljs-keyword">else</span>           crc = (crc &lt;&lt; <span class="hljs-number">1</span>);    &#125;  &#125;<span class="hljs-keyword">return</span> crc;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">i2c_delay</span> <span class="hljs-params">(<span class="hljs-type">uint8_t</span> t)</span>&#123;<span class="hljs-keyword">while</span>(t--);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  i2c start.</span><span class="hljs-comment"> * @param  None.</span><span class="hljs-comment"> * @retval None.</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;I2C_SDA = <span class="hljs-number">1</span>; I2C_SCL = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  i2c start. I2C_SCL、I2C_SDA同为高，I2C_SDA跳变成低之后，I2C_SCL跳变成低</span><span class="hljs-comment"> * @param  None.</span><span class="hljs-comment"> * @retval None.</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  I2C_SDA = <span class="hljs-number">1</span>;  I2C_SCL = <span class="hljs-number">1</span>;  i2c_delay(<span class="hljs-number">10</span>);  I2C_SDA = <span class="hljs-number">0</span>;  i2c_delay(<span class="hljs-number">10</span>);  I2C_SCL = <span class="hljs-number">0</span>;  i2c_delay(<span class="hljs-number">10</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  i2c stop.I2C_SCL、I2C_SDA同为低，I2C_SCL跳变成高之后，I2C_SDA跳变成高</span><span class="hljs-comment"> * @param  None.</span><span class="hljs-comment"> * @retval None.</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  I2C_SDA = <span class="hljs-number">0</span>;  I2C_SCL = <span class="hljs-number">0</span>;i2c_delay(<span class="hljs-number">10</span>);  I2C_SCL = <span class="hljs-number">1</span>;  i2c_delay(<span class="hljs-number">10</span>);  I2C_SDA = <span class="hljs-number">1</span>;  i2c_delay(<span class="hljs-number">10</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  CPU从I2C总线设备发送8bit数据</span><span class="hljs-comment"> * @param  write_byte: 待写入的1字节数据</span><span class="hljs-comment"> * @retval res：(获取从机ack)ACK: 0, NACK：1.</span><span class="hljs-comment"> */</span>ack_e <span class="hljs-title function_">i2c_wr_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> write_byte)</span>&#123;<span class="hljs-type">uint8_t</span> i;ack_e ack_status;I2C_SCL = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)&#123;<span class="hljs-comment">//要发送8位，从最高位开始</span><span class="hljs-keyword">if</span> (write_byte &amp; <span class="hljs-number">0x80</span>) <span class="hljs-comment">// I2C_SDA = (write_byte &amp; 0x80) &gt;&gt; 7;</span>&#123;I2C_SDA = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;I2C_SDA = <span class="hljs-number">0</span>;&#125;i2c_delay(<span class="hljs-number">10</span>);I2C_SCL = <span class="hljs-number">1</span>;<span class="hljs-comment">//输出I2C_SDA稳定后，拉高I2C_SCL给出上升沿，从机检测到后进行数据采样</span>i2c_delay(<span class="hljs-number">50</span>);I2C_SCL = <span class="hljs-number">0</span>;i2c_delay(<span class="hljs-number">10</span>);write_byte &lt;&lt;= <span class="hljs-number">1</span>;&#125;I2C_SDA = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放总线</span>I2C_SCL = <span class="hljs-number">1</span>;i2c_delay(<span class="hljs-number">50</span>);ack_status = I2C_SDA;I2C_SCL=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> ack_status;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  CPU从I2C总线设备读取8bit数据</span><span class="hljs-comment"> * @param  recv_byte : 读取的1字节数据指针.</span><span class="hljs-comment"> * @param  ack_status：主机发送ack（ACK: 0, NACK：1.）</span><span class="hljs-comment"> * @retval None.</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_rd_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* recv_byte, ack_e ack_status)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) <span class="hljs-comment">//from MSB to LSB</span>&#123;*recv_byte &lt;&lt;= <span class="hljs-number">1</span>;I2C_SCL = <span class="hljs-number">1</span>;i2c_delay(<span class="hljs-number">30</span>);<span class="hljs-comment">//延时等待信号稳定</span><span class="hljs-keyword">if</span>(I2C_SDA == <span class="hljs-number">1</span>)(*recv_byte)++;I2C_SCL = <span class="hljs-number">0</span>; <span class="hljs-comment">//fall edge for next value</span>i2c_delay(<span class="hljs-number">10</span>);&#125;I2C_SDA = ack_status; i2c_delay(<span class="hljs-number">10</span>);I2C_SCL = <span class="hljs-number">1</span>;<span class="hljs-comment">//产生一个时钟</span>i2c_delay(<span class="hljs-number">50</span>);I2C_SCL = <span class="hljs-number">0</span>;i2c_delay(<span class="hljs-number">10</span>);I2C_SDA = <span class="hljs-number">1</span>;<span class="hljs-comment">//释放总线</span>&#125;</code></pre></div><ul><li>SHT31代码部分：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __SHT3X_H_</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SHT3X_H_</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_i2c.h&quot;</span></span><span class="hljs-comment">/* only the 7 MSBs of the I2C Read/Write header constitute the I2C Address. */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHT3XADDR 0x44    <span class="hljs-comment">//default address             </span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHT3XWriteHeader SHT3XADDR&lt;&lt;1   <span class="hljs-comment">//7 MSBs + write bit 0</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHT3XReadHeader  SHT3XWriteHeader|0x01   <span class="hljs-comment">//7 MSBs + read bit 1</span></span><span class="hljs-comment">/* Error codes */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span>  NO_ERROR       = <span class="hljs-number">0x00</span>, <span class="hljs-comment">// no error</span>  ACK_ERROR      = <span class="hljs-number">0x01</span>, <span class="hljs-comment">// no acknowledgment error</span>  CHECKSUM_ERROR = <span class="hljs-number">0x02</span>, <span class="hljs-comment">// checksum mismatch error</span>  TIMEOUT_ERROR  = <span class="hljs-number">0x04</span>, <span class="hljs-comment">// timeout error</span>  PARM_ERROR     = <span class="hljs-number">0x80</span>, <span class="hljs-comment">// parameter out of range error</span>&#125;etError;<span class="hljs-comment">/* Sensor Commands */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span>  CMD_READ_SERIALNBR  = <span class="hljs-number">0x3780</span>, <span class="hljs-comment">// read serial number</span>  CMD_READ_STATUS     = <span class="hljs-number">0xF32D</span>, <span class="hljs-comment">// read status register</span>  CMD_CLEAR_STATUS    = <span class="hljs-number">0x3041</span>, <span class="hljs-comment">// clear status register</span>  CMD_HEATER_ENABLE   = <span class="hljs-number">0x306D</span>, <span class="hljs-comment">// enabled heater</span>  CMD_HEATER_DISABLE  = <span class="hljs-number">0x3066</span>, <span class="hljs-comment">// disable heater</span>  CMD_SOFT_RESET      = <span class="hljs-number">0x30A2</span>, <span class="hljs-comment">// soft reset</span>  CMD_MEAS_CLOCKSTR_H = <span class="hljs-number">0x2C06</span>, <span class="hljs-comment">// measurement: clock stretching, high repeatability</span>  CMD_MEAS_CLOCKSTR_M = <span class="hljs-number">0x2C0D</span>, <span class="hljs-comment">// measurement: clock stretching, medium repeatability</span>  CMD_MEAS_CLOCKSTR_L = <span class="hljs-number">0x2C10</span>, <span class="hljs-comment">// measurement: clock stretching, low repeatability</span>  CMD_MEAS_POLLING_H  = <span class="hljs-number">0x2400</span>, <span class="hljs-comment">// measurement: polling, high repeatability</span>  CMD_MEAS_POLLING_M  = <span class="hljs-number">0x240B</span>, <span class="hljs-comment">// measurement: polling, medium repeatability</span>  CMD_MEAS_POLLING_L  = <span class="hljs-number">0x2416</span>, <span class="hljs-comment">// measurement: polling, low repeatability</span>  CMD_MEAS_PERI_05_H  = <span class="hljs-number">0x2032</span>, <span class="hljs-comment">// measurement: periodic 0.5 mps, high repeatability</span><span class="hljs-comment">//  CMD_MEAS_PERI_05_M  = 0x2024, // measurement: periodic 0.5 mps, medium repeatability</span>  CMD_MEAS_PERI_05_L  = <span class="hljs-number">0x202F</span>, <span class="hljs-comment">// measurement: periodic 0.5 mps, low repeatability</span>  CMD_MEAS_PERI_1_H   = <span class="hljs-number">0x2130</span>, <span class="hljs-comment">// measurement: periodic 1 mps, high repeatability</span><span class="hljs-comment">//  CMD_MEAS_PERI_1_M   = 0x2126, // measurement: periodic 1 mps, medium repeatability</span>  CMD_MEAS_PERI_1_L   = <span class="hljs-number">0x212D</span>, <span class="hljs-comment">// measurement: periodic 1 mps, low repeatability</span>  CMD_MEAS_PERI_2_H   = <span class="hljs-number">0x2236</span>, <span class="hljs-comment">// measurement: periodic 2 mps, high repeatability</span><span class="hljs-comment">//  CMD_MEAS_PERI_2_M   = 0x2220, // measurement: periodic 2 mps, medium repeatability</span>  CMD_MEAS_PERI_2_L   = <span class="hljs-number">0x222B</span>, <span class="hljs-comment">// measurement: periodic 2 mps, low repeatability</span>  CMD_MEAS_PERI_4_H   = <span class="hljs-number">0x2334</span>, <span class="hljs-comment">// measurement: periodic 4 mps, high repeatability</span><span class="hljs-comment">//  CMD_MEAS_PERI_4_M   = 0x2322, // measurement: periodic 4 mps, medium repeatability</span>  CMD_MEAS_PERI_4_L   = <span class="hljs-number">0x2329</span>, <span class="hljs-comment">// measurement: periodic 4 mps, low repeatability</span>  CMD_MEAS_PERI_10_H  = <span class="hljs-number">0x2737</span>, <span class="hljs-comment">// measurement: periodic 10 mps, high repeatability</span><span class="hljs-comment">//  CMD_MEAS_PERI_10_M  = 0x2721, // measurement: periodic 10 mps, medium repeatability</span>  CMD_MEAS_PERI_10_L  = <span class="hljs-number">0x272A</span>, <span class="hljs-comment">// measurement: periodic 10 mps, low repeatability</span>  CMD_FETCH_DATA      = <span class="hljs-number">0xE000</span>, <span class="hljs-comment">// readout measurements for periodic mode</span>  CMD_R_AL_LIM_LS     = <span class="hljs-number">0xE102</span>, <span class="hljs-comment">// read alert limits, low set</span>  CMD_R_AL_LIM_LC     = <span class="hljs-number">0xE109</span>, <span class="hljs-comment">// read alert limits, low clear</span>  CMD_R_AL_LIM_HS     = <span class="hljs-number">0xE11F</span>, <span class="hljs-comment">// read alert limits, high set</span>  CMD_R_AL_LIM_HC     = <span class="hljs-number">0xE114</span>, <span class="hljs-comment">// read alert limits, high clear</span>  CMD_W_AL_LIM_HS     = <span class="hljs-number">0x611D</span>, <span class="hljs-comment">// write alert limits, high set</span>  CMD_W_AL_LIM_HC     = <span class="hljs-number">0x6116</span>, <span class="hljs-comment">// write alert limits, high clear</span>  CMD_W_AL_LIM_LC     = <span class="hljs-number">0x610B</span>, <span class="hljs-comment">// write alert limits, low clear</span>  CMD_W_AL_LIM_LS     = <span class="hljs-number">0x6100</span>, <span class="hljs-comment">// write alert limits, low set</span>  CMD_NO_SLEEP        = <span class="hljs-number">0x303E</span>,&#125;etCommands;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sht3x_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> etError <span class="hljs-title function_">sht3x_rd_serial_num</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>* serialNumber)</span>; <span class="hljs-keyword">extern</span> etError <span class="hljs-title function_">sht3x_single_polling</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd, <span class="hljs-type">uint8_t</span> timeout)</span>;<span class="hljs-keyword">extern</span> etError <span class="hljs-title function_">sht3x_single_clkStretch</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd, <span class="hljs-type">uint8_t</span> timeout)</span>;<span class="hljs-keyword">extern</span> etError <span class="hljs-title function_">sht3x_periodic_mode</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ************************************************</span><span class="hljs-comment">  * @filesht31.c</span><span class="hljs-comment">  * @authorKayoung</span><span class="hljs-comment">  * @versionV1.0.0</span><span class="hljs-comment">  * @date2023.04.30</span><span class="hljs-comment">  * @briefsht3x温湿度传感器驱动函数</span><span class="hljs-comment">  ************************************************</span><span class="hljs-comment">  */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sht31.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;intrins.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">Delay1ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j;_nop_();i = <span class="hljs-number">11</span>;j = <span class="hljs-number">190</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief向sht3x传感器写指令</span><span class="hljs-comment">  * @paramcommand：指令</span><span class="hljs-comment">  * @retvalerror（ack：0 or nack：1）</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> ack_e <span class="hljs-title function_">sht3x_wr_cmd</span><span class="hljs-params">(etCommands command)</span>&#123;  ack_e error; <span class="hljs-comment">// ack or nack</span>  error  = i2c_wr_byte(command &gt;&gt; <span class="hljs-number">8</span>); <span class="hljs-comment">//upper 8 bits</span>  error |= i2c_wr_byte(command &amp; <span class="hljs-number">0xFF</span>); <span class="hljs-comment">//lower 8 bits</span>  <span class="hljs-keyword">return</span> error;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefsht3x初始化</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">sht3x_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;i2c_init();<span class="hljs-comment">//I2C初始化</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief读取sht3x序列号</span><span class="hljs-comment">  * @paramserialNumber: sht3x序列号指针</span><span class="hljs-comment">  * @retvalerror</span><span class="hljs-comment">  */</span>etError <span class="hljs-title function_">sht3x_rd_serial_num</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>* serialNumber)</span>&#123;etError error = NO_ERROR;           <span class="hljs-comment">// error code</span><span class="hljs-type">uint8_t</span> serialNumWords[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;      <span class="hljs-comment">//serial number raw value and checksum value</span>  <span class="hljs-type">uint8_t</span> i;i2c_start();  error = i2c_wr_byte(SHT3XWriteHeader);<span class="hljs-keyword">if</span>(error == NO_ERROR)  error = sht3x_wr_cmd(CMD_READ_SERIALNBR); <span class="hljs-comment">// write &quot;read serial number&quot; command</span>Delay1ms();<span class="hljs-keyword">if</span>(error == NO_ERROR)&#123;i2c_start();error = i2c_wr_byte(SHT3XReadHeader);&#125;<span class="hljs-comment">/* read temperature and humidity raw values */</span>  <span class="hljs-keyword">if</span>(error == NO_ERROR)  &#123;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123; i2c_rd_byte(&amp;serialNumWords[i], ACK);&#125;    i2c_rd_byte(&amp;serialNumWords[i], NACK);<span class="hljs-comment">//i = 5</span><span class="hljs-comment">//serialNumWords[6] = &#x27;\0&#x27;;</span>i2c_stop();<span class="hljs-keyword">if</span>(serialNumWords[<span class="hljs-number">2</span>] != crc8_calc(serialNumWords,<span class="hljs-number">2</span>))     error = CHECKSUM_ERROR;  <span class="hljs-keyword">if</span>(serialNumWords[<span class="hljs-number">5</span>] != crc8_calc(&amp;serialNumWords[<span class="hljs-number">3</span>],<span class="hljs-number">2</span>)) error = CHECKSUM_ERROR;  &#125;  <span class="hljs-comment">/* calc serial number as 32-bit integer */</span>  <span class="hljs-keyword">if</span>(error == NO_ERROR)  &#123;<span class="hljs-comment">/* print serialNumber */</span><span class="hljs-comment">//printf(&quot;serialNumber: 0x%02x%02x\r\n&quot;, serialNumWords[0], serialNumWords[1], serialNumWords[3], serialNumWords[4]);</span>*serialNumber = serialNumWords[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span> | serialNumWords[<span class="hljs-number">1</span>];*serialNumber &lt;&lt;= <span class="hljs-number">16</span>;*serialNumber |= serialNumWords[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span> | serialNumWords[<span class="hljs-number">4</span>];&#125;  <span class="hljs-keyword">return</span> error;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefsht3x单次轮询模式获取温湿度数据</span><span class="hljs-comment">  * @paramtemperature : 温度指针</span><span class="hljs-comment">  * @paramhumidity: 湿度指针</span><span class="hljs-comment">  * @param  cmd：指令</span><span class="hljs-comment">  * @param  timeout：超时（ms）</span><span class="hljs-comment">  * @retvalerror（ack：0 or nack：1）</span><span class="hljs-comment">  */</span>etError <span class="hljs-title function_">sht3x_single_polling</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd, <span class="hljs-type">uint8_t</span> timeout)</span>&#123;    etError error = NO_ERROR;           <span class="hljs-comment">// error code</span>    <span class="hljs-type">uint16_t</span> rawValueTemp, rawValueHumi;    <span class="hljs-comment">// temperature and humidity raw value from sensor</span>    <span class="hljs-type">uint8_t</span> Rdata[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;      <span class="hljs-comment">//temperature and humidity raw value and checksum value</span>    <span class="hljs-type">uint8_t</span> i;    <span class="hljs-comment">/* Start Measurement*/</span>    i2c_start();    error = i2c_wr_byte(SHT3XWriteHeader);    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        error = sht3x_wr_cmd(cmd);    &#125;    i2c_stop();    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        i2c_start();        error = i2c_wr_byte(SHT3XReadHeader);    &#125;    <span class="hljs-keyword">while</span>(timeout--)    &#123;        i2c_stop();        i2c_start();        error = i2c_wr_byte(SHT3XReadHeader);<span class="hljs-comment">// check if the measurement has finished</span>        <span class="hljs-keyword">if</span>(error == NO_ERROR) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// if measurement has finished -&gt; exit loop</span>        Delay1ms();    &#125;    <span class="hljs-keyword">if</span>(timeout == <span class="hljs-number">0</span>) error = TIMEOUT_ERROR;    <span class="hljs-comment">// check for timeout error</span>    <span class="hljs-comment">/* read temperature and humidity raw values */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)        &#123;            i2c_rd_byte(&amp;Rdata[i], ACK);        &#125;        i2c_rd_byte(&amp;Rdata[i], NACK);        i2c_stop();        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">2</span>] != crc8_calc(Rdata,<span class="hljs-number">2</span>))     error = CHECKSUM_ERROR;        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">5</span>] != crc8_calc(&amp;Rdata[<span class="hljs-number">3</span>],<span class="hljs-number">2</span>)) error = CHECKSUM_ERROR;    &#125;    <span class="hljs-comment">/* calculate temperature in  and humidity in %RH */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        rawValueTemp = (Rdata[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">1</span>];        rawValueHumi = (Rdata[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">4</span>];        *temperature = <span class="hljs-number">175.0f</span> * (<span class="hljs-type">float</span>)rawValueTemp / <span class="hljs-number">65535.0f</span> - <span class="hljs-number">45.0f</span>;        *humidity = <span class="hljs-number">100.0f</span> * (<span class="hljs-type">float</span>)rawValueHumi / <span class="hljs-number">65535.0f</span>;    &#125;    <span class="hljs-keyword">return</span> error;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefsht3x单次时钟扩展模式获取温湿度数据</span><span class="hljs-comment">  * @paramtemperature : 温度指针</span><span class="hljs-comment">  * @paramhumidity: 湿度指针</span><span class="hljs-comment">  * @param  cmd：指令</span><span class="hljs-comment">  * @param  timeout：超时（ms）</span><span class="hljs-comment">  * @retvalerror（ack：0 or nack：1）</span><span class="hljs-comment">  */</span>etError <span class="hljs-title function_">sht3x_single_clkStretch</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd, <span class="hljs-type">uint8_t</span> timeout)</span>&#123;    etError error = NO_ERROR;           <span class="hljs-comment">// error code</span>    <span class="hljs-type">uint16_t</span> rawValueTemp, rawValueHumi;    <span class="hljs-comment">// temperature and humidity raw value from sensor</span>    <span class="hljs-type">uint8_t</span> Rdata[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;      <span class="hljs-comment">//temperature and humidity raw value and checksum value</span>    <span class="hljs-type">uint8_t</span> i;    <span class="hljs-comment">/* Start Measurement*/</span>    i2c_start();    error = i2c_wr_byte(SHT3XWriteHeader);    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        error = sht3x_wr_cmd(cmd);    &#125;    i2c_stop();    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        i2c_start();        error = i2c_wr_byte(SHT3XReadHeader);    &#125;    <span class="hljs-keyword">while</span>(timeout--)    &#123;        Delay1ms();    &#125;    <span class="hljs-keyword">if</span>(timeout == <span class="hljs-number">0</span>) error = TIMEOUT_ERROR;    <span class="hljs-comment">// check for timeout error</span>    <span class="hljs-comment">/* read temperature and humidity raw values */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)        &#123;            i2c_rd_byte(&amp;Rdata[i], ACK);        &#125;        i2c_rd_byte(&amp;Rdata[i], NACK);        i2c_stop();        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">2</span>] != crc8_calc(Rdata,<span class="hljs-number">2</span>))     error = CHECKSUM_ERROR;        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">5</span>] != crc8_calc(&amp;Rdata[<span class="hljs-number">3</span>],<span class="hljs-number">2</span>)) error = CHECKSUM_ERROR;    &#125;    <span class="hljs-comment">/* calculate temperature in  and humidity in %RH */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        rawValueTemp = (Rdata[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">1</span>];        rawValueHumi = (Rdata[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">4</span>];        *temperature = <span class="hljs-number">175.0f</span> * (<span class="hljs-type">float</span>)rawValueTemp / <span class="hljs-number">65535.0f</span> - <span class="hljs-number">45.0f</span>;        *humidity = <span class="hljs-number">100.0f</span> * (<span class="hljs-type">float</span>)rawValueHumi / <span class="hljs-number">65535.0f</span>;    &#125;    <span class="hljs-keyword">return</span> error;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefsht3x 周期性获取温湿度数据</span><span class="hljs-comment">  * @paramtemperature : 温度指针</span><span class="hljs-comment">  * @paramhumidity: 湿度指针</span><span class="hljs-comment">  * @param  cmd：指令</span><span class="hljs-comment">  * @retvalerror（ack：0 or nack：1）</span><span class="hljs-comment">  */</span>etError <span class="hljs-title function_">sht3x_periodic_mode</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd)</span>&#123;    etError error = NO_ERROR;           <span class="hljs-comment">// error code</span>    <span class="hljs-type">uint16_t</span> rawValueTemp, rawValueHumi;    <span class="hljs-comment">// temperature and humidity raw value from sensor</span>    <span class="hljs-type">uint8_t</span> Rdata[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;      <span class="hljs-comment">//temperature and humidity raw value and checksum value</span>    <span class="hljs-type">uint8_t</span> i;    <span class="hljs-comment">/* start measurement */</span>    i2c_start();    error  = i2c_wr_byte(SHT3XWriteHeader);    <span class="hljs-keyword">if</span>(error == NO_ERROR) error = sht3x_wr_cmd(cmd);    <span class="hljs-comment">/* Readout of Measurement Results */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        i2c_start();        error  = i2c_wr_byte(SHT3XWriteHeader);    &#125;    <span class="hljs-keyword">if</span>(error == NO_ERROR) error = sht3x_wr_cmd(CMD_FETCH_DATA);    <span class="hljs-keyword">if</span>(error == NO_ERROR)     &#123;        i2c_start();        error = i2c_wr_byte(SHT3XReadHeader);    &#125;    <span class="hljs-comment">/* read temperature and humidity raw values */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)        &#123;            i2c_rd_byte(&amp;Rdata[i], ACK);        &#125;        i2c_rd_byte(&amp;Rdata[i], NACK);        i2c_stop();        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">2</span>] != crc8_calc(Rdata,<span class="hljs-number">2</span>))     error = CHECKSUM_ERROR;        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">5</span>] != crc8_calc(&amp;Rdata[<span class="hljs-number">3</span>],<span class="hljs-number">2</span>)) error = CHECKSUM_ERROR;    &#125;    <span class="hljs-comment">/* calculate temperature in  and humidity in %RH */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        rawValueTemp = (Rdata[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">1</span>];        rawValueHumi = (Rdata[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">4</span>];        *temperature = <span class="hljs-number">175.0f</span> * (<span class="hljs-type">float</span>)rawValueTemp / <span class="hljs-number">65535.0f</span> - <span class="hljs-number">45.0f</span>;        *humidity = <span class="hljs-number">100.0f</span> * (<span class="hljs-type">float</span>)rawValueHumi / <span class="hljs-number">65535.0f</span>;    &#125;    <span class="hljs-keyword">return</span> error;&#125;</code></pre></div><p>main.c</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sht31.h&quot;</span></span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> serialNumber;<span class="hljs-type">float</span> temperature = <span class="hljs-number">0.0f</span>, humidity = <span class="hljs-number">0.0f</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">Delay500ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">22</span>;j = <span class="hljs-number">3</span>;k = <span class="hljs-number">227</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;uart1_init();sht3x_init();<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">/* get the serial number */</span>sht3x_rd_serial_num(&amp;serialNumber); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;serial number: %#lx\r\n&quot;</span>, serialNumber);sht3x_periodic_mode(&amp;temperature, &amp;humidity, CMD_MEAS_PERI_1_H); <span class="hljs-comment">//周期性获取温湿度</span><span class="hljs-comment">//sht3x_single_polling(&amp;temperature, &amp;humidity, CMD_MEAS_POLLING_L, 50); //单次轮询模式获取温湿度</span><span class="hljs-comment">//sht3x_single_clkStretch(&amp;temperature, &amp;humidity, CMD_MEAS_CLOCKSTR_H, 50);//单次时钟扩展模式获取温湿度</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;temperature = %.3f℃ humidity = %.3f%%\r\n&quot;</span>, temperature, humidity);Delay500ms();&#125;&#125;</code></pre></div><p>串口输出：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230507195015130.png" alt="image-20230507195015130" style="zoom: 80%;" /></p><p>工程代码Gitee ：<ahref="https://gitee.com/kayoungzhang/my_codehub.git">sht3x</a></p><h3 id="参考链接">参考链接</h3><p><ahref="https://sensirion.com/media/documents/213E6A3B/63A5A569/Datasheet_SHT3x_DIS.pdf">DatasheetSHT3x-DIS</a></p><p>https://sensirion.com/resource/software/code/sht3x</p><p><ahref="https://blog.csdn.net/weixin_45607920/article/details/109526396">SHT3X温湿度模块 C51驱动 ——简单调用获取温湿度信息</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>温湿度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>温度传感器DS18B20的应用</title>
    <link href="/2023/04/28/%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8DS18B20%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/28/%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8DS18B20%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>DS18B20温度传感器在日常应用中，使用比较广泛，以下简单介绍一下：</p><h3 id="特点">特点：</h3><ul><li>单总线传输（1-Wire interface）</li><li>供电范围： 3.0V ~ 5.5V</li><li>测量温度范围：-55°C ~ +125°C</li><li>精度：-10°C ~ +85°C（±0.5°C）</li><li>分辨率： 9 ~ 12 bits</li><li>每一个 DS1820 有唯一的系列号，因此多个 DS1820可以存在于同一条单线总线上。</li></ul><h3 id="存储器图">存储器图</h3><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230428152810011.png"alt="image-20230428152810011" /><figcaption aria-hidden="true">image-20230428152810011</figcaption></figure><h3 id="单总线接口访问ds1820的协议">单总线接口访问DS1820的协议</h3><p>1.初始化 2.进行ROM功能操作 3.进行RAM功能操作 4.传输数据</p><h3 id="rom功能指令">ROM功能指令</h3><table><thead><tr class="header"><th>ROM指令</th><th>功能</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>Read ROM [33h]</td><td>读取DS18B20内部信息</td><td>总线存在多个DS18B20无法使用此命令</td></tr><tr class="even"><td>Match ROM [55h]</td><td>根据64位ROM信息匹配对应的DS18B20</td><td></td></tr><tr class="odd"><td>Skip ROM [CCh]</td><td>跳过DS18B20</td><td>总线上只有一个DS18B20</td></tr><tr class="even"><td>Search ROM [F0h]</td><td>搜索DS18B20</td><td></td></tr><tr class="odd"><td>Alarm Search [ECh]</td><td>搜索DS18B20</td><td>上一次碰到警报才搜索DS18B20</td></tr></tbody></table><h3 id="ram功能指令">RAM功能指令</h3><table><thead><tr class="header"><th>RAM命令</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>Write Scratchpad [4Eh]</td><td>向暂存存储器写内容</td></tr><tr class="even"><td>Read Scratchpad [BEh]</td><td>读暂存存储器的内容</td></tr><tr class="odd"><td>Copy Scratchpad [48h]</td><td>复制暂存存储器内容到非易失存储器 <strong>E2 RAM</strong></td></tr><tr class="even"><td>Convert T [44h]</td><td>转换温度</td></tr><tr class="odd"><td>Recall E2 [B8h]</td><td>重新调出 <strong>E2 RAM</strong> 存储到暂存存储器</td></tr><tr class="even"><td>Read Power Supply [B4h]</td><td>读供电方式</td></tr></tbody></table><h3 id="初始化时序">初始化时序</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230428144010335.png" alt="image-20230428144010335" style="zoom: 67%;" /></p><h3 id="写时序">写时序</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230428144206875.png" alt="image-20230428144206875" style="zoom: 67%;" /></p><h3 id="读时序">读时序</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230428144418569.png" alt="image-20230428144418569" style="zoom:67%;" /></p><h3 id="程序实现">程序实现</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DEV_DS18B20_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DS18B20_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stc15.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> DQ P37   <span class="hljs-comment">//ds18b20接口定义</span></span><span class="hljs-comment">/******* ROM function command ****************/</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>READ_ROM(0x33)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>MATCH_ROM(0x55)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>SKIP_ROM(0xCC)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>SEARCH_ROM(0xF0)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ALARM_SEARCH(0XEC)</span><span class="hljs-comment">/******* RAM function command ****************/</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>WRITE_SCRATCHPAD(0x4E)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>READ_SCRATCHPAD(0xBE)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>COPY_SCRATCHPAD(0x48) <span class="hljs-comment">//把暂存器RAM中的数据复制到EEPROM中</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span>CONVERT_T(0x44)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>RECALL_EE(0xB8) <span class="hljs-comment">//把EEPROM中的数据恢复到RAM中</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span>READ_POWER(0xB4)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_LIMIT(0x78)<span class="hljs-comment">//120℃</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TL_LIMIT(0x05)<span class="hljs-comment">//5℃</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> RESOLUTION_9(0x1F)<span class="hljs-comment">//Thermometer Resolution Configuration</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> RESOLUTION_10(0x3F)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> RESOLUTION_11(0x5F)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> RESOLUTION_12(0x7F)</span><span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ds18b20_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds18b20_convert_temp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">float</span> <span class="hljs-title function_">ds18b20_get_temp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ************************************************</span><span class="hljs-comment">  * @filedev_ds18b20.c</span><span class="hljs-comment">  * @authorKayoung</span><span class="hljs-comment">  * @versionV1.0</span><span class="hljs-comment">  * @date20220324</span><span class="hljs-comment">  * @briefds18b20测温度</span><span class="hljs-comment">  **********************************************</span><span class="hljs-comment">  */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dev_ds18b20.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;intrins.h&gt;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief检测温度传感器是否正常</span><span class="hljs-comment">  * @paramNone </span><span class="hljs-comment">  * @retval1:失败 0：成功</span><span class="hljs-comment">*/</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ds18b20_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//延时循环变量</span><span class="hljs-type">uint8_t</span> ack;<span class="hljs-comment">//存储检测设备是否成功标志</span>DQ = <span class="hljs-number">1</span>;DQ = <span class="hljs-number">0</span>;i = <span class="hljs-number">227</span>;<span class="hljs-comment">//将总线拉低480us~960us，这里延时500us</span><span class="hljs-keyword">while</span> (--i);DQ = <span class="hljs-number">1</span>;<span class="hljs-comment">//然后拉高总线，延时70us</span>i = <span class="hljs-number">29</span>;<span class="hljs-keyword">while</span> (--i);ack = DQ; <span class="hljs-comment">//读取总线电平</span>i = <span class="hljs-number">227</span>;<span class="hljs-comment">//延时500us</span><span class="hljs-keyword">while</span>(i--);<span class="hljs-keyword">return</span> ack;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefds18b20发送一个位</span><span class="hljs-comment">  * @paramsendbit：待发送的位</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ds18b20_sendbit</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> sendbit)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//延时时间循环变量</span>DQ = <span class="hljs-number">0</span>; <span class="hljs-comment">//主机拉低延时10us</span>i = <span class="hljs-number">2</span>;<span class="hljs-keyword">while</span> (--i); DQ = sendbit; <span class="hljs-comment">//发送位，延时50us</span>i = <span class="hljs-number">20</span>;<span class="hljs-keyword">while</span> (--i); DQ = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放总线</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefds18b20接收到一位</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalBit: 从总线上接收到的一位</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ds18b20_recvbit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-type">uint8_t</span> Bit; <span class="hljs-comment">//存储接收到的一位</span>DQ = <span class="hljs-number">0</span>; <span class="hljs-comment">//主机拉低，延时8us</span>i = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (--i);DQ = <span class="hljs-number">1</span>; <span class="hljs-comment">//主机释放总线，延时8us</span>i = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (--i);Bit = DQ; <span class="hljs-comment">//读取总线数据，延时50us</span>i = <span class="hljs-number">20</span>;<span class="hljs-keyword">while</span> (--i);<span class="hljs-keyword">return</span> Bit;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief向温度传感器写一个字节</span><span class="hljs-comment">  * @paramwr_data：待写入的数据</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">*/</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds18b20_wr_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> wr_data)</span>&#123;<span class="hljs-type">uint8_t</span> j;<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)   <span class="hljs-comment">//From LSB to MSB</span>&#123;ds18b20_sendbit(wr_data &amp; (<span class="hljs-number">0x01</span> &lt;&lt; j));&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief读取温度传感器一个字节</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalrecv_byte：读取的一个字节</span><span class="hljs-comment">*/</span><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ds18b20_rd_byte</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> recv_byte = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储接收到的数据</span><span class="hljs-type">uint8_t</span> j;<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<span class="hljs-comment">//from LSB to MSB</span>&#123;<span class="hljs-keyword">if</span>(ds18b20_recvbit())&#123;recv_byte |= (<span class="hljs-number">0x01</span> &lt;&lt; j);&#125;&#125;<span class="hljs-keyword">return</span> recv_byte;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief转换温度</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ds18b20_convert_temp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;ds18b20_init();ds18b20_wr_byte(SKIP_ROM);  <span class="hljs-comment">//跳过ROM</span>ds18b20_wr_byte(CONVERT_T); <span class="hljs-comment">//转换命令</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief获取正负温度</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalftemp：温度值</span><span class="hljs-comment">  */</span><span class="hljs-type">float</span> <span class="hljs-title function_">ds18b20_get_temp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> TLSB, TMSB;<span class="hljs-comment">//存储温度的两个字节</span><span class="hljs-type">int</span> temp; <span class="hljs-comment">//存储温度的整形</span><span class="hljs-type">float</span> ftemp; <span class="hljs-comment">//温度</span>ds18b20_init();ds18b20_wr_byte(SKIP_ROM);ds18b20_wr_byte(READ_SCRATCHPAD);TLSB = ds18b20_rd_byte();TMSB = ds18b20_rd_byte();temp = (TMSB &lt;&lt; <span class="hljs-number">8</span>) | TLSB; ftemp = temp * <span class="hljs-number">0.0625</span>; <span class="hljs-comment">//分辨率是0.0625</span><span class="hljs-keyword">return</span> ftemp;<span class="hljs-comment">//负数是以其补码形式存储的，所以此函数可以表示负温度</span>&#125;</code></pre></div><p>注意事项：</p><p>单总线传输过程中，有严格的延时时序要求，对于不同的MCU，延时时间会跟此程序不一致，需要根据其时序图进行相应的调整。此程序已上传Gitee：<ahref="https://gitee.com/kayoungzhang/my_codehub.git">ds18b20</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>温度传感器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传感器的三种常用算法处理</title>
    <link href="/2023/04/27/%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%84%E7%90%86/"/>
    <url>/2023/04/27/%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<ul><li>加权平滑：平滑和均衡传感器数据，减小偶然数据突变的影响。</li><li>抽取突变：去除静态和缓慢变化的数据背景，强调瞬间变化。</li><li>简单移动平均线：保留数据流最近的K个数据，取平均值。</li></ul><hr /><p><strong>加权平滑</strong>，使用算法如下：</p><p>新值 = 旧值<em>(1 - a) + X </em>a；其中a为设置的权值，X为最新数据，程序实现如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> filter_coe 0.00001  <span class="hljs-comment">//滤波系数 小于1</span></span><span class="hljs-type">static</span> <span class="hljs-type">long</span> AD_Res_Last=<span class="hljs-number">0</span>;<span class="hljs-comment">//上一轮的ADC数值保存</span><span class="hljs-type">long</span> <span class="hljs-title function_">Read_18Bit_AD</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">float</span> out,c;out = AD_Res_Last;c = Read_CS1237();<span class="hljs-keyword">if</span>(c!=<span class="hljs-number">0</span>) <span class="hljs-comment">// 读到正确数据</span>&#123;out = out*filter_coe + c*(<span class="hljs-number">1</span>-filter_coe);AD_Res_Last = out;<span class="hljs-comment">//把这次的计算结果放到全局变量里面保护</span>&#125;<span class="hljs-keyword">return</span> AD_Res_Last;&#125;</code></pre></div><p><strong>抽取突变</strong>采用上面加权平滑的逆算法<strong>，</strong>实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">onSensorChanged</span><span class="hljs-params">(SensorEvent event)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-type">float</span> ALPHA = <span class="hljs-number">0.8</span>;    gravity[<span class="hljs-number">0</span>] = ALPHA * gravity[<span class="hljs-number">0</span>] + (<span class="hljs-number">1</span>-ALPHA) * event.values[<span class="hljs-number">0</span>];    gravity[<span class="hljs-number">1</span>] = ALPHA * gravity[<span class="hljs-number">1</span>] + (<span class="hljs-number">1</span>-ALPHA) * event.values[<span class="hljs-number">1</span>];    gravity[<span class="hljs-number">2</span>] = ALPHA * gravity[<span class="hljs-number">2</span>] + (<span class="hljs-number">1</span>-ALPHA) * event.values[<span class="hljs-number">2</span>];    filteredValues[<span class="hljs-number">0</span>] = event.values[<span class="hljs-number">0</span>] - gravity[<span class="hljs-number">0</span>];    filteredValues[<span class="hljs-number">1</span>] = event.values[<span class="hljs-number">1</span>] - gravity[<span class="hljs-number">1</span>];    filteredValues[<span class="hljs-number">2</span>] = event.values[<span class="hljs-number">2</span>] - gravity[<span class="hljs-number">2</span>];&#125;</code></pre></div><p><strong>简单移动平均线，</strong>保留传感器数据流中最近的K个数据，返回它们的平均值。k表示平均“窗口”的大小，实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 12</span><span class="hljs-type">char</span> <span class="hljs-title function_">filter</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> count;    <span class="hljs-keyword">for</span>(count = <span class="hljs-number">0</span>; count &lt; N; count++)    &#123;        sum += get_ad();        delay();&#125;<span class="hljs-keyword">return</span> (<span class="hljs-type">char</span>)(sum/N);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sensor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STC芯片内部EEPROM的程序设计</title>
    <link href="/2023/04/27/STC%E8%8A%AF%E7%89%87%E5%86%85%E9%83%A8EEPROM%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/04/27/STC%E8%8A%AF%E7%89%87%E5%86%85%E9%83%A8EEPROM%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>STC单片机内部集成了的EEPROM是与程序空间是分开的，利用ISP/IAP技术可将内部DataFlash当EEPROM，擦写次数在10万次以上。以下根据datasheet简单介绍一下单片机内部EEPROM的编程方式。</p><h3id="iap及eeprom特殊功能寄存器介绍">IAP及EEPROM特殊功能寄存器介绍</h3><ul><li>ISP/IAP数据寄存器IAP_DATA</li><li>ISP/IAP地址寄存器IAP_ADDRH和IAP_ADDRL</li><li>ISP/IAP命令寄存器IAP_CMD</li><li>ISP/IAP命令触发寄存器IAP_TRIG</li><li>ISP/IAP控制寄存器IAP_CONTR</li></ul><h3 id="注意事项">注意事项</h3><p>1.<strong>写数据</strong>：如果该字节不是0xFF，则须先将整个扇区擦除，因为只有扇区擦除才可以将<strong>0</strong> 变为 <strong>1</strong> 。</p><p>2.<strong>扇区擦除</strong>：将扇区内各字节变为 <strong>0xFF</strong>。</p><p>3.同一次修改的数据放在同一扇区中，不是同一次修改的数据放在另外的扇区。</p><p>4.IAP指令完成后，地址不会自动增减，需要手动处理。</p><h3 id="eeprom程序实现">EEPROM程序实现</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span>IAP_EEPROM__H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stc15.h&quot;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">uint16_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">uint32_t</span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> TOTAL_ITEM (20) <span class="hljs-comment">//存储数据的数量</span></span><span class="hljs-comment">/** STC12C5A60S2</span><span class="hljs-comment">  *eeprom 扇区地址</span><span class="hljs-comment">  * 0x0000 ~ 0x3fff</span><span class="hljs-comment">  */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_ADDR_SECTOR_00x0000  <span class="hljs-comment">//第一扇区基地址</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_ADDR_SECTOR_10x0200  <span class="hljs-comment">//第二扇区基地址</span></span><span class="hljs-comment">/* IAP_CMD register */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_CMD_STANDBY0x00  <span class="hljs-comment">//待机模式</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_CMD_BYTE_RD0x01  <span class="hljs-comment">//字节读</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_CMD_BYTE_WR0x02  <span class="hljs-comment">//字节写</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_CMD_SECTOR_ERASE0x03  <span class="hljs-comment">//扇区擦除</span></span><span class="hljs-comment">/* IAP_TRIG register */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TRIG_FIRST0x5a</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TRIG_SECOND0xa5</span><span class="hljs-comment">/* IAP_CONTR register */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_EN0x80<span class="hljs-comment">//IAP使能</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_ISP0x60<span class="hljs-comment">//复位后从系统ISP监控程序区启动</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_1M0x07<span class="hljs-comment">//设置系统时钟小于或等于1MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_2M0x06<span class="hljs-comment">//设置系统时钟小于或等于2MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_3M0x05<span class="hljs-comment">//设置系统时钟小于或等于3MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_6M0x04<span class="hljs-comment">//设置系统时钟小于或等于6MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_12M0x03<span class="hljs-comment">//设置系统时钟小于或等于12MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_20M0x02<span class="hljs-comment">//设置系统时钟小于或等于20MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_24M0x01<span class="hljs-comment">//设置系统时钟小于或等于24MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_30M0x00<span class="hljs-comment">//设置系统时钟小于或等于30MHZ</span></span><span class="hljs-keyword">extern</span> <span class="hljs-type">uint16_t</span> eeprom_save[TOTAL_ITEM];<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iap_erase</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iap_rd_byte</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* dat)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iap_wr_byte</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr,<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* dat)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iap_rd_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iap_wr_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  * @file    eeprom.c </span><span class="hljs-comment">  * @version V1.0.0</span><span class="hljs-comment">  * @date    2023.03.16</span><span class="hljs-comment">  * @author  Kayoung</span><span class="hljs-comment">  * @brief   IAP EEPROM 相关功能</span><span class="hljs-comment">  * @details  </span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  * @attention </span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;eeprom.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;intrins.h&quot;</span></span><span class="hljs-comment">/* 定义一个存储数据数组 */</span><span class="hljs-type">uint16_t</span> eeprom_save[TOTAL_ITEM] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//注意：每个数据两字节</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  关闭IAP功能</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;IAP_CONTR = <span class="hljs-number">0</span>;IAP_CMD = <span class="hljs-number">0</span>;IAP_TRIG = <span class="hljs-number">0</span>;IAP_ADDRH = <span class="hljs-number">0xff</span>;IAP_ADDRL = <span class="hljs-number">0xff</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  擦除某地址所在的扇区</span><span class="hljs-comment">  * @param  addr：待擦除扇区地址</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_erase</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span>&#123;IAP_CONTR = IAP_EN | IAP_TIMEOUT_12M;<span class="hljs-comment">//允许IAP操作，设置IAP操作速度         </span>IAP_CMD = IAP_CMD_SECTOR_ERASE;<span class="hljs-comment">//扇区擦除命令            </span>IAP_ADDRL = addr;              IAP_ADDRH = addr &gt;&gt; <span class="hljs-number">8</span>;<span class="hljs-comment">//地址赋值          </span>IAP_TRIG = IAP_TRIG_FIRST;                IAP_TRIG = IAP_TRIG_SECOND;<span class="hljs-comment">//触发命令               </span>_nop_();_nop_();         iap_disable();<span class="hljs-comment">//清空IAP操作寄存器等</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  在某地址写入一个字节</span><span class="hljs-comment">  * @param  addr: 地址</span><span class="hljs-comment">  * @paramdat： 待写入的一字节数据指针</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_wr_byte</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr,<span class="hljs-type">uint8_t</span>* dat)</span>&#123;IAP_CONTR = IAP_EN | IAP_TIMEOUT_12M;<span class="hljs-comment">//允许IAP操作，设置IAP操作速度   </span>IAP_CMD = IAP_CMD_BYTE_WR;<span class="hljs-comment">//IAP写命令</span>IAP_ADDRL = addr;IAP_ADDRH = addr &gt;&gt; <span class="hljs-number">8</span>;<span class="hljs-comment">//地址赋值</span>IAP_DATA = *dat;<span class="hljs-comment">//更新写寄存器</span>IAP_TRIG = IAP_TRIG_FIRST;IAP_TRIG = IAP_TRIG_SECOND;<span class="hljs-comment">//触发</span>_nop_();iap_disable();<span class="hljs-comment">//清空IAP操作寄存器等</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  读取某地址一个字节</span><span class="hljs-comment">  * @param  addr: 地址</span><span class="hljs-comment">  * @param  dat： 待读取的一字节数据指针</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_rd_byte</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint8_t</span>* dat)</span>&#123;IAP_CONTR = IAP_EN | IAP_TIMEOUT_12M;<span class="hljs-comment">//允许IAP</span>IAP_CMD = IAP_CMD_BYTE_RD;<span class="hljs-comment">//IAP读命令</span>IAP_ADDRL = addr;IAP_ADDRH = addr &gt;&gt; <span class="hljs-number">8</span>;<span class="hljs-comment">//地址赋值</span>IAP_TRIG = IAP_TRIG_FIRST;IAP_TRIG = IAP_TRIG_SECOND;<span class="hljs-comment">//触发</span>_nop_();_nop_();*dat = IAP_DATA;iap_disable();<span class="hljs-comment">//清空IAP操作寄存器等</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  读取eeprom存储的参数</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_rd_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> tmp_h = <span class="hljs-number">0</span>, tmp_l = <span class="hljs-number">0</span>; <span class="hljs-comment">//临时变量</span><span class="hljs-type">uint8_t</span> i;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; TOTAL_ITEM; i++)&#123;iap_rd_byte(IAP_ADDR_SECTOR_0 + <span class="hljs-number">2</span>*i, &amp;tmp_l);iap_rd_byte(IAP_ADDR_SECTOR_0 + <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>, &amp;tmp_h);eeprom_save[i] = tmp_h &lt;&lt; <span class="hljs-number">8</span> | tmp_l; <span class="hljs-comment">//EEPROM中每两个字节组成一个数据</span>&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  存储数据到eeprom</span><span class="hljs-comment">  * @param  void</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_wr_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> tmp_h = <span class="hljs-number">0</span>, tmp_l = <span class="hljs-number">0</span>; <span class="hljs-comment">//临时变量</span><span class="hljs-type">uint8_t</span> i;<span class="hljs-comment">/* 保存之前，擦除当前需要保存数据的扇区 */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; TOTAL_ITEM; i++)&#123;<span class="hljs-keyword">if</span>(eeprom_save[i] != <span class="hljs-number">0xffff</span>)&#123;iap_erase(IAP_ADDR_SECTOR_0);<span class="hljs-comment">//擦除eeprom 1st sector</span><span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">/* 存储数据到eeprom */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; TOTAL_ITEM; i++)&#123;        <span class="hljs-comment">/* 擦除完EEPROM，每个字节数据都是0xff*/</span><span class="hljs-keyword">if</span>(eeprom_save[i] == <span class="hljs-number">0xffff</span>)eeprom_save[i] = <span class="hljs-number">0</span>;tmp_h = eeprom_save[i] / <span class="hljs-number">256</span>;tmp_l = eeprom_save[i] % <span class="hljs-number">256</span>;iap_wr_byte(IAP_ADDR_SECTOR_0 + <span class="hljs-number">2</span>*i, &amp;tmp_l);iap_wr_byte(IAP_ADDR_SECTOR_0 + <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>, &amp;tmp_h);&#125;&#125;</code></pre></div><p>程序附件 <ahref="https://gitee.com/kayoungzhang/my_codehub.git">iap_eeprom</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于LCD1602的程序开发</title>
    <link href="/2023/04/26/%E5%85%B3%E4%BA%8ELCD1602%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <url>/2023/04/26/%E5%85%B3%E4%BA%8ELCD1602%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>LCD1602字符型显示屏在单片机程序开发中作为显示输出的器件，因为简单，成本低，被大量应用。在我们平时开发调试过程中，除了串口printf可以输出信息外，其实，LCD1602一样可以作为调试工具，用来输出一些重要信息。下面详细介绍一下它的程序设计。</p><h3 id="lcd1602引脚信号">1. LCD1602引脚信号</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426170209080.png" alt="image-20230426170209080" style="zoom: 67%;" /></p><h3 id="基本操作时序">2. 基本操作时序</h3><ul><li>读状态：RS = L，RW = H， E = H</li><li>写指令：RS = L，RW = L， D0~D7 = 指令码， E = 下降沿</li><li>读数据：RS = H，RW = H， E = H</li><li>写数据：RS = H，RW = L， D0~D7 = 数据， E = 下降沿</li></ul><p>（H：高电平，L：低电平）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426172246464.png" alt="image-20230426172246464" style="zoom: 67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426172326018.png" alt="image-20230426172326018" style="zoom:67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426172355403.png" alt="image-20230426172355403" style="zoom:67%;" /></p><h3 id="内部地址ram映射表">3. 内部地址RAM映射表</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426171931946.png" alt="image-20230426171931946"  /></p><h3 id="lcd1602指令码">4. LCD1602指令码</h3><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426184139175.png"alt="image-20230426184139175" /><figcaption aria-hidden="true">image-20230426184139175</figcaption></figure><h3 id="程序实现">5.程序实现</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LCD1602_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1602_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC15.H&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  <span class="hljs-type">uint32_t</span>;<span class="hljs-comment">/* 引脚定义 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1602_RSP26</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1602_ENP27</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1602_WRP25</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1602_DATAP0</span><span class="hljs-comment">/* LCD1602指令码 */</span><span class="hljs-comment">/* 1. Clear Display */</span>  <span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_CLEAR0x01</span><span class="hljs-comment">/* 2. Return Home */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  CURSOR_RETURN0x02</span><span class="hljs-comment">/* 3. Entry Mode Set */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  AC_INCREMENT0x06</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  AC_DECREMENT       0x04</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_SHIFT_ON    0x05</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_SHIFT_OFF    0x04</span><span class="hljs-comment">/* 4. Display On/Off Control */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_ON0x0c</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  CURSOR_ON    0x0a</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  CURSOR_BLINK0x09</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISP_OFF0x08</span><span class="hljs-comment">/* 5. Cursor or Display Shift */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  CURSOR_SHIFT_LEFT   0x10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  CURSOR_SHIFT_RIGHT 0x14</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_SHIFT_LEFT 0x18</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_SHIFT_RIGHT 0x1c</span><span class="hljs-comment">/* 6. Function Set */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DATA_LENGTH_4   0x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DATA_LENGTH_8   0x30</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_ONE_LINE 0x20  </span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_TWO_LINE 0x28</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DOT_FONT_5X8    0x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DOT_FONT_5X10   0x24</span><span class="hljs-comment">/* 数据地址AC */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA_ADDR_ROW_ONE  0x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA_ADDR_ROW_TWO  0xc0</span><span class="hljs-comment">/* 函数声明 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showchar</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint8_t</span> wr_char)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showstring</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint8_t</span>* p_wr_string)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_shownum</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_show_signednum</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">int</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showhex</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showbin</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_dip_shift</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_clear</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ************************************************</span><span class="hljs-comment">  * @file    lcd1602.c</span><span class="hljs-comment">  * @authorKayoung</span><span class="hljs-comment">  * @versionV1.0</span><span class="hljs-comment">  * @date20220326</span><span class="hljs-comment">  * @briefLCD1602显示驱动</span><span class="hljs-comment">  **********************************************</span><span class="hljs-comment">  */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lcd1602.h&quot;</span></span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">delay1ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j;i = <span class="hljs-number">2</span>;j = <span class="hljs-number">199</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">delay300ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">13</span>;j = <span class="hljs-number">156</span>;k = <span class="hljs-number">83</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brieflcd1602写命令</span><span class="hljs-comment">  * @paramcommand：命令</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_wr_com</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> command)</span>&#123;LCD1602_RS = <span class="hljs-number">0</span>;LCD1602_WR = <span class="hljs-number">0</span>;LCD1602_DATA = command;LCD1602_EN = <span class="hljs-number">1</span>;delay1ms();<span class="hljs-comment">//根据timing，延时1ms，确保命令写到命令端口上</span>LCD1602_EN = <span class="hljs-number">0</span>;delay1ms();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brieflcd1602写数据</span><span class="hljs-comment">  * @paramwr_data: 待写入的数据</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_wr_data</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> wr_data)</span>&#123;LCD1602_RS = <span class="hljs-number">1</span>;LCD1602_WR = <span class="hljs-number">0</span>;LCD1602_DATA = wr_data;LCD1602_EN = <span class="hljs-number">1</span>;delay1ms();LCD1602_EN = <span class="hljs-number">0</span>;delay1ms();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brieflcd1602初始化</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;lcd1602_wr_com(DATA_LENGTH_8 | DISP_TWO_LINE); <span class="hljs-comment">//16x2显示模式，5x7点阵，8位数据接口</span>lcd1602_wr_com(DISP_ON); <span class="hljs-comment">//开显示，不显示光标</span>lcd1602_wr_com(AC_INCREMENT); <span class="hljs-comment">//写一个字符后，AC加1</span>lcd1602_wr_com(DISP_CLEAR); <span class="hljs-comment">//显示清零</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief确定光标位置</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_set_cursor</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column)</span>&#123;<span class="hljs-comment">/* 确定位置 */</span><span class="hljs-keyword">if</span>(row == <span class="hljs-number">1</span>)&#123;lcd1602_wr_com(DATA_ADDR_ROW_ONE | (column - <span class="hljs-number">1</span>)); &#125;<span class="hljs-keyword">else</span>&#123;lcd1602_wr_com(DATA_ADDR_ROW_TWO | (column - <span class="hljs-number">1</span>));&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示一个字符</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  wr_char：待写入的字符</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showchar</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint8_t</span> wr_char)</span>&#123;lcd1602_set_cursor(row, column);<span class="hljs-comment">/* 写入数据 */</span>lcd1602_wr_data(wr_char);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示字符串</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  p_wr_string：待写入的字符串指针</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showstring</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint8_t</span>* p_wr_string)</span>&#123;lcd1602_set_cursor(row, column);<span class="hljs-keyword">while</span>((*p_wr_string) != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;lcd1602_wr_data(*p_wr_string++);&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief指数函数</span><span class="hljs-comment">  * @parambase: 底数</span><span class="hljs-comment">  * @paramindex：幂指数</span><span class="hljs-comment">  * @retvalresult：结果</span><span class="hljs-comment">  */</span><span class="hljs-type">int</span> <span class="hljs-title function_">lcd_pow</span><span class="hljs-params">(base, index)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-comment">//循环变量</span><span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; index; i++)&#123;result *= base;&#125;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示一个数字</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  num：待写入的数(0~65535)</span><span class="hljs-comment">  * @param  num_length: 数的位数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_shownum</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//循环变量</span>lcd1602_set_cursor(row, column);<span class="hljs-comment">/* 显示各位数字字符 */</span><span class="hljs-keyword">for</span>(i = num_length; i &gt; <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-comment">/* 根据规律，每次循环，得出其中的一位 */</span>lcd1602_wr_data((num / lcd_pow(<span class="hljs-number">10</span>, (i<span class="hljs-number">-1</span>)) % <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//转换成数字字符</span>&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示一个带符号数字</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  num：待写入的数</span><span class="hljs-comment">  * @param  num_length: 数的位数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_show_signednum</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">int</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//循环变量</span><span class="hljs-type">uint32_t</span> num_temp;<span class="hljs-comment">//无符号临时变量，存储有符号数字</span>lcd1602_set_cursor(row, column);<span class="hljs-comment">/* 判断是否是带符号数字 */</span><span class="hljs-keyword">if</span>(num &gt;= <span class="hljs-number">0</span>)&#123;lcd1602_wr_data(<span class="hljs-string">&#x27;+&#x27;</span>);num_temp = num;&#125;<span class="hljs-keyword">else</span>&#123;lcd1602_wr_data(<span class="hljs-string">&#x27;-&#x27;</span>);num_temp = -num;&#125;<span class="hljs-comment">/* 显示各位数字字符 */</span><span class="hljs-keyword">for</span>(i = num_length; i &gt; <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-comment">/* 根据规律，每次循环，得出其中的一位 */</span>lcd1602_wr_data((num_temp / lcd_pow(<span class="hljs-number">10</span>, (i<span class="hljs-number">-1</span>)) % <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//转换成数字字符</span>&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示十六进制数</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  num：待写入的数</span><span class="hljs-comment">  * @param  num_length: 数的位数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showhex</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-comment">//循环变量</span><span class="hljs-type">uint8_t</span> single_num; <span class="hljs-comment">//存储单个位数</span>lcd1602_set_cursor(row, column);<span class="hljs-comment">/* 显示各位数字字符 */</span><span class="hljs-keyword">for</span>(i = num_length; i &gt; <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-comment">/* 根据规律，每次循环，得出其中的一位 */</span>single_num = num / lcd_pow(<span class="hljs-number">16</span>, (i<span class="hljs-number">-1</span>)) % <span class="hljs-number">16</span>;<span class="hljs-keyword">if</span>(single_num &lt; <span class="hljs-number">10</span>)<span class="hljs-comment">//0~9</span>&#123;lcd1602_wr_data(single_num + <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//转换成数字字符</span>&#125;<span class="hljs-keyword">else</span>  <span class="hljs-comment">//A~F</span>&#123;lcd1602_wr_data(single_num + <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">10</span>); <span class="hljs-comment">//转换成数字字符</span>&#125;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示一个数的二进制</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  num：待写入的数(0~65535)</span><span class="hljs-comment">  * @param  num_length: 数的位数（8或16）</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showbin</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//循环变量</span>lcd1602_set_cursor(row, column);<span class="hljs-comment">/* 显示各位数字字符 */</span><span class="hljs-keyword">for</span>(i = num_length; i &gt; <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-comment">/* 根据规律，每次循环，得出其中的一位 */</span>lcd1602_wr_data((num / lcd_pow(<span class="hljs-number">2</span>, (i<span class="hljs-number">-1</span>)) % <span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//转换成数字字符</span>&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief lcd1602屏幕移动</span><span class="hljs-comment">  * @param None</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_dip_shift</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;lcd1602_wr_com(DISP_SHIFT_LEFT);delay300ms();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brieflcd1602清屏</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_clear</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;lcd1602_wr_com(DISP_CLEAR);&#125;</code></pre></div><p>在 main函数中，根据需要调用这些接口函数，即可完成相应的功能。</p><p>代码已上传码云： <ahref="https://gitee.com/kayoungzhang/my_codehub.git">lcd1602</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora数学公式格式编辑汇总</title>
    <link href="/2023/04/24/Typora%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%A0%BC%E5%BC%8F%E7%BC%96%E8%BE%91%E6%B1%87%E6%80%BB/"/>
    <url>/2023/04/24/Typora%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%A0%BC%E5%BC%8F%E7%BC%96%E8%BE%91%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>在Typora编辑中，会经常使用到数学公式，以下总结常用的公式编辑语法。</p><h4 id="常用符号">常用符号</h4><table><thead><tr class="header"><th>类型及语法</th><th>显示</th><th>类型及语法</th><th>显示</th></tr></thead><tbody><tr class="odd"><td>上标 a^2</td><td><span class="math inline">\(a^2\)</span></td><td>下标 A_2</td><td><span class="math inline">\(A_2\)</span></td></tr><tr class="even"><td>正负号 2 \pm 3</td><td><span class="math inline">\(2 \pm 3\)</span></td><td>分式 \frac{1}{2}</td><td><span class="math inline">\(\frac{1}{2}\)</span></td></tr><tr class="odd"><td>根号 \sqrt[6]{2}</td><td><span class="math inline">\(\sqrt[6]{2}\)</span></td><td>水平线 \overline{a+b}=\underline{b+c}</td><td><spanclass="math inline">\(\overline{a+b}=\underline{b+c}\)</span></td></tr><tr class="even"><td>对数 \log_28</td><td><span class="math inline">\(log_28\)</span></td><td>矢量 \vec{a}</td><td><span class="math inline">\(\vec{a}\)</span></td></tr><tr class="odd"><td>上方箭头 \overleftarrow{x}</td><td><span class="math inline">\(\overleftarrow{x}\)</span></td><td>三角函数 \sin{\theta}</td><td><span class="math inline">\(\sin{\theta}\)</span></td></tr><tr class="even"><td>并集 A \bigcup B</td><td><span class="math inline">\(A \bigcup B\)</span></td><td>交集 A \bigcap B</td><td><span class="math inline">\(A \bigcap B\)</span></td></tr><tr class="odd"><td>属于 A \in B</td><td><span class="math inline">\(A \in B\)</span></td><td>异或 A \oplus B</td><td><span class="math inline">\(A \oplus B\)</span></td></tr><tr class="even"><td>同或 A \odot B</td><td><span class="math inline">\(A \odot B\)</span></td><td>存在 \exists</td><td><span class="math inline">\(\exists\)</span></td></tr><tr class="odd"><td>任意 \forall</td><td><span class="math inline">\(\forall\)</span></td><td>分隔符 \vert-2 \vert</td><td><span class="math inline">\(\vert-2 \vert\)</span></td></tr><tr class="even"><td>单空格 A \ B</td><td><span class="math inline">\(A \ B\)</span></td><td>Tab空格 A \quad B</td><td><span class="math inline">\(A \quad B\)</span></td></tr><tr class="odd"><td>多空格 A \qquad B</td><td><span class="math inline">\(A \qquad B\)</span></td><td>换行 A <code>\\</code> B</td><td>A<br />B</td></tr><tr class="even"><td>不定积分 \int{x}dx</td><td><span class="math inline">\(\int{x}dx\)</span></td><td>不等号 2 \neq 3</td><td><span class="math inline">\(2 \neq 3\)</span></td></tr><tr class="odd"><td>小于或等于 3 \leq 6</td><td><span class="math inline">\(3 \leq 6\)</span></td><td>大于或等于 8 \geq 3</td><td><span class="math inline">\(8 \geq 3\)</span></td></tr><tr class="even"><td>约等于 2.1 \approx 2</td><td><span class="math inline">\(2.1 \approx 2\)</span></td><td>水平双向箭头 \Longleftrightarrow</td><td><span class="math inline">\(\Longleftrightarrow\)</span></td></tr><tr class="odd"><td>水平单箭头 \longrightarrow</td><td><span class="math inline">\(\longrightarrow\)</span></td><td>水平双箭头 \Longleftarrow</td><td><span class="math inline">\(\Longleftarrow\)</span></td></tr><tr class="even"><td>箭头带字 A \xrightarrow{加热} B</td><td><span class="math inline">\(A \xrightarrow{加热} B\)</span></td><td>大号的括号 \left( \right)</td><td>$( ) $</td></tr><tr class="odd"><td>角度 \angle</td><td><span class="math inline">\(\angle\)</span></td><td>因为符 \because</td><td><span class="math inline">\(\because\)</span></td></tr><tr class="even"><td>所以符 \therefore</td><td><span class="math inline">\(\therefore\)</span></td><td>垂直符 \bot</td><td><span class="math inline">\(\bot\)</span></td></tr><tr class="odd"><td>字体大小\large A \small A</td><td><span class="math inline">\(\large A \small A\)</span></td><td>转义符 \ \</td><td>\</td></tr></tbody></table><p><strong>注意：如果上下标级联，需要{}括起来</strong></p><h4 id="希腊字母">希腊字母</h4><table><thead><tr class="header"><th>大写</th><th>Typora语法</th><th>小写</th><th>Typora语法</th><th>大写</th><th>Typora语法</th><th>小写</th><th>Typora语法</th></tr></thead><tbody><tr class="odd"><td>A</td><td>A</td><td>α</td><td>\alpha</td><td>Ω</td><td>\Omega</td><td>ω</td><td>\omega</td></tr><tr class="even"><td>B</td><td>B</td><td>β</td><td>\beta</td><td>Ψ</td><td>\Psi</td><td>ψ</td><td>\psi</td></tr><tr class="odd"><td>Γ</td><td>\Gamma</td><td>γ</td><td>\gamma</td><td>X</td><td>X</td><td>χ</td><td>\chi</td></tr><tr class="even"><td>Δ</td><td>\Delta</td><td>δ</td><td>\delta</td><td>φ</td><td>\varphi</td><td></td><td></td></tr><tr class="odd"><td>E</td><td>E</td><td>ϵ</td><td>\epsilon</td><td>Φ</td><td>\Phi</td><td>ϕ</td><td>\phi</td></tr><tr class="even"><td>ε</td><td>\varepsilon</td><td></td><td></td><td>Υ</td><td>\Upsilon</td><td>υ</td><td>\upsilon</td></tr><tr class="odd"><td>Z</td><td>Z</td><td>ζ</td><td>\zeta</td><td>T</td><td>T</td><td>τ</td><td>\tau</td></tr><tr class="even"><td>H</td><td>H</td><td>η</td><td>\eta</td><td>Σ</td><td>\Sigma</td><td>σ</td><td>\sigma</td></tr><tr class="odd"><td>Θ</td><td>\Theta</td><td>θ</td><td>\theta</td><td>P</td><td>P</td><td>ρ</td><td>\rho</td></tr><tr class="even"><td>I</td><td>I</td><td>ι</td><td>\iota</td><td>Π</td><td>\Pi</td><td>π</td><td>\pi</td></tr><tr class="odd"><td>K</td><td>K</td><td>κ</td><td>\kappa</td><td>O</td><td>O</td><td>ο</td><td>\omicron</td></tr><tr class="even"><td>Λ</td><td>\Lambda</td><td>λ</td><td>\lambda</td><td>Ξ</td><td>\Xi</td><td>ξ</td><td>\xi</td></tr><tr class="odd"><td>M</td><td>M</td><td>μ</td><td>\mu</td><td>N</td><td>N</td><td>ν</td><td>\nu</td></tr></tbody></table><h4 id="复杂表达式">复杂表达式</h4><p><strong>求和</strong> \sum_{n=1}^{100} {a_n}<br /><span class="math display">\[\sum_{n=1}^{100} {a_n}\]</span> <strong>累乘</strong> \prod_{n=1}^{199} {x_n} <spanclass="math display">\[\prod_{n=1}^{199} {x_n}\]</span> <strong>定积分</strong> \int_{1}^{2}xdx<br /><span class="math display">\[\int_{1}^{2}xdx\]</span> <strong>极限</strong> \lim_{n\rightarrow + \infty}{(a+b)}<br /><span class="math display">\[\lim_{n\rightarrow + \infty}{(a+b)}\]</span></p><p><strong>矩阵</strong></p><div class="code-wrapper"><pre><code class="hljs livescript">a = <span class="hljs-string">\left[\matrix&#123;\alpha_1</span> &amp; test1<span class="hljs-string">\\</span> <span class="hljs-string">\alpha_2</span> &amp; test2<span class="hljs-string">\\</span> <span class="hljs-string">\alpha_3</span> &amp; test3 &#125;<span class="hljs-string">\right]</span></code></pre></div><p><span class="math display">\[a = \left[\matrix{\alpha_1 &amp; test1\\ \alpha_2 &amp; test2\\ \alpha_3&amp; test3 }\right]\]</span> <strong>行列式</strong></p><div class="code-wrapper"><pre><code class="hljs livescript">X=<span class="hljs-string">\left|</span><span class="hljs-string">\begin&#123;matrix&#125;</span>x_&#123;<span class="hljs-number">11</span>&#125; &amp; x_&#123;<span class="hljs-number">12</span>&#125; &amp; <span class="hljs-string">\cdots</span> &amp; x_&#123;<span class="hljs-number">1d</span>&#125;<span class="hljs-string">\\</span>x_&#123;<span class="hljs-number">21</span>&#125; &amp; x_&#123;<span class="hljs-number">22</span>&#125; &amp; <span class="hljs-string">\cdots</span> &amp; x_&#123;<span class="hljs-number">2d</span>&#125;<span class="hljs-string">\\</span><span class="hljs-string">\vdots</span> &amp; <span class="hljs-string">\vdots</span> &amp; <span class="hljs-string">\ddots</span> &amp; <span class="hljs-string">\vdots</span> <span class="hljs-string">\\</span>x_&#123;<span class="hljs-number">11</span>&#125; &amp; x_&#123;<span class="hljs-number">12</span>&#125; &amp; <span class="hljs-string">\cdots</span> &amp; x_&#123;<span class="hljs-number">1d</span>&#125;<span class="hljs-string">\\</span><span class="hljs-string">\end&#123;matrix&#125;</span><span class="hljs-string">\right|</span> <span class="hljs-string">\tag&#123;2-3&#125;</span></code></pre></div><p><span class="math display">\[X=\left|    \begin{matrix}        x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\\        x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d}\\        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\        x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\\    \end{matrix}\right| \tag{2-3}\]</span> <strong>分段函数</strong></p><div class="code-wrapper"><pre><code class="hljs excel">f(<span class="hljs-built_in">n</span>)=\begin&#123;cases&#125;<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>, &amp; \text&#123;<span class="hljs-built_in">if</span> $<span class="hljs-built_in">n</span>$ is <span class="hljs-built_in">even</span>&#125;\\<span class="hljs-number">3</span><span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>,&amp; \text&#123;<span class="hljs-built_in">if</span> $<span class="hljs-built_in">n</span>$ is <span class="hljs-built_in">odd</span>&#125;\end&#123;cases&#125;</code></pre></div><p><span class="math display">\[f(n)=    \begin{cases}        n/2, &amp; \text{if $n$ is even}\\        3n+1,&amp; \text{if $n$ is odd}    \end{cases}\]</span> <strong>方程组</strong></p><div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-string">\left\&#123;</span><span class="hljs-string">\begin&#123;array&#125;&#123;c&#125;</span>a_1x+b_1y+c_1z=d_1<span class="hljs-string">\\</span>a_2x+b_2y+c_2z=d_2<span class="hljs-string">\\</span>a_3x+b_3y+c_3z=d_3<span class="hljs-string">\end&#123;array&#125;</span><span class="hljs-string">\right.</span> <span class="hljs-string">\tag&#123;1-1&#125;</span></code></pre></div><p><span class="math display">\[\left\{    \begin{array}{c}        a_1x+b_1y+c_1z=d_1\\        a_2x+b_2y+c_2z=d_2\\        a_3x+b_3y+c_3z=d_3    \end{array}\right. \tag{1-1}\]</span> 其它复杂的数学公式可直接在线编辑。</p><h4 id="在线编辑器">在线编辑器</h4><p><a href="https://www.latexlive.com/home">LaTeX公式编辑器</a></p><p><a href="http://www.hostmath.com/">The Equation Editor</a></p><h4 id="参考链接">参考链接</h4><p><ahref="https://blog.csdn.net/alwaysrun/article/details/115830269">Typora使用简介与插入数学公式</a></p><p><ahref="https://zhuanlan.zhihu.com/p/261750408">Typora数学公式汇总（Markdown）</a></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PID理论及程序实现</title>
    <link href="/2023/04/24/PID%E7%90%86%E8%AE%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/04/24/PID%E7%90%86%E8%AE%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="pid控制的概念">PID控制的概念</h3><hr /><p>PID 控制的整体框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230424111806125.png" alt="image-20230424111806125" style="zoom:80%;" /></p><p>PID是 <strong>P</strong>roportion <strong>I</strong>ntegration<strong>D</strong>ifferentiation 的缩写，由<strong>比例项（Proportion）</strong>，<strong>积分项（Integration）</strong>，<strong>微分项（Differentiation）</strong>三个部分组成，具体形式就是下面的公式： <span class="math display">\[U(t) = Kp \{ err(t) + \frac{1}{Ti}*\int_0^t err(t)dt +Td*\frac{derr(t)}{dt} \}\]</span> 其中： <strong>U(t)</strong>是调节器的输出信号，<strong>err(t)</strong> 是当前值和目标值的偏差，<strong>Kp</strong> 是比例增益， <strong>Ti</strong> 是积分时间，<strong>Td</strong> 是微分时间。</p><p>PID控制其实就是对偏差的控制过程；如果偏差为 0,则比例环节不起作用，只有存在偏差时，比例环节才起作用；积分环节主要是用来消除静差，所谓静差，就是系统稳定后输出值和设定值之间的差值，积分环节实际上就是偏差累计的过程，把累计的误差加到原有系统上以抵消系统造成的静差；而微分信号则反应了偏差信号的变化规律，也可以说是变化趋势，根据偏差信号的变化趋势来进行超前调节，从而增加了系统的预知性。</p><p><strong>比例项</strong>：某时刻误差值,代表着现在,表明现在预设值与实际的偏差。<strong>积分项</strong>：所有时刻误差和,代表着过去，是过去Ti时间内的偏差积累，可以减少震荡。<strong>微分项</strong>：某时刻误差变化率,代表着未来，可以超前预测并提出控制。</p><h3 id="pid的离散化公式">PID的离散化公式</h3><hr /><p>在数字系统中进行PID算法控制，需要对上述公式进行离散化，然后才好进行程序设计，从而得到：<span class="math display">\[U(k) = Kp*e(k) + \frac{Kp*T}{Ti}\sum_{n=0}^k e(n)+\frac{Kp*Td}{T}(e(k)-e(k-1))\]</span> 其中：<strong>e(k)</strong> 是当前值和目标值的偏差，<strong>Kp</strong> 是比例增益， <strong>T</strong>是控制周期，<strong>Ti</strong> 是积分时间， <strong>Td</strong>是微分时间。</p><p>为了方便起见，将这些系数进行统一: <span class="math display">\[比例系数Kp= Kp;\ 积分系数Ki = \frac{Kp*T}{Ti};\ 微分系数Kd =\frac{Kp*Td}{T}\]</span> 则得到 <strong>位置式PID</strong> 公式： <spanclass="math display">\[U(k) = Kp*e(k) + Ki\sum_{n=0}^k e(n)+ Kd*(e(k)-e(k-1))\]</span> 因为 <code>△U(k) = U(k) - U(k-1)</code>，这样得到<strong>增量式PID</strong> 公式： <span class="math display">\[△U(k) = Kp*(e(k)-e(k-1)) + Ki*e(k) + Kd*(e(k)-2*e(k-1)+e(k-2))\]</span></p><p><span class="math display">\[U(k) = △U(k)+U(k-1)\]</span></p><h3 id="pid算法的c语言实现">PID算法的C语言实现</h3><hr /><p>经过pid算法后得到的输出值，进行处理加工送到执行结构进行系统控制。在温度控制场景中，对于制冷控制，只需要将pid的输出值进行反向处理即可。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 位置式pid和增量式pid的选择 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> POSITION_PID</span><span class="hljs-comment">//#define INCREMENT_PID</span><span class="hljs-comment">/* pid 参数结构体定义 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">float</span> target;  <span class="hljs-comment">//target value 目标值</span><span class="hljs-type">float</span> curr;    <span class="hljs-comment">//current value 当前值</span><span class="hljs-type">float</span> err;     <span class="hljs-comment">//err=tag-cur 偏差值</span><span class="hljs-type">float</span> sum_err; <span class="hljs-comment">//偏差积分和</span><span class="hljs-type">float</span> last_err; <span class="hljs-comment">//上一个偏差值</span><span class="hljs-type">float</span> prev_last_err; <span class="hljs-comment">//上上个偏差值</span><span class="hljs-type">float</span> kp; <span class="hljs-comment">//proportion</span><span class="hljs-type">float</span> ki; <span class="hljs-comment">//integral</span><span class="hljs-type">float</span> kd; <span class="hljs-comment">//differential</span><span class="hljs-type">float</span> limit_integral; <span class="hljs-comment">//积分限幅</span><span class="hljs-type">float</span> limit_output; <span class="hljs-comment">//输出限幅</span><span class="hljs-type">float</span> output;<span class="hljs-comment">//控制输出值</span>&#125;<span class="hljs-type">pid_t</span>;<span class="hljs-comment">/* 限幅处理的宏定义 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIMIT_MAX(value, max) \</span><span class="hljs-meta">    &#123;                        \</span><span class="hljs-meta"><span class="hljs-keyword">if</span> (value &gt; max)       \</span><span class="hljs-meta">value = max;       \</span><span class="hljs-meta"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; -max) \</span><span class="hljs-meta">value = -max;      \</span><span class="hljs-meta">    &#125;</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  pid初始化</span><span class="hljs-comment">  * @param  pid：pid结构体指针</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">pid_init</span><span class="hljs-params">(<span class="hljs-type">pid_t</span>* pid)</span>&#123;pid-&gt;target = <span class="hljs-number">0</span>;pid-&gt;curr = <span class="hljs-number">0</span>;pid-&gt;kp = <span class="hljs-number">2.3</span>;pid-&gt;ki = <span class="hljs-number">0.5</span>;pid-&gt;kd = <span class="hljs-number">5.6</span>;pid-&gt;err = <span class="hljs-number">0</span>;pid-&gt;last_err = <span class="hljs-number">0</span>;pid-&gt;prev_last_err = <span class="hljs-number">0</span>;pid-&gt;sum_err = <span class="hljs-number">0</span>;pid-&gt;output = <span class="hljs-number">0</span>;pid-&gt;limit_integral = <span class="hljs-number">255</span>;<span class="hljs-comment">//根据pwm输出范围进行设置</span>pid-&gt;limit_output = <span class="hljs-number">255</span>; <span class="hljs-comment">//根据pwm输出范围进行设置</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  pid的运算</span><span class="hljs-comment">  * @param  pid：pid指针</span><span class="hljs-comment">  * @paramcurrent_value：当前值</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">pid_calc</span><span class="hljs-params">(<span class="hljs-type">pid_t</span>* pid, <span class="hljs-type">float</span> current_value)</span>&#123;<span class="hljs-type">float</span> increment = <span class="hljs-number">0</span>;pid-&gt;curr = current_value;pid-&gt;err = pid-&gt;target - pid-&gt;curr;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> POSITION_PID</span><span class="hljs-comment">/* 位置式公式：u(t)=Kp*E(t)+Ki*[E(1)+...+E(t)]+Kd*[E(t)-E(t-1)] */</span>pid-&gt;sum_err += pid-&gt;err;LIMIT_MAX(pid-&gt;sum_err, pid-&gt;limit_integral);<span class="hljs-comment">//积分限幅</span>pid-&gt;output = pid-&gt;kp * pid-&gt;err + pid-&gt;ki * pid-&gt;sum_err + \pid-&gt;kd * (pid-&gt;err - pid-&gt;last_err);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> INCREMENT_PID</span><span class="hljs-comment">/* 增量式公式：△u(t)=Kp*[E(t)-E(t-1)]+Ki*E(t)+Kd*[E(t)-2*E(t-1)+E(t-2)] */</span>increment = pid-&gt;kp * (pid-&gt;err - pid-&gt;last_err) + pid-&gt;ki * pid-&gt;err + \pid-&gt;kd * (pid-&gt;err - <span class="hljs-number">2</span> * pid-&gt;last_err + pid-&gt;prev_last_err);pid-&gt;output += increment;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>LIMIT_MAX(pid-&gt;output, pid-&gt;limit_output);<span class="hljs-comment">//输出限幅</span>pid-&gt;last_err = pid-&gt;err;pid-&gt;prev_last_err = pid-&gt;last_err;<span class="hljs-keyword">return</span> pid-&gt;output;&#125;</code></pre></div><h3 id="pid调试">PID调试</h3><hr /><p>借助<ahref="https://serialplot.ozderya.net/downloads/serialplot-0.12.0-win32.exe">SerialPlot工具</a>使用printf函数将目标值和实时值图形显示处理，调节不同的Kp，Ki和Kd，可以很方便的进行调试。</p><h4 id="位置式pid调节">位置式PID调节</h4><p>位置型PID的参数整定过程一般是，先整定KP，然后整定KI，最后整定KD；</p><p>参数整定找最佳，从小到大顺序查 先是比例后积分，最后再把微分加曲线振荡很频繁，比例度盘要放大(Kp减小)曲线漂浮绕大湾，比例度盘往小扳(Kp增大)曲线偏离回复慢，积分时间往下降(Ki增大)曲线波动周期长，积分时间再加长(Ki减小)曲线振荡频率快，先把微分降下来(Kd增大)动差大来波动慢。微分时间应加长(Kd减小) 理想曲线两个波，前高后低4比1一看二调多分析，调节质量不会低</p><h4 id="增量式pid调节">增量式pid调节</h4><p>增量型PID应该先整定Ki，然后整定Kd，最后整定Kp。这一点需要特别注意，弄错顺序的话会发现整定规律完全不适用的。<strong>网上大多数资料把增量式跟位置式混为一谈</strong></p><h3 id="参考链接">参考链接</h3><p><ahref="https://blog.csdn.net/qq_25352981/article/details/81007075?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168231970816800192213769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168231970816800192213769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-81007075-null-null.142%5Ev86%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=pid&amp;spm=1018.2226.3001.4187">一文读懂PID控制算法（抛弃公式，从原理上真正理解PID控制）</a></p><p><ahref="https://blog.csdn.net/skythinker616/article/details/123019829?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168231970816800192213769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168231970816800192213769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123019829-null-null.142%5Ev86%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=pid&amp;spm=1018.2226.3001.4187">PID超详细教程——PID原理+串级PID+C代码+在线仿真调参</a></p><p><ahref="https://blog.csdn.net/qq_45396672/article/details/118057838?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168231970816800192213769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168231970816800192213769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-8-118057838-null-null.142%5Ev86%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=pid&amp;spm=1018.2226.3001.4187">图文详解PID调参</a></p><p><ahref="https://blog.csdn.net/u010312937/article/details/53363831">PID控制算法的C语言实现</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PID参数的自整定</title>
    <link href="/2023/04/24/PID%E5%8F%82%E6%95%B0%E7%9A%84%E8%87%AA%E6%95%B4%E5%AE%9A/"/>
    <url>/2023/04/24/PID%E5%8F%82%E6%95%B0%E7%9A%84%E8%87%AA%E6%95%B4%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>在某些PID应用场合，不同的对象就得采用不同的参数值，所以需要进行参数自整定。实质就是在首次使用时，通过N次测量得到一套PID参数。具体的整定方法有三种：临界比例度法、衰减曲线法、经验法。三种方法共同点都是通过试验，然后按照工程经验公式对控制器参数进行整定。现在一般采用比较多的是临界比例度法。</p><h4id="临界比例度法ziegler-nichols">1、临界比例度法（Ziegler-Nichols）</h4><h5 id="操作方法">1.1 操作方法</h5><p>（1）将纯比例控制器接入到闭环控制系统中（设置控制器参数积分时间常数Ti=∞，实际微分时间常数Td=0）。</p><p>（2）由小到大改变比例增益K，直到闭环系统出现持续等幅振荡。此时的增益为临界增益（Ku），振荡周期（波峰间的时间）为临界周期（Tu）。然后根据下表得出PID控制器参数。</p><table><thead><tr class="header"><th>调节规律</th><th>K</th><th>Ti</th><th>Td</th></tr></thead><tbody><tr class="odd"><td><strong>P</strong></td><td>0.5Ku</td><td>-</td><td>-</td></tr><tr class="even"><td><strong>PI</strong></td><td>0.45Ku</td><td>0.85Tu</td><td>-</td></tr><tr class="odd"><td><strong>PD</strong></td><td>0.65Ku</td><td>-</td><td>0.15Tu</td></tr><tr class="even"><td><strong>PID</strong></td><td>0.6Ku</td><td>0.5Tu</td><td>0.125Tu</td></tr></tbody></table><h5 id="计算pid的三个参数值">1.2 计算PID的三个参数值：</h5><p><strong>Kp = K；</strong></p><p>**Ki = Kp*(T/Ti)；**</p><p>**Kd = Kp*(Td/T)；**</p><p>其中： <strong>T</strong>是采样周期，也叫控制周期，每隔T时间段进行一次PID计算。</p><h5 id="注意事项">1.3 注意事项：</h5><p>（1）应使控制系统工作在线性区，不要使控制阀出现开、关的极端状态，否则得到的持续振荡曲线可能是“极限循环”，从线性系统概念上说系统早已处于发散振荡了。</p><p>（2）由于被控对象特性的不同，应针对具体系统在实际运行过程中对上述求得的控制器参数进行在线校正。</p><p>（3）适用于临界振幅不大、振荡周期较长的过程控制系统，但有些系统用纯比例控制时始终是稳定的，是无法用临界比例度法来进行参数整定的。</p><p>（4）只适用于二阶以上的高阶对象，或一阶加纯滞后的对象，否则，在纯比例控制情况下，系统不会出现等幅振荡。</p><h4 id="衰减曲线法">2、衰减曲线法</h4><h5 id="整定步骤">2.1 整定步骤</h5><p>（1）在纯比例控制器下，置比例增益K为较小值。系统稳定后，作设定值阶跃扰动，观察系统的响应。若系统响应衰减太快，则减小比例增益K；反之，应增大比例增益K。</p><p>（2）直到系统出现如下图（a）所示的4:1衰减振荡过程，记下此时的比例增益Ks及和振荡周期Ts数值。同理，10：1衰减曲线如下图（b）所示。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/v2-68670d44361ce32e7d24f695bd61c62c_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（3）利用Ks和Ts值，Tr值，按下表给出的经验公式，计算出控制器的参数整定值。</p><table><thead><tr class="header"><th>衰减率</th><th>调节规律</th><th>K</th><th>Ti</th><th>Td</th></tr></thead><tbody><tr class="odd"><td><strong>0.75（0.9）</strong></td><td><strong>P</strong></td><td>Ks</td><td>-</td><td>-</td></tr><tr class="even"><td><strong>0.75（0.9）</strong></td><td><strong>PI</strong></td><td>0.83Ks</td><td>0.5Ts（2Tr）</td><td>-</td></tr><tr class="odd"><td><strong>0.75（0.9）</strong></td><td><strong>PID</strong></td><td>1.25Ks</td><td>0.3TS（1.2Tr）</td><td>0.1Ts（0.4Tr</td></tr></tbody></table><h5 id="注意事项-1">2.2 注意事项</h5><p>（1）加给定干扰不能太大，要根据生产操作要求来定，一般在5%左右，也有例外的情况。</p><p>（2）必须在工艺参数稳定的情况下才能加给定干扰，否则得不到正确的整定参数。</p><p>（3）对于反应快的系统，如流量、管道压力和小容量的液位调节等，要得到严格的4：1衰减曲线较困难，一般以被调参数来回波动两次达到稳定，就近似地认为达到4：1衰减过程了。</p><p>（4）投运时，先将K放在较小的数值，把Ti减少到整定值，把Td逐步放大到整定值，然后把K拉到整定值（如果在K=整定值的条件下很快地把Td放到整定值，控制器的输出会剧烈变化）。</p><h4 id="经验整定法">3、经验整定法</h4><h5 id="方法一">3.1方法一</h5><p>（1）确定比例增益</p><p>使PID为纯比例调节,输入设定为系统允许最大值的60%~70%，由0逐渐加大比例增益至系统出现振荡；再逐渐减小比例增益至系统振荡消失，记录此时的比例增益，则设定PID的比例增益P为当前值的60%~70%。</p><p>（2）确定积分时间常数Ti</p><p>比例增益P确定后，设定一个较大的积分时间常数Ti的初值，逐渐减小Ti至系统出现振荡，之后逐渐加大Ti至振荡消失。记录此时的Ti，则设定PID的积分时间常数Ti为当前值的150%~180%。</p><p>（3）确定积分时间常数Td</p><p>积分时间常数Td一般不用设定，为0即可。若要设定，与确定P和Ti的方法相同，取不振荡时的30%。</p><p>（4）系统带载联调，再对PID参数进行微调，直至满足要求。</p><h5 id="方法二">3.2 方法二</h5><p>（1）在实际调试中，也可以先大致设定一个经验值，然后根据调节效果修改。</p><p>　　流量系统：P（%）40~100，Ti（分）0.1~1</p><p>　　压力系统：P（%）30~70， Ti（分）0.4~3</p><p>　　液位系统：P（%）20~80， Ti（分）1~5</p><p>　　温度系统：P（%）20~60， Ti（分）3~10，Td（分）0.5~3</p><p>（2）以下整定的口诀：</p><p>阶跃扰动投闭环，参数整定看曲线；先投比例后积分，最后再把微分加；</p><p>理想曲线两个波，振幅衰减4比1；曲线震荡动作繁，微分时间要加长；</p><p>曲线震荡很频繁，比例刻度要放大；曲线漂浮波动大，比例刻度要拉小；</p><p>曲线波动周期长，积分时间要加长；偏离定值回复慢，积分时间往小降。</p><h3 id="参考链接">参考链接</h3><p><ahref="https://zhuanlan.zhihu.com/p/82344845">详细讲解PID控制</a></p><p><ahref="https://www.cnblogs.com/luckytimor/p/6881569.html">PID公式参数</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stc单片机存储器</title>
    <link href="/2023/04/23/stc%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2023/04/23/stc%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>stc单片机存储器结构的主要特点是 <strong>程序存储器</strong> 和<strong>数据存储器</strong>是各自独立编址的。单片机内部在物理和逻辑上有三个独立的地址空间：flashROM(内部集成EEPROM)，片内基本RAM(256字节)和片内扩展RAM(1024字节)。</p><h3 id="程序存储器flash-rom">程序存储器flash ROM：</h3><p>程序存储器用于存放用户程序、数据和表格等信息。内部集成了的EEPROM是与程序空间是分开的，利用ISP/IAP技术可将内部DataFlash当EEPROM。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423212147712.png" alt="image-20230423212147712" style="zoom:67%;" /></p><h3 id="片内基本ram">片内基本RAM：</h3><p>片内基本RAM分低128字节和高128字节。</p><p>低128字节分为三个区：工作寄存器组区、可位寻址区、通用RAM区。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423212429407.png" alt="image-20230423212429407" style="zoom:80%;" /></p><p>高128字节RAM与特殊功能寄存器区貌似共用相同的地址范围，都使用80H~FFH,地址空间虽然貌似重叠，但物理上是独立的，使用时通过不同的寻址方式加以区分。高128字节RAM只能间接寻址，特殊功能寄存器区只可直接寻址。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423212649092.png" alt="image-20230423212649092" style="zoom: 80%;" /></p><h3 id="片内扩展ram">片内扩展RAM：</h3><p>在C语言中，可使用 <strong>xdata</strong> 声明扩展RAM变量存储类型，如<code>unsigned  char  xdata  i=0;</code>。默认情况下，选择的是片内扩展RAM，当需要访问片外RAM时，EXTRAM必须为1.</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423213425262.png" alt="image-20230423213425262" style="zoom:67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423213920633.png" alt="image-20230423213920633" style="zoom: 80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stc</tag>
      
      <tag>存储器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STC12C5A60S2单片机注意事项</title>
    <link href="/2023/04/23/STC12C5A60S2%E5%8D%95%E7%89%87%E6%9C%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/04/23/STC12C5A60S2%E5%8D%95%E7%89%87%E6%9C%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>STC12C5A60S2单片机是stc12系列一款比较经典的MCU，下面对照它的参考手册，摘录其使用时注意事项：</p><ol type="1"><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423184155244.png" alt="image-20230423184155244" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423184511042.png" alt="image-20230423184511042" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423185326975.png" alt="image-20230423185326975" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423190016475.png" alt="image-20230423190016475" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423190316983.png" alt="image-20230423190316983" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423222004968.png" alt="image-20230423222004968" style="zoom: 80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423193706324.png" alt="image-20230423193706324" style="zoom:80%;" /></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423194010351.png" alt="image-20230423194010351" style="zoom:80%;" /></p><ol start="7" type="1"><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423194201742.png" alt="image-20230423194201742" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423194225873.png" alt="image-20230423194225873" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423222448627.png" alt="image-20230423222448627" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423223648757.png" alt="image-20230423223648757" style="zoom:80%;" /></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423224016123.png" alt="image-20230423224016123" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用命令汇总</title>
    <link href="/2023/04/21/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <url>/2023/04/21/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>Linux开发过程中会经常接触到各种命令，常用的命令它们大致分为：</p><p><strong>文件管理、文档编辑、磁盘管理、系统设备管理、网络通讯、权限管理、其它</strong></p><hr /><p>在详细介绍各种常用命令之前，先了解一下Linux命令行默认显示的部分<code>[root@localhost ~]#</code>：</p><ul><li><p><strong>root</strong>是当前登录的用户</p></li><li><p><strong>localhost</strong>是主机名字</p></li><li><p><strong>~</strong> 表示当前所在的目录(家目录)，<strong>/</strong> 表示根目录</p></li><li><p><strong>#</strong> 是用户标识，表示管理员， <strong>$</strong>表示普通用户</p></li></ul><hr /><h3 id="文件管理命令">文件管理命令：</h3><div class="code-wrapper"><pre><code class="hljs shell">ls       #查看目录ls -a　　 #列出全部的文件,包括以.开头的隐藏文件ls -l 　 #显示文件和目录的详细资料cd     #切换工作目录cd ~   #切换到家目录cd /   #切换到根目录cd ..  #切换到上一级mkdir abc                 # 在当前目录下新建一个名为abc的文件夹mkdir /usr/abc            #在指定目录下创建一个名为abc的文件夹mkdir -p /usr/file/abc    #在指定目录下创建文件夹abc，并创建父文件夹filetouch abc.txt              #在当前目录创建一个文件abc.txttouch /usr/abc.txt         #在指定目录下创建一个文件abc.txtmv 文件  文件夹          # 移动文件到目标文件夹中mv 文件A 文件B          # 修改文件A的名字为文件B，同样适用于目录名修改mv /usr/tmp /opt       #将/usr目录下的tmp目录剪切到 /opt目录下面cp file1 file2         #在当前目录下把file1复制粘贴为file2 cp /usr/tmp /opt       #将/usr目录下的tmp目录复制到 /opt目录下面cp -r /usr/tmp /opt    #递归剪复制目录中所有文件和文件夹rm rm -f file1　　 #强制删除file1文件rm -rf dir　　     #强制删除dir目录及其子目录下所有文件 rmdir dir　     　 #删除dir空目录（只能删除空目录）find / -name file1          #从根目录下查找file1文件find /bin -name &#x27;a*&#x27;        #查找/bin目录下的所有以a开头的文件或者目录find / -user user1          #搜索属于用户 &#x27;user1&#x27; 的文件和目录 ln log2013.log ln2013       #为log2013.log创建硬链接ln2013，log2013.log与ln2013的各项属性相同ln -s log2013.log link2013  #为log2013.log文件创建软链接link2013</code></pre></div><h3 id="文档编辑命令">文档编辑命令</h3><div class="code-wrapper"><pre><code class="hljs shell">vi 文件名        #打开需要编辑的文件，大多数Linux默认安装了vim编辑工具命令模式（command mode）：-按&quot;i&quot;在光标所在字符前开始插入-按&quot;a&quot;在光标所在字符后开始插入-按&quot;o&quot;在光标所在行的下面另起一新行插入-控制光标移动：↑，↓，j-跳到指定行 &quot;:n&quot; -跳到行首 &quot;gg&quot;-使用命令&quot;dd&quot;删除当前整行-使用命令&quot;/字段&quot;进行查找-按&quot;：&quot;进入底行模式插入模式（Insert mode）：-按&quot;ESC&quot;进入底行模式底行模式（last line mode）：-退出编辑：             :q-强制退出并取消本次修改：  :q!-保存并退出：            :wq或:xcat a.txt          #查看文件最后一屏内容less a.txt         #从第一页开始查看文件内容，PgUp向上翻页，PgDn向下翻页，&quot;q&quot;退出查看more a.txt         #显示百分比，回车查看下一行，空格查看下一页，&quot;q&quot;退出查看tail -10 a.txt    #查看文件的后10行，&quot;Ctrl+C&quot;退出查看head -10 a.txt     #查看文件的前10行，&quot;Ctrl+C&quot;退出查看grep abc test.txt #在test.txt文件中搜索abc字符串，大小写敏感且显示行；grep -n abc test.txt #在test.txt文件中搜索abc字符串，大小写敏感且显示行及行号；grep ^abc /var/test.txt  #在文件中查找以&quot;abc&quot;开始的词汇 grep [0-9] /var/test.txt # 在文件中选择所有包含数字的行 grep abc -R /var/log/*   #在目录 &#x27;/var/log&#x27; 及随后的目录中搜索字符串&quot;abc&quot;</code></pre></div><h3 id="磁盘管理命令">磁盘管理命令</h3><div class="code-wrapper"><pre><code class="hljs shell">du   #显示目录或者文件所占空间du -h test   #以K，M，G为单位显示test目录所占空间情况df -h         #显示文件系统的磁盘使用情况pwd   #查看当前所在目录tree dir           #树形显示dir目录下的所有文件mount /dev/hda1 /mnt  #将 /dev/hda1 挂在 /mnt 之下mount -o ro /dev/hda1 /mnt   #将 /dev/hda1 用唯读模式挂在 /mnt 之下 ， -o rw：用可读写模式挂上umount -v /dev/sda1    #通过设备名卸载sda1umount -v /mnt/mymount/  #通过挂载点卸载dd #命令用于读取、转换并输出数据，uboot应用中会使用到，详情查看手册man ddfdisk -l  #显示当前分区情况fdisk -lu #显示SCSI硬盘的每个分区情况</code></pre></div><h3 id="系统设备管理命令">系统设备管理命令</h3><div class="code-wrapper"><pre><code class="hljs shell">clear         #清屏export -p //列出当前的环境变量值date  #显示当前时间history       #查看历史的输入命令hostname               # 查看主机名uname -a      #显示一些重要的系统信息，例如内核名称、主机名、内核版本号、处理器类型之类的信息 kill id      #杀死该id的进程su 用户名            #切换用户sudo 命令      #以系统管理者的身份执行指令ps -ef        #查看所有正在运行的进程shutdown -h now        #立刻关机shutdown -h 15:30      #到15:30关机shutdown -h 5          #5分钟后关机shutdown -r now        #立刻重启shutdown -r 5          #5分钟后重启reboot                 #立刻重启sleep 5m               #休眠5分钟，时间长度，后面可接 s、m、h 或 dlogout                 #退出系统login                  #使用新的身份登录系统halt   #关闭系统exit                   #退出终端groupadd 组名    #创建组groupdel 组名    #删除组useradd -g 组名 用户名    #创建用户passwd runoob   #设置runoob用户的密码passwd -d lx138   #删除用户密码userdel -r 用户名    #删除用户</code></pre></div><h3 id="权限管理命令">权限管理命令</h3><div class="code-wrapper"><pre><code class="hljs shell">chmod u+x 文件名    # 给文件的所有者添加执行权限chmod o-rwx 文件名  # 给文件的其他人删除所有权限chmod g=wx 文件名   # 给文件的所属组设置读写权限chmod 764 file     #对file的所有者设置读写及可执行权限，对用户组设置读写权限, 为其他用户设置读权限<span class="hljs-meta prompt_">#</span><span class="language-bash">参数说明：u：文件所有者；g:文件所有者所在组；o:其他用户；</span><span class="hljs-meta prompt_">#</span><span class="language-bash">参数说明：+：增加权限；-:去除权限； =:设置权限；</span><span class="hljs-meta prompt_">#</span><span class="language-bash">参数说明：r(4):读权限；w(2):写权限；x(1)：可执行权限；</span></code></pre></div><h3 id="网络通讯">网络通讯</h3><div class="code-wrapper"><pre><code class="hljs shell">systemctl status 服务名       # 服务器管理命令systemctl start 服务名        # 启动服务systemctl restart 服务名      # 重启服务systemctl stop 服务名         # 停止服务systemctl disable 服务名      # 禁止服务随linux启动。systemctl enable 服务名       # 设置服务随linux启动。ifconfig    #显示网络设备信息ifconfig eth0 down   #关闭指定网卡ifconfig eth0 up     #启动指定网卡ifconfig eth0 192.168.1.56   #给eth0网卡配置IP地址netstat -a     #显示详细的网络状况netstat -i     #显示网卡列表netstat -l     #显示监听的套接口ping www.runoob.com    #检测是否与主机连通tty    #显示当前终端ftp 主机名称或IP地址   #匿名登录tftp 218.28.188.288 #连接远程服务器 telnet 192.168.0.5  #登录IP为 192.168.0.5 的远程主机</code></pre></div><h3 id="其它命令">其它命令</h3><div class="code-wrapper"><pre><code class="hljs shell">tar -zcvf a.tar file1 file2,...     #将多个文件压缩打包成a.tartar -zxvf a.tar                      #解包至当前目录tar -zxvf a.tar -C /usr              #指定解压的位置<span class="hljs-meta prompt_"># </span><span class="language-bash">参数说明：z：调用gzip压缩命令进行压缩; x:解压文件; c：打包文件; v：显示运行过程; f：指定文件名</span>whereis ls    #将和ls文件相关的文件都查找出来which bash    #在环境变量$PATH设置的目录里查找指令&quot;bash&quot;的绝对路径ifconfig  --help：     #命令帮助文档，查看网卡信息man shutdown           #man手册，打开命令说明书之后，使用按键q退出</code></pre></div><p><strong>参考链接：</strong></p><p><ahref="https://www.runoob.com/linux/linux-command-manual.html">Linux命令大全</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32 SRAM调试设置</title>
    <link href="/2023/04/20/stm32-SRAM%E8%B0%83%E8%AF%95%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/04/20/stm32-SRAM%E8%B0%83%E8%AF%95%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>我们知道，当程序下载到芯片中，是直接下载到内部的flash区域，在我们写程序的初期阶段，会频繁的进行程序的下载烧录，而flash的擦除和写入是有寿命限制的，当然，我们平时这些几千上万次是无关紧要的，但为了进一步提高它的寿命，其实在调试阶段可以将程序写入SRAM中，这和写入flash中是一样的效果。</p><p>下面简单介绍一下：</p><p>在keil软件中，按下图步骤建立一个调试工程，其下会自动复制工程的所有文件：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230420192151263.png"alt="image-20230420192151263" /><figcaption aria-hidden="true">image-20230420192151263</figcaption></figure><p>此时，我们会看到当前的工程名字变成我们刚才设置的名字了。下面进行参数设置：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230420192729247.png"alt="image-20230420192729247" /><figcaption aria-hidden="true">image-20230420192729247</figcaption></figure><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230420193056604.png"alt="image-20230420193056604" /><figcaption aria-hidden="true">image-20230420193056604</figcaption></figure><p>然后创建一个SRAM.ini文件，放到工程中，并进行加载设置，文件内容如下：</p><div class="code-wrapper"><pre><code class="hljs bash">/*---------------------------------------------------------------------------- * Name:    Debug_RAM.ini * Purpose: RAM Debug Initialization File * Note(s): *---------------------------------------------------------------------------- * This file is part of the uVision/ARM development tools. * This software may only be used under the terms of a valid, current, * end user licence from KEIL <span class="hljs-keyword">for</span> a compatible version of KEIL software * development tools. Nothing <span class="hljs-keyword">else</span> gives you the right to use this software. * * This software is supplied <span class="hljs-string">&quot;AS IS&quot;</span> without warranties of any kind. * * Copyright (c) 2008-2011 Keil - An ARM Company. All rights reserved. *----------------------------------------------------------------------------*//*----------------------------------------------------------------------------  Setup()  configure PC &amp; SP <span class="hljs-keyword">for</span> RAM Debug *----------------------------------------------------------------------------*/FUNC void Setup (void) &#123;  SP = _RDWORD(0x20000000);          // Setup Stack Pointer  PC = _RDWORD(0x20000004);          // Setup Program Counter  _WDWORD(0xE000ED08, 0x20000000);   // Setup Vector Table Offset Register&#125;FUNC void OnResetExec (void)  &#123;      // executes upon software RESET  Setup();                           // Setup <span class="hljs-keyword">for</span> Running&#125;load %L incrementalSetup();                             // Setup <span class="hljs-keyword">for</span> Runningg, main</code></pre></div><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230420193627116.png"alt="image-20230420193627116" /><figcaption aria-hidden="true">image-20230420193627116</figcaption></figure><p>最后，手动设置一下板子上的<strong>BOOT0</strong>和<strong>BOOT1</strong>引脚到高电平，从<strong>SRAM</strong>启动即可。</p><p>参考链接</p><hr /><p><ahref="https://www.cnblogs.com/TrueElement/archive/2012/09/11/2680863.html">STM32的SRAM调试</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32 memory的转换计算</title>
    <link href="/2023/04/20/stm32-memory%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/04/20/stm32-memory%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>在stm32开发过程中，会经常考虑到各个外设部分在内存中分配情况，其中就牵扯到内存的计算问题，下面简单了解一下，以下是stm32f1系列的memory分配情况。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/memory%20map.png"alt="memory map" /><figcaption aria-hidden="true">memory map</figcaption></figure><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/memory%20address%E8%AE%A1%E7%AE%97.jpg"alt="memory address计算" /><figcaption aria-hidden="true">memory address计算</figcaption></figure><p>可以看出，芯片厂商在分配外设内存区域时，起止地址都是有规律可循的，图上已经标识，所以，通过它的内存起止地址，就可以很方便快速知道某个外设部分的内存分配大小。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git的使用教程</title>
    <link href="/2023/04/19/git%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2023/04/19/git%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>git是世界上最先进的开源分布式版本管理工具，相比于svn集中式版本管理工具，git可以让开发人员更加方便的查看和操作项目。</p><h3 id="git安装">1. git安装</h3><p>软件下载：<a href="https://git-scm.com/">git官网</a> 或 <ahref="https://npm.taobao.org/mirrors/git-for-windows/">国内镜像</a></p><h3 id="配置本地git标识用户名和邮箱">2.配置本地git标识(用户名和邮箱)</h3><p>打开 <code>git bash</code>,输入：</p><div class="code-wrapper"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;John Doe&quot;</span>git config --global user.email johndoe@example.com</code></pre></div><p><code>John Doe</code>替换成你的用户名，<code>johndoe@example.com</code>替换成你的邮箱。设置这两个信息的原因是在于远程库进行关联时需要一个key，配置这两个信息以确保你的唯一性。</p><p>使用--global参数表明你这台机器上所有的仓库都进行相同的配置。</p><h3 id="git的基本操作">3. git的基本操作</h3><div class="code-wrapper"><pre><code class="hljs bash">git init  <span class="hljs-comment"># 初始化git仓库，会在当前目录生成一个.git隐藏文件夹，不要去修改这个文件夹下的任意东西。</span>git add [file] <span class="hljs-comment">#添加文件到暂存区</span>git commit -m <span class="hljs-string">&quot;填写提交说明信息&quot;</span>   <span class="hljs-comment">#提交暂存区中的内容到本地仓库</span>git <span class="hljs-built_in">log</span>   <span class="hljs-comment"># 查看提交日志，可查看到版本commit ID</span>git status <span class="hljs-comment"># 查看所有文件的状态</span>git reset --hard HEAD^   <span class="hljs-comment">#上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写成HEAD~100</span>git reset --hard commit <span class="hljs-built_in">id</span> <span class="hljs-comment">#通过commit ID回退到那个版本，ID只需要前几位即可</span></code></pre></div><h3 id="git忽视文件">4. git忽视文件</h3><p>有些文件是不想被git管理可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。在仓库的根目录创建一个<code>.gitignore</code>的文件,然后将不需要被管理的文件添加到此文件中即可。如：</p><div class="code-wrapper"><pre><code class="hljs bash">log.txt  <span class="hljs-comment"># 忽视log.txt文件</span>.gitignore  <span class="hljs-comment"># 忽视.gitignore文件</span>css/*.js  <span class="hljs-comment"># 忽视css下的所有的js文件</span>css/*.*  <span class="hljs-comment"># 忽视css下的所有文件</span></code></pre></div><h3 id="git分支与合并">5. Git分支与合并</h3><div class="code-wrapper"><pre><code class="hljs bash">git branch                      <span class="hljs-comment">#查看本地分支</span>git branch [branch-name]        <span class="hljs-comment">#新建一个分支，但依然停留在当前分支</span>git checkout -b [branch]        <span class="hljs-comment">#新建一个分支，并切换到该branch分支</span>git checkout [branch-name]      <span class="hljs-comment">#切换到指定分支，并更新工作区</span>git branch -d [branch-name]     <span class="hljs-comment">#删除本地分支</span>git merge [branch]              <span class="hljs-comment">#合并指定branch分支到当前分支</span></code></pre></div><h3 id="关联远程仓库">6. 关联远程仓库</h3><p>远程仓库主要有：<a href="https://github.com/">github</a>和<ahref="https://gitee.com/">gitee</a>。</p><p><strong>gitee</strong>服务器在国内，网速比较快，<strong>github</strong>服务器在国外，访问速度比较慢，但用户数比较多。</p><ul><li><p>进入他们的官网，按照要求自行注册一个账户。</p></li><li><p>远程仓库绑定本地仓库，就可以SSH免密登陆，在<code>git bash</code>命令行窗口输入<strong>ssh-keygen-trsa</strong>,一直默认按回车即可，在本地目录：<code>C:\Users\Administrator\.ssh</code>文件中会生产两个秘钥文件，用记事本打开公钥文件<strong>id_rsa.pub</strong>，复制里面的内容。</p></li><li><p>在 <strong>github</strong> 网页上，依次打开<strong>settings</strong> -&gt; <strong>SSH and GPGkeys</strong>页面，新创建SSHkey，填上任意Title，在Key文本框里粘贴刚才复制的内容，添加即可。（gitee类似操作）</p></li><li><p>在 <strong>github</strong>网页上新建一个远程仓库，然后实现云端仓库和本地仓库同步。（gitee类似操作）</p></li></ul><div class="code-wrapper"><pre><code class="hljs bash">git remote add origin [远端仓库地址]   <span class="hljs-comment">#把本地仓库与远程仓库进行关联</span>git push -u origin [本地分支名字]  <span class="hljs-comment">#推送分支的所有内容到远程仓库</span></code></pre></div><h3 id="将远程仓库内容复制到本地">7. 将远程仓库内容复制到本地</h3><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [url]  　<span class="hljs-comment">#获取github上的远程仓库</span>git pull [url]     <span class="hljs-comment">#拉取github上远程仓库变化的内容</span></code></pre></div><h3 id="git的一些常用命令">8. git的一些常用命令</h3><ul><li>新建代码库</li></ul><div class="code-wrapper"><pre><code class="hljs bash">git init         <span class="hljs-comment"># 在当前目录新建一个Git代码库</span>git <span class="hljs-built_in">clone</span> [url]  <span class="hljs-comment">#clone 远程仓库到本地</span></code></pre></div><ul><li>本地仓库更改</li></ul><div class="code-wrapper"><pre><code class="hljs bash">git add [file1] [file2] ...    <span class="hljs-comment"># 添加指定文件到暂存区</span>git add .     <span class="hljs-comment"># 添加当前目录的所有文件到暂存区</span>git diff       <span class="hljs-comment"># 显示暂存区和工作区的差异</span>git <span class="hljs-built_in">rm</span> [file1] [file2] ...     <span class="hljs-comment"># 删除工作区文件，并且将这次删除放入暂存区</span>git commit -m [message]        <span class="hljs-comment"># 提交暂存区到仓库区</span>git status                  <span class="hljs-comment"># 显示有变更的文件</span>git <span class="hljs-built_in">log</span>                      <span class="hljs-comment"># 显示当前分支的版本历史</span></code></pre></div><ul><li><p>分支与标签 <div class="code-wrapper"><pre><code class="hljs bash">git branch       <span class="hljs-comment"># 列出所有本地分支</span>git branch -r    <span class="hljs-comment"># 列出所有远程分支</span>git branch [branch-name]    <span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span>git checkout -b [branch]   <span class="hljs-comment"># 新建一个分支，并切换到该分支</span>git checkout [branch-name]  <span class="hljs-comment"># 切换到指定分支，并更新工作区</span>git branch -d [branch-name]  <span class="hljs-comment"># 删除分支</span>git merge [branch]  <span class="hljs-comment"># 合并指定分支到当前分支</span>git tag [tag-name] <span class="hljs-comment"># Mark the current commit with a tag</span>git tag -d [tag]   <span class="hljs-comment"># 删除本地tag</span>git show [tag]  <span class="hljs-comment"># 查看tag信息</span></code></pre></div></p></li><li><p>更新与发行</p></li></ul><div class="code-wrapper"><pre><code class="hljs bash">git fetch [remote]  <span class="hljs-comment"># 下载远程仓库的所有变动</span>git remote -v   <span class="hljs-comment"># 显示所有远程仓库</span>git remote show [remote]   <span class="hljs-comment"># 显示某个远程仓库的信息</span>git remote add [shortname] [url]  <span class="hljs-comment"># 增加一个新的远程仓库，并命名</span>git pull [remote] [branch]   <span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span>git push [remote] [branch]   <span class="hljs-comment"># 上传本地指定分支到远程仓库</span>git push [remote] --force  <span class="hljs-comment"># 强行推送当前分支到远程仓库，即使有冲突</span>git merge &lt;branch&gt;   <span class="hljs-comment">#Merge &lt;branch&gt; into your current HEAD</span>git rebase &lt;branch&gt;  <span class="hljs-comment">#Rebase your current HEAD onto &lt;branch&gt; </span></code></pre></div><ul><li>撤销</li></ul><div class="code-wrapper"><pre><code class="hljs bash">git checkout [file]  <span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span>git reset [file]   <span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span>git reset --hard   <span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span>git reset [commit]   <span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span>git reset --hard [commit]   <span class="hljs-comment"># 重置当前分支的HEAD为指定commit</span>git reset --keep [commit]  <span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span>$ git revert [commit]  <span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span></code></pre></div><h3 id="参考链接">参考链接</h3><p><ahref="https://mp.weixin.qq.com/s/fU5lAC9_zjx6t5-ABfHRaQ">快速掌握Git分布式系统操作</a></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于删除keil或Altium Designer工程下无用文件</title>
    <link href="/2023/04/18/%E5%85%B3%E4%BA%8E%E5%88%A0%E9%99%A4keil%E6%88%96Altium-Designer%E5%B7%A5%E7%A8%8B%E4%B8%8B%E6%97%A0%E7%94%A8%E6%96%87%E4%BB%B6/"/>
    <url>/2023/04/18/%E5%85%B3%E4%BA%8E%E5%88%A0%E9%99%A4keil%E6%88%96Altium-Designer%E5%B7%A5%E7%A8%8B%E4%B8%8B%E6%97%A0%E7%94%A8%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>当使用keil软件或AltiumDesigner创建工程，完成工程后，需要进行打包传输，这时候会发现工程体积很大，其实里面有些文件是在编译时生成的，可以进行删除，只需保留必要的工程文件即可。如果手动删除，一个工程还好，如果是上百个工程，那就会很麻烦，其实，得益于<strong>bash</strong>指令，通过几句命令就可以自动批量删除这些工程中的无用文件。命令如下：</p><div class="code-wrapper"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> on:: keil trash<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.ddk&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.edk&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.lst&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.lnp&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.mpf&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.mpj&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.bak&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.obj&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.omf&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.rpt&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.tmp&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.__i&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.crf&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.o&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.d&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.axf&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.tra&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.iex&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.htm&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.sct&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.map&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.Administrator&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.dep&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;Jlink*&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;uvgui.*&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f:: Altium Designer trash<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.LOG&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.Dat&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.html&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.txtPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.PcbDocPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.PrjPcbStructure&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.SchDocPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.PcbPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.SchPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.pcbdoc_viewstate&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.$$<span class="hljs-variable">$Preview</span>&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.AnnotationPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.OutJob&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.ERC&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.drc&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;Status Report.Txt&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;History&quot;</span>) <span class="hljs-keyword">do</span> rd <span class="hljs-string">&quot;%%f&quot;</span> /s /q<span class="hljs-keyword">for</span> /D %%a <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;Project Logs for*&quot;</span>) <span class="hljs-keyword">do</span> rd <span class="hljs-string">&quot;%%a&quot;</span> /s /q<span class="hljs-keyword">for</span> /D %%a <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;Project Outputs for*&quot;</span>) <span class="hljs-keyword">do</span> rd <span class="hljs-string">&quot;%%a&quot;</span> /s /qpause</code></pre></div><p>新建一个文本文档，将以上命令复制粘贴到文档中，命名为<code>trash clear.bat</code>,然后将此文件放到工程目录下，运行即可。它会删除你所有工程下需要删除的文件。</p><p>如果需要删除的某一个工程，只需将此文件放到当前工程目录中运行。如果你需要删除的文件不在以上内容中，可以自行按照其格式添加进去即可。</p><p><strong><u>注意：这些命令是在当前目录中依次打开各个文件夹查找需要删除的内容。切记不要将不需要清除的文件夹放到当前目录中。</u></strong></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>添加U盘图标的方法</title>
    <link href="/2023/04/18/%E6%B7%BB%E5%8A%A0U%E7%9B%98%E5%9B%BE%E6%A0%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/18/%E6%B7%BB%E5%8A%A0U%E7%9B%98%E5%9B%BE%E6%A0%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>有时候我们想让U盘插到电脑上显示一个漂亮的图标，这样看起来就比较美观，其实，它的实现方式很简单，只需要进行几步设置，就可以打造出一个个性化的U盘出场方式，以下简单说明一下：</p><ol type="1"><li>准备一个漂亮的U盘 <strong>ico</strong>格式的图标，借助图片处理工具将像素大小设置为<strong>256像素x256像素</strong>，同时将图标命名为<code>u_disk.ico</code></li><li>使用记事本创建一个文件，重命名为<strong>autorun.inf</strong>,进入文件，写入以下内容：</li></ol><div class="code-wrapper"><pre><code class="hljs bash">[autorun]  icon=u_disk.ico,0label=Kayoung</code></pre></div><p><code>label</code> 显示的是U盘的名字。</p><ol start="3" type="1"><li>将这两个文件同时拷贝到U盘中，并各自右键打开文件的属性，设置为隐藏模式。</li><li>依次打开 <strong>工具</strong> -&gt; <strong>文件夹选项</strong>-&gt; <strong>查看</strong> -&gt; <strong>隐藏文件和文件夹</strong>-&gt; <code>勾选</code><strong>不显示隐藏的文件、文件夹或驱动器</strong>, 然后点击<strong>确定</strong>，这样，U盘中的两个文件就被隐藏了。</li></ol><p>效果图：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230418080723296.png"alt="image-20230418080723296" /><figcaption aria-hidden="true">image-20230418080723296</figcaption></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BAM-1020 连续颗粒物监测仪器手册</title>
    <link href="/2023/04/17/BAM1020%E8%BF%9E%E7%BB%AD%E9%A2%97%E7%B2%92%E7%89%A9%E7%9B%91%E6%B5%8B%E4%BB%AA%E5%99%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2023/04/17/BAM1020%E8%BF%9E%E7%BB%AD%E9%A2%97%E7%B2%92%E7%89%A9%E7%9B%91%E6%B5%8B%E4%BB%AA%E5%99%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p>前两年部门采购了几套美国 <strong>MetOne</strong> 公司的颗粒物采样设备<code>BAM-1020</code>，查看了它的使用说明手册，都是英文的，且没有电子版，后来为了好好研究一下它的操作规程，便于后期翻阅查看，我就把纸质版说明书拍照下来，借助<strong>OCR工具</strong> （<ahref="http://ocr.tianruo.net/">天若OCR文字识别</a>），整理成电子版，然后借助翻译软件（<ahref="https://copytranslator.github.io/">CopyTranslator</a>）将其翻译下来。当然这两款软件并不是很智能，也会存在识别不出来，翻译不正确的地方，这就需要自己细心认真的进行处理，但借助它可以缩短我整理和翻译的速度，提高了效率，现在记录一下。</p><p>英文目录：</p><div class="code-wrapper"><pre><code class="hljs tex">Table of Contents1  INTRODUCTION11.1  About This Manual11.2  Technical Service11.3  BAM: Beta Attenuation Monitor21.4  Beta Radiation Safety Statement31.5  BAM 1020 US-EPA Configurations31.6  BAM 1020 Other Configurations31.7  BAM 1020 Specifications32  SITE SELECTION AND INSTALLATION42.1  Unpacking, Inspection, and Evaluation Testing42.2  Enclosure Selection and Temperature Control52.3  Site Selection and Inlet Positioning Criteria62.4  Mounting Options in a Walk-In Shelter62.5  BAM 1020 Installation Instructions72.6  BAM 1020 Power and Electrical Service133  INITIAL SETUP OF THE BAM 1020143.1  Power up153.2  Warm-up Period153.3  The Main Menu and Using the Keypad and Display153.4  Filter Tape Loading163.5  Self-Test173.6  Initial SETUP Settings Considerations183.7  Initial Leak Check and Flow Check193.8  Starting a Measurement Cycle193.9  Accessing the Flow Statistics Screen193.10  The OPERATE Menus193.11  The NORMAL Operation Screen203.12  The INSTANTANEOUS and AVERAGE Operation Screens204  THE MEASUREMENT CYCLE214.1  The One-Hour Cycle Timeline214.2  Automatic Span Checks During The Cycle224.3  Filter Tape Use235  FLOW SYSTEM and FLOW CALIBRATIONS235.1  Flow System Diagram235.2  Flow Control and Flow Reporting Types - Standard or Actual Flow245.2.1  ACTUAL Flow Control:245.2.2  STANDARD Flow Control:245.3  Total Flow(QTOT) and Flow Rate(LPM) Conversions255.4  About Leak Checks, Nozzle Cleaning, and Flow Checks255.5  Leak Check Procedure255.5.1  Basic Leak Check265.5.2  Advanced Leak Checks275.6  Nozzle and Vane Cleaning Procedure295.7  Field Calibration of the Flow System - Actual Flow Mode315.8  Field Calibration of the Flow System - Standard Flow Mode326  SETUP MENU DESCRIPTIONS336.1  CLOCK Setup Screen346.2  SAMPLE Setup Screen -Range, Sample, and Timing Settings346.3  CALIBRATE Setup Screen-Flow and Calibration Settings366.4  EXTRA1 Setup Screen386.5  ERRORS Setup Screen for the Analog Output386.6  PASSWORD Setup Screen396.7  INTERFACE Setup Screen406.8  SENSOR Setup Screen for External Met Sensors406.9  HEATER Setup Screen - RH Control Settings416.10  QUERY Setup Screen -Custom Data Array Setup436.11  REPORTS Setup Screen - Daily Data and Dynamic Ranges446.11.1  Daily Data Range446.11.2  Dynamic Range446.11.3  Log BP456.11.4  Log Membrane456.12  HJ 653 Setup Screen -Chinese Data Formatting457 MAINTENANCE, DIAGNOSTICS and TROUBLESHOOTING457.1  Met One Recommended Periodic Maintenance Table467.2  BAM 1020 Error and Alarm Descriptions467.3  Comparison of BAM 1020 Data to Integrated Filter Sampler Data507.4  Power Up Problems and Electrical Safety Considerations517.5  Basic Problem and Cause/Solution Table537.6  Nozzle Component Service and O-ring Replacement567.7  Performing the 72-Hour Zero Filter Background Test587.8  The TEST Menu System - Overview597.9  COUNT Test Menu -Beta Detector Count Tests607.10  PUMP Test Menu - Manual Pump and Nozzle Tests607.11  TAPE Test Menu -Manual Filter Forward/Backward Tests617.12  DAC Test Menu - Analog Output Test617.13  CALIBRATE Test Menu - Span Membrane Mass Tests617.14  INTERFACE Test Menu -Relay IO Channel Tests627.15  FLOW Test Menu627.16  ALIGN Test Menu -Tape Transport Motor and Photosensor Tests627.17  HEATER Test Menu637.18  FILTER-T Test Menu -Filter Temperature Sensor Tests647.19  FILTER-RH Test Menu - Filter Humidity Sensor Test and Calibration648  EXTERNAL DATA LOGGER INTERFACE SYSTEM658.1  Analog Concentration Output Signal658.2  Early Cycle Mode Option For Analog Data Collection668.3  Telemetry and Error Relays678.4  Interfacing a Digital Data logger with the BAM 1020699  DIGITAL COMMUNICATIONS AND DATA RETRIEVAL709.1  Direct Serial Port Connections and Settings719.2  Using Met One Comet Communications Software719.3  Downloading Data Using Simple Terminal Programs729.4  System Menu and File Descriptions Using a Terminal Program739.5  Printer Output Port Functions809.6  Modem Option819.7  BAM 1020 Firmware Upgrades819.8  Resetting the Data Pointer for New Data Collection849.9  Data Collection Using the Query Output or Bayern-Hessen Protocol8410  ACCESSORIES and PARTS8610.1  Consumables, Replacement Parts, and Accessories8610.2  BX-500 Series Meteorological Sensor Configurations9111  THEORY OF OPERATION9311.1  Converting Data Between EPA Standard and Actual Conditions95</code></pre></div><p>中文目录：</p><div class="code-wrapper"><pre><code class="hljs tex">目录1  概况11.1 关于本手册11.2 技术服务11.3 BAM: β衰减监测仪21.4 β辐射安全声明21.5 BAM 1020 US-EPA 配置21.6 BAM 1020 其他配置31.7 BAM 1020 规格32  采样点选择与安装42.1  拆箱，检视和评估测试42.2  外罩选择和温度控制42.3  选址和入口定位标准52.4  移动式方舱中的安装选项52.5  BAM 1020 安装指南52.6  BAM 1020 电力和电气服务113   BAM 1020的初始设置123.1  开机123.2  预热阶段133.3  主菜单和使用键盘和显示器133.4  过滤带加载143.5  自测143.6  初始设置注意事项153.7  初始泄漏检查和流量检查153.8  开始一个测量周期163.9  访问流量统计信息界面163.10  操作菜单163.11  NORMAL操作界面173.12  瞬时和平均操作界面174  测量周期174.1  一小时周期时间线184.2  循环期间自动量程（Span）检查194.3  滤带使用195  流量系统和流量校准195.1 流程系统图195.2  流量控制和流量报告类型-标况或工况流量205.2.1  工况流量控制:205.2.2  标况流量控制:205.3  总体积流量(QTOT) 和流量(LPM) 转换215.4  关于泄漏检查、喷嘴清洁和流量检查215.5  泄漏检查过程215.5.1 基本泄漏检查215.5.2  高级泄漏检查225.6  喷嘴和卡环清洁程序245.7  流量系统的现场校准-工况流量模式255.8  流量系统的现场校准-标况流量模式276  设置菜单说明276.1  时钟设置界面286.2  采样设置界面-范围、采样和时间设置286.3  校准设置界面-流量和校准设置306.4  EXTRA1设置界面316.5 模拟输出错误设置界面316.6  密码设置界面336.7  接口设置界面336.8  外部气象传感器的传感器设置界面336.9  加热器设置界面-相对湿度控制设置346.10  查询设置界面-自定义数据项设置356.11 报告设置界面-每日数据和动态范围366.11.1  每日数据范围376.11.2  动态范围376.11.3  BP日志376.11.4  膜日志376.12  HJ 653设置界面-中文数据格式377 维护、诊断和故障排除387.1 Met One建议的定期维护表387.2 BAM 1020错误和报警描述397.3 BAM 1020数据与集成过滤采样器数据的比较417.4 开机问题和电气安全注意事项427.5 基本问题及原因/解决方案表437.6 喷嘴部件维修和O形圈更换467.7 执行72小时零过滤器背景测试477.8 测试菜单系统-概述487.9 计数测试菜单-β探测器计数测试487.10 泵测试菜单-手动泵和喷嘴测试497.11 滤带测试菜单-过滤器向前/向后手动测试497.12 DAC测试菜单-模拟输出测试497.13 校准测试菜单-量程膜质量测试507.14 接口测试菜单-继电器IO通道测试507.15 流量测试菜单507.16 校准测试菜单-滤带传输电机和光电传感器测试507.17 加热器测试菜单517.18 FILTER-T 测试菜单-滤带温度传感器测试517.19 FILTER-RH 测试菜单 - 滤带湿度传感器测试和校准528  外部数据记录器接口系统528.1  模拟浓度输出信号538.2  模拟数据采集的早期循环模式选项538.3  遥测和错误继电器548.4 数字数据记录器与BAM 1020的接口569  数字通信与数据检索579.1  直接串行端口连接和设置579.2  使用Met One Comet通信软件589.3  使用简单的终端程序下载数据599.4  使用终端程序的系统菜单和文件说明609.5  打印机输出端口功能669.6  调制解调器选项669.7  BAM 1020固件升级669.8  重置新数据收集的数据指针699.9  使用查询输出或拜仁-黑森协议进行数据收集6910  附件和零件7010.1  消耗品、可替换的零件和附件7010.2  BX-500系列气象传感器配置7511  操作理论7811.1  在EPA标况（Standard）和工况（Actual）条件之间转换数据79</code></pre></div><p>因为能力有限，好多专业词汇翻译不够详尽，肯定还有很多翻译不正确的地方，但相比于长篇英语文章，后期翻阅就比较容易上手了，手册详细内容已上传：</p><p><ahref="https://gitee.com/kayoungzhang/my_codehub.git">码云Gitee</a></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语</tag>
      
      <tag>环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stc单片机免断电自动下载程序方法</title>
    <link href="/2023/04/16/stc%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%8D%E6%96%AD%E7%94%B5%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/16/stc%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%8D%E6%96%AD%E7%94%B5%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>学过stc单片机的人，应该都知道，下载程序时，需要先加载程序，然后断电再上电，方可将程序下载到单片机中运行。有的开发板做了硬件电路处理，结合下载软件的设置，就不用断电也可以进行程序下载，下面介绍一下另外一种方式，硬件电路不需要如何修改，只通过软件设置就可以进行免断电下载程序。</p><p>在 <strong>STC</strong>官方下载软件（<strong>STC-ISP</strong>）中，点击下载按钮后，其实从电脑端串口是一直在发送数据的，一般是<strong>0x7F</strong>，也可以是用户自定义，根据STC12C5A60S2芯片手册软件复位一章中，设置<strong>IAP_CONTR寄存器</strong>（STC89是<strong>ISP_CONTR寄存器</strong>）就可以实现不断电复位，从而进入ISP下载区进行程序的下载。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/014.png"alt="014" /><figcaption aria-hidden="true">014</figcaption></figure><p>第一种方式：利用串口下载程序瞬间一直发送 <strong>0x7f</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 方案一：串行口中断,用于stc单片机不断电自动下载程序 */</span><span class="hljs-type">uint8_t</span> uCount = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数</span><span class="hljs-type">void</span> <span class="hljs-title function_">UART1_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> interrupt 4&#123;ES = <span class="hljs-number">0</span>; <span class="hljs-comment">//关闭串口中断</span><span class="hljs-keyword">if</span>(RI)&#123;RI = <span class="hljs-number">0</span>; <span class="hljs-comment">//Clear receive interrupt flag</span><span class="hljs-keyword">if</span>(SBUF == <span class="hljs-number">0x7F</span>)&#123;            uCount++;            <span class="hljs-keyword">if</span>(uCount &gt; <span class="hljs-number">9</span>)   <span class="hljs-comment">//isp软件用户自定义命令连续发送10个0x7F，即可实现自动热复位下载</span>            &#123;                uCount = <span class="hljs-number">0</span>;                IAP_CONTR |= <span class="hljs-number">0x60</span>;    <span class="hljs-comment">//软复位到系统ISP监控区</span>            &#125;&#125;<span class="hljs-keyword">else</span>&#123;uCount = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数清零</span>&#125;&#125;ES = <span class="hljs-number">1</span>; <span class="hljs-comment">//重新打开串口中断。</span>&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230416190006307-16816443491601.png" alt="image-20230416190006307" style="zoom:80%;" /></p><p>第二种方式：利用<strong>stc-isp</strong>下载工具默认内部自定义命令”<strong><spanclass="citation" data-cites="STCISP">@STCISP</span>#</strong>“</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">UART1_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> interrupt 4&#123;<span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;@STCISP#&quot;</span>;<span class="hljs-comment">//stc internal definition command</span>ES = <span class="hljs-number">0</span>; <span class="hljs-comment">//关闭串口中断</span><span class="hljs-keyword">if</span>(RI)&#123;RI = <span class="hljs-number">0</span>; <span class="hljs-comment">//Clear receive interrupt flag</span><span class="hljs-keyword">while</span>(*str != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(*str++ == SBUF)<span class="hljs-keyword">continue</span>;IAP_CONTR |= <span class="hljs-number">0x60</span>;&#125;&#125;<span class="hljs-keyword">else</span>TI = <span class="hljs-number">0</span>;ES = <span class="hljs-number">1</span>; <span class="hljs-comment">//重新打开串口中断。</span>&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230416190418784.png" alt="image-20230416190418784" style="zoom:80%;" /></p><p>选择以上任何一种方式，保证 <strong>USB-CDC/串口模式</strong>中波特率跟自己程序中串口1的波特率一致，在main函数的开头初始化一下串口1，就可以实现不断电下载程序了。</p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的多任务管理程序架构</title>
    <link href="/2023/04/16/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/04/16/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>对于裸机开发过程中，任务多了就会出现一堆全局变量，管理上就会出现很混乱的状况，这在开发中是不允许的。看了B站上<strong>无极单片机</strong>up主讲的程序架构设计的教程中，发觉有些功能还可以删减，所以，自己再结合其他一些教程，写了一个的轮询任务管理架构，简单实用，下面详细介绍一下这套多任务管理架构。</p><p>多任务实现方式，我直接封装成 <code>scheduler.h</code> 和<code>scheduler.c</code> ,首先看头文件：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SCHEDULER_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCHEDULER_H</span><span class="hljs-meta">#<span class="hljs-keyword">undef</span> NULL</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined (_cplusplus)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void*)0)</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">/* exact-width signed integer types */</span><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">char</span> <span class="hljs-type">int8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">int16_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">int</span> <span class="hljs-type">int32_t</span>;<span class="hljs-comment">/* exact-width unsigned integer types */</span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">uint16_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">uint32_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*p_task_func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//任务函数指针，方便传参</span><span class="hljs-comment">/* 任务ID枚举,将需要在main函数中执行的任务放到此处 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><span class="hljs-class">&#123;</span>LED0_TASK,LED1_TASK,LED2_TASK,OS_TASK_SUM <span class="hljs-comment">//任务总数,不需要修改</span>&#125;task_id_e;<span class="hljs-comment">/* 任务运行状态 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><span class="hljs-class">&#123;</span>TASK_IDLE,TASK_RUN = !TASK_IDLE&#125;task_status_e;<span class="hljs-comment">/* 任务的结构体 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">void</span> (*p_task)(<span class="hljs-type">void</span>);   <span class="hljs-comment">// Pointer to the task</span>task_status_e run_flag; <span class="hljs-comment">//task status</span>  <span class="hljs-type">uint32_t</span> time_slice;   <span class="hljs-comment">// Delay (ticks) until the task will (next) be run(period/10ms)</span>  <span class="hljs-type">uint32_t</span> period;   <span class="hljs-comment">// Interval (ticks) between subsequent runs.(time_slice * 10ms)</span>&#125;<span class="hljs-type">os_task_t</span>; <span class="hljs-comment">/* task declarition */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">os_task_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">os_task_create</span><span class="hljs-params">(task_id_e task_id, p_task_func proc, <span class="hljs-type">uint32_t</span> period)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">os_task_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">os_task_dispatch</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">//放到定时器10ms中断处理函数中</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>头文件中，主要定义了任务的结构体和两个枚举类型的变量，都写有注释，简单明了。下面介绍几个函数的定义：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ***************************************************************</span><span class="hljs-comment">  * @file       scheduler.c</span><span class="hljs-comment">  * @author     Kayoung</span><span class="hljs-comment">  * @version    V1.0.0</span><span class="hljs-comment">  * @date       2023.04.01</span><span class="hljs-comment">  * @brief      一种轻量级的多任务实现方法</span><span class="hljs-comment">  * @attention  必须将任务调度函数放到定时器10ms中断处理函数中</span><span class="hljs-comment">  ***************************************************************</span><span class="hljs-comment">  */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;scheduler.h&quot;</span></span><span class="hljs-comment">/* 定义任务数组 */</span><span class="hljs-keyword">volatile</span> <span class="hljs-type">os_task_t</span> os_task[OS_TASK_SUM];<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  系统任务初始化</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">os_task_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; OS_TASK_SUM; i++)&#123;os_task[i].p_task = <span class="hljs-literal">NULL</span>;os_task[i].run_flag = TASK_IDLE;os_task[i].time_slice = <span class="hljs-number">0</span>;os_task[i].period = <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  创建任务</span><span class="hljs-comment">  * @param  task_id:任务的id</span><span class="hljs-comment">  * @param  proc:具体任务处理函数指针</span><span class="hljs-comment">  * @param  period:任务周期(ms)</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">os_task_create</span><span class="hljs-params">(task_id_e task_id, p_task_func proc, <span class="hljs-type">uint32_t</span> period)</span>&#123;<span class="hljs-keyword">if</span>(!os_task[task_id].p_task)<span class="hljs-comment">//不存在任务</span>&#123;os_task[task_id].p_task = proc;os_task[task_id].run_flag = TASK_IDLE;os_task[task_id].period = period;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  任务调度器,必须放到10ms的定时器或系统时钟中断函数中</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">os_task_dispatch</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; OS_TASK_SUM; i++)&#123;<span class="hljs-keyword">if</span>(os_task[i].p_task) <span class="hljs-comment">//存在任务功能函数</span>&#123;os_task[i].time_slice++;<span class="hljs-keyword">if</span>(os_task[i].time_slice == os_task[i].period / <span class="hljs-number">10</span>)<span class="hljs-comment">//判断计时器值是否达到任务运行周期</span>&#123;os_task[i].time_slice = <span class="hljs-number">0</span>;os_task[i].run_flag = TASK_RUN;&#125;&#125;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  任务开始运行</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">os_task_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; OS_TASK_SUM; i++)&#123;<span class="hljs-keyword">if</span>(os_task[i].run_flag == TASK_RUN)&#123;os_task[i].run_flag = TASK_IDLE;os_task[i].p_task();<span class="hljs-comment">//执行任务</span>&#125;&#125;&#125;</code></pre></div><p>具体应用过程中，首先定义一个 <strong>10ms</strong>的定时器，然后将任务调度器函数直接放到这个定时器中断中，接着定义不同的任务，<strong>这个任务函数形式必须跟任务函数指针定义的形式一致</strong>，同时将相应的任务放到任务ID枚举中，最后，在<strong>main</strong> 函数中进行初始化调用，<strong>while</strong>循环中启动任务即可。下面结合 <strong>main.c</strong> 函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC90C5xAD.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;scheduler.h&quot;</span></span>sbit led0 = P0^<span class="hljs-number">0</span>;sbit led1 = P0^<span class="hljs-number">1</span>;sbit led2 = P0^<span class="hljs-number">2</span>;<span class="hljs-comment">/* 10ms定时器初始化 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Timer0_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//10毫秒@11.0592MHz</span>&#123;AUXR &amp;= <span class="hljs-number">0x7F</span>;<span class="hljs-comment">//定时器时钟12T模式</span>TMOD &amp;= <span class="hljs-number">0xF0</span>;<span class="hljs-comment">//设置定时器模式</span>TMOD |= <span class="hljs-number">0x01</span>;<span class="hljs-comment">//设置定时器模式</span>TL0 = <span class="hljs-number">0x00</span>;<span class="hljs-comment">//设置定时初始值</span>TH0 = <span class="hljs-number">0xDC</span>;<span class="hljs-comment">//设置定时初始值</span>TF0 = <span class="hljs-number">0</span>;<span class="hljs-comment">//清除TF0标志</span>TR0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//定时器0开始计时</span>ET0 = <span class="hljs-number">1</span>;EA = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/* 定义三个led 翻转任务 */</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  led翻转</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">led0_tongle</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;led0 = ~led0;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">led1_tongle</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;led1 = ~led1;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">led2_tongle</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;led2 = ~led2;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;Timer0_Init();os_task_init();<span class="hljs-comment">/* 创建三个不同周期闪烁的任务 */</span>os_task_create(LED0_TASK, led0_tongle, <span class="hljs-number">500</span>);<span class="hljs-comment">//500ms</span>os_task_create(LED1_TASK, led1_tongle, <span class="hljs-number">1000</span>);<span class="hljs-comment">//1000ms</span>os_task_create(LED2_TASK, led2_tongle, <span class="hljs-number">2000</span>);<span class="hljs-comment">//2000ms</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;os_task_start();<span class="hljs-comment">//执行启动任务</span>&#125;&#125;<span class="hljs-comment">/* 定时器0中断函数 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">timer0_isr</span><span class="hljs-params">()</span> interrupt 1&#123;<span class="hljs-comment">/* reload counter */</span>TL0 = <span class="hljs-number">0x00</span>;TH0 = <span class="hljs-number">0xDC</span>;os_task_dispatch();&#125;</code></pre></div><p>烧录程序，会看到三个led不同频率的闪烁。</p><p>以上代码，已放到码云：<ahref="https://gitee.com/kayoungzhang/my_codehub.git">multitaskos</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客更换主题详细方法</title>
    <link href="/2023/04/16/hexo%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E8%AF%A6%E7%BB%86%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/16/hexo%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E8%AF%A6%E7%BB%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在创建hexo个人博客时，已经简单介绍了更换主题的方法，下面主要是介绍我在更换<strong>fluid</strong>主题后，进行的一些自定义设置及碰到的问题和解决方法。</p><h3 id="下载-fluid-主题及修改配置文件">1. 下载 fluid主题及修改配置文件</h3><p>在本地 <strong>Hexo</strong> 博客目录中打开 <strong>gitbash</strong>，然后下载 <strong>fluid</strong> 主题。</p><div class="code-wrapper"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/fluid-dev/</span>hexo-theme-fluid.git themes/fluid</code></pre></div><p>修改 <strong>Hexo</strong> 博客目录中的配置文件 **_config.yml** :</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span> <span class="hljs-comment">#根据主题目录下language文件夹选择相应语言</span></code></pre></div><h3 id="创建关于页">2. 创建「关于页」</h3><p><strong>fluid</strong>主题默认已经创建了首页，分类，归档，标签等项，但主题的「关于页」需要手动创建:</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">page</span> <span class="hljs-string">about</span></code></pre></div><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加<code>layout</code> 属性。修改后的文件示例如下：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><span class="hljs-attr">date:</span> <span class="hljs-number">2023-04-16 10:16:49</span><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><span class="hljs-meta">---</span><span class="hljs-meta"></span><span class="hljs-comment">#这里写关于页的正文，添加你需要在关于页展示的内容，支持 Markdown, HTML</span></code></pre></div><p>此时，运行以下命令，打开<code>http://localhost:4000/</code>,即可查看到你的本地网页博客。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><span class="hljs-string">hexo</span> <span class="hljs-string">g</span><span class="hljs-string">hexo</span> <span class="hljs-string">s</span></code></pre></div><h3 id="自定义设置">3. 自定义设置</h3><p>打开 <strong>fluid</strong> 主题目录下配置文件 **_config.yml**，里面详细介绍了各种设置的方法，并进行了中文翻译。</p><h4 id="更换-页面光标闪烁">3.1 更换 页面光标闪烁</h4><div class="code-wrapper"><pre><code class="hljs javascript"># <span class="hljs-title class_">Cursor</span> character<span class="hljs-attr">cursorChar</span>: <span class="hljs-string">&quot;✍&quot;</span></code></pre></div><h4 id="修改导航栏博客名">3.2 修改导航栏博客名</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">blog_title</span>: <span class="hljs-string">&quot;My Tech Blog&quot;</span></code></pre></div><h4 id="添加页脚-个人版权信息">3.3 添加页脚 个人版权信息</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;</span><span class="hljs-string">    &lt;p &lt;i class=&quot;iconfont icon-copyright&quot;&gt;&lt;/i&gt; &lt;span&gt;2023 | KayougZhang&lt;/span&gt; &lt;/p&gt;</span><span class="hljs-string">    &lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Hexo&lt;/span&gt;&lt;/a&gt;</span><span class="hljs-string">    &lt;i class=&quot;iconfont icon-love&quot;&gt;&lt;/i&gt;</span><span class="hljs-string">    &lt;a href=&quot;https://github.com/fluid-dev/hexo-theme-fluid&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Fluid&lt;/span&gt;&lt;/a&gt;</span><span class="hljs-string">  &#x27;</span></code></pre></div><h4 id="修改首页显示的图像">3.4 修改首页显示的图像</h4><p>找到自己喜欢的 <strong>png</strong> 格式图片，命名为<strong>default.png</strong> ，然后复制到主题目录<code>source/img</code> 下，进行替换原图片。</p><h4 id="修改post页面显示的图像">3.5 修改post页面显示的图像</h4><p>找到自己喜欢的 <strong>png</strong> 格式图片，命名为<strong>article.png</strong> ，然后复制到主题目录<code>source/img</code> 下。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">post</span>:  <span class="hljs-attr">banner_img</span>: <span class="hljs-regexp">/img/</span>article.<span class="hljs-property">png</span>  <span class="hljs-attr">banner_img_height</span>: <span class="hljs-number">70</span>  <span class="hljs-attr">banner_mask_alpha</span>: <span class="hljs-number">0.3</span></code></pre></div><h4 id="修改首页宣传语">3.6 修改首页宣传语</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">slogan</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>  # 为空则按 hexo config.<span class="hljs-property">subtitle</span> 显示  # <span class="hljs-title class_">If</span> empty, text based on <span class="hljs-string">`subtitle`</span> <span class="hljs-keyword">in</span> hexo config  <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;积跬步以至千里，积小流而成江海&quot;</span></code></pre></div><h4 id="文章开头显示更新时间">3.7 文章开头显示更新时间</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">updated</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span></code></pre></div><h4 id="关闭文章目录显示和版权声明">3.8 关闭文章目录显示和版权声明</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">toc</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">false</span><span class="hljs-attr">copyright</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">false</span></code></pre></div><h4 id="设置评论插件">3.9 设置评论插件</h4><p>打开评论插件需要第三方服务，所以需要进行第三方设置，根据<ahref="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">fluid评论配置指南</a>，选择<a href="https://twikoo.js.org/">Twikoo</a>，进行 <ahref="https://twikoo.js.org/quick-start.html#zeabur-部署">Zeabur部署</a>，进行它的提示进行设置，最后会得到一个 <strong>envId</strong>,此处我设置的是 https://ENV, 在配置文件进行如下设置：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">comments</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>    # 指定的插件，需要同时设置对应插件的必要参数    # <span class="hljs-title class_">The</span> specified plugin needs to set the necessary parameters at the same time    # <span class="hljs-title class_">Options</span>: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus    <span class="hljs-attr">type</span>: twikoo     # <span class="hljs-title class_">Twikoo</span># 基于腾讯云开发 , <span class="hljs-title class_">Zeabur</span> 部署# <span class="hljs-title class_">Based</span> on <span class="hljs-title class_">Tencent</span> <span class="hljs-title class_">CloudBase</span># <span class="hljs-title class_">See</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//twikoo.js.org</span><span class="hljs-attr">twikoo</span>:  <span class="hljs-attr">envId</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//ENV</span>  <span class="hljs-attr">region</span>: ap-shanghai  <span class="hljs-attr">path</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span></code></pre></div><h4 id="更改about页图标">3.10 更改「about」页图标</h4><p>在 <strong>about</strong> 配置栏中，删除名字和介绍的部分，在 <ahref="https://hexo.fluid-dev.com/docs/icon/">图标用法</a>中，选择需要添加的图标，然后进行设置，我添加了<strong>github，mail</strong> 和<strong>微信</strong>，所以，需要准备我的微信图片，命名为<strong>wechat.png</strong> ,复制到主题目录 <code>source/img</code>下。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">about</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>  <span class="hljs-attr">banner_img</span>: <span class="hljs-regexp">/img/</span><span class="hljs-keyword">default</span>.<span class="hljs-property">png</span>  <span class="hljs-attr">banner_img_height</span>: <span class="hljs-number">60</span>  <span class="hljs-attr">banner_mask_alpha</span>: <span class="hljs-number">0.3</span>  <span class="hljs-attr">avatar</span>: <span class="hljs-regexp">/img/</span>avatar.<span class="hljs-property">png</span>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-attr">intro</span>: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">icons</span>:  - &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;iconfont icon-github-fill&quot;</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">&quot;https://github.com/KayoungZhang&quot;</span>, <span class="hljs-attr">tip</span>: <span class="hljs-string">&quot;GitHub&quot;</span> &#125;  - &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;iconfont icon-mail&quot;</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">&quot;mailto:zky0830@163.com&quot;</span>, <span class="hljs-attr">tip</span>: <span class="hljs-string">&quot;Email me&quot;</span> &#125;  - &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;iconfont icon-wechat-fill&quot;</span>, <span class="hljs-attr">qrcode</span>: <span class="hljs-string">&quot;/img/wechat.png&quot;</span> &#125;</code></pre></div><h4 id="更改about页avatar图像">3.11 更改「about」页avatar图像</h4><p>avatar图像可进行修改，也可以进行删除，修改方式是，找到自己喜欢的图片，命名为<strong>avatar.png</strong> , 粘贴到 <strong>img</strong>文件夹中进行替换，此处我直接删除，操作方式如下：</p><p>打开主题目录下 <code>layout/layout.ejs</code> 文件,删除以下代码：</p><div class="code-wrapper"><pre><code class="hljs javascript">&lt;% <span class="hljs-keyword">if</span>(page.<span class="hljs-property">layout</span> === <span class="hljs-string">&#x27;about&#x27;</span>) &#123; %&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;about-avatar&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&lt;%= url_for(theme.about.avatar) %&gt;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-fluid&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;avatar&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">&lt;% &#125; %&gt;</span></code></pre></div><h4 id="调整-post-页面的大小">3.12 调整 post 页面的大小</h4><p>在post页中，文章内容部分页面很窄，有的文章排版成挤缩状，看起不舒服，进行如下设置：</p><p>打开主题目录下 <code>layout/post.ejs</code> 文件, 将<strong>col-lg-8</strong> 修改为 <strong>12</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;col-lg-12 nopadding-x-md&quot;</span>&gt;</code></pre></div><p>以上是我采用 <strong>fluid</strong> 主题的一些详细设置，因为不会<strong>javascript</strong>，所以，后面几项设置折腾了两天，现在记录一下。</p><h4 id="更改代码显示的样式">3.13 更改代码显示的样式</h4><p>打开 <strong>fluid</strong> 主题目录下配置文件 **_config.yml**，修改：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">highlightjs:</span>    <span class="hljs-comment"># 在链接中挑选 style 填入</span>    <span class="hljs-comment"># Select a style in the link</span>    <span class="hljs-comment"># See: https://highlightjs.org/static/demo/</span>    <span class="hljs-comment"># style: &quot;github gist&quot;</span>    <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;Vs&quot;</span>    <span class="hljs-attr">style_dark:</span> <span class="hljs-string">&quot;dark&quot;</span></code></pre></div><h3 id="添加数学公式支持">4. 添加数学公式支持</h3><p>打开主题目录下的配置文件<code>_config.yml</code>,将markdown公式支持打开。</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">math:</span>  <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span>  <span class="hljs-comment"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span>  <span class="hljs-comment"># If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math</span>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># Options: mathjax | katex</span>  <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span></code></pre></div><p>下载安装： <ahref="https://github.com/jgm/pandoc/releases">pandoc</a>，然后进入本地博客目录下，右键打开<code>git bash</code>,安装<strong>hexo-renderer-pandoc</strong></p><div class="code-wrapper"><pre><code class="hljs ada">npm uninstall hexo-renderer-marked <span class="hljs-comment">--save  </span>npm install hexo-renderer-pandoc <span class="hljs-comment">--save</span></code></pre></div><p>根据 <code>\node_modules\hexo-renderer-pandoc</code>目录下的<strong>README.md</strong> 文档，打开本地博客主目录下的配置文件：<code>_config.yml</code>，添加pandoc软件的路径。</p><div class="code-wrapper"><pre><code class="hljs arcade">pandoc:  pandoc_path: C:<span class="hljs-regexp">/Program Files/</span>Pandoc/pandoc.exe</code></pre></div><p><strong>注意：</strong>有时部署博客文章会出现关于pandoc的错误，可根据提示，进行相应的修改。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230706225516667.png" alt="image-20230706225516667" style="zoom:80%;" /></p><p>在需要显示数学公式的文档前面添加<code>math: true</code>,之后页面就会显示公式。为了方便，可以打开<code>\scaffolds\post.md</code>文件，添加<code>math:</code>,这样，在以后需要显示公式的文档中将math后面添加true即可。</p><h3 id="参考链接">参考链接</h3><hr /><p><a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid用户手册</a></p><p><ahref="https://zhuanlan.zhihu.com/p/35988761">Hexo构建blog时渲染LaTeX数学公式的问题</a></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>log输出函数总结</title>
    <link href="/2023/04/15/log%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/15/log%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>在调试程序时，会经常需要将某些信息输出到电脑，便于查找问题原因，快速解决问题。printf函数作为已经封装好的信息输出函数，会被经常使用到，下面介绍一些它的使用方式：</p><ul><li><h4 id="头文件-stdio.h-函数原型">头文件<strong>&lt;stdio.h&gt;</strong> 函数原型：</h4></li></ul><p><code>int printf ( const char * format, … );</code>返回值：正确返回输出的字符总数，错误返回负值。</p><ul><li><h4 id="调用格式">调用格式：</h4></li></ul><p><code>printf(“格式化字符串”, 输出表列);</code>格式化字符串包含：（1）字符串常量；（2）格式控制字符串；（3）转义字符。</p><ul><li>格式控制字符串形式:</li></ul><p><code>%[flags][width][.prec][length]type  //%[标志][最小宽度][.精度][类型长度]类型</code></p><div class="code-wrapper"><pre><code class="hljs c">标志:-左对齐, 默认右对齐<span class="hljs-number">0</span>右对齐时, 用<span class="hljs-number">0</span>填充宽度.(默认用空格填充)空格   输出值为正数时,在输出值前面加上空格, 为负数时加上负号#对x类型,在输出时加前缀<span class="hljs-number">0</span>x如：<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d\n&quot;</span>,<span class="hljs-number">1000</span>);     <span class="hljs-comment">//输出:( 1000)默认右对齐,左边补空格</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-5d\n&quot;</span>,<span class="hljs-number">1000</span>);     <span class="hljs-comment">//输出:(1000 )左对齐,右边补空格</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>,<span class="hljs-number">1000</span>);    <span class="hljs-comment">//输出:(01000)前面补0</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x\n&quot;</span>,<span class="hljs-number">1000</span>);  <span class="hljs-comment">//输出:0x3e8</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.0f %#.0f\n&quot;</span>,<span class="hljs-number">1000.0</span>,<span class="hljs-number">1000.0</span>);<span class="hljs-comment">//输出:(1000 1000.)当小数点后不输出值时依然输出小数点</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c">类型长度:长度         修饰类型 含义hhd、i、o、u、x输出 <span class="hljs-type">char</span>hd、i、o、u、x输出 <span class="hljs-type">short</span> <span class="hljs-type">int</span>ld、i、o、u、x输出 <span class="hljs-type">long</span> <span class="hljs-type">int</span>lld、i、o、u、x输出 <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>如：<span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-type">short</span> <span class="hljs-type">int</span> b = <span class="hljs-number">123</span>;<span class="hljs-type">int</span>  c = <span class="hljs-number">123</span>;<span class="hljs-type">long</span> <span class="hljs-type">int</span> d = <span class="hljs-number">123</span>;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> e = <span class="hljs-number">123</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%hhd\n&quot;</span>, a); <span class="hljs-comment">// 97</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%hd\n&quot;</span>, b); <span class="hljs-comment">// 123</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c); <span class="hljs-comment">// 123</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>, d); <span class="hljs-comment">// 123</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, e); <span class="hljs-comment">// 123</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c">类型:d有符号<span class="hljs-number">10</span>进制整型i有符号<span class="hljs-number">10</span>进制整型u无符号<span class="hljs-number">10</span>进制整型o无符号<span class="hljs-number">8</span>进制整型x无符号<span class="hljs-number">16</span>进制整型X无符号<span class="hljs-number">16</span>进制整型f单、双精度浮点数(默认保留<span class="hljs-number">6</span>位小数)e / E以指数形式输出单、双精度浮点数g / G以最短输出宽度,输出单、双精度浮点数c字符s字符串p地址如：有符号十进制:  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-number">123</span>);<span class="hljs-comment">//输出123</span>无符号十进制:   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u&quot;</span>,<span class="hljs-number">-10</span>);<span class="hljs-comment">//不可以输出负数,输出429496786</span>无符号八进制:    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%o&quot;</span>,<span class="hljs-number">123</span>);<span class="hljs-comment">//输出123</span>无符号十六进制： <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x 0x%X&quot;</span>,<span class="hljs-number">123</span>,<span class="hljs-number">123</span>);  <span class="hljs-comment">//输出0x7b 0x7B</span>无符号十六进制： <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x %#X&quot;</span>,<span class="hljs-number">123</span>,<span class="hljs-number">123</span>);  <span class="hljs-comment">//输出0x7b 0X7B</span>字符型数据：  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,<span class="hljs-number">64</span>);<span class="hljs-comment">//输出A</span>字符串型数据： <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,<span class="hljs-string">&quot;测试test&quot;</span>);<span class="hljs-comment">//输出：测试test</span>单精度浮点数： <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.9f&quot;</span>,<span class="hljs-number">0.000000123</span>);<span class="hljs-comment">//输出0.000000123</span>科学计数法：  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%e %E&quot;</span>,<span class="hljs-number">0.000000123</span>,<span class="hljs-number">0.000000123</span>);<span class="hljs-comment">//输出1.230000e-07 1.230000E-07</span></code></pre></div><ul><li><h4 id="ansi-c标准中有几个标准预定义宏也是常用的">ANSIC标准中有几个标准预定义宏（也是常用的）:</h4></li></ul><div class="code-wrapper"><pre><code class="hljs c">__LINE__：当前的函数行 (<span class="hljs-type">int</span>)__FILE__：当前程序源文件 (<span class="hljs-type">char</span>*)__DATE__：在源文件中插入当前的编译日期__TIME__：在源文件中插入当前编译时间__STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为<span class="hljs-number">1</span>__FUNCTION__:  当前运行的函数 (<span class="hljs-type">char</span>*)__cplusplus：当编写C++程序时该标识符被定义。如：<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file: %s\n&quot;</span>, __FILE__);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;function: %s\n&quot;</span>, __FUNCTION__);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;line: %d\n&quot;</span>, __LINE__);</code></pre></div><ul><li><h4 id="字符串化操作符"><strong>#</strong> 字符串化操作符</h4></li></ul><p>可以使用 <strong>#</strong> 将当前的内容转换成字符串。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DPRINT(expr) printf(<span class="hljs-string">&quot;%s = %d\n&quot;</span>, #expr, expr);</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">int</span> x = <span class="hljs-number">3</span>;    <span class="hljs-type">int</span> y = <span class="hljs-number">5</span>;    DPRINT(x / y);    DPRINT(x + y);    DPRINT(x * y);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>执行结果：</p><div class="code-wrapper"><pre><code class="hljs c">x / y = <span class="hljs-number">0</span>x + y = <span class="hljs-number">8</span>x * y = <span class="hljs-number">15</span></code></pre></div><ul><li><h4 id="连接操作符"><strong>##</strong> 连接操作符</h4></li></ul><p><strong>##</strong>是C语言中的连接操作符，可以在编译的预处理阶段实现字符串连接的操作。在程序的调试语句中，<strong>##</strong> 常用的方式如下</p><p><code>#define DEBUG(fmt, args…) printf(fmt, ##args)</code></p><p>调试宏第一种形式:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(fmt, args...)\</span><span class="hljs-meta">do&#123;  \</span><span class="hljs-meta">    printf(<span class="hljs-string">&quot;file:%s function: %s line: %d &quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span>    <span class="hljs-built_in">printf</span>(fmt, #<span class="hljs-meta">#args); \</span><span class="hljs-meta">&#125;while(0)</span></code></pre></div><p>调试宏的第二种定义方式:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(fmt, args...)    printf(<span class="hljs-string">&quot;file:%s function: %s line: %d &quot;</span> \</span><span class="hljs-meta">fmt, __FILE__, __FUNCTION__, __LINE__, ##args)</span></code></pre></div><p>实例：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_DEBUG  <span class="hljs-comment">//开启DEBUG宏 #undef DEBUG （不开启宏）</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_DEBUG</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(fmt, args...) printf(<span class="hljs-string">&quot;file:%s function: %s line: %d &quot;</span> \</span><span class="hljs-meta">    fmt, __FILE__, __FUNCTION__, __LINE__, ##args)</span><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(fmt, args...)</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;        <span class="hljs-type">char</span> str[]=<span class="hljs-string">&quot;Hello World&quot;</span>;        debug(<span class="hljs-string">&quot;%s&quot;</span>,str);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><ul><li><h4 id="printf-函数重定向方法"><strong>printf()</strong>函数重定向方法</h4></li></ul><p>在C语言中 <strong>printf</strong>函数已经定义为默认输出到显示器的，在单片机中若要想在串口上显示，那就需要重定向<strong>printf</strong>。例如将 <strong>printf</strong> 函数重定向到<strong>USART1</strong>，这样就可以利用printf函数将单片机的数据通过串口调试助手打印到PC上。</p><p>printf函数底层实际是调用 <strong>fputc</strong> 函数，所以重定向<strong>printf</strong> 函数，就是重新写 <strong>fputc</strong>函数。</p><p>在 <strong>51单片机</strong> 中:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">uart1_send_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> value)</span>&#123;SBUF = value;<span class="hljs-keyword">while</span> (!TI); <span class="hljs-comment">//等待发送完成</span>TI = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 重定向printf函数 */</span><span class="hljs-type">char</span> <span class="hljs-title function_">putchar</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span>&#123;uart1_send_byte(ch);<span class="hljs-keyword">return</span> ch;&#125;</code></pre></div><p>在 <strong>STM32</strong> 中, 注意要勾选keil软件中<strong>TARGET</strong> 中的 <strong>USE Micro LIB</strong> 选项,然后进行重定义：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;    <span class="hljs-keyword">while</span> ((USART1 -&gt; SR &amp; <span class="hljs-number">0X40</span>)== <span class="hljs-number">0</span> );    USART1 -&gt; DR  = (<span class="hljs-type">uint8_t</span>)ch;    <span class="hljs-keyword">return</span>  ch;&#125;或者<span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;  USART_SendData(USARTx, (<span class="hljs-type">uint8_t</span>)ch); <span class="hljs-comment">/* 发送一个字节数据到串口 */</span>  <span class="hljs-keyword">while</span> (USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET);<span class="hljs-comment">/* 等待发送完毕 */</span>  <span class="hljs-keyword">return</span> (ch);&#125;或者<span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;  HAL_UART_Transmit(&amp;huartx, (<span class="hljs-type">uint8_t</span> *)&amp;ch, <span class="hljs-number">1</span>, <span class="hljs-number">0xffff</span>);  <span class="hljs-keyword">return</span> ch;&#125;</code></pre></div><p>此外，<strong>正点原子</strong>有另外一种半主机模式，也可以实现printf输出，只做了解：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span>   import (__use_no_semihosting)</span><span class="hljs-class"><span class="hljs-keyword">struct</span>  __<span class="hljs-title">FILE</span></span><span class="hljs-class">&#123;</span>   <span class="hljs-type">int</span>  handle ;&#125;;FILE  __stdout ;_sys_exit (<span class="hljs-type">int</span>  x)&#123;   x  =  x ;&#125;<span class="hljs-type">int</span>  <span class="hljs-title function_">fputc</span> <span class="hljs-params">(<span class="hljs-type">int</span>  ch , FILE   * f)</span>&#123;   <span class="hljs-keyword">while</span> ((USART1 -&gt; SR &amp; <span class="hljs-number">0X40</span> )== <span class="hljs-number">0</span>);    USART1 -&gt; DR  = (<span class="hljs-type">uint8_t</span>) ch ;    <span class="hljs-keyword">return</span>  ch ;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>printf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程常用英文单词及缩写汇总</title>
    <link href="/2023/04/15/%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%8F%8A%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB/"/>
    <url>/2023/04/15/%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%8F%8A%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>在写程序过程中，会经常定义变量、函数等，比较规范的做法是采用英文定义，这样，别人读到你的代码时，就会立刻了解它的意思，同时，在应用过程中，有些单词较复杂，为了代码的简洁，一般会采用它的缩写，下面介绍一些编程中常用的英文单词：</p><h3 id="正反属性词">正反属性词</h3><hr /><table style="width:100%;"><thead><tr class="header"><th style="text-align: left;">正义词</th><th>意思</th><th>反义词</th><th>意思</th><th>正义词</th><th>意思</th><th>反义词</th><th>意思</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">add</td><td>添加</td><td>remove</td><td>删除</td><td>begin</td><td>开启</td><td>end</td><td>结束</td></tr><tr class="even"><td style="text-align: left;">create</td><td>创建</td><td>destroy</td><td>销毁</td><td>insert</td><td>插入</td><td>delete</td><td>删除</td></tr><tr class="odd"><td style="text-align: left;">first</td><td>首先</td><td>last</td><td>最后</td><td>get</td><td>获取</td><td>release</td><td>发行</td></tr><tr class="even"><td style="text-align: left;">increment</td><td>增长</td><td>decrement</td><td>减少</td><td>put</td><td>放</td><td>get</td><td>获得</td></tr><tr class="odd"><td style="text-align: left;">add</td><td>添加</td><td>delete</td><td>删除</td><td>lock</td><td>锁住</td><td>unlock</td><td>解锁</td></tr><tr class="even"><td style="text-align: left;">open</td><td>打开</td><td>close</td><td>关闭</td><td>min</td><td>最小</td><td>max</td><td>最大</td></tr><tr class="odd"><td style="text-align: left;">old</td><td>旧的</td><td>new</td><td>新的</td><td>start</td><td>开始</td><td>stop</td><td>停止</td></tr><tr class="even"><td style="text-align: left;">next</td><td>下一个</td><td>previous</td><td>前一个</td><td>source</td><td>源头</td><td>target</td><td>目标</td></tr><tr class="odd"><td style="text-align: left;">show</td><td>展示</td><td>hide</td><td>隐藏</td><td>send</td><td>发送</td><td>receive</td><td>接收</td></tr><tr class="even"><td style="text-align: left;">source</td><td>来源</td><td>destination</td><td>目的地</td><td>copy</td><td>复制</td><td>paste</td><td>粘贴</td></tr><tr class="odd"><td style="text-align: left;">up</td><td>上</td><td>down</td><td>下</td><td>big</td><td>大</td><td>small</td><td>小</td></tr></tbody></table><h3 id="常用词及缩写">常用词及缩写</h3><hr /><table style="width:100%;"><thead><tr class="header"><th style="text-align: left;">英文单词(缩写)</th><th>意思</th><th>英文单词(缩写)</th><th>意思</th><th style="text-align: center;">英文单词(缩写)</th><th>意思</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">compare(cmp)</td><td>比较</td><td>utility (util)</td><td>实用程序</td><td style="text-align: center;">configuration(cfg)</td><td>配置</td></tr><tr class="even"><td style="text-align: left;">device(dev)</td><td>设备</td><td>information(info)</td><td>信息</td><td style="text-align: center;">error(err)</td><td>错误</td></tr><tr class="odd"><td style="text-align: left;">hexadecimal(hex)</td><td>十六进制</td><td>image (img)</td><td>图像</td><td style="text-align: center;">increment(inc)</td><td>增加</td></tr><tr class="even"><td style="text-align: left;">initialize(init)</td><td>初始化</td><td>function (func)</td><td>函数</td><td style="text-align: center;">maximum(max)</td><td>最大</td></tr><tr class="odd"><td style="text-align: left;">message(msg)</td><td>信息</td><td>array (arr)</td><td>数组</td><td style="text-align: center;">minimum(min)</td><td>最小</td></tr><tr class="even"><td style="text-align: left;">parameter(param)</td><td>参数</td><td>read(rd)</td><td>读</td><td style="text-align: center;">previous(prev)</td><td>前一个</td></tr><tr class="odd"><td style="text-align: left;">register(reg)</td><td>注册</td><td>hour (hr)</td><td>小时</td><td style="text-align: center;">semaphore(sem)</td><td>信号量</td></tr><tr class="even"><td style="text-align: left;">statistic(stat)</td><td>统计</td><td>value(val)</td><td>值</td><td style="text-align: center;">synchronize(syn)</td><td>同步</td></tr><tr class="odd"><td style="text-align: left;">temp(tmp)</td><td>临时变量</td><td>version(ver)</td><td>版本</td><td style="text-align: center;">buffer(buf)</td><td>缓存</td></tr><tr class="even"><td style="text-align: left;">argument(arg)</td><td>参数</td><td>user (usr)</td><td>用户</td><td style="text-align: center;">command(cmd)</td><td>命令</td></tr><tr class="odd"><td style="text-align: left;">clock(clk)</td><td>时钟</td><td>time (tm)</td><td>时间</td><td style="text-align: center;">reference (ref)</td><td>参考</td></tr><tr class="even"><td style="text-align: left;">power (pwr)</td><td>电源</td><td>system (sys)</td><td>系统</td><td style="text-align: center;">password (pw)</td><td>密码</td></tr><tr class="odd"><td style="text-align: left;">control (ctrl)</td><td>控制</td><td>standard (std)</td><td>标准</td><td style="text-align: center;">package (pkg)</td><td>安装包</td></tr><tr class="even"><td style="text-align: left;">number (num)</td><td>数目</td><td>signal (sig)</td><td>信号</td><td style="text-align: center;">negative(neg)</td><td>负极</td></tr><tr class="odd"><td style="text-align: left;">copy (cpy)</td><td>复制</td><td>return (ret)</td><td>返回</td><td style="text-align: center;">constant (const)</td><td>常量</td></tr><tr class="even"><td style="text-align: left;">check (chk)</td><td>检查</td><td>request (req)</td><td>请求</td><td style="text-align: center;">calculate (calc)</td><td>计算</td></tr><tr class="odd"><td style="text-align: left;">asynchronous(asyn)</td><td>异步</td><td>receive (recv)</td><td>接收</td><td style="text-align: center;">assembly (asm)</td><td>装配</td></tr><tr class="even"><td style="text-align: left;">application(app)</td><td>应用</td><td>alternate (alt)</td><td>交替</td><td style="text-align: center;">administrator(admin)</td><td>管理员</td></tr><tr class="odd"><td style="text-align: left;">technology(tech)</td><td>技术</td><td>pointer (ptr)</td><td>指针</td><td style="text-align: center;">adjust (adj)</td><td>调整</td></tr><tr class="even"><td style="text-align: left;">address (addr)</td><td>地址</td><td>picture (pic)</td><td>图片</td><td style="text-align: center;">position (pos)</td><td>位置</td></tr><tr class="odd"><td style="text-align: left;">acknowledge(ack)</td><td>承认</td><td>multiplication(mul)</td><td>乘</td><td style="text-align: center;">positive(pos)</td><td>正极</td></tr><tr class="even"><td style="text-align: left;">write(wr)</td><td>写</td><td>middle (mid)</td><td>中间</td><td style="text-align: center;">memory (mem)</td><td>内存</td></tr><tr class="odd"><td style="text-align: left;">variable (var)</td><td>变量</td><td>link (lnk)</td><td>链接</td><td style="text-align: center;">library (lib)</td><td>库</td></tr><tr class="even"><td style="text-align: left;">button (btn)</td><td>按钮</td><td>average (avg)</td><td>平均</td><td style="text-align: center;">attribute (attr)</td><td>属性</td></tr><tr class="odd"><td style="text-align: left;">column (col)</td><td>列</td><td>count (cnt)</td><td>计数</td><td style="text-align: center;">clear (clr)</td><td>清除</td></tr><tr class="even"><td style="text-align: left;">make (mk)</td><td>做</td><td>database(db)</td><td>数据库</td><td style="text-align: center;">current (cur)</td><td>当前</td></tr><tr class="odd"><td style="text-align: left;">object (obj)</td><td>对象</td><td>decrease (dec)</td><td>减少</td><td style="text-align: center;">debug (dbg)</td><td>调试</td></tr><tr class="even"><td style="text-align: left;">process (proc)</td><td>处理</td><td>delete (del)</td><td>删除</td><td style="text-align: center;">definition(def)</td><td>定义</td></tr><tr class="odd"><td style="text-align: left;">record (rec)</td><td>记录</td><td>difference (diff)</td><td>不同</td><td style="text-align: center;">destination(dest)</td><td>目的地</td></tr><tr class="even"><td style="text-align: left;">volume (vol)</td><td>音量，体积</td><td>length (leng)</td><td>长度</td><td style="text-align: center;">language(lang)</td><td>语言</td></tr><tr class="odd"><td style="text-align: left;">rename (ren)</td><td>重命名</td><td>display(disp)</td><td>显示</td><td style="text-align: center;">directory (dir)</td><td>目录</td></tr><tr class="even"><td style="text-align: left;">result (res)</td><td>结果</td><td>division(div)</td><td>除</td><td style="text-align: center;">distance (dist)</td><td>距离</td></tr><tr class="odd"><td style="text-align: left;">connection (conn)</td><td>连接</td><td>icon (ico)</td><td>图标</td><td style="text-align: center;">background (bg)</td><td>背景</td></tr><tr class="even"><td style="text-align: left;">structure(struct)</td><td>结构体</td><td>extension(ext)</td><td>拓展</td><td style="text-align: center;">experience(exp)</td><td>经验</td></tr><tr class="odd"><td style="text-align: left;">remove (rm)</td><td>移除</td><td>document (doc)</td><td>文档</td><td style="text-align: center;">dialog(dlg)</td><td>对话框</td></tr><tr class="even"><td style="text-align: left;">source (src)</td><td>源头</td><td>environment(env)</td><td>环境</td><td style="text-align: center;">driver (drv)</td><td>驱动</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言中位操作</title>
    <link href="/2023/04/14/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/04/14/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>嵌入式开发过程中，C语言的位操作在寄存器的设置中会经常用到，需要熟练掌握，从而在实际应用中灵活应用位操作，其中主要会用到它的三种基本操作方式，具体如下：</p><p><strong>清零操作</strong></p><p>如将 char型变量a的第七位(bit6)清零，其它位不变：</p><div class="code-wrapper"><pre><code class="hljs c">a &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);   <span class="hljs-comment">/* 1&lt;&lt;6 -&gt; 0100 0000 取反 -&gt; 1011 1111  位与 -&gt; bit6为0，其它位不变 */</span></code></pre></div><p><strong>置位操作</strong></p><p>如将 char型变量a的第七位(bit6)置1，其它位不变：</p><div class="code-wrapper"><pre><code class="hljs c">a |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<span class="hljs-comment">/* 1&lt;&lt;6 -&gt; 0100 0000 位或 -&gt; bit6为1，其它位不变 */</span></code></pre></div><p><strong>取反操作</strong></p><p>如将 char型变量a的第七位(bit6)取反，其它位不变：</p><div class="code-wrapper"><pre><code class="hljs c">a ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<span class="hljs-comment">/* 1&lt;&lt;6 -&gt; 0100 0000 异或 -&gt; bit6取反了，其它位不变 */</span></code></pre></div><p>下面介绍通过位操作，在实际应用中的使用。</p><p><strong>1. 获取32bit数据单字节:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BYTE0(x)    ((x &gt;&gt; 0) &amp; 0x000000FF)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BYTE1(x)    ((x &gt;&gt; 8) &amp; 0x000000FF)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BYTE2(x)    ((x &gt;&gt; 16) &amp; 0x000000FF)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BYTE3(x)    ((x &gt;&gt; 24) &amp; 0x000000FF)</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n = <span class="hljs-number">0x12345678</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, GET_BYTE0(n)); <span class="hljs-comment">//0x78</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, GET_BYTE1(n)); <span class="hljs-comment">//0x56</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, GET_BYTE2(n)); <span class="hljs-comment">//0x34</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, GET_BYTE3(n)); <span class="hljs-comment">//0x12        </span>&#125;</code></pre></div><p><strong>2. 获取32bit数据某一位:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BIT(x, n) ((x &amp; (1<span class="hljs-string">&lt;&lt;n)) &gt;</span>&gt; n)</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-comment">//0001_0010_0011_0100_0101_0110_0111_1000</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit0 is %d\r\n&quot;</span>, GET_BIT(a, <span class="hljs-number">0</span>));<span class="hljs-comment">//0</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit3 is %d\r\n&quot;</span>, GET_BIT(a, <span class="hljs-number">3</span>));<span class="hljs-comment">//1</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit28 is %d\r\n&quot;</span>, GET_BIT(a, <span class="hljs-number">28</span>));<span class="hljs-comment">//1</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit31 is %d\r\n&quot;</span>, GET_BIT(a, <span class="hljs-number">31</span>));<span class="hljs-comment">//0</span>&#125;</code></pre></div><p><strong>3. 获取32bit数据某连续几位的值:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 获取第[n:m]位的值(m&gt;n) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BITS(x, n, m)  ((x <span class="hljs-string">&lt;&lt; (31-m)) &gt;</span>&gt; (31-(m-n)))</span><span class="hljs-comment">/* 获取第[n:m]位的值(m&lt;n) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BITS(x, n, m)  ((x <span class="hljs-string">&lt;&lt; (31-n)) &gt;</span>&gt; (31-(n-m)))</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-comment">//0001_0010_0011_0100_0101_0110_0111_1000</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit[3, 1] is %x\r\n&quot;</span>, GET_BITS(a, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>));<span class="hljs-comment">//0100b</span>&#125;</code></pre></div><p><strong>4. 32bit数据清零某一字节:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BYTE0(x)  (x &amp; 0xFFFFFF00)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BYTE1(x)  (x &amp; 0xFFFF00FF)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BYTE2(x)  (x &amp; 0xFF00FFFF)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BYTE3(x)  (x &amp; 0x00FFFFFF)</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, CLEAR_BYTE0(a));<span class="hljs-comment">//0x12345600</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, CLEAR_BYTE1(a));<span class="hljs-comment">//0x12340078</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, CLEAR_BYTE2(a));<span class="hljs-comment">//0x12005678</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#.8x\r\n&quot;</span>, CLEAR_BYTE3(a));<span class="hljs-comment">//0x00345678</span>&#125;</code></pre></div><p><strong>5. 32bit数据清零某一位:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BIT(x, n)    (x &amp; ~(1&lt;&lt;n))</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-comment">//0001_0010_0011_0100_0101_0110_0111_1000</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit3 change to 0. 0x%x\r\n&quot;</span>, CLEAR_BIT(a, <span class="hljs-number">3</span>));<span class="hljs-comment">//0x12345670</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit6 change to 0. 0x%x\r\n&quot;</span>, CLEAR_BIT(a, <span class="hljs-number">6</span>));<span class="hljs-comment">//0x12345638</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit28 change to 0. 0x%x\r\n&quot;</span>, CLEAR_BIT(a, <span class="hljs-number">28</span>));<span class="hljs-comment">//0x2345678</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit31 change to 0. 0x%x\r\n&quot;</span>, CLEAR_BIT(a, <span class="hljs-number">31</span>));<span class="hljs-comment">//0x12345678</span>&#125;</code></pre></div><p><strong>6. 32bit数据某一字节置位:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BYTE0(x)    x | 0x000000FF</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BYTE1(x)    x | 0x0000FF00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BYTE2(x)    x | 0x00FF0000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BYTE3(x)    x | 0xFF000000</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set byte0: 0x%x\r\n&quot;</span>, SET_BYTE0(a));<span class="hljs-comment">//0x123456ff</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set byte1: 0x%x\r\n&quot;</span>, SET_BYTE1(a));<span class="hljs-comment">//0x1234ff78</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set byte2: 0x%x\r\n&quot;</span>, SET_BYTE2(a));<span class="hljs-comment">//0x12ff5678</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set byte3: 0x%x\r\n&quot;</span>, SET_BYTE3(a));<span class="hljs-comment">//0xff345678</span>&#125;</code></pre></div><p><strong>7. 32bit数据某一位置位:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BIT(x, n)     x | (1&lt;&lt;n)</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-comment">//0001_0010_0011_0100_0101_0110_0111_1000</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set bit0 to 1: 0x%x\r\n&quot;</span>, SET_BIT(a, <span class="hljs-number">0</span>));<span class="hljs-comment">//0x12345679</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set bit3 to 1: 0x%x\r\n&quot;</span>, SET_BIT(a, <span class="hljs-number">3</span>));<span class="hljs-comment">//0x12345678</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set bit7 to 1: 0x%x\r\n&quot;</span>, SET_BIT(a, <span class="hljs-number">7</span>));<span class="hljs-comment">//0x123456f8</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set bit31 to 1: 0x%x\r\n&quot;</span>, SET_BIT(a, <span class="hljs-number">31</span>));<span class="hljs-comment">//0x92345678</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ASCII编码对照表</title>
    <link href="/2023/04/14/ASCII%E7%BC%96%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <url>/2023/04/14/ASCII%E7%BC%96%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/ascii.png"alt="ascii" /><figcaption aria-hidden="true">ascii</figcaption></figure><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/02.jpg"alt="../_images/02.jpg" /><figcaption aria-hidden="true">../_images/02.jpg</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ASCII</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows局域网共享文件</title>
    <link href="/2023/04/14/Windows%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"/>
    <url>/2023/04/14/Windows%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>有的时候，我们需要在两台电脑上进行局域网连接，通过一根网线，进行相应的简单设置，就可以实现这个目的，具体有以下4个步骤：</p><ul><li><strong>1.配置IP地址</strong></li><li><strong>2.关闭防火墙</strong></li><li><strong>3.更改“本地策略”</strong></li><li><strong>4.共享需要访问的文件夹</strong></li></ul><p>具体步骤如下：</p><p><strong>1.</strong> 将两台电脑中的其中一台的IPV4地址配置为：</p><div class="code-wrapper"><pre><code class="hljs dns">IP地址：<span class="hljs-number">192.168.1.101</span>子网掩码：<span class="hljs-number">255.255.255.0</span>默认网关：<span class="hljs-number">192.168.1.1</span></code></pre></div><p>另一台设置：</p><div class="code-wrapper"><pre><code class="hljs dns">IP地址：<span class="hljs-number">192.168.1.102</span> （此地址只要设置在同一网段即可）子网掩码：<span class="hljs-number">255.255.255.0</span>默认网关：<span class="hljs-number">192.168.1.1</span></code></pre></div><p><strong>2.</strong> 打开控制面板中的防火墙，关闭防火墙</p><p><strong>3.</strong><strong>Win+R</strong>，输入<strong>gpedit.msc</strong>打开本地策略，依次展开 <strong>计算机配置</strong> -&gt;<strong>Windows设置</strong> -&gt; <strong>本地策略</strong> -&gt;<strong>安全选项</strong>，双击其中的一个账户：<strong>账户：使用空白密码的本地账户只允许进行控制台登陆</strong>，改为 <strong>已禁用</strong> 点击确定。</p><p><strong>4.</strong> 右键需要共享的文件夹，选择共享即可。</p><p><strong>5.</strong> 访问操作，在一台电脑上<strong>Win+R</strong>，输入对方IP地址，如：\192.168.102即可看到共享的文件，同理在另一台电脑上<strong>Win+R</strong>输入\192.168.101即可看到另一台电脑上共享的文件夹或者进入电脑桌面的网络，选择相应的共享电脑，就可看到共享的文件夹（或者网络邻居进行访问）。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows变量路径与通配符</title>
    <link href="/2023/04/14/Windows%E5%8F%98%E9%87%8F%E8%B7%AF%E5%BE%84%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <url>/2023/04/14/Windows%E5%8F%98%E9%87%8F%E8%B7%AF%E5%BE%84%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p><code>%SystemDrive%</code> 操作系统所在的分区号。如 C:</p><p><code>%SystemRoot%</code> 操作系统根目录。如 C:</p><p><code>%windir%</code> 操作系统根目录。如 C:</p><p><code>%ALLUSERSPROFILE%</code> 相当于 C:and SettingsUsers</p><p><code>%APPDATA%</code> 相当于 C:and SettingsData</p><p><code>%ProgramFiles%</code> 相当于 C:Files</p><p><code>%CommonProgramFiles%</code> 相当于 C:FilesFiles</p><p><code>%HOMEDRIVE%</code>操作系统所在的分区号。如：C:</p><p><code>%HOMEPATH%</code> 相当于 and Settings</p><p><code>%USERPROFILE%</code> 相当于 C:and Settings</p><p><code>%ALLUSERSPROFILE%</code> 列出所有用户Profile文件位置。</p><p><code>%system%</code> 即C:</p><p><code>%APPDATA%</code> 列出应用程序数据的默认存放位置。</p><p><code>%CD%</code>列出当前目录。</p><p><code>%CLIENTNAME%</code>列出联接到终端服务会话时客户端的NETBIOS名。</p><p><code>%CMDCMDLINE%</code> 列出启动当前cmd.exe所使用的命令行。</p><p><code>%CMDEXTVERSION%</code> 命令出当前命令处理程序扩展版本号。</p><p><code>%CommonProgramFiles%</code> 列出了常用文件的文件夹路径。</p><p><code>%COMPUTERNAME%</code> 列出了计算机名。</p><p><code>%COMSPEC%</code>列出了可执行命令外壳（命令处理程序）的路径。</p><p><code>%DATE%</code> 列出当前日期。</p><p><code>%ERRORLEVEL%</code> 列出了最近使用的命令的错误代码。</p><p><code>%HOMEDRIVE%</code> 列出与用户主目录所在的驱动器盘符。</p><p><code>%HOMEPATH%</code> 列出用户主目录的完整路径。</p><p><code>%HOMESHARE%</code> 列出用户共享主目录的网络路径。</p><p><code>%LOGONSEVER%</code> 列出有效的当前登录会话的域名控制器名。</p><p><code>%NUMBER_OF_PROCESSORS%</code> 列出了计算机安装的处理器数。</p><p><code>%OS%</code> 列出操作系统的名字。(Windows XP 和 Windows 2000列为 Windows_NT.)</p><p><code>%Path%</code> 列出了可执行文件的搜索路径。</p><p><code>%PATHEXT%</code> 列出操作系统认为可被执行的文件扩展名。</p><p><code>%PROCESSOR_ARCHITECTURE%</code> 列出了处理器的芯片架构。</p><p><code>%PROCESSOR_IDENTFIER%</code> 列出了处理器的描述。</p><p><code>%PROCESSOR_LEVEL%</code> 列出了计算机的处理器的型号。</p><p><code>%PROCESSOR_REVISION%</code> 列出了处理器的修订号。</p><p><code>%ProgramFiles%</code> 列出了Program Files文件夹的路径。</p><p><code>%PROMPT%</code> 列出了当前命令解释器的命令提示设置。</p><p><code>%RANDOM%</code> 列出界于0 和 32767之间的随机十进制数。</p><p><code>%SESSIONNAME%</code>列出连接到终端服务会话时的连接和会话名。</p><p><code>%SYSTEMDRIVE%</code> 列出了Windows启动目录所在驱动器。</p><p><code>%SYSTEMROOT%</code> 列出了Windows启动目录的位置。</p><p><code>%TEMP%</code> 和 <code>%TMP%</code>列出了当前登录的用户可用应用程序的默认临时目录。</p><p><code>%TIME%</code> 列出当前时间。</p><p><code>%USERDOMAIN%</code> 列出了包含用户帐号的域的名字。</p><p><code>%USERNAME%</code> 列出当前登录的用户的名字。</p><p><code>%USERPROFILE%</code> 列出当前用户Profile文件位置。</p><p><code>%WINDIR%</code> 列出操作系统目录的位置。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>产品文档体系</title>
    <link href="/2023/04/14/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E4%BD%93%E7%B3%BB/"/>
    <url>/2023/04/14/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>产品在整个开发过程及售后都会涉及到文档的编写，具体文档如下：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/07.png"alt="../_images/07.png" /><figcaption aria-hidden="true">../_images/07.png</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>调试九法：软硬件错误的排除之道</title>
    <link href="/2023/04/14/%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%EF%BC%9A%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E9%99%A4%E4%B9%8B%E9%81%93/"/>
    <url>/2023/04/14/%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%EF%BC%9A%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E9%99%A4%E4%B9%8B%E9%81%93/</url>
    
    <content type="html"><![CDATA[<p>在嵌入式技术过程中，会经常进行debug调试，最近看了<strong>《调试九法：软硬件错误的排除之道》</strong>一书，里面详细介绍了九种不同的调试方式，针对不同的问题不同的状态进行不同的思考方式来进行解决，觉得很是受用。现记录如下：</p><h4 id="理解系统">1. 理解系统</h4><p>仔细查阅手册每个细节。</p><h4 id="制造失败">2. 制造失败</h4><p>从头开始复制现象，查找不受控制的条件，记录每件事情，不要过于相信统计数据。</p><h4 id="不要想而要看">3. 不要想，而要看</h4><p>查看细节，并使用外部调试工具</p><h4 id="分而治之">4. 分而治之</h4><p>主次逼近缩小搜索范围，使用易于查看的测试模式。</p><h4 id="一次只改一个地方">5. 一次只改一个地方</h4><p>隔离关键因素，一次只改动一个测试，与正常情况进行对比，确定自从上一次正常工作以来改动的地方。</p><h4 id="保持审计跟踪">6. 保持审计跟踪</h4><p>记下你的每步操作、顺序和结果，记录任何细节，最好用计算机记录下来附加到bug报告中，可以之道修订版本信息。</p><h4 id="检查插头">7. 检查插头</h4><p>质疑你的假设，尤其是一些显而易见的假设，从头开始检查，对工具进行测试。</p><h4 id="获得全新观点">8. 获得全新观点</h4><p>征求别人的意见，获取专业知识，听取别人的经验，报告症状而不要讲你的理论。</p><h4 id="如果你不修复bug它将依然存在">9.如果你不修复bug，它将依然存在</h4><p>bug从来不会自己消失，从根本上解决问题。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora基本用法</title>
    <link href="/2023/04/14/Typora%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2023/04/14/Typora%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。typora软件大部分语法都可以通过快捷键和鼠标右键来完成，具体如下：</p><h4 id="标题级别">标题级别</h4><p>使用简单的 <code>ctrl+数字键</code> 就可以快速完成各种级别的标题</p><h4 id="高亮显示">高亮显示</h4><p><code>==文字==</code> 文字两字就会高亮</p><h4 id="下划线">下划线</h4><p>ctrl + u</p><p><u>下划线</u></p><h4 id="斜体">斜体</h4><p>使用 <code>*单个星号*</code> 或者 <code>_单下划线_</code>可以字体倾斜。快捷键 <code>Ctrl + I</code></p><p><em>斜体</em></p><h4 id="加粗">加粗</h4><p>使用 <code>**两个星号**</code> 或者 <code>__两个下划线__</code>可以字体加粗。快捷键 <code>Ctrl + B</code></p><p><strong>加粗</strong></p><h4 id="删除线">删除线</h4><p>使用<code>~~删除线~~</code></p><p><del>删除线</del></p><h4 id="引用文字">引用文字</h4><p>&gt; + 空格 + 引用文字</p><blockquote><p>这是一段引用文字</p><blockquote><p>换行</p></blockquote></blockquote><h4 id="无序列表">无序列表</h4><p>-或+或* + space + enter</p><ul><li><p>AAA</p></li><li><p>BBB</p></li><li><p>CCC</p></li></ul><h4 id="嵌套无序列表">嵌套无序列表</h4><p>在删除第一级后，自动跳到下一级，返回上一级，连续按次enter</p><h4 id="有序列表">有序列表</h4><p>数字键 + space + enter</p><ol type="1"><li><p>AAA</p></li><li><p>BBB</p></li><li><p>CCC</p></li></ol><h4 id="任务列表">任务列表</h4><p>鼠标右键选择对勾即可。</p><h4 id="代码块">代码块</h4><ul><li><p>插入单句或单词，使用反引号（`） 把其包围</p><p><code>prinf();</code></p></li><li><p>插入代码段，输入3个反引号（`） +enter，并在后面选择一个语言名称即可实现语法高亮。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">helloworld</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello,world!&quot;</span>)</code></pre></div></li></ul><h4 id="表格">表格</h4><p>使用鼠标右键插入表格或快捷键Ctrl + T。</p><h4 id="分割线">分割线</h4><p>输入 <code>***</code> 或者 <code>---</code>再按回车即可绘制一条水平线，如下：</p><hr /><h4 id="脚注">脚注</h4><p><code>文字[^脚注]</code></p><p>这是一个脚注[^1]</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414224318716.png"/></p><h4 id="目录toc">目录（TOC）</h4><p>输入 <code>[toc]</code>然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。</p><h4 id="插入图片">插入图片</h4><p>直接拖进来或鼠标右键插入图像</p><h4 id="链接">链接</h4><p><code>[链接名](http://example.com/)</code></p><p><a href="http://example.com/">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reST基础语法</title>
    <link href="/2023/04/14/reST%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/04/14/reST%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>RestructureText(ReST)是Docutils和Sphinx都使用的默认明文标记语言。Docutils提供了基本的重构文本语法，而Sphinx对此进行了扩展，以支持额外的功能。可以使用在线的rst编辑器了解相关语法：<ahref="http://rst.ninjs.org/">rst在线编辑器</a>，下面介绍它的一些常用语法：</p><h2 id="章节标题">1. 章节标题</h2><p>在文本下一行（或上一行）添加至少与文本长度同宽的符号，即可以使文本成为标题,<code>= - ` : ' " ~ ^ _ * + # &lt; &gt;</code> 这些符号都可以</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">===============    一级标题~~~~~~~~~~~~~~~    二级标题---------------    三级标题^^^^^^^^^^^^^^^    四级标题&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;    五级标题***************    六级标题</code></pre></div><p>效果如下： <imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/section.png"alt="章节级数" /></p><h2 id="字体样式">2. 字体样式</h2><p>符号外侧必须留有空格, 英文标点符号::</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">**强调***斜体*``红色字体块``:guilabel:`背景块`.. centered:: 黑体中心字体</code></pre></div><p>效果如下： <imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414210438330.png"alt="image-20230414210438330" /></p><div class="code-wrapper"><pre><code class="hljs reStructuredText">无序列表:- hhhhhhhh- hhhhhhhh- hhhhhhhh* 列表第一级   + 第二级       - 第三级   + 第二级的另一个项目有序列表:支持数字、大小写字母和罗马数字1. hhhhhhhh#. hhhhhhhh#. hhhhhhhha. hhhhhhhh#. hhhhhhhh#. hhhhhhhh</code></pre></div><p>效果如下： <imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414210520680.png"alt="image-20230414210520680" /></p><h2 id="提示框">3. 提示框</h2><p>特殊提示支持警告、重要、提示、注意等标签，适合做显眼的用途。</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. note:: This is note.(注解).. attention:: Directives at large.(注意).. warning:: This is warning.(警告).. caution:: Don&#x27;t take any wooden nickels.(警告).. seealso:: This is seealso.(参见).. danger:: Mad scientist at work!(危险).. error:: Does not compute.(错误).. hint:: It&#x27;s bigger than a bread box.(提示).. important::   - Wash behind your ears.  - Clean up your room.  - Call your mother.  - Back up your data.(重要).. tip:: 15% if the service is good.(小技巧).. admonition:: by the way  You can make up your own admonition too.</code></pre></div><p>效果如下：<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414210957097.png" alt="image-20230414210957097" style="zoom: 50%;" /></p><h2 id="超链接">4. 超链接</h2><div class="code-wrapper"><pre><code class="hljs reStructuredText">1.直接嵌入： `野火公司官网 &lt;http://www.embedfire.com&gt;`_2.使用引用的方式把具体网址定义在其它地方： - 单个词汇：External hyperlinks, like Python_.- 多个词汇时，使用``, `fire website`_.. _Python: http://www.python.org/     .. _fire website: http://www.embedfire.com</code></pre></div><p>效果：<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414211213549.png" alt="image-20230414211213549" style="zoom:80%;" /></p><h2 id="图片">5. 图片</h2><p>显示图片直接使用image或figure指令，还需要添加“alt”选项指定图片的描述（类似doc中的题注），以便图片加载失败时显示文字,<strong>不要使用bmp图片</strong>，bmp图片在生成pdf的时候会丢失，所以不要使用bmp格式的图片。</p><p>figure命令</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. figure: pic/fire.png    :alt: 野火logo    :align: center    :caption: 野火logo   align-&gt;&quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;center&quot;, or &quot;right&quot;</code></pre></div><p>image命令</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. image:: pic/fire.png    :align: center    :alt: 野火logo</code></pre></div><p>效果一样： <imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/fire.png"alt="野火logo" /></p><p>图片还可以使用 width、heigh、scale等参数，但不推荐使用。</p><h2 id="代码高亮">6. 代码高亮</h2><p>在reST文档中列出代码有三种方式：</p><ul><li><ol type="1"><li>单行代码 用 `code`，如：</li></ol><p>`#define LED P23`</p><p>效果： <code>#define LED P23</code></p></li><li><ol start="2" type="1"><li>简单代码块在代码块的上一个段落后面加2个冒号，空一行后开始代码块，代码块要缩进,如：</li></ol><div class="code-wrapper"><pre><code class="hljs reStructuredText">::     #此命令在主机执行     sudo apt install python     echo &quot;helloworld,this is a script test!&quot;</code></pre></div><p>效果：</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">#此命令在主机执行sudo apt install pythonecho &quot;helloworld,this is a script test!&quot;</code></pre></div></li><li><ol start="3" type="1"><li>复杂代码块使用code-block指导语句，还可以选择列出行号和高亮重点行等，如：</li></ol><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. code-block:: c:caption: test:name: test333:emphasize-lines: 2,4-9:linenos:int main()&#123;    printf(&quot;hello, world! This is a C program.\n&quot;);    for(int i=0;i&lt;10;i++ )&#123;    printf(&quot;output i=%d\n&quot;,i);&#125;return 0;&#125;注意：code-block 后面可以是不同的编程语言，sh、c、v(verilog)、python、makefile等caption -&gt; 代码前面显示的名字name -&gt; 自定义名字，方便其他地方使用此名字加下划线来引用emphasize-lines -&gt; 高亮的行linenos -&gt; 显示行数</code></pre></div></li></ul><h2 id="表格">7. 表格</h2><p>表格语法说明：http://docutils.sourceforge.net/docs/ref/rst/directives.html#csv-table,推荐使用列表式表格，修改比较方便,</p><h4 id="列表式表格">7.1 列表式表格</h4><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. list-table:: Frozen Delights!    :widths: 15 10 30    :header-rows: 1    * - Treat    - Quantity    - Description    * - Albatross    - 2.99    - On a stick!    * - Crunchy Frog    - 1.49    - If we took the bones out, it wouldn&#x27;t be    crunchy, now would it?    * - Gannet Ripple    - 1.99    - On a stick!</code></pre></div><p>效果：<imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414214027390.png"alt="image-20230414214027390" /></p><h4 id="普通表格">7.2 普通表格</h4><div class="code-wrapper"><pre><code class="hljs reStructuredText">=====  =====  =======A      B      A and B=====  =====  =======False  False  FalseTrue   False  FalseFalse  True   FalseTrue   True   True=====  =====  =======</code></pre></div><p>效果：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414214149304.png"alt="image-20230414214149304" /><figcaption aria-hidden="true">image-20230414214149304</figcaption></figure><h4 id="csv表格">7.3 CSV表格</h4><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. csv-table:: Frozen Delights!    :header: &quot;Treat&quot;, &quot;Quantity&quot;, &quot;Description&quot;    :widths: 15, 10, 30    &quot;Albatross&quot;, 2.99, &quot;On a stick!&quot;    &quot;Crunchy Frog&quot;, 1.49, &quot;If we took the bones out, it wouldn&#x27;t be    crunchy, now would it?&quot;    &quot;Gannet Ripple&quot;, 1.99, &quot;On a stick!&quot;</code></pre></div><p>效果： <imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414214306558.png"alt="image-20230414214306558" /></p><h2 id="引用">8. 引用</h2><h4 id="引用图片表格">8.1 引用图片、表格</h4><p>在图片、表格上面加一个下划线的引用标签，然后在下面通过 ref指令引用。示例1：</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. _my-reference-label:.. figure: pic/fire.png   :alt: 野火logo   :align: center   name   :ref:`my-reference-label`</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414214640426.png" alt="image-20230414214640426" style="zoom:67%;" /></p><p>示例2：</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. _Table1:.. table:: 拨码开关启动配置表    ==== ====== ========== ==== == ===    编号 名称   NAND FLASH eMMC SD USB    ==== ====== ========== ==== == ===    1    MODE0  0          0    0  1    2    MODE1  1          1    1  0    3    CFG1-4 1          0    0  X    4    CFG1-5 0          1    0  X    5    CFG1-6 0          1    1  X    6    CFG1-7 1          0    0  X    7    CFG2-3 0          1    0  X    8    CFG2-5 0          0    1  X    ==== ====== ========== ==== == ===:ref:`Table1` :ref:`自定义引用名称 &lt;Table1&gt;`</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414214843366.png" alt="image-20230414214843366" style="zoom: 67%;" /></p><h4 id="引用文档">8.2 引用文档</h4><div class="code-wrapper"><pre><code class="hljs reStructuredText">:doc:`base-syntax`链接到当前目录的base-syntax.rst文档，且显示为其标题:doc:`our two different sites &lt;base-syntax&gt;`链接到当前目录的base-syntax.rst文档</code></pre></div><p>效果：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414215033089.png"alt="image-20230414215033089" /><figcaption aria-hidden="true">image-20230414215033089</figcaption></figure><h4 id="引用非rst文档">8.3 引用非rst文档</h4><p>会呈现出点击后下载文件的效果。注意这种引用方式在生成pdf文件时链接会无效。</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">:download:`引用非rst的本地文档 &lt;base-syntax.rst&gt;`.</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414215143223.png" alt="image-20230414215143223" style="zoom:80%;" /></p><h2 id="脚注">9. 脚注</h2><p>与引用语法类似，只是它在正文中显示的不是文本，而是编号。</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">Footnote references, like [5]_.using [#]_ and [#]_.instant[#fourth]_ and [#third]_.reference[DOC]_.                                                                             Footnotes                                                       .. [5] A numerical footnote... [#] This is the first one. .. [#] This is the second one. .. [#third] a.k.a. third.. [#fourth] a.k.a. fourth .. [DOC] A citation</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414215340170.png" alt="image-20230414215340170" style="zoom:67%;" /></p><h2 id="rst格式">10. rst格式</h2><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. include:: ../README.rst在index.rst中添加其他rst文件.. contents:: 目录        生成目录.. section-numbering::生成的目录自动编号.. contents::    :local:  当前主题之下生成目录   :depth: 3  目录深度为3级</code></pre></div><h2 id="参考链接">参考链接</h2><ul><li><ahref="https://docutils.sourceforge.io/docs/user/rst/">restruct语法官网</a></li><li><ahref="https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html">reST参考网站</a></li><li><ahref="https://www.jianshu.com/p/1885d5570b37">其他参考网站</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sphinx + reST + github + ReadtheDocs编写在线文档</title>
    <link href="/2023/04/14/Sphinx-reST-github-ReadtheDocs%E7%BC%96%E5%86%99%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3/"/>
    <url>/2023/04/14/Sphinx-reST-github-ReadtheDocs%E7%BC%96%E5%86%99%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>使用标记语言(MarkupLanguage)写文档是当前比较流行的文档编写方式，目前标记语言主要有两种，Markdown和reStructuredText（简称reST)。很多开源项目的文档就是用Sphinx+reST做的，上传到github和ReadtheDocs，通过浏览器就可以直接查看带有格式的文档了。结合网上多个教程，总结了以下创建教程。</p><h3 id="安装软件包">1. 安装软件包</h3><hr /><ul><li>安装 <ahref="https://www.python.org/">python3</a>,并添加bin目录到环境变量中。</li><li>安装 <a href="https://git-scm.com/download">git软件</a>，并添加bin目录到环境变量中。</li><li>通过pip工具安装 <ahref="https://www.sphinx-doc.org/en/master/index.html">sphinx工具</a>,<code>pip install -U Sphinx</code> 或<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple sphinx</code></li><li>安装 <ahref="https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes">SphinxThemes</a>, 这里选择 <a href="https://sphinx-themes.org/">第三方主题</a>“Read the Docs”,<code>pip install sphinx sphinx-autobuild sphinx_rtd_theme</code> 或<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple sphinx sphinx-autobuild sphinx_rtd_theme</code></li></ul><h3 id="建立项目">2. 建立项目</h3><hr /><p>新建文件夹，这里命名为 <strong>doc_demo</strong> ,进入文件夹，按住<strong>shift键</strong> ，点击鼠标右键，选择<strong>在此处打开命令窗口</strong> ，弹出cmd命令行，运行sphinx-quickstart，根据需要命令行中的提示输入创建信息。这里我建立了一个<strong>doc</strong>的Project，版本是 <strong>1.0</strong>， 作者名为<strong>kayoungzhang</strong>，语言为 <strong>zh_CN</strong>,将source与build目录分开。</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">Microsoft Windows [版本 <span class="hljs-number">6.1</span><span class="hljs-number">.7601</span>]版权所有 (c) <span class="hljs-number">2009</span> Microsoft Corporation。保留所有权利。C:\Users\Administrator&gt;cd doc_demoC:\Users\Administrator\doc_demo&gt;sphinx-quickstartWelcome <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> Sphinx <span class="hljs-number">3.5</span><span class="hljs-number">.4</span> quickstart utility.Please enter values <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> following settings (just press Enter <span class="hljs-built_in">to</span>accept <span class="hljs-keyword">a</span> default <span class="hljs-built_in">value</span>, <span class="hljs-keyword">if</span> <span class="hljs-literal">one</span> is given <span class="hljs-keyword">in</span> brackets).Selected root path: .You have <span class="hljs-literal">two</span> options <span class="hljs-keyword">for</span> placing <span class="hljs-keyword">the</span> build <span class="hljs-built_in">directory</span> <span class="hljs-keyword">for</span> Sphinx output.Either, you use <span class="hljs-keyword">a</span> <span class="hljs-built_in">directory</span> <span class="hljs-string">&quot;_build&quot;</span> <span class="hljs-keyword">within</span> <span class="hljs-keyword">the</span> root path, <span class="hljs-keyword">or</span> you separate<span class="hljs-string">&quot;source&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;build&quot;</span> <span class="hljs-built_in">directories</span> <span class="hljs-keyword">within</span> <span class="hljs-keyword">the</span> root path.&gt; Separate source <span class="hljs-keyword">and</span> build <span class="hljs-built_in">directories</span> (y/n) [n]: yThe project name will occur <span class="hljs-keyword">in</span> several places <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> built documentation.&gt; Project name: doc&gt; Author name(s): kayoungzhang&gt; Project release []: <span class="hljs-number">1.0</span>If <span class="hljs-keyword">the</span> documents are <span class="hljs-built_in">to</span> be written <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> language other than English,you can select <span class="hljs-keyword">a</span> language here <span class="hljs-keyword">by</span> its language code. Sphinx will <span class="hljs-keyword">then</span>translate <span class="hljs-keyword">text</span> that <span class="hljs-keyword">it</span> generates <span class="hljs-keyword">into</span> that language.For <span class="hljs-keyword">a</span> list <span class="hljs-keyword">of</span> supported codes, see<span class="hljs-keyword">https</span>://www.sphinx-doc.org/en/master/usage/configuration.html<span class="hljs-comment">#confval-language.</span>&gt; Project language [en]: zh_CNCreating <span class="hljs-built_in">file</span> C:\Users\Administrator\doc_demo\source\conf.py.Creating <span class="hljs-built_in">file</span> C:\Users\Administrator\doc_demo\source\index.rst.Creating <span class="hljs-built_in">file</span> C:\Users\Administrator\doc_demo\Makefile.Creating <span class="hljs-built_in">file</span> C:\Users\Administrator\doc_demo\make.bat.Finished: An initial <span class="hljs-built_in">directory</span> structure has been created.You should now populate your master <span class="hljs-built_in">file</span> C:\Users\Administrator\doc_demo\source\index.rst <span class="hljs-keyword">and</span> <span class="hljs-built_in">create</span> other documentationsource <span class="hljs-built_in">files</span>. Use <span class="hljs-keyword">the</span> Makefile <span class="hljs-built_in">to</span> build <span class="hljs-keyword">the</span> docs, like so:make builderwhere <span class="hljs-string">&quot;builder&quot;</span> is <span class="hljs-literal">one</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> supported builders, e.g. html, latex <span class="hljs-keyword">or</span> linkcheck.C:\Users\Administrator\doc_demo&gt;</code></pre></div><p><strong>doc_demo</strong> 文件夹中出现一些文件：</p><ul><li>source和build分别是源文件目录和编译生成文件的存放目录</li><li>Makefile和make.bat分别是Linux和Windows下的makefile</li><li>conf.py是配置文件，index.rst是配置文档显示结构，_static是静态文件存放目录_templates是模板存放目录</li></ul><h3 id="conf.py配置">3. conf.py配置</h3><hr /><h4 id="更换主题">3.1 更换主题</h4><p>使用记事本打开文件 <strong>conf.py</strong>，找到<strong>theme</strong> 主题，屏蔽旧主题，更换新的主题。</p><div class="code-wrapper"><pre><code class="hljs clean"># html_theme = <span class="hljs-string">&#x27;alabaster&#x27;</span><span class="hljs-keyword">import</span> sphinx_rtd_themehtml_theme = <span class="hljs-string">&quot;sphinx_rtd_theme&quot;</span></code></pre></div><h4 id="添加主页logo">3.2 添加主页logo</h4><p>准备好logo文件</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">html_logo</span> = <span class="hljs-string">&#x27;./logo.png&#x27;</span></code></pre></div><h4 id="不显示源文件链接">3.3 不显示源文件链接</h4><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">html_show_sourcelink</span> = <span class="hljs-literal">False</span></code></pre></div><h4 id="支持markdown编辑及表格">3.4 支持markdown编辑及表格</h4><p>首先需要安装插件<strong>myst-parser，recommonmark，sphinx-markdown_tables</strong>:</p><div class="code-wrapper"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> myst-parserpip <span class="hljs-keyword">install</span> recommonmarkpip <span class="hljs-keyword">install</span> sphinx-markdown_tables</code></pre></div><p>然后在 <strong>conf.py</strong> 添加：</p><div class="code-wrapper"><pre><code class="hljs pgsql">extensions = [‘myst_parser’, ‘sphinx_markdown_tables’]<span class="hljs-keyword">from</span> recommonmark.<span class="hljs-keyword">parser</span> <span class="hljs-keyword">import</span> CommonMarkParsersource_parsers = &#123;                <span class="hljs-string">&#x27;.md&#x27;</span>: CommonMarkParser,&#125;source_suffix = [<span class="hljs-string">&#x27;.rst&#x27;</span>, <span class="hljs-string">&#x27;.md&#x27;</span>]</code></pre></div><h3 id="创建rst文件">4. 创建rst文件</h3><hr /><p>当需要创建自己的文档时，就在 <strong>source</strong>文件夹中创建，这里创建 <strong>sphinx.rst</strong> 和<strong>vscode.rst</strong> 文档，同时新建文件夹<strong>docxtorst</strong> ，并在其中创建 <strong>docxtorst.rst</strong>文档。在这三个文档中添加标题和内容。</p><h3 id="设置toctree">5. 设置toctree</h3><hr /><p>使用记事本打开 <strong>source</strong> 目录下的<strong>index.rst</strong>文件，根据刚才创建的文档和位置，填写以下内容：</p><div class="code-wrapper"><pre><code class="hljs elixir">.. toctree::   <span class="hljs-symbol">:maxdepth</span>: <span class="hljs-number">2</span>   <span class="hljs-symbol">:caption</span>: <span class="hljs-title class_">Table</span> of <span class="hljs-title class_">Contents</span>   <span class="hljs-symbol">:titlesonly</span>:   <span class="hljs-symbol">:numbered</span>:   sphinx   vscode   docxtorst/docxtorst</code></pre></div><p>说明：</p><div class="code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">maxdepth</span> -&gt;</span> 目录中可显示标题的最多级数，不添加则会显示文档中所有标题<span class="hljs-function"><span class="hljs-title">caption</span> -&gt;</span> toctree显示标题<span class="hljs-function"><span class="hljs-title">titleonly</span> -&gt;</span>只想显示toctree文档标题，而不显示同一级别的其他标题<span class="hljs-function"><span class="hljs-title">numbered</span> -&gt;</span> 给罗列的文档标题进行显示标号，子目录也会自动编号<span class="hljs-function"><span class="hljs-title">sphinx</span>、vscode -&gt;</span>当前index.rst文档所在目录下的sphinx.rst和vscode.rst文档<span class="hljs-function"><span class="hljs-title">docxtorst</span>/docxtorst -&gt;</span> docxtorst文件夹下的docxtorst.rst文档</code></pre></div><h3 id="编译输出">6. 编译输出</h3><hr /><p>在命令行中，运行 <code>make html</code> 编译生成html文件：</p><div class="code-wrapper"><pre><code class="hljs gams">C:\Users\Administrator\doc_demo&gt;make htmlRunning Sphinx v3<span class="hljs-number">.5</span><span class="hljs-number">.4</span>loading translations [zh_CN]... done<span class="hljs-function"><span class="hljs-title">loading</span></span> pickled environment... donemyst v0<span class="hljs-number">.14</span><span class="hljs-number">.0</span>: MdParserConfig(renderer=<span class="hljs-string">&#x27;sphinx&#x27;</span>, commonmark_only=False, dmath_allow_labels=True, dmath_allow_space=True, dmath_allow_digits=True, dmath_double_inline=False, update_mathjax=True, enable_extensions=[<span class="hljs-string">&#x27;dollarmath&#x27;</span>], disable_syntax=[], url_schemes=None, heading_anchors=None, html_meta=[], footnote_transition=True, substitutions=[], sub_delimiters=[<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>], words_per_minute=<span class="hljs-number">200</span>)building [mo]: targets <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> po <span class="hljs-keyword">files</span> that are out of datebuilding [html]: targets <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> source <span class="hljs-keyword">files</span> that are out of dateupdating environment: [config changed (<span class="hljs-string">&#x27;source_parsers&#x27;</span>)] <span class="hljs-number">4</span> added, <span class="hljs-number">0</span> changed, <span class="hljs-number">0</span>removed<span class="hljs-function"><span class="hljs-title">reading</span></span> sources... [<span class="hljs-number">100</span>%] vscode<span class="hljs-function"><span class="hljs-title">looking</span></span> <span class="hljs-keyword">for</span> now-outdated <span class="hljs-keyword">files</span>... none found<span class="hljs-function"><span class="hljs-title">pickling</span></span> environment... done<span class="hljs-function"><span class="hljs-title">checking</span></span> consistency... done<span class="hljs-function"><span class="hljs-title">preparing</span></span> documents... done<span class="hljs-function"><span class="hljs-title">Building</span></span> prefix dict from the default dictionary ...Loading <span class="hljs-keyword">model</span> from cache C:\Users\ADMINI~<span class="hljs-number">1</span>\AppData\Local\Temp\jieba.cacheLoading <span class="hljs-keyword">model</span> cost <span class="hljs-number">1.264</span> seconds.Prefix dict has been built succesfully.<span class="hljs-function"><span class="hljs-title">writing</span></span> output... [<span class="hljs-number">100</span>%] vscode<span class="hljs-function"><span class="hljs-title">generating</span></span> indices... genindex done<span class="hljs-function"><span class="hljs-title">writing</span></span> additional pages... search done<span class="hljs-function"><span class="hljs-title">copying</span></span> images... [<span class="hljs-number">100</span>%] docxtorst/media/docxto015.png<span class="hljs-function"><span class="hljs-title">copying</span></span> static <span class="hljs-keyword">files</span>... done<span class="hljs-function"><span class="hljs-title">copying</span></span> extra <span class="hljs-keyword">files</span>... donedumping search index in Chinese (code: zh)... done<span class="hljs-function"><span class="hljs-title">dumping</span></span> object inventory... donebuild succeeded.The HTML pages are in build\html.</code></pre></div><p>在build文件夹的html文件夹下, 打开html文件即可看到具体的网页实现：</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414133802554.png"alt="image-20230414133802554" /><figcaption aria-hidden="true">image-20230414133802554</figcaption></figure><h3 id="github或gitee托管">7. github或gitee托管</h3><hr /><p>以上的操作，只能在本地的浏览器查看文档，若想让所有人都能看到，需要部署到<strong>ReadtheDocs</strong>，在部署之前，要把代码托管到代码托管平台，这里选用github，也可以选gitee，国内访问使用速度快。</p><p>先到 <strong>github</strong> 上建立一个公开的仓库，如我建立一个名为<strong>doc</strong> 的仓库,然后在本地仓库中创建一个<strong>.gitignore</strong>文件，它的作用是将本地一些文件不上传到远程仓库，这里将<code>build/</code>填入此其中，最后打开 <strong>gitbash</strong>，将本地仓库上传到远端：</p><div class="code-wrapper"><pre><code class="hljs mipsasm">git initgit <span class="hljs-keyword">add </span>-Agit commit -m <span class="hljs-string">&quot;first commit&quot;</span>git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>github上远程库地址git push -u <span class="hljs-keyword">origin </span>master</code></pre></div><h3 id="readthedocs托管">8. ReadtheDocs托管</h3><hr /><p>在 <a href="https://readthedocs.org/">ReadtheDocs</a> 上注册一个账号,登陆后点击“<strong>Import</strong>”，给该文档项目填写一个名字比如：<strong>doc</strong>,添加你在GitHub上面的工程 <strong>HTTPS链接</strong>, 选择仓库类型为<strong>Git</strong>, 其他项目根据自己的需要填写,点击<strong>Create</strong>，创建完后会自动激活Webhooks，不用再去GitHub设置，从此只要你往这个仓库push内容，readthedoc上面的文档就会自动更新。可参考<ahref="https://github.com/rtfd/readthedocs.org">ReadtheDocs官方文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bat(批处理)指令与应用</title>
    <link href="/2023/04/13/Bat-%E6%89%B9%E5%A4%84%E7%90%86-%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/13/Bat-%E6%89%B9%E5%A4%84%E7%90%86-%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Windows下批处理指令在工作生活中有很大的应用，可实现自动化处理某些任务。打开window中的命令行窗口，输入相应命令加上/?可以查看各命令的详细使用方法（如 <strong>dir /?</strong>），下面介绍一些常用的指令：</p><hr /><h4 id="基本指令">基本指令</h4><p><code>rem 这是一条注释语句</code> ---&gt;命令行注释，可以回显</p><p><code>:: 这是一条注释语句</code> ---&gt;命令行注释，不可回显</p><p><code>pause</code> ---&gt;暂停批处理文件的执行，命令行提示<strong>请按任意键继续</strong></p><p><code>@echo off</code>---&gt;关闭回显，一般批处理文件第一行都是这句</p><p><code>echo off</code> ---&gt;从下一行开始关闭回显</p><p><code>echo on</code> ---&gt;从下一行开始打开回显</p><p><code>ehco.</code> ---&gt;换行</p><p><code>echo Y | rd /s E:\mybat</code> ---&gt;删除文件提示<strong>Y</strong></p><p><code>echo hello word &gt; E:\newfile.txt</code>---&gt;创建文件并向文件写内容</p><p><code>echo hello word &gt;&gt; E:\newfile.txt</code>---&gt;向文件追加内容</p><p><code>cls</code> ---&gt;清屏</p><p><code>title 这是一个标题</code> ---&gt;设置窗口标题</p><p><code>color 0A</code> ---&gt;设置窗口颜色，颜色的设置具体用法查看<strong>color /?</strong></p><p><code>dir</code> ---&gt;显示当前目录下文件</p><p><code>cd 路径</code> ---&gt;切换路径</p><p><code>call test1.bat</code>---&gt;在同一个命令窗口调用另一个批处理文件</p><p><code>start e:\test.txt</code>---&gt;打开命令行并执行一个新的程序</p><p><code>del /q/a/f d:\temp\*.*</code>---&gt;删除指定文件，参数的具体用法查看 <strong>del /?</strong></p><p><code>rd /s/q d:\temp</code> ---&gt;删除文件夹及子文件夹</p><p><code>md mybat</code> ---&gt;创建文件夹</p><p><code>copy C:\mybat.txt D:\</code>---&gt;复制文件，不能复制文件夹</p><p><code>ren d:\temp tmp</code> ---&gt;重命名文件</p><p><code>move mybat\1.txt myfile\</code> ---&gt;移动文件</p><p><code>find "abc" mybat\4.txt</code>---&gt;在文件中查找字符，参数的具体用法查看 <strong>find /?</strong></p><p><code>type c:\boot.ini</code> ---&gt;显示文件内容</p><p><code>date</code> ---&gt;显示系统日期</p><p><code>time</code> ---&gt;显示系统时间</p><p><code>:label</code> ---&gt;行标签</p><p><code>goto label</code> ---&gt;跳转到指定标签</p><p><code>tree d:\</code> ---&gt;显示目录结构</p><p><code>ping www.baidu.com</code> ---&gt;测试网络连接量</p><p><code>del a.txt &amp;&amp; echo OK</code>---&gt;顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令</p><p><code>del a.txt || echo error</code>---&gt;顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令</p><p><code>dir *.* /s/a | find /c ".exe"</code> --&gt;管道命令表示先执行dir 命令，对其输出的结果执行后面的 find 命令</p><hr /><h4 id="高级指令">高级指令</h4><p><strong><code>if</code> 判断命令</strong>,具体查看 <strong>if/?</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> not exist d:\test.bat (    <span class="hljs-built_in">echo</span> @<span class="hljs-built_in">echo</span> off&gt;d:\test.bat) <span class="hljs-keyword">else</span> (    del d:\test.bat) ::如果d盘不存在test.bat文件，则在d盘创建test.bat文件，并写入 @<span class="hljs-built_in">echo</span> off，如果存在则删除此文件</code></pre></div><p><strong><code>for</code> 循环命令</strong>，具体查看 <strong>for/?</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> %%i <span class="hljs-keyword">in</span> (d:\*.*) <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;%%i&quot;</span>  ::找出D盘下所有文件<span class="hljs-keyword">for</span> %%i <span class="hljs-keyword">in</span> (*.txt) <span class="hljs-keyword">do</span> find <span class="hljs-string">&quot;abc&quot;</span> %%i   ::对当前目录里所有的txt文件执行 find 命令<span class="hljs-keyword">for</span> /r d:\mp3 %%i <span class="hljs-keyword">in</span> (*.mp3) <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> %%i&gt;&gt;d:\mp3.txt   ::把 d:\mp3 及其子目录里的mp3文件的文件名都存到 d:\mp3.txt 里去<span class="hljs-keyword">for</span> /l %%i <span class="hljs-keyword">in</span> (2,1,8) <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> %%i   ::生成2345678序列，2是数字序列的开头，8是结尾，1表示每次加1<span class="hljs-keyword">for</span> /f <span class="hljs-string">&quot;skip=5 tokens=4&quot;</span> %%a <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;dir&#x27;</span>) <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> %%a   ::对<span class="hljs-built_in">dir</span>命令的结果，跳过前5行，余下每行取第4列</code></pre></div><p><strong><code>start</code></strong></p><div class="code-wrapper"><pre><code class="hljs bash">start <span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;D:\Program Files\Git\git-bash.exe&quot;</span> -c <span class="hljs-string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d;bash&quot;</span> ::通过命令窗口打开git-bash，并在git-bash中运行hexo命令，完成后bash窗口不关闭::参数说明： <span class="hljs-string">&quot;&quot;</span> ---&gt;用于执行计算机空白符::参数说明： -c ---&gt;设置启动命令参数，各个参数间用&amp;&amp;分隔::参数说明： ;bash结尾符 ---&gt;防止git-bash窗口关闭</code></pre></div><p><strong><code>set</code> 设置变量</strong>，具体查看 <strong>set/?</strong></p><ol type="1"><li>set接收用户输入数据</li></ol><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> /p param=请输入密码：<span class="hljs-built_in">echo</span> %param%</code></pre></div><ol start="2" type="1"><li>set定义变量</li></ol><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> p=aa1bb1aa2bb2           ::设置变量p并赋值，即aa1bb1aa2bb2, <span class="hljs-string">&quot;变量名=值&quot;</span> 中间不要有空格<span class="hljs-built_in">echo</span> %p%                     ::显示变量p代表的字符串，即aa1bb1aa2bb2<span class="hljs-built_in">echo</span> %p:~6%                  ::显示变量p中第6个字符以后的所有字符，即aa2bb2<span class="hljs-built_in">echo</span> %p:~6,3%                ::显示第6个字符以后的3个字符，即aa2<span class="hljs-built_in">echo</span> %p:~0,3%                ::显示前3个字符，即aa1<span class="hljs-built_in">echo</span> %p:~-2%                 ::显示最后面的2个字符，即b2<span class="hljs-built_in">echo</span> %p:~0,-2%               ::显示除了最后2个字符以外的其它字符，即aa1bb1aa2b<span class="hljs-built_in">echo</span> %p:aa=c%                ::用c替换变量p中所有的aa，即显示c1bb1c2bb2<span class="hljs-built_in">echo</span> %p:aa=%                 ::将变量p中的所有aa字符串置换为空，即显示1bb12bb2<span class="hljs-built_in">echo</span> %p:*bb=c%               ::第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2<span class="hljs-built_in">set</span> p=%p:*bb=c%              ::设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2<span class="hljs-built_in">set</span> /a p=39                  ::设置p为数值型变量，值为39<span class="hljs-built_in">set</span> /a p=39/10               ::支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3<span class="hljs-built_in">set</span> /a p=p/10                ::用 /a 参数时，在 = 后面的变量可以不加%直接引用<span class="hljs-built_in">set</span> /a p=”1&amp;0″               ::”与”运算，要加引号。<span class="hljs-built_in">set</span> p=                       ::取消p变量</code></pre></div><ol start="3" type="1"><li>set用于数字表达式</li></ol><div class="code-wrapper"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<span class="hljs-built_in">set</span> a=1&amp;<span class="hljs-built_in">set</span> b=6<span class="hljs-built_in">set</span> c=%a%+%b% <span class="hljs-built_in">echo</span> %c% ::输出1+6<span class="hljs-built_in">set</span> d=a+b<span class="hljs-built_in">echo</span> %d% ::输出a+b<span class="hljs-built_in">set</span> /a e=a+b<span class="hljs-built_in">echo</span> %e% ::输出7pause</code></pre></div><p><strong><code>变量%0--%9</code></strong> 命令行传递给批处理的参数</p><div class="code-wrapper"><pre><code class="hljs bash">%0 ::批处理文件本身%1 ::第一个参数%9 ::第九个参数%* ::从第一个参数开始的所有参数%~1     :: 删除引号(<span class="hljs-string">&quot;)，扩充 %1</span><span class="hljs-string">%~f1    :: 将 %1 扩充到一个完全合格的路径名</span><span class="hljs-string">%~d1    :: 仅将 %1 扩充到一个驱动器号</span><span class="hljs-string">%~p1    :: 仅将 %1 扩充到一个路径</span><span class="hljs-string">%~n1    :: 仅将 %1 扩充到一个文件名</span><span class="hljs-string">%~x1    :: 仅将 %1 扩充到一个文件扩展名</span><span class="hljs-string">%~s1    :: 扩充的路径指含有短名</span><span class="hljs-string">%~a1    :: 将 %1 扩充到文件属性</span><span class="hljs-string">%~t1    :: 将 %1 扩充到文件的日期/时间</span><span class="hljs-string">%~z1    :: 将 %1 扩充到文件的大小</span><span class="hljs-string">%~dp1   ::只将 %1 扩展到驱动器号和路径</span><span class="hljs-string">%~nx1   ::只将 %1 扩展到文件名和扩展名</span></code></pre></div><p><strong><code>net</code> 网络命令</strong></p><div class="code-wrapper"><pre><code class="hljs bash">::关闭/启动MySQL服务,等待停止/启动的过程,完成后执行之后的代码net start MySQLnet stop MySQLnet start   ::查看所有运行的服务</code></pre></div><p><strong><code>mshta</code></strong></p><div class="code-wrapper"><pre><code class="hljs bash">::可以调用vb脚本和js脚本mshta vbscript:window.execScript(<span class="hljs-string">&quot;alert(&#x27;hello world!&#x27;);&quot;</span>,<span class="hljs-string">&quot;javascript&quot;</span>)(window.close)mshta javascript:window.execScript(<span class="hljs-string">&quot;msgBox(&#x27;hello world!&#x27;)(window.close)&quot;</span>,<span class="hljs-string">&quot;vbs&quot;</span>)mshta vbscript:msgbox(<span class="hljs-string">&quot;弹窗单行显示内容&quot;</span>,65,<span class="hljs-string">&quot;弹窗的标题&quot;</span>)(window.close)mshta vbscript:CreateObject(<span class="hljs-string">&quot;Wscript.Shell&quot;</span>).popup(<span class="hljs-string">&quot;弹窗内容&quot;</span>,7,<span class="hljs-string">&quot;标题&quot;</span>,64)(window.close)::连续弹二个信息框mshta vbscript:execute(<span class="hljs-string">&quot;msgbox &quot;</span><span class="hljs-string">&quot;one BOX&quot;</span><span class="hljs-string">&quot;:msgbox &quot;</span><span class="hljs-string">&quot;two BOX&quot;</span><span class="hljs-string">&quot;:window.close&quot;</span>)</code></pre></div><p><strong><code>延时</code></strong></p><div class="code-wrapper"><pre><code class="hljs bash">ping 127.0.0.1 -n 3 &gt;nul ---&gt;延时3s<span class="hljs-built_in">timeout</span> /t 10   ---&gt;延迟10s，具体查看 <span class="hljs-built_in">timeout</span> /?</code></pre></div><p><strong><code>弹框</code></strong></p><ol type="1"><li>MSG命令方式</li></ol><div class="code-wrapper"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off::/time:5设置时间弹框的显示时间为5S,5S后自动关闭msg * /time:5 这里是弹窗显示的文本pause::设置弹窗的多行文本(<span class="hljs-built_in">echo</span> 这是弹窗的第一行文本<span class="hljs-built_in">echo</span> 这是第二行文本)|msg * /time:5pause</code></pre></div><ol start="2" type="1"><li>调用VBScript的MsgBox实现弹窗</li></ol><div class="code-wrapper"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> offmshta vbscript:msgbox(<span class="hljs-string">&quot;弹窗单行显示内容&quot;</span>,65,<span class="hljs-string">&quot;弹窗的标题&quot;</span>)(window.close)::多行显示文本可在文本中使用vbCrLf或vbNewLine<span class="hljs-built_in">set</span> msg=<span class="hljs-string">&quot;多行显示vbCrLf这是第二行vbNewLine这是第三行&quot;</span>mshta vbscript:msgbox(Replace(Replace(%msg%,<span class="hljs-string">&quot;vbCrLf&quot;</span>,vbCrLf),<span class="hljs-string">&quot;vbNewLine&quot;</span>,vbNewLine),6,<span class="hljs-string">&quot;自定义标题&quot;</span>)(window.close)MsgBox的button参数取值如下：0 = vbOKOnly - 只显示确定按钮。1 = vbOKCancel - 显示确定和取消按钮。2 = vbAbortRetryIgnore - 显示放弃、重试和忽略按钮。3 = vbYesNoCancel - 显示是、否和取消按钮。4 = vbYesNo - 显示是和否按钮。5 = vbRetryCancel - 显示重试和取消按钮。16 = vbCritical - 显示临界信息图标。32 = vbQuestion - 显示警告查询图标。48 = vbExclamation - 显示警告消息图标。64 = vbInformation - 显示信息消息图标。0 = vbDefaultButton1 - 第一个按钮为默认按钮。256 = vbDefaultButton2 - 第二个按钮为默认按钮。512 = vbDefaultButton3 - 第三个按钮为默认按钮。768 = vbDefaultButton4 - 第四个按钮为默认按钮。0 = vbApplicationModal - 应用程序模式：用户必须响应消息框才能继续在当前应用程序中工作。4096 = vbSystemModal - 系统模式：在用户响应消息框前，所有应用程序都被挂起。注意：第一组值 (0 - 5) 用于描述对话框中显示的按钮类型与数目；第二组值 (16, 32, 48, 64) 用于描述图标的样式；第三组值 (0, 256, 512) 用于确定默认按钮；第四组值 (0, 4096) 则决定消息框的样式。在将这些数字相加以生成 buttons 参数值时，只能从每组值中取用一个数字。</code></pre></div><h4 id="参考链接">参考链接</h4><p><ahref="https://www.jb51.net/article/245233.htm">bat脚本常用命令及亲测示例代码超详细讲解</a><ahref="https://blog.csdn.net/qq_43331089/article/details/124222342">Bat文件的创建及其命令大全</a></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo和Github Pages搭建个人博客</title>
    <link href="/2023/04/12/Hexo%E5%92%8CGithub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/04/12/Hexo%E5%92%8CGithub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="前言">1. 前言</h3><hr /><p>目前网上有很多第三方博客类型，像博客园，CSDN，简书，知乎等。也可以自己搭建个人技术博客，这里以Hexo+GithubPages为例搭建个人博客。Hexo是一个简单、快速、强大的基于Node.js的静态博客发布工具，支持Markdown格式，有众多优秀插件和主题。GithubPages 是 Github提供的一种免费的静态网页托管服务，可以用来托管博客、项目官网等静态网页。搭建步骤如下：</p><h3 id="开发环境">2. 开发环境</h3><hr /><p>需要安装开发环境<a href="https://nodejs.org/zh-cn">Node.js</a>和<ahref="https://git-scm.com/downloads">git</a></p><h4id="section"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412203324937.png" alt="image-20230412203324937" style="zoom: 67%;" /></h4><h4id="section-1"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412203447726.png" alt="image-20230412203447726" style="zoom: 67%;" /></h4><p>安装完成后，在桌面右键选择 <code>Git Bash Here</code>，命令窗口打开后，分别输入<code>git --version</code>,<code>node -v</code>, <code>npm -v</code>,如果弹出对应的版本号，则说明安装正确，否则，需要查找原因。<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412203622210.png" alt="image-20230412203622210" style="zoom:67%;" /></p><h3 id="安装-hexo">3. 安装 Hexo</h3><hr /><p>在你的电脑上创建一个博客文件夹，如：<code>F:\Blog</code>,进入此文件夹，右键打开<code>Git Bash Here</code>,依次输入</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-cli</span> <span class="hljs-string">-g</span>  <span class="hljs-comment"># 安装hexo</span><span class="hljs-string">hexo</span> <span class="hljs-string">init</span>                <span class="hljs-comment"># 初始化，安装所需包</span><span class="hljs-string">npm</span> <span class="hljs-string">install</span>              <span class="hljs-comment"># 新版本的Hexo在初始化时就安装好了依赖包</span><span class="hljs-string">hexo</span> <span class="hljs-string">g</span>                   <span class="hljs-comment"># 生成</span><span class="hljs-string">hexo</span> <span class="hljs-string">s</span>                   <span class="hljs-comment"># 启动本地服务</span></code></pre></div><p>打开浏览器访问 <code>http://localhost:4000</code>即可看到博客网页内容。第一次初始化的时候hexo已经帮我们写了一篇名为 HelloWorld 的文章。</p><h3 id="配置ssh-key">4. 配置SSH key</h3><hr /><p>ssh key用来解决本地和服务器的连接访问github权限问题。</p><h4 id="本地生成密钥对">4.1 本地生成密钥对</h4><p>在git bash命令行中执行 <code>cd ~/.ssh</code>, 如果弹出<code>No such file or directory</code>,说明你是第一次使用git。需要生成sshkey,否则说明你已经配置了SSH key，不需要再次操作。 在命令行中执行 ：</p><div class="code-wrapper"><pre><code class="hljs c">git config --global user.name <span class="hljs-string">&quot;填入你的github用户名&quot;</span>git config --global user.email <span class="hljs-string">&quot;填入你的email地址&quot;</span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;填入你的email地址&quot;</span></code></pre></div><p>连续三次回车，最终会在用户目录下生成文件，在用户目录下（C:）找到<code>.ssh\id_rsa.pub</code>文件，用记事本打开并复制里面的所有内容。</p><h4 id="添加公钥到github">4.2 添加公钥到Github</h4><p>打开你的github主页，进入Settings -&gt; SSH and GPG keys -&gt; New SSHkey：<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412203930192.png" alt="image-20230412203930192" style="zoom:67%;" /></p><p>添加完成后，还需要确认并添加主机到本机SSH可信列表，在 git bash中输入<code>ssh -T git@github.com</code> ,若返回<code>Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.</code>则证明添加成功。</p><h3 id="创建github远程仓库并与本地blog仓库关联">5.创建github远程仓库，并与本地blog仓库关联</h3><hr /><p>进入你的github主页，创建一个新的仓库，因为Github仅能使用一个同名仓库的代码托管一个静态站点，所以Repository名字必须是<strong>你的Github名.github.io</strong>，比如我的是<code>KayoungZhang.github.io</code></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412204212914.png" alt="image-20230412204212914" style="zoom: 67%;" /></p><p>打开本地blog仓库中配置文件 **_config.yml**，在末尾添加：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><span class="hljs-attr">type:</span> <span class="hljs-string">git</span><span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:你的用户名/你的用户名.github.io.git</span><span class="hljs-comment">#上一步的Github仓库地址，项目主页点SSH再复制url，不要采用http形式的url</span><span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><span class="hljs-comment">#填写远程仓库的分支名，新版本默认是main分支，老版本是master分支</span></code></pre></div><p>在blog文件夹中打开git bash命令行，安装hexo部署插件，然后进行部署。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-deployer-git</span> <span class="hljs-string">--save</span><span class="hljs-string">hexo</span> <span class="hljs-string">d</span></code></pre></div><p>在浏览器中输入网址： <strong>你的用户名.github.io</strong>，即可查看到网页。一般来说如果出现莫名的问题，按照以下步骤来解决。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">删除本地blog仓库中.deploy_git文件夹</span><span class="hljs-string">git</span> <span class="hljs-string">bash中执行命令</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><span class="hljs-string">hexo</span> <span class="hljs-string">g</span><span class="hljs-string">hexo</span> <span class="hljs-string">d</span></code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412204326064.png" alt="image-20230412204326064" style="zoom: 50%;" /></p><h3 id="写博客">6. 写博客</h3><hr /><p>在本地blog仓库中，打开<code>git bash</code>，执行命令<code>hexo new 'my-first-blog'</code>(my-first-blog是文件名)，hexo会帮我们在<code>source/_posts</code>下生成<strong>my-first-blog.md</strong>文件，打开文件，hexo自动添加了一些说明的文件头，后面只需要自己添加文章内容即可。写完后，执行以下命令完成网页上传部署，一般情况下编辑文章中的图片在网页上会无法正常显示，需要图床，将图片上传到网上，同时在主题目录下<strong>head.jade</strong>文件中添加<code>&lt;meta name="referrer" content="no-referrer" /&gt;</code>，具体操作和原因，参看博客<a href="https://zhuanlan.zhihu.com/p/102594554">PicGo +Gitee(码云)实现markdown图床</a>，<ahref="https://www.cnblogs.com/selier/archive/2018/09/01/9570650.html">Hexo使用细节及各种问题</a></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><span class="hljs-string">hexo</span> <span class="hljs-string">g</span> <span class="hljs-string">-d</span></code></pre></div><h3 id="个性化你的博客">7. 个性化你的博客</h3><hr /><h4 id="更换主题">7.1 更换主题</h4><p>默认主题不好看，可以进入 <ahref="https://hexo.io/themes/">hexo主题官网</a>选择自己喜欢的主题，进行更改。这里以 <strong>beautiful-hexo</strong>主题为例。进入本地blog文件夹中，右键打开 <code>Git Bash Here</code>,根据选择主题的 <strong>README.md</strong>文件执行相应命令:</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">--save</span> <span class="hljs-string">hexo-generator-archive</span> <span class="hljs-string">hexo-renderer-jade</span> <span class="hljs-string">hexo-generator-tag</span> <span class="hljs-string">hexo-generator-feed</span> <span class="hljs-string">hexo-generator-sitemap</span> <span class="hljs-string">hexo-browsersync</span> <span class="hljs-string">git</span> <span class="hljs-string">clone</span> <span class="hljs-string">--depth</span> <span class="hljs-number">1</span> <span class="hljs-string">https://github.com/twoyao/beautiful-hexo.git</span> <span class="hljs-string">themes/beautiful-hexo</span></code></pre></div><p>在blog文件夹中找到配置文件 **_config.yml** ,使用记事本打开，找到<strong>theme: landscape</strong> , 将 <strong>landscape</strong>改为<strong>beautiful-hexo</strong>,保存后，执行命令<code>hexo clean</code>, 清理一下public的内容，然后执行<code>hexo g</code>来重新生成, 最后打开本地服务器，执行<code>hexo s</code> ,打开浏览器就会看到新的主题界面。</p><figure><imgsrc="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230413074402552.png"alt="image-20230413074402552" /><figcaption aria-hidden="true">image-20230413074402552</figcaption></figure><h4 id="主题配置">7.2 主题配置</h4><p>打开<strong>主题目录</strong>下的配置文件**_config.yml**，可以进行自修改，不使用的功能进行注释（语句前添加#）</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">header:</span>   <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;Beautiful Hexo&quot;</span>   <span class="hljs-attr">motto:</span> <span class="hljs-string">不积跬步无以至千里，不积小流无以成江海</span>   <span class="hljs-attr">bigimgs:</span>       <span class="hljs-bullet">-</span> <span class="hljs-attr">src:</span> <span class="hljs-string">/bigimgs/01.jpg</span>         <span class="hljs-attr">desc:</span> <span class="hljs-string">beautiful</span> <span class="hljs-string">island</span>       <span class="hljs-bullet">-</span> <span class="hljs-attr">src:</span> <span class="hljs-string">/bigimgs/02.jpg</span>         <span class="hljs-attr">desc:</span> <span class="hljs-string">Tropical</span> <span class="hljs-string">Fish</span>       <span class="hljs-bullet">-</span> <span class="hljs-attr">src:</span> <span class="hljs-string">/bigimgs/03.jpg</span>         <span class="hljs-attr">desc:</span> <span class="hljs-string">ocean</span><span class="hljs-attr">mail:</span>  <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;mailto:zky0830@163.com&#x27;</span>  <span class="hljs-attr">title:</span> <span class="hljs-string">Email</span> <span class="hljs-string">me</span>  <span class="hljs-attr">icon:</span> <span class="hljs-string">fa-envelope</span>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><span class="hljs-attr">wechat:</span>  <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/wechat.png&#x27;</span> <span class="hljs-comment">#将图片放到source目录下</span>  <span class="hljs-attr">title:</span> <span class="hljs-string">Wechat</span>  <span class="hljs-attr">icon:</span> <span class="hljs-string">fa-wechat</span>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span></code></pre></div><h4 id="全局配置">7.3 全局配置</h4><p>打开配置文件 <code>_config.yml</code>，修改相应内容：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><span class="hljs-attr">title:</span> <span class="hljs-string">My</span> <span class="hljs-string">Tech</span> <span class="hljs-string">Blog</span> <span class="hljs-comment">#主页标题</span><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">#副标题</span><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">#网站描述</span><span class="hljs-attr">keywords:</span><span class="hljs-attr">author:</span> <span class="hljs-string">KayoungZhang</span> <span class="hljs-comment">#作者</span><span class="hljs-attr">language:</span> <span class="hljs-string">zh-cn</span> <span class="hljs-comment">#可根据themes主题中language选择相应语言</span><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment"># URL</span><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><span class="hljs-attr">url:</span> <span class="hljs-string">https://KayoungZhang.github.io</span> <span class="hljs-comment">#项目的 GitHub Pages网址</span><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><span class="hljs-attr">permalink_defaults:</span><span class="hljs-attr">pretty_urls:</span>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><span class="hljs-comment">#自定义站点内容搜索，需要安装插件：</span><span class="hljs-comment"># npm install hexo-generator-search --save</span><span class="hljs-attr">search:</span>  <span class="hljs-attr">path:</span> <span class="hljs-string">search.xml</span>  <span class="hljs-attr">field:</span> <span class="hljs-string">all</span> <span class="hljs-comment"># 如果只索引文章，可设置为post</span></code></pre></div><h4 id="创建文档标签和分类">7.4 创建文档、标签和分类</h4><p>创建标签和分类是为了便于管理和查找，为了给文章自动添加标识，比较方便的做法是，打开<strong>scaffolds</strong>目录下的<strong>post.md</strong>文档，添加<code>tags: 和 categories:</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> &#123;&#123; <span class="hljs-string">title</span> &#125;&#125;<span class="hljs-attr">date:</span> &#123;&#123; <span class="hljs-string">date</span> &#125;&#125;<span class="hljs-attr">tags:</span><span class="hljs-attr">categories:</span><span class="hljs-meta">---</span></code></pre></div><p>这样以后创建文档，它就会自动在文档开头添加标识，你只需要在相应标识下添加分类和标签（以<code>-</code>+空格开头）即可，注意：hexo一篇文章只能属于一个分类，不会产生两个分类，而是把分类嵌套。如下：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">Hexo和Github</span> <span class="hljs-string">Pages搭建个人博客</span><span class="hljs-attr">date:</span> <span class="hljs-number">2023-04-12 18:57:46</span><span class="hljs-attr">tags:</span> <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-bullet">-</span> <span class="hljs-string">入门</span><span class="hljs-attr">categories:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Blog</span></code></pre></div><p>进入本地blog仓库，打开<code>git bash</code>，通过不同的命令，创建相应的内容。</p><h5 id="创建文章">7.4.1 创建文章</h5><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">&quot;填入你的文章名&quot;</span></code></pre></div><p>在<code>source/_posts</code>目录下就会生成创建的文档，打开进行写作即可。</p><h5 id="创建标签">7.4.2 创建标签</h5><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">page</span> <span class="hljs-string">tags</span></code></pre></div><p>在<strong>source/tags/</strong>目录下会生成<strong>index.md</strong>文档，打开此文档，添加<code>layout: "tags"</code>到文档中保存退出，如：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">tags</span><span class="hljs-attr">date:</span> <span class="hljs-number">2023-04-12 11:12:33</span><span class="hljs-attr">layout:</span> <span class="hljs-string">&quot;tags&quot;</span><span class="hljs-meta">---</span></code></pre></div><p>要想在主页显示标签栏，需要进入主题配置文件<code>_config.yml</code>，添加标签栏</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">navbar-links:</span><span class="hljs-string">...</span><span class="hljs-attr">Tags:</span> <span class="hljs-string">/tags</span></code></pre></div><p>点击首页的 “tags”可以看到该标签页下的所有文章。当然，只有文章中添加了tag属性的才会被收录到首页的“标签” 中。</p><h5 id="创建分类">7.4.3 创建分类</h5><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">page</span> <span class="hljs-string">categories</span></code></pre></div><p>在<strong>source/categories</strong>目录下生成的<strong>index.md</strong>文档，打开文档，添加<code>layout: "categories"</code>到内容中,保存退出，如：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">categories</span><span class="hljs-attr">date:</span> <span class="hljs-number">2023-04-12 19:05:47</span><span class="hljs-attr">layout:</span> <span class="hljs-string">&quot;categories&quot;</span><span class="hljs-meta">---</span></code></pre></div><p>同理，要想在主页显示分类栏，需要进入主题配置文件<code>_config.yml</code>，添加分类栏：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">navbar-links:</span>  <span class="hljs-string">...</span>  <span class="hljs-attr">Categories:</span> <span class="hljs-string">/categories</span></code></pre></div><p>对于<strong>beautiful-hexo</strong>主题，还需要在主题的<strong>layout</strong>目录下创建<strong>categories.jade</strong>文件，内容如下（<em>因为不会前端知识，所以根据tags.jade编写</em>）：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">extends</span> <span class="hljs-string">partial/base</span><span class="hljs-string">block</span> <span class="hljs-string">header</span>    <span class="hljs-string">header.header-section</span>        <span class="hljs-string">.intro-header.no-img</span><span class="hljs-string">block</span> <span class="hljs-string">content</span>    <span class="hljs-string">.container</span>        <span class="hljs-string">.row</span>            <span class="hljs-string">.col-lg-6.col-lg-offset-3.col-md-10.col-md-offset-1</span>                <span class="hljs-bullet">-</span> <span class="hljs-string">site.categories.map(function(category)</span> &#123;                      <span class="hljs-string">if</span> <span class="hljs-string">category.posts.length</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">0</span>                        <span class="hljs-string">ul.archive-list</span>                            <span class="hljs-string">span.fa.fa-category.listing-seperator(id=category.name</span>, <span class="hljs-string">style=&quot;font-size:</span> <span class="hljs-number">1.</span><span class="hljs-string">17em;&quot;)</span>                            <span class="hljs-string">span(style=&quot;font-size:</span> <span class="hljs-number">1.</span><span class="hljs-string">5em;</span> <span class="hljs-attr">font-weight:</span> <span class="hljs-string">bold;</span> <span class="hljs-attr">margin-left:</span> <span class="hljs-string">5px;&quot;)=</span> <span class="hljs-string">category.name</span>                            <span class="hljs-bullet">-</span> <span class="hljs-string">category.posts.map(function(post)</span> &#123;                                <span class="hljs-string">li.col-lg-offset-1.col-md-offset-1</span>                                    <span class="hljs-string">span.post-meta=</span> <span class="hljs-string">full_date(post.date</span>, <span class="hljs-string">&#x27;MMM D&#x27;</span><span class="hljs-string">)</span>                                    <span class="hljs-string">a.post-title(href=url_for(post.path))=</span> <span class="hljs-string">post.title</span>                            <span class="hljs-bullet">-</span> &#125;<span class="hljs-string">)</span>                <span class="hljs-bullet">-</span> &#125;<span class="hljs-string">)</span></code></pre></div><p>点击首页的 “categories” 可以看到该分类下的所有文章。 参考博客：<ahref="https://www.baidu.com/link?url=jNXzClJm8Ve2gFpOPz9vyfQiMfkrP7icKAOSfJyszHlh2vGqYoCZ9YDXU5T1aZj86pjyFXrf4lrjp6Mwj80qSa&amp;wd=&amp;eqid=f4337b38000dc2e90000000664376496">使用Hexo创建文章、标签和分类</a></p><h3 id="hexo博客同时发布到github和gitee">8.Hexo博客同时发布到github和gitee</h3><hr /><p>因为github服务器在国外，所以打开网页比较慢，国内的giteepages具有同样的部署功能，打开网页就会更快一些，所以可以将hexo博客同步到gitee上，它的部署发布与github差不多，就是每次更新完博客后，gitee部署时需要进入Pages页面进行手动更新，不再过多赘述，具体参照这篇博客：<ahref="https://blog.csdn.net/qq_23858785/article/details/123104823">hexo博客同时发布到github和gitee</a></p><p>本地博客文件同时上传到github和gitee：<ahref="https://blog.csdn.net/yilovexing/article/details/107226141">如何将一个项目同时提交到GitHub和Gitee(码云)两个仓库</a></p><h3 id="多台设备同步更新hexo博客">9. 多台设备同步更新Hexo博客</h3><hr /><p>真正的原始Hexo博客内容在我们的电脑本地，上传到网页上的内容是public文件夹里面的静态内容，有的时候写文章需要在不同的电脑上操作，这样就需要博客项目在不同设备间的迁移与同步，具体操作参照博客：<ahref="https://blog.csdn.net/K1052176873/article/details/122879462">Hexo在多台电脑上提交和更新</a><ahref="https://blog.csdn.net/qq_30105599/article/details/118302086">多台电脑同步更新Hexo博客</a></p><p>以上是备份本地博客内容到云端仓库，所以所有人都能看到你的源文件，如果不想让人看到你的源文件，只需在云端仓库新建一个仓库，再与本地博客仓库关联起来即可。之后在不同的设备上，gitclone这个云端新仓库，然后按照正常方式操作即可。</p><h3 id="参考链接">参考链接</h3><hr /><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a> <ahref="https://segmentfault.com/a/1190000017986794">超详细Hexo+GithubPage搭建技术博客教程</a> <ahref="https://lovenight.github.io/2015/11/10/Hexo-3-1-1-静态博客搭建指南/?">Hexo3.1.1静态博客搭建指南</a></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
