<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PID控制器算法进阶</title>
    <link href="/2023/09/25/PID%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/09/25/PID%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p>PID算法中处理方式有：</p><ul><li><p>pid算法巩固</p><p><a href="https://blog.csdn.net/foxclever/article/details/80250994">https://blog.csdn.net/foxclever/article/details/80250994</a></p></li><li><p>积分分离</p><p><a href="https://blog.csdn.net/foxclever/article/details/80274790">https://blog.csdn.net/foxclever/article/details/80274790</a></p></li><li><p>抗积分饱和</p><p><a href="https://blog.csdn.net/foxclever/article/details/80294264">https://blog.csdn.net/foxclever/article/details/80294264</a></p></li><li><p>梯形积分</p><p><a href="https://blog.csdn.net/foxclever/article/details/80297989">https://blog.csdn.net/foxclever/article/details/80297989</a></p></li><li><p>变积分</p><p><a href="https://blog.csdn.net/foxclever/article/details/80466623">https://blog.csdn.net/foxclever/article/details/80466623</a></p></li><li><p>不完全微分</p><p><a href="https://blog.csdn.net/foxclever/article/details/80551919">https://blog.csdn.net/foxclever/article/details/80551919</a></p></li><li><p>微分先行</p><p><a href="https://blog.csdn.net/foxclever/article/details/80633275">https://blog.csdn.net/foxclever/article/details/80633275</a></p></li><li><p>带死区pid</p><p><a href="https://blog.csdn.net/foxclever/article/details/80778748">https://blog.csdn.net/foxclever/article/details/80778748</a></p></li><li><p>模糊pid</p><p><a href="https://blog.csdn.net/foxclever/article/details/83932107">https://blog.csdn.net/foxclever/article/details/83932107</a></p></li><li><p>神经元网络pid</p><p><a href="https://blog.csdn.net/foxclever/article/details/84678393">https://blog.csdn.net/foxclever/article/details/84678393</a></p></li><li><p>前馈补偿</p><p><a href="https://blog.csdn.net/foxclever/article/details/81048086">https://blog.csdn.net/foxclever/article/details/81048086</a></p></li><li><p>手动自动切换</p><p><a href="https://blog.csdn.net/foxclever/article/details/105308284">https://blog.csdn.net/foxclever/article/details/105308284</a></p></li><li><p>pid参数的动态调整</p><p><a href="https://blog.csdn.net/foxclever/article/details/105006205">https://blog.csdn.net/foxclever/article/details/105006205</a></p></li><li><p>pid参数的选择设置</p><p><a href="https://blog.csdn.net/foxclever/article/details/122801130">https://blog.csdn.net/foxclever/article/details/122801130</a></p></li><li><p>正反向的控制过程</p><p><a href="https://blog.csdn.net/foxclever/article/details/105613183">https://blog.csdn.net/foxclever/article/details/105613183</a></p></li><li><p>串级pid</p><p><a href="https://blog.csdn.net/foxclever/article/details/105907982">https://blog.csdn.net/foxclever/article/details/105907982</a></p></li><li><p>pid设定值相应</p><p><a href="https://blog.csdn.net/foxclever/article/details/105747647">https://blog.csdn.net/foxclever/article/details/105747647</a></p></li><li><p>pid防超调设置</p><p><a href="https://blog.csdn.net/foxclever/article/details/126085428">https://blog.csdn.net/foxclever/article/details/126085428</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于算术平均算法的滤波器</title>
    <link href="/2023/09/22/%E5%9F%BA%E4%BA%8E%E7%AE%97%E6%9C%AF%E5%B9%B3%E5%9D%87%E7%AE%97%E6%B3%95%E7%9A%84%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2023/09/22/%E5%9F%BA%E4%BA%8E%E7%AE%97%E6%9C%AF%E5%B9%B3%E5%9D%87%E7%AE%97%E6%B3%95%E7%9A%84%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>在AD采集获取数据时，为避免干扰信号的影响，一般我们都会对获取的原始数据进行滤波处理，比较常见的做法是算术平均，即对N个数据进行平均求值，为了进一步优化这种简易的平均算法，我们可以采用以下方法：</p><ul><li><strong>算术平均的递推平滑滤波</strong></li><li><strong>算术平均的带阻平滑滤波</strong></li><li><strong>算术平均的阶梯平滑滤波</strong></li><li><strong>算术平均的中值滤波</strong></li><li><strong>算术平均的限幅滤波</strong></li></ul><p>下面分别来看看这几种算术平均滤波算法：</p><h2 id="算术平均的递推平滑滤波">算术平均的递推平滑滤波</h2><p>在简易的平均算法中，取N个数计算后就会丢弃，如果N值较大，耗时就会较长，这样数据看起来可能就并不那么平滑，而递推平均算法则不存在这些问题。同样一个长度为N的数据队列，每新采样一次数据，就用此数据替换掉最老的数据，并输出算术平均值。实现如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 定义平滑滤波对象类型 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">FilterObject</span>&#123;</span>  <span class="hljs-type">float</span> newValue;       <span class="hljs-comment">//最新测量值</span>  <span class="hljs-type">float</span> lastValue;      <span class="hljs-comment">//上一个输出值</span>  <span class="hljs-type">float</span> *buffer;        <span class="hljs-comment">//数据缓存区</span>  <span class="hljs-type">int16_t</span> position;     <span class="hljs-comment">//写操作位置</span>  <span class="hljs-type">uint16_t</span> bufCount;    <span class="hljs-comment">//滤波的数量</span>&#125;<span class="hljs-type">filter_t</span>;<span class="hljs-comment">/* 平滑滤波处理函数，返回滤波后的值 */</span><span class="hljs-type">float</span> <span class="hljs-title function_">SmoothingFilter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> _FilterObject *filter)</span>&#123;  <span class="hljs-type">float</span> result=lastValue;   <span class="hljs-comment">/* 填充缓冲区 */</span>  <span class="hljs-keyword">if</span>(filter-&gt;position&gt;=filter-&gt;bufCount)  &#123;<span class="hljs-comment">/* 超出范围 */</span>    filter-&gt;position=<span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span>  &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;filter-&gt;bufCount;i++)    &#123;      filter-&gt;buffer[i]=filter-&gt;newValue;    &#125;    filter-&gt;position=<span class="hljs-number">0</span>;    filter-&gt;lastValue=filter-&gt;newValue;  &#125; <span class="hljs-comment">/* 算法的关键处-&gt;类同变化率 */</span>  result = filter-&gt;lastValue - filter-&gt;buffer[filter-&gt;position]/filter-&gt;bufCount;  result += filter-&gt;newValue/filter-&gt;bufCount;    filter-&gt;buffer[filter-&gt;position++] = filter-&gt;newValue;<span class="hljs-comment">//替换之后，位置后移</span>  filter-&gt;lastValue = result;  filter-&gt;newValue = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>特点：第一，对周期性干扰和高频的干扰都有一定的效果。第二，数据变化不明显，响应较慢，而且N越大越明显。第三，对偶然出现的脉冲性干扰的抑制作用较差。所以这种滤波器并不适用于脉冲干扰比较严重的场合。</p><h2 id="算术平均的带阻平滑滤波">算术平均的带阻平滑滤波</h2><p>这种方式是对比本次采集与上次采集数据的偏差值，如果偏差值大于设定的做大值则认为数据变化远超干扰的影响，忽略干扰，直接对数据进行更新。如果偏差值小于设定的最小值则认为数据稳定，不需要滤波。如果偏差值处于设定的最大最小值之间，则需要进行滤波处理。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*定义平滑滤波对象类型*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FilterObject</span>&#123;</span>  <span class="hljs-type">float</span> newValue;       <span class="hljs-comment">//最新测量值</span>  <span class="hljs-type">float</span> lastValue;      <span class="hljs-comment">//上一个输出值</span>  <span class="hljs-type">float</span> *buffer;        <span class="hljs-comment">//数据缓存区</span>  <span class="hljs-type">int16_t</span> position;    <span class="hljs-comment">//写操作位置指针</span>  <span class="hljs-type">uint16_t</span> bufCount;    <span class="hljs-comment">//滤波的数量</span>  <span class="hljs-type">uint16_t</span> delayCount;  <span class="hljs-comment">//延迟计数</span>  <span class="hljs-type">uint16_t</span> delayLimit;  <span class="hljs-comment">//延迟限值</span>  <span class="hljs-type">float</span> rangeLimit;     <span class="hljs-comment">//量程范围</span>  <span class="hljs-type">float</span> upperRario;     <span class="hljs-comment">//比例下限</span>  <span class="hljs-type">float</span> lowerRatio;     <span class="hljs-comment">//比例下限</span>&#125;FilterObjectType;<span class="hljs-comment">/* 带阻平滑滤波器，对指定区间滤波，返回滤波后的值*/</span><span class="hljs-type">float</span> <span class="hljs-title function_">BandSmoothingFilter</span><span class="hljs-params">(FilterObjectType *filter)</span>&#123;  <span class="hljs-type">float</span> result=filter-&gt;lastValue;   <span class="hljs-comment">/* 填充缓冲区 */</span>  <span class="hljs-keyword">if</span>(filter-&gt;position&gt;=filter-&gt;bufCount)  &#123;    filter-&gt;position=<span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span>  &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;filter-&gt;bufCount;i++)    &#123;      filter-&gt;buffer[i]=filter-&gt;newValue;    &#125;    filter-&gt;position=<span class="hljs-number">0</span>;    filter-&gt;lastValue=filter-&gt;newValue;  &#125;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(filter-&gt;newValue-filter-&gt;lastValue)&gt;=(filter-&gt;rangeLimit*filter-&gt;lowerRatio/<span class="hljs-number">100</span>))  &#123;<span class="hljs-comment">/* 范围之间 滤波 */</span>    result=filter-&gt;lastValue-filter-&gt;buffer[filter-&gt;position]/filter-&gt;bufCount;    result+=filter-&gt;newValue/filter-&gt;bufCount;      filter-&gt;buffer[filter-&gt;position++]=filter-&gt;newValue;  &#125;  <span class="hljs-keyword">else</span>  &#123;<span class="hljs-comment">/* 不滤波 消抖 */</span>    filter-&gt;delayCount+=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(filter-&gt;delayCount&gt;=filter-&gt;delayLimit)    &#123;      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;filter-&gt;bufCount;i++)      &#123;        filter-&gt;buffer[i]=filter-&gt;newValue;      &#125;      filter-&gt;position++;      result=filter-&gt;newValue;      filter-&gt;delayCount=<span class="hljs-number">0</span>;    &#125;  &#125;  filter-&gt;lastValue=result;  filter-&gt;newValue=<span class="hljs-number">0.0</span>;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>特点：通过区间滤波，对周期性干扰和小幅的噪声干扰均有较好的效果。如果出现持续性的高频大幅脉冲干扰，这一滤波器将变得无能为力。</p><h2 id="算术平均的阶梯平滑滤波">算术平均的阶梯平滑滤波</h2><p>对于一些情况，如小幅值干扰信号持续存在而被测信号也基本处于一个稳定的区间内。对比本次采集与上次采集数据的偏差值，如果偏差值大于设定的做大值则认为数据变化远超干扰的影响，忽略干扰，直接对数据进行更新。如果偏差值小于设定的最小值则认为数据稳定，这时的干扰于数据的变化不能忽略，我们需要采用完全滤波。如果偏差值处于设定的最大最小值之间，则干扰信号相比于数据的变化较小，但不可忽略，进行半滤波处理。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*定义平滑滤波对象类型*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FilterObject</span>&#123;</span>  <span class="hljs-type">float</span> newValue;       <span class="hljs-comment">//最新测量值</span>  <span class="hljs-type">float</span> lastValue;      <span class="hljs-comment">//上一个输出值</span>  <span class="hljs-type">float</span> *buffer;        <span class="hljs-comment">//数据缓存区</span>  <span class="hljs-type">int16_t</span> position;    <span class="hljs-comment">//写操作位置指针</span>  <span class="hljs-type">uint16_t</span> bufCount;    <span class="hljs-comment">//滤波的数量</span>  <span class="hljs-type">uint16_t</span> delayCount;  <span class="hljs-comment">//延迟计数</span>  <span class="hljs-type">uint16_t</span> delayLimit;  <span class="hljs-comment">//延迟限值</span>  <span class="hljs-type">float</span> rangeLimit;     <span class="hljs-comment">//量程范围</span>  <span class="hljs-type">float</span> upperRario;     <span class="hljs-comment">//比例下限</span>  <span class="hljs-type">float</span> lowerRatio;     <span class="hljs-comment">//比例下限</span>&#125;FilterObjectType;<span class="hljs-comment">/* 阶梯平滑滤波处理函数，返回滤波后的值*/</span><span class="hljs-type">float</span> <span class="hljs-title function_">StepSmoothingFilter</span><span class="hljs-params">(FilterObjectType *filter)</span>&#123;  <span class="hljs-type">float</span> result=filter-&gt;lastValue;  <span class="hljs-comment">/* 填充缓冲区 */</span>  <span class="hljs-keyword">if</span>(filter-&gt;position&gt;=filter-&gt;bufCount)  &#123;    filter-&gt;position=<span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span>  &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;filter-&gt;bufCount;i++)    &#123;      filter-&gt;buffer[i]=filter-&gt;newValue;    &#125;    filter-&gt;position=<span class="hljs-number">0</span>;    filter-&gt;lastValue=filter-&gt;newValue;  &#125;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(filter-&gt;newValue-filter-&gt;lastValue)&gt;(filter-&gt;rangeLimit*filter-&gt;upperRario/<span class="hljs-number">100</span>))  &#123;<span class="hljs-comment">/* 超过最大值直接更新值 消抖 */</span>    filter-&gt;delayCount+=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(filter-&gt;delayCount&gt;=filter-&gt;delayLimit)    &#123;      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;filter-&gt;bufCount;i++)      &#123;        filter-&gt;buffer[i]=filter-&gt;newValue;      &#125;      filter-&gt;position++;      result=filter-&gt;newValue;      filter-&gt;delayCount=<span class="hljs-number">0</span>;    &#125;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(filter-&gt;newValue-filter-&gt;lastValue)&gt;=(filter-&gt;rangeLimit*filter-&gt;lowerRatio/<span class="hljs-number">100</span>))  &#123;<span class="hljs-comment">/* 小于最小值 完全滤波 */</span>    result=filter-&gt;lastValue-filter-&gt;buffer[filter-&gt;position]/filter-&gt;bufCount;       result+=filter-&gt;newValue/filter-&gt;bufCount;       filter-&gt;buffer[filter-&gt;position++]=filter-&gt;newValue;    <span class="hljs-keyword">if</span>(filter-&gt;position&gt;=filter-&gt;bufCount)    &#123;      filter-&gt;position=<span class="hljs-number">0</span>;    &#125;       result=result-filter-&gt;buffer[filter-&gt;position]/filter-&gt;bufCount;    result=result+filter-&gt;newValue/filter-&gt;bufCount;    filter-&gt;buffer[filter-&gt;position++]=filter-&gt;newValue;    filter-&gt;delayCount=<span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">else</span>  &#123;<span class="hljs-comment">/* 范围之内 半滤波 */</span>    result=filter-&gt;lastValue-filter-&gt;buffer[filter-&gt;position]/filter-&gt;bufCount;     result=result+filter-&gt;newValue/filter-&gt;bufCount;    filter-&gt;buffer[filter-&gt;position++]=filter-&gt;newValue;    filter-&gt;delayCount=<span class="hljs-number">0</span>;  &#125;   filter-&gt;lastValue=result;  filter-&gt;newValue=<span class="hljs-number">0.0</span>;  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><h2 id="算术平均的中值滤波"><strong>算术平均的中值滤波</strong></h2><p>中值滤波主要是去除相对频率较低的周期干扰和相对频率较高的非周期干扰。去掉最高和最低的数，中间的数更为接近真实值。这一滤波算法适用于高速采集，必须采集到一定数量的数据，一般一次采集几十个数然后再做此滤波是比较有效果的。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 中值平均滤波算法 */</span><span class="hljs-comment">/* pData:采集的数据指针 */</span><span class="hljs-comment">/* aSize:采集的数据长度 */</span><span class="hljs-comment">/* eSize:各需要丢弃的极大值和极小值的数量 */</span><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">MedianMeanFilter</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *pData,<span class="hljs-type">uint16_t</span> aSize,<span class="hljs-type">uint16_t</span> eSize)</span>&#123;    <span class="hljs-type">uint32_t</span> tData;    <span class="hljs-type">uint32_t</span> result=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(aSize&lt;=<span class="hljs-number">2</span>*eSize)    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/* 冒泡排序 */</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;aSize<span class="hljs-number">-1</span>; i++)  <span class="hljs-comment">//比较n-1轮</span>    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;aSize<span class="hljs-number">-1</span>-i; j++)  <span class="hljs-comment">//每轮比较n-1-i次,</span>        &#123;            <span class="hljs-keyword">if</span> (pData[j] &lt; pData[j+<span class="hljs-number">1</span>])            &#123;                tData = pData[j];                pData[j] = pData[j+<span class="hljs-number">1</span>];                pData[j+<span class="hljs-number">1</span>] = tData;            &#125;        &#125;    &#125;    <span class="hljs-comment">/* 去掉首末端eSize数据，取平均值 */</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=eSize;j&lt;(aSize-eSize);j++)    &#123;        result+=pData[j];    &#125;        result /= (aSize<span class="hljs-number">-2</span>*eSize);        <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><h2 id="算术平均的限幅滤波"><strong>算术平均的限幅滤波</strong></h2><p>此种算法就是在中值滤波的基础上剔除超出限幅的数据。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*限幅平均滤波算法*/</span><span class="hljs-comment">/* pData:采集的数据指针 */</span><span class="hljs-comment">/* aSize:采集的数据长度 */</span><span class="hljs-comment">/* eSize:各需要丢弃的极大值和极小值的数量 */</span><span class="hljs-comment">/* rData:参考值 */</span><span class="hljs-comment">/* lValue:偏离参考值的限幅 */</span><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">LimitedMeanFilter</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *pData,<span class="hljs-type">uint16_t</span> aSize,<span class="hljs-type">uint16_t</span> eSize,<span class="hljs-type">uint32_t</span> rData,<span class="hljs-type">uint32_t</span> lValue)</span>&#123;  <span class="hljs-type">uint32_t</span> uResult=<span class="hljs-number">0</span>, mResult=<span class="hljs-number">0</span>, lResult=<span class="hljs-number">0</span>; <span class="hljs-comment">//求和值</span>  <span class="hljs-type">uint16_t</span> uNumber=<span class="hljs-number">0</span>, mNumber=<span class="hljs-number">0</span>, lNumber=<span class="hljs-number">0</span>; <span class="hljs-comment">//数量</span>  <span class="hljs-comment">/* 判断采集的数据量 */</span>  <span class="hljs-keyword">if</span>(aSize&lt;=<span class="hljs-number">2</span>*eSize)  &#123;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">/* 冒泡排序 */</span>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;aSize<span class="hljs-number">-1</span>; i++) <span class="hljs-comment">//比较n-1轮</span>  &#123;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;aSize<span class="hljs-number">-1</span>-i; j++) <span class="hljs-comment">//每轮比较n-1-i次,</span>     &#123;       <span class="hljs-keyword">if</span> (pData[j] &lt; pData[j+<span class="hljs-number">1</span>])       &#123;         pData[j]^=pData[j+<span class="hljs-number">1</span>];         pData[j+<span class="hljs-number">1</span>]^= pData[j];         pData[j]^=pData[j+<span class="hljs-number">1</span>];       &#125;     &#125;  &#125;  <span class="hljs-comment">/* 剔除极值后根据限幅值求和 */</span>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=eSize;j&lt;(aSize-eSize);j++)  &#123;     <span class="hljs-keyword">if</span>(pData[j]&gt;(rData+lValue))     &#123;<span class="hljs-comment">/* 大于上限 */</span>       uResult+=pData[j];       uNumber++;     &#125;     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pData[j]&lt;(rData-lValue))     &#123;<span class="hljs-comment">/* 小于下限 */</span>       lResult+=pData[j];       lNumber++;     &#125;     <span class="hljs-keyword">else</span>     &#123;<span class="hljs-comment">/* 上下限之间 */</span>       mResult+=pData[j];       mNumber++;     &#125;  &#125;  <span class="hljs-comment">/* 求平均值 */</span>  <span class="hljs-keyword">if</span>((mNumber&gt;uNumber)&amp;&amp;(mNumber&gt;lNumber))  &#123;<span class="hljs-comment">/* 处于上下限之间的数据量较大时 */</span>     mResult = mResult/mNumber;  &#125;  <span class="hljs-keyword">else</span>  &#123;     mResult = (uResult+mResult+lResult)/(uNumber+mNumber+lNumber);  &#125;    <span class="hljs-keyword">return</span> mResult;&#125;</code></pre></div><p><strong>参考链接：</strong></p><p><a href="https://blog.csdn.net/foxclever/article/details/106038732">滤波器开发之一：基于算数平均的平滑滤波器_算术平均掩模_foxclever的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/foxclever/article/details/106296222">滤波器开发之二：基于算数平均的带阻平滑滤波器_用均值滤波实现带阻滤波-CSDN博客</a></p><p><a href="https://blog.csdn.net/foxclever/article/details/106448052">滤波器开发之三：基于算数平均的阶进平滑滤波器_阶梯平滑_foxclever的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/foxclever/article/details/120925665">滤波器开发之四：基于算术平均的中值滤波器_算术中值滤波_foxclever的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/foxclever/article/details/121191411">滤波器开发之五：基于算术平均的限幅滤波器-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算术平均</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的回调函数及使用</title>
    <link href="/2023/09/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/09/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在开发过程中，我们会经常碰到回调函数的问题，那什么是回调函数？怎么使用回调函数呢？下面具体来看看。</p><h1 id="什么是回调函数">什么是回调函数</h1><p><strong>回调函数</strong>就是一个通过<strong>函数指针</strong>调用的函数。</p><p>假如你把 <strong>函数A的指针</strong> 当作参数传给 <strong>函数B</strong>，然后在 <strong>函数B</strong> 中通过传进来的这个指针调用 <strong>函数A</strong> ，那么这就是回调机制，<strong>函数A</strong> 就是<strong>回调函数</strong>。</p><p>知乎上有个比较形象的比喻：你到商店买东西，刚好没货，于是留下了你的电话，有货后店员就打了你的电话，去店里取货。在这个例子里，你的电话号码就叫<strong>回调函数</strong>，你把电话留给店员就叫<strong>注册回调函数</strong>，店里后来有货了叫做<strong>触发了回调关联的事件</strong>，店员给你打电话叫做<strong>调用回调函数</strong>，你到店里去取货叫做<strong>响应回调事件</strong>。</p><h1 id="为何要使用回调函数">为何要使用回调函数</h1><p>回调函数最大的优势是解耦，降低了程序的耦合度，使上层的应用更完整，而不需要考虑底层的实现细节，方便协作与移植。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2ecc00017db499f2620d.jpeg" alt="" /><figcaption>img</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;softwareLib.h&gt;</span> <span class="hljs-comment">//Library 函数所在库的头文件</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">Callback</span><span class="hljs-params">()</span> <span class="hljs-comment">// Callback Function</span>&#123;    <span class="hljs-comment">// TODO</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <span class="hljs-comment">// Main program</span>&#123;    <span class="hljs-comment">// TODO</span>    Library(Callback);    <span class="hljs-comment">// TODO</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>乍一看，回调似乎只是函数间的调用，和普通函数调用没啥区别，但仔细一看，可以发现：</p><p>主函数和回调函数是在同一层，而库函数在另外一层，主程序中把回调函数当参数传入库函数中。只要我们改变传进库函数的参数（函数指针），就可以实现不同的功能，丝毫不需要修改库函数的实现，这就是解耦。</p><h1 id="如何使用回调函数">如何使用回调函数</h1><h3 id="以简单的函数指针参数形式使用">1.以简单的函数指针参数形式使用</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">Callback_1</span><span class="hljs-params">()</span> <span class="hljs-comment">// Callback Function 1</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, this is Callback_1\n&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">Callback_2</span><span class="hljs-params">()</span> <span class="hljs-comment">// Callback Function 2</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, this is Callback_2\n&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Handle</span><span class="hljs-params">(<span class="hljs-type">int</span> (*Callback)())</span>&#123;Callback();&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;Handle(Callback_1);  Handle(Callback_2);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230918221802882.png" alt="" /><figcaption>image-20230918221802882</figcaption></figure><h3 id="以typedef定义的函数指针类型方式使用">2.以typedef定义的函数指针类型方式使用</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*cb)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">Callback_1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-comment">// Callback Function 1</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, this is Callback_1, %d\n&quot;</span>, a);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">Callback_2</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span> <span class="hljs-comment">// Callback Function 2</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, this is Callback_2, %d\n&quot;</span>, b);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Handle</span><span class="hljs-params">(cb callback, <span class="hljs-type">int</span> x)</span>&#123;callback(x);&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;  Handle(Callback_1, <span class="hljs-number">1</span>);  Handle(Callback_2, <span class="hljs-number">2</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230918225732968.png" alt="" /><figcaption>image-20230918225732968</figcaption></figure><h3 id="以弱函数的方式使用">3.以弱函数的方式使用</h3><p>在回调函数前面添加标识： <code>__weak</code> ，该函数允许定义与其名称和形式完全一样的函数，若使用者重新定义了该函数则会调用新函数，否则使用此默认函数。在STM32的HAL库中使用了很多这样的函数。如：</p><div class="code-wrapper"><pre><code class="hljs c">__weak <span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span>&#123;  <span class="hljs-comment">/* Prevent unused argument(s) compilation warning */</span>  UNUSED(GPIO_Pin);  <span class="hljs-comment">/* <span class="hljs-doctag">NOTE:</span> This function Should not be modified, when the callback is needed,</span><span class="hljs-comment">           the HAL_GPIO_EXTI_Callback could be implemented in the user file</span><span class="hljs-comment">   */</span>&#125;</code></pre></div><h3 id="以函数封装注册的方式使用">4.以函数封装注册的方式使用</h3><p>对于一些复杂的对象进行属性和方法的封装，如STM32中DMA外设中的回调函数被一起封装在一个结构体中：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">DMA_HandleTypeDef</span></span><span class="hljs-class">&#123;</span>  DMA_Channel_TypeDef        *Instance;                                               DMA_InitTypeDef            Init;                                                    HAL_LockTypeDef            Lock;                                                    __IO HAL_DMA_StateTypeDef  State;                                                    <span class="hljs-type">void</span>                       *Parent;                                                   <span class="hljs-type">void</span>  (* XferCpltCallback)( <span class="hljs-keyword">struct</span> __DMA_HandleTypeDef * hdma);   <span class="hljs-type">void</span>  (* XferHalfCpltCallback)( <span class="hljs-keyword">struct</span> __DMA_HandleTypeDef * hdma);  <span class="hljs-type">void</span>  (* XferErrorCallback)( <span class="hljs-keyword">struct</span> __DMA_HandleTypeDef * hdma);    <span class="hljs-type">void</span>  (* XferAbortCallback)( <span class="hljs-keyword">struct</span> __DMA_HandleTypeDef * hdma);      __IO <span class="hljs-type">uint32_t</span>              ErrorCode;                                                 DMA_TypeDef                *DmaBaseAddress;                                           <span class="hljs-type">uint32_t</span>                   ChannelIndex;                                           &#125; DMA_HandleTypeDef;</code></pre></div><p>在使用时我们只需声明一个DMA对象，编写对应的回调函数，然后通过注册函数进行注册(<code>HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)( DMA_HandleTypeDef * _hdma))</code>),这样就可以使用了。可参考：<a href="https://zhuanlan.zhihu.com/p/390460838">c语言回调函数的使用及实际作用详解</a></p><p><strong>链接：</strong></p><p><a href="https://www.runoob.com/w3cnote/c-callback-function.html">C 语言回调函数详解 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://blog.csdn.net/miao19920101/article/details/75648491">回调指针回调函数的使用（C语言）_森林之猫猫狗狗的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回调函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中几个重要的关键字</title>
    <link href="/2023/09/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/09/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>在了解关键字之前，先来了解变量或函数的“声明”与“定义”之间的区别：</p><p><strong>声明</strong>：告诉编译器，声明的变量或函数在程序中的某个位置，数据类型，参数顺序及返回类型，但未为它们分配内存。</p><p><strong>定义</strong>：编译器创建一个对象并分配一块内存并给取一个名字，这个名字就是变量名或对象名。</p><p>因此，我们可以将声明作为定义的子集。变量或函数可以声明多次，但只能定义一次。</p><p>由ANSI标准定义的C语言关键字共32个:</p><ul><li><strong>数据类型关键字（14个）：char double float short unsigned signed int long void struct enum union typedef sizeof</strong></li><li><strong>存储类型关键字（6个）：extern const static auto register volatile</strong><br /></li><li><strong>流程控制关键字（12个）：do if while break else switch case continue for default goto return</strong></li></ul><p>这里主要来看看存储类型的几个关键字。</p><h1 id="extern">extern</h1><p>通过使用 <strong>extern</strong> 关键字来声明变量或函数，不会为变量或函数分配存储空间，而只是指示编译器该变量或函数在其他文件中定义，提供一个全局变量的引用，可以在当前文件引用此变量或函数。</p><p>一般在模块化编程中，我们都会在头文件中声明的函数名前添加 extern 关键字，以供外部文件使用，当我们不添加此关键字，使用也是正常的，那是因为编译器会默认给该函数增加外部使用的属性，但我们在编写程序时，为养成好习惯，最好添加 extern 关键字，不同的平台，不同的编译器，所产生的结果会不一样。</p><h1 id="const">const</h1><p>const 关键字用来告诉编译器，<strong>被修饰的这些变量或函数，具有“只读”的特点</strong>。在编译的过程中，一旦我们的代码试图去改变这些变量或函数，编译器就会给出错误提示。关于 const 的用法有以下几种：</p><h4 id="修饰局部变量">1.修饰局部变量</h4><p><strong>const 变量必须被初始化</strong>！！</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 这两种方式都是表示变量n的值不能被改变了 */</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<span class="hljs-type">int</span> <span class="hljs-type">const</span> n = <span class="hljs-number">5</span>;<span class="hljs-comment">/* 修饰字符串常量 */</span><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;abcdef&quot;</span>; <span class="hljs-comment">//防止无意错误的修改，如：str[4] = &#x27;y&#x27;;</span><span class="hljs-comment">/* 以下编译错误 */</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> n;n = <span class="hljs-number">5</span>;</code></pre></div><h4 id="修饰指针变量">2.修饰指针变量</h4><p><strong>常量指针</strong>：说明此指针指向常量。<strong>指针指向的值不能改变，但指针的指向可以改变。</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<span class="hljs-type">int</span> b = <span class="hljs-number">6</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span>* p = &amp;a;<span class="hljs-comment">//常量指针p，指向const的变量，这里指向int型变量a</span>p = &amp;b;<span class="hljs-comment">//编译正常，指针的指向可以改变</span>*p = <span class="hljs-number">10</span>; <span class="hljs-comment">//编译报错，指针指向的值是只读的</span></code></pre></div><p><strong>指针常量</strong>：说明此指针是个常量。<strong>指针指向不可改变，但指针指向的值可以改变。</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<span class="hljs-type">int</span> b = <span class="hljs-number">6</span>;<span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a; <span class="hljs-comment">//只读变量指针p，指向变量a</span>*p = <span class="hljs-number">8</span>;<span class="hljs-comment">//编译正常，指针指向的值可以改变</span>p = &amp;b;<span class="hljs-comment">//编译报错，const指针自身内容(指向)不能改变</span></code></pre></div><p>区分常量指针和指针常量的一般规则是：<strong>从右向左，const就近依次结合</strong>。如：</p><p><code>int * const p</code> : p先与<code>const</code>结合，说明p为只读变量，然后与<code>*</code>结合，说明p是一个只读变量指针，最后与<code>int</code> 结合，说明只读变量指针p指向一个int型的变量。所以这就是一个指向int型的只读指针。</p><p><code>const int * p</code> : p先与<code>*</code>结合，说明p为一个指针，然后与<code>int</code>结合，说明p指向一个int型的变量，最后与<code>const</code> 结合，说明p指向的是一个只读的int型变量。所以这是一个指向只读int型变量的指针。</p><p>当然也可以根据const关键字的位置来区别：当const关键字的右边是类型时，则表示值是常量。当const关键字的右边是指针变量时，则表示指针本身是常量。</p><h4 id="修饰函数的参数">3.修饰函数的参数</h4><p>关键字const修饰函数形参时，通常用于参数为指针或引用的情况，且只能修饰输入参数。若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。将函数参数声明为 const 类型，表示函数内部是不能改变这个参数的值。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 防止修改指针指向的内容，即改变了源字符串的值 */</span><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span>  <span class="hljs-comment">/* 防止修改指针指向的地址 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span> <span class="hljs-params">( <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p1 , <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p2 )</span></code></pre></div><h4 id="修饰函数的返回值">4.修饰函数的返回值</h4><p>const 型的返回值，指的是函数的返回值为一个 const 变量，函数返回值（即指针）的内容不能被修改，且该返回值只能被赋给加const 修饰的同类型指针。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title function_">GetString</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-type">char</span> *str = GetString(); <span class="hljs-comment">//编译错误</span><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = GetString();<span class="hljs-comment">//编译正确</span></code></pre></div><h4 id="修饰全局变量">5.修饰全局变量</h4><p>全局变量的作用域是整个文件，我们应该尽量避免使用全局变量，因为一旦有一个函数改变了全局变量的值，它也会影响到其他引用这个变量的函数，导致除了bug后很难发现，如果一定要用全局变量，我们应该尽量的使用const修饰符进行修饰，这样防止不必要的人为修改，使用的方法与局部变量是相同的。</p><h1 id="static">static</h1><p>static关键字常见用法有三种：</p><h4 id="修饰局部变量-1">1.修饰局部变量</h4><p>使用static修饰局部变量，称为静态局部变量，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于全局（静态）存储区，在函数返回时，<strong>它的值会保持不变</strong>。其作用域为局部作用域，当定义它的函数结束时，其作用域随之结束。</p><h4 id="修饰全局变量-1">2.修饰全局变量</h4><p>使用static修饰全局变量，称为静态全局变量，变量可以被当前文件内的所有函数访问，但不能被其它文件内的函数访问。其他文件可以定义与其同名的变量，两者互不影响。</p><h4 id="修饰函数">3.修饰函数</h4><p>函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数。静态函数只能在声明它的文件中被调用，不可被其它模块的函数调用，方便封装一些模块内部属性的功能。不同的文件可以使用相同名字的静态函数，互不影响。</p><h1 id="volatile">volatile</h1><p>用 volatile 关键字声明的变量是提醒编译器该变量随时都有可能改变(如被别的程序更新)，不要对该变量进行优化，需要存储或读取该变量时，直接从该变量地址中存储或读取数据。</p><p>使用 volatile 的场景主要有：</p><h4 id="存储器映射的硬件寄存器">1.存储器映射的硬件寄存器</h4><p>由于我们外部的数据都是直接进入内存区域，而程序只是引用它的值。编译器优化时可能就直接采用寄存器中的副本了，所以需要将这段内存对应的变量声明为volatile。如在STM32库文件中的各外设寄存器存储器映射：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230907171919476.png" alt="" /><figcaption>image-20230907171919476</figcaption></figure><h4 id="中断服务程序中改变对象值">2.中断服务程序中改变对象值</h4><p>中断服务程序中需要修改的变量，以供其它程序检测，则需要加volatile。如：</p><p>我们将变量定义为：<code>static int var=0;</code> ，然后在中断服务程序中将其修改：<code>var=1;</code>，但是在另一函数中使用它但不会修改它，那么编译器会认为它没有变化，从而直接使用寄存器中的副本。</p><p>如果我们将变量定义为：<code>volatile int var=0;</code> ，那么每次在函数中使用var变量时，都会重新读取寄存器中的值。</p><h4 id="多任务共享标志">3.多任务共享标志</h4><p>多任务共享时，其实也是一样的，在一个任务中修改了一个对象后，在另一个对象中应用它，但编译器并没发现在该任务中对它有修改。由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。从而并不能响应在另一任务下的变化。</p><p>在这种情况下，一般我们都需要使用volatile关键字来定义任务间共享的标识。</p><p><strong>链接：</strong></p><p><a href="https://blog.csdn.net/xingjiarong/article/details/47282255">C语言中const关键字的用法_xingjiarong的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/guotianqing/article/details/79828100">c语言中static关键字用法详解_static在c语言中的用法_guotianqing的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/foxclever/article/details/83721019?spm=1001.2014.3001.5502">C语言volatile关键字及其使用_foxclever的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>关键字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modbus通讯协议详解</title>
    <link href="/2023/09/04/Modbus%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/09/04/Modbus%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="modbus协议简介">Modbus协议简介</h1><p>Modbus协议是一种通用的工业通讯总线协议，跟I2C、SPI总线类似，通讯的服务器端和客户端都在同一条总线上。</p><p>Modbus协议最初是Modicon公司（现在的施耐德电气 Schneider Electric）于1979年为使用可编程逻辑控制器（PLC）通信而开发的，现在已成为工业领域通信协议的业界标准。</p><p>Modbus官网：<a href="https://modbus.org/">https://modbus.org/</a></p><p>本文主要以modbus官方文档（<a href="https://modbus.org/specs.php">Modbus Specifications and Implementation Guides</a>）进行说明。</p><h1 id="modbus协议传输方式">Modbus协议传输方式</h1><p>Modbus协议主要有以下几种传输方式：</p><ul><li><p><strong>基于串口的Modbus-RTU</strong></p><p>采用二进制表现形式以及紧凑数据结构，通信效率较高，应用比较广泛，在工业现场一般都是采用Modbus RTU协议。</p><p>RTU协议中的指令由地址码(一个字节），功能码（一个字节），起始地址（两个字节），数据（N个字节），校验码（两个字节）五个部分组成，其中数据又由数据长度（两个字节，表示的是寄存器个数，假定内容为M）和数据正文（M乘以2个字节）组成，而RTU协议是采用3.5个字节的空闲时间作为指令的起始和结束，一般而言，只有当从机返回数据或者主机写操作的时候，才会有数据正文，而其他时候比如主机读操作指令的时候，没有数据正文，只需要数据长度即可。</p></li><li><p><strong>基于串口的Modbus-ASCII</strong></p><p>采用ASCII码传输，并且利用特殊字符作为其字节的开始与结束标识，其传输效率要远远低于Modbus RTU协议，一般只有在通信数据量较小的情况下才使用Modbus ASCII通信。</p></li><li><p><strong>基于以太网的Modbus-TCP</strong></p><p>是在RTU协议上加一个MBAP报文头，由于TCP是基于可靠连接的服务，所以就不需要CRC校验了。</p></li></ul><h1 id="modbus协议数据帧">Modbus协议数据帧</h1><p>Modbus协议帧比较简洁，如下所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904153822090.png" alt="" /><figcaption>image-20230904153822090</figcaption></figure><p>一帧Modbus数据由客户端构建，开启数据传输（无错误发生）：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904155252355.png" alt="" /><figcaption>image-20230904155252355</figcaption></figure><p>当服务器检测到异常，则会发出异常码和异常功能码：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904155609179.png" alt="" /><figcaption>image-20230904155609179</figcaption></figure><h1 id="modbus数据编码和数据模型">Modbus数据编码和数据模型</h1><p>Modbus协议中采用的是 <strong>大端模式</strong> ，所以传输多字节地址和数据时，要先发送高位字节，如数据：<strong>0x1234</strong> ，要先发送高位字节 <strong>0x12</strong>，然后发送低位字节 <strong>0x34</strong> 。</p><p>Modbus协议规定，进行读写操作的数据类型主要分为以下4种：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904185445076.png" alt="" /><figcaption>image-20230904185445076</figcaption></figure><h1 id="功能码的分类与定义">功能码的分类与定义</h1><p>Modbus功能码主要有公共功能码(如：1~65 或 73~100 或 111~127)和自定义功能码（如：66~72 或 101~110）。</p><p>主要来看看公共功能码：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904164451733.png" alt="" /><figcaption>image-20230904164451733</figcaption></figure><p>因为PLC主要控制的是继电器触点，所以在PLC上还会经常对线圈（Coils）进行读写。</p><p>最常用的功能码：</p><ul><li><p><strong>03 (0x03) - 读保持寄存器</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904181240364.png" alt="" /><figcaption>image-20230904181240364</figcaption></figure></li><li><p><strong>04 (0x04) - 读输入寄存器</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904182100762.png" alt="" /><figcaption>image-20230904182100762</figcaption></figure></li><li><p><strong>06 (0x06) - 写单个寄存器</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904182705385.png" alt="" /><figcaption>image-20230904182705385</figcaption></figure></li><li><p><strong>16 (0x10) - 写多个寄存器</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230904184016458.png" alt="" /><figcaption>image-20230904184016458</figcaption></figure></li></ul><p>可以看出，不同的功能码，对应的请求和响应不太一样，但一般 <strong>功能码占用1Byte，地址占用2Bytes，寄存器数量占用2Bytes，寄存器值占用2Bytes，数据字节数占用1Byte</strong>。另外，在实际应用中，还有设备地址占用1Byte，CRC校验占用2Bytes。如在Modbus RTU传输中：</p><ul><li><strong>03 (0x03) - 读保持寄存器</strong></li></ul><p><strong>请求</strong>：1byte设备地址 + 1byte功能代码 + 2bytes寄存器起始地址 + 2bytes寄存器数量 + 2bytes CRC校验</p><p><strong>响应</strong>：1byte设备地址 + 1byte功能代码 + 1byte数据字节数 + 2N bytes寄存器数据 + 2bytes CRC校验</p><ul><li><strong>06 (0x06) - 写单个寄存器</strong></li></ul><p><strong>请求</strong>：1byte设备地址 + 1byte功能代码 + 2bytes寄存器起始地址 + 2bytes数据 + 2bytes CRC校验</p><p><strong>响应</strong>：1byte设备地址 + 1byte功能代码 + 2bytes寄存器起始地址 + 2bytes数据 + 2bytes CRC校验</p><h1 id="modbus协议应用">Modbus协议应用</h1><p><a href="https://www.modbus.cn/11740.html">格力中央空调多联机 Modbus 通讯协议 | Modbus物联网云平台</a></p><p>Modbus官网有个外链驱动库：<a href="https://libmodbus.org/">libmodbus驱动库</a> ，在应用中可以直接移植到程序中，而不用自己重复的编写驱动。具体移植过程可参考：<a href="https://blog.csdn.net/whik1194/article/details/119010616?spm=1001.2014.3001.5501">Modbus驱动库—libmodbus驱动库的使用_whik1194的博客-CSDN博客</a>）</p><p><strong>链接：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/38920259">Modbus RTU/TCP协议解析 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Modbus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于OLED字模取模方式的选择</title>
    <link href="/2023/09/02/%E5%85%B3%E4%BA%8EOLED%E5%AD%97%E6%A8%A1%E5%8F%96%E6%A8%A1%E6%96%B9%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <url>/2023/09/02/%E5%85%B3%E4%BA%8EOLED%E5%AD%97%E6%A8%A1%E5%8F%96%E6%A8%A1%E6%96%B9%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<p>OLED（Organic Light-Emitting Diode）,有机发光二极体，属于一种电流型的有机发光器件，当电流流动时就会自行发光。因其简单，使用方便，所以在开发过程中会经常使用到这种显示器件。</p><p>市面上有很多OLED显示模块，根据控制显示的驱动芯片的不同，有不同的连接接口，一般大体会有四种：</p><ul><li><strong>6800并行接口</strong></li><li><strong>8080并行接口</strong></li><li><strong>4线SPI串行接口</strong></li><li><strong>I2C接口</strong></li></ul><p>下面主要是来看看OLED在显示中文信息时，需要注意的事项：</p><p>显示中文信息需要用到字模工具，如：<a href="https://gitee.com/kayoungzhang/my_codehub/blob/master/tools/PCtoLCD2018.zip">PCtoLCD</a> ，当然，还有其它的一些字模工具，功能都差不多。</p><p>PCtoLCD字符模式的配置（16*16汉字）与使用方式如图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230902141405518.png" alt="image-20230902141405518" style="zoom:80%;" /></p><p>将生成的数据放到一个二维数组中，可以将这个二维数组保存到一个头文件中，使用时，包含这个头文件即可。如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> OLEDFONT_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> OLEDFONT_H    </span><span class="hljs-type">char</span> <span class="hljs-type">const</span> SHOW[][<span class="hljs-number">32</span>]=&#123;    &#123;<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;,    &#123;<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;,<span class="hljs-comment">/*&quot;中&quot;,0*/</span>    <span class="hljs-comment">/* (16 X 16 , 宋体 )*/</span>    &#123;<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0x12</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0xF2</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0x92</span>,<span class="hljs-number">0x12</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;,    &#123;<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x4A</span>,<span class="hljs-number">0x4C</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;,<span class="hljs-comment">/*&quot;国&quot;,1*/</span>    <span class="hljs-comment">/* (16 X 16 , 宋体 )*/</span>    &#123;<span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x44</span>,<span class="hljs-number">0x58</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x46</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>&#125;,    &#123;<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x18</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x78</span>,<span class="hljs-number">0x00</span>&#125;,<span class="hljs-comment">/*&quot;光&quot;,2*/</span>    <span class="hljs-comment">/* (16 X 16 , 宋体 )*/</span>    &#123;<span class="hljs-number">0x00</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x88</span>,<span class="hljs-number">0x84</span>,<span class="hljs-number">0x43</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x0C</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x41</span>,<span class="hljs-number">0x82</span>,<span class="hljs-number">0x84</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;,    &#123;<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0x42</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>&#125;,<span class="hljs-comment">/*&quot;谷&quot;,3*/</span>    <span class="hljs-comment">/* (16 X 16 , 宋体 )*/</span>&#125;;<span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* OLEDFONT_H */</span></span></code></pre></div><p>这里看一下它的取模方式，各种取模方式的演示，可查看软件上自带的演示示例。这四种方式各自的特点如下：</p><ul><li><p><strong>逐列式</strong></p><ul><li>从第一列开始向下每取8个点作为一个字节，如果最后不足8个点就补满8位。取模顺序是从低到高，即第一个点作为最低位。</li><li>不需要进行数据重组，取模软件取出数据直接运用。</li><li>写完一字节数据就需要重新设置一次地址，写一个16x16汉字，需要经历32次地址设置 ： 每一列数据需要设置2次，共16列。</li></ul></li><li><p><strong>逐行式</strong></p><ul><li><p>从第一行开始向右每取8个点作为一个字节，如果最后不足8个点就补满8位。取模顺序是从低到高 ，即第一个点作为最低位。</p></li><li><p>需要进行数据重组，取模软件取出的数值无法直接运用。</p></li><li><p>写1个字节数据需要对8个数据进行Bit位数值的提取和重组操作，写完16字节数据需要重新设置一次地址，写一个16x16汉字，需要经历2次地址设置 ： 汉字上半部分的页地址和汉字下半部分的页地址分别设置一次。</p></li></ul></li><li><p><strong>列行式</strong></p><ul><li>从第一列开始向下取8个点作为一个字节，然后从第二列开始向下取8个点作为第二个字节...依此类推。如果最后不足8个点就补满8位。取模顺序是从低到高，即第一个点作为最低位。</li><li>不需要进行数据重组，取模软件取出数据直接运用。</li><li>写完16字节数据需要重新设置一次地址，写一个16x16汉字，需要经历2次地址变换： 汉字上半部分的页地址和汉字下半部分的页地址分别设置一次。（注意这里和逐行式的做法本质上是一样的，只是在于数据是否可以直接运用）</li></ul></li><li><p><strong>行列式</strong></p><ul><li>从第一行开始向右取8个点作为一个字节，然后从第二行开始向右取8个点作为第二个字节...依此类推。如果最后不足8个点就补满8位。取模顺序是从低到高，即第一个点作为最位。</li><li>需要进行数据重组，取模软件取出的数值无法直接运用。</li><li>写1个字节数据需要对8个数据进行Bit位数值的提取和重组操作，写完8个字节数据就需要重新设置一次地址，写一个16x16汉字，需要经历4次地址设置：汉字分为左上部分、左下部分、右上部分、右下部分，共需要设置4次地址</li></ul></li></ul><p>通过对比，可以发现：</p><ul><li>从数据处理方面看，不进行数据重组，其书写速度上可以更快，因此逐列式和列行式更有优势。</li><li>从地址设置方面看，尽量少的程序设置地址，而尽量多的利用硬件自身的列地址自增的性质，这样速度更快，因此逐行式=列行式&gt;行列式&gt;逐列式。</li></ul><p>所以， 对于显示16x16汉字，列行式是最为突出的算法，不仅直接利用数据无需重组，而且尽量多的利用了其硬件特性，是最好的选择。</p><p>PCtoLCD图形模式的配置（128*64图片）与使用方式如图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230902152256627.png" alt="image-20230902152256627" style="zoom:67%;" /></p><p>同上一样，将生成的数据放到一个数组中，将这个数组保存到一个头文件中，使用时，包含这个头文件即可。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">char</span> <span class="hljs-type">const</span> pic[] = &#123;    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xE4</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF2</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xF2</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,    <span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,    <span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x05</span>,<span class="hljs-number">0x09</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x09</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x61</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x03</span>,<span class="hljs-number">0x05</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x04</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0x8F</span>,<span class="hljs-number">0x9F</span>,<span class="hljs-number">0x9F</span>,<span class="hljs-number">0x87</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,    <span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xD0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,    <span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0xFE</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x7F</span>,    <span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0x01</span>,    <span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFD</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xBF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0xC8</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xC0</span>,<span class="hljs-number">0xE2</span>,<span class="hljs-number">0xF0</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xE0</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x01</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x41</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xE7</span>,<span class="hljs-number">0xBF</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xBF</span>,<span class="hljs-number">0x41</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x43</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFC</span>,    <span class="hljs-number">0xFE</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x3F</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFC</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xF8</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x08</span>,<span class="hljs-number">0x09</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x03</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x03</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x3F</span>,    <span class="hljs-number">0x3F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x13</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x03</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,    <span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x03</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,    <span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x1F</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x03</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;</code></pre></div><p><strong>链接：</strong></p><p><a href="https://blog.csdn.net/yagnruinihao/article/details/47133455">https://blog.csdn.net/yagnruinihao/article/details/47133455</a></p><p><a href="https://www.cnblogs.com/dragonet-Z/p/14689345.html">https://www.cnblogs.com/dragonet-Z/p/14689345.html</a></p>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OLED</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cJSON使用教程</title>
    <link href="/2023/08/29/cJSON%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2023/08/29/cJSON%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>JSON</strong> (JavaScript Object Notation) 是一种轻量级的数据交换格式。它采用完全独立于编程语言的文本格式来存储和表示数据，语法简洁、层次结构清晰，易于人阅读和编写，同时也易于机器解析和生成，有效的提升了网络传输效率。</p><h2 id="json-构建结构">JSON 构建结构</h2><p>JSON 构建结构主要有两种：</p><ul><li><strong>名称/值的集合。</strong>在不同的编程语言中，体现方式分别有 对象、记录、结构体、字典、哈希表、键值列表或关联数组。(object, record, struct, dictionary, hash table, keyed list, associative array)</li><li><strong>有序的数据列表。</strong>在大多数编程语言中，体现方式主要是数组、向量、列表或序列。(array, vector, list, sequence)</li></ul><h2 id="json-语法">JSON 语法</h2><ul><li>数据以 <strong>name：value</strong> (名称:值) 的形式存在，名称和值之间使用"<code>:</code>"分隔</li><li>每个数据由逗号 <strong><code>,</code></strong> 分隔</li><li>大括号 <strong><code>&#123;&#125;</code></strong> 内部保存对象，允许嵌套使用</li><li>中括号 <strong><code>[]</code></strong> 内部保存数组，数组可以包含多个对象</li></ul><p>JSON值类型有：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* cJSON Types: */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_False 0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_True 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_NULL 2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_Number 3</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_String 4</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_Array 5</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> cJSON_Object 6</span></code></pre></div><p>示例如下：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JSON中国&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://www.json.org.cn&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;page&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">88</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;isNonProfit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;street&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;浙大路38号.&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;浙江杭州&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;country&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;中国&quot;</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;links&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Google&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://www.google.com&quot;</span>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Baidu&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>        <span class="hljs-punctuation">&#123;</span>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SoSo&quot;</span><span class="hljs-punctuation">,</span>            <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://www.SoSo.com&quot;</span>        <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h2 id="cjson">cJSON</h2><p>cJSON是一个基于C的JSON解析库，这个库非常简短，提供有很多有用的API，支持JSON的解析和创建，移植时只需包含<code>cJSON.h</code>和<code>cJSON.c</code> 这两个文件，然后包含头文件即可调用其API函数。</p><p>cJSON项目托管在Github上，地址：<a href="https://github.com/DaveGamble/cJSON">https://github.com/DaveGamble/cJSON</a></p><h2 id="使用cjson库创建json数据">使用cJSON库创建JSON数据</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cJSON.h&quot;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    cJSON* cjson_test = <span class="hljs-literal">NULL</span>;    cJSON* cjson_address = <span class="hljs-literal">NULL</span>;    cJSON* cjson_skill = <span class="hljs-literal">NULL</span>;    <span class="hljs-type">char</span>* str = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/* 创建一个JSON数据对象(链表头结点) */</span>    cjson_test = cJSON_CreateObject();    <span class="hljs-comment">/* 添加一条字符串类型的JSON数据(添加一个链表节点) */</span>    cJSON_AddStringToObject(cjson_test, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;cjson&quot;</span>);    <span class="hljs-comment">/* 添加一条整数类型的JSON数据(添加一个链表节点) */</span>    cJSON_AddNumberToObject(cjson_test, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">10</span>);    <span class="hljs-comment">/* 添加一条浮点类型的JSON数据(添加一个链表节点) */</span>    cJSON_AddNumberToObject(cjson_test, <span class="hljs-string">&quot;weight&quot;</span>, <span class="hljs-number">20.3</span>);    <span class="hljs-comment">/* 添加一个嵌套的JSON数据（添加一个链表节点） */</span>    cjson_address = cJSON_CreateObject();    cJSON_AddStringToObject(cjson_address, <span class="hljs-string">&quot;country&quot;</span>, <span class="hljs-string">&quot;China&quot;</span>);    cJSON_AddNumberToObject(cjson_address, <span class="hljs-string">&quot;zip-code&quot;</span>, <span class="hljs-number">111111</span>);    cJSON_AddItemToObject(cjson_test, <span class="hljs-string">&quot;address&quot;</span>, cjson_address);    <span class="hljs-comment">/* 添加一个数组类型的JSON数据(添加一个链表节点) */</span>    cjson_skill = cJSON_CreateArray();    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString(<span class="hljs-string">&quot;C&quot;</span>));    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString(<span class="hljs-string">&quot;Java&quot;</span>));    cJSON_AddItemToArray(cjson_skill, cJSON_CreateString(<span class="hljs-string">&quot;Python&quot;</span>));    cJSON_AddItemToObject(cjson_test, <span class="hljs-string">&quot;skill&quot;</span>, cjson_skill);    <span class="hljs-comment">/* 添加一个值为 False 的布尔类型的JSON数据(添加一个链表节点) */</span>    cJSON_AddFalseToObject(cjson_test, <span class="hljs-string">&quot;student&quot;</span>);    <span class="hljs-comment">/* 打印JSON对象(整条链表)的所有数据 */</span>    str = cJSON_Print(cjson_test);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<span class="hljs-comment">/* 释放内存 */</span>cJSON_Delete(cjson_test);cJSON_Delete(cjson_address);cJSON_Delete(cjson_skill);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>运行结果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830083025553.png" alt="image-20230830083025553" style="zoom:80%;" /></p><h2 id="使用cjson库来解析json数据">使用cJSON库来解析JSON数据</h2><p>用于测试JSON数据，我们先用一个char型的字符串来保存，由于JSON对象的name和value都需要使用引号（数值或逻辑型value除外），所以 <strong>在遇到引号时，要加反斜杠<code>\</code>来转义</strong>。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cJSON.h&quot;</span></span><span class="hljs-type">char</span> *message =                               <span class="hljs-string">&quot;&#123;\&quot;name\&quot;: \&quot;cjson\&quot;,                      \</span><span class="hljs-string">\&quot;age\&quot;:  10,                             \</span><span class="hljs-string">\&quot;weight\&quot;:       20.300000,              \</span><span class="hljs-string">\&quot;address\&quot;:      &#123;                       \</span><span class="hljs-string">\&quot;country\&quot;:      \&quot;China\&quot;,      \</span><span class="hljs-string">\&quot;zip-code\&quot;:     111111          \</span><span class="hljs-string">&#125;,                                        \</span><span class="hljs-string">\&quot;skill\&quot;:        [\&quot;C\&quot;, \&quot;Java\&quot;, \&quot;Python\&quot;],  \</span><span class="hljs-string">\&quot;student\&quot;:      false                   \</span><span class="hljs-string">&#125;&quot;</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  cJSON* cjson_test = <span class="hljs-literal">NULL</span>;  cJSON* cjson_name = <span class="hljs-literal">NULL</span>;  cJSON* cjson_age = <span class="hljs-literal">NULL</span>;  cJSON* cjson_weight = <span class="hljs-literal">NULL</span>;  cJSON* cjson_address = <span class="hljs-literal">NULL</span>;  cJSON* cjson_address_country = <span class="hljs-literal">NULL</span>;  cJSON* cjson_address_zipcode = <span class="hljs-literal">NULL</span>;  cJSON* cjson_skill = <span class="hljs-literal">NULL</span>;  cJSON* cjson_student = <span class="hljs-literal">NULL</span>;  <span class="hljs-type">int</span>    skill_array_size = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;  cJSON* cjson_skill_item = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">/* 解析整段JSON数据 */</span>  cjson_test = cJSON_Parse(message);  <span class="hljs-keyword">if</span>(cjson_test == <span class="hljs-literal">NULL</span>)  &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parse fail.\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  &#125;  <span class="hljs-comment">/* 依次根据名称提取JSON数据（键值对） */</span>  cjson_name = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;name&quot;</span>);  cjson_age = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;age&quot;</span>);  cjson_weight = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;weight&quot;</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s\n&quot;</span>, cjson_name-&gt;valuestring);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;age:%d\n&quot;</span>, cjson_age-&gt;valueint);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;weight:%.1f\n&quot;</span>, cjson_weight-&gt;valuedouble);  <span class="hljs-comment">/* 解析嵌套JSON数据 */</span>  cjson_address = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;address&quot;</span>);  cjson_address_country = cJSON_GetObjectItem(cjson_address, <span class="hljs-string">&quot;country&quot;</span>);  cjson_address_zipcode = cJSON_GetObjectItem(cjson_address, <span class="hljs-string">&quot;zip-code&quot;</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address-country:%s\naddress-zipcode:%d\n&quot;</span>, cjson_address_country-&gt;valuestring, cjson_address_zipcode-&gt;valueint);  <span class="hljs-comment">/* 解析数组 */</span>  cjson_skill = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;skill&quot;</span>);  skill_array_size = cJSON_GetArraySize(cjson_skill);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;skill:[&quot;</span>);  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; skill_array_size; i++)  &#123;    cjson_skill_item = cJSON_GetArrayItem(cjson_skill, i);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s,&quot;</span>, cjson_skill_item-&gt;valuestring);  &#125;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\b]\n&quot;</span>);  <span class="hljs-comment">/* 解析布尔型数据 */</span>  cjson_student = cJSON_GetObjectItem(cjson_test, <span class="hljs-string">&quot;student&quot;</span>);  <span class="hljs-keyword">if</span>(cjson_student-&gt;valueint == <span class="hljs-number">0</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student: false\n&quot;</span>);  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student:error\n&quot;</span>);  <span class="hljs-comment">/* 释放内存 */</span>  cJSON_Delete(cjson_test);  cJSON_Delete(cjson_name);  cJSON_Delete(cjson_age);  cJSON_Delete(cjson_weight);  cJSON_Delete(cjson_address);  cJSON_Delete(cjson_address_country);  cJSON_Delete(cjson_address_zipcode);  cJSON_Delete(cjson_skill);  cJSON_Delete(cjson_student);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>运行结果：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830103105877.png" alt="" /><figcaption>image-20230830103105877</figcaption></figure><p>上面是针对JSON数据量较少的情况，通过一个字符串来保存，然后进行解析的方式。但实际使用中，JSON数据的内容较为庞大，<strong>一般都是使用文件的形式来保存JSON数据</strong>。</p><p>下面准备一个原始数据，如下面的json.txt：</p><div class="code-wrapper"><pre><code class="hljs c">&#123;    <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://www.json.org.cn&quot;</span>,    <span class="hljs-string">&quot;page&quot;</span>: <span class="hljs-number">88</span>,    <span class="hljs-string">&quot;address&quot;</span>: &#123;        <span class="hljs-string">&quot;street&quot;</span>: <span class="hljs-string">&quot;浙大路38号.&quot;</span>,        <span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;浙江杭州&quot;</span>,        <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;中国&quot;</span>    &#125;,    <span class="hljs-string">&quot;links&quot;</span>: [        &#123;            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Google&quot;</span>,            <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://www.google.com&quot;</span>        &#125;,        &#123;            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Baidu&quot;</span>,            <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>        &#125;,        &#123;            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;SoSo&quot;</span>,            <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://www.SoSo.com&quot;</span>        &#125;    ]&#125;</code></pre></div><p>解析这种JSON文件，使用要使用 <code>fopen()</code> 来打开这个文件,还要使用<code>fseek()</code>和<code>ftell()</code>来计算文件的大小，目的是用于后面的分配内存时指定大小。然后使用<code>fread()</code>将文件读入分配的内存中,接着使用<code>cJSON_Parse()</code> 将JSON数据解析为 <code>cJSON</code> 型的对象,然后就可以同上面的一样使用cJSON库中提供的各种函数API来操作这个对象了。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span> <span class="hljs-comment">//memset</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cJSON.h&quot;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> fileSize; <span class="hljs-comment">//文件大小</span><span class="hljs-type">char</span> *buf; <span class="hljs-comment">//分配内存buf</span><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, len = <span class="hljs-number">0</span>;<span class="hljs-comment">//数组长度</span>    <span class="hljs-comment">/* 打开JSON文件 */</span>     FILE *fp = fopen(<span class="hljs-string">&quot;json.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);    <span class="hljs-keyword">if</span>(fp == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-comment">/* 计算文件大小 */</span>     fseek(fp, <span class="hljs-number">0</span>, SEEK_END);<span class="hljs-comment">/* 定位文件指针到文件尾 */</span>     fileSize = ftell(fp);<span class="hljs-comment">/* 获取文件指针偏移量，即文件大小 */</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fileSize: %d Byte\r\n&quot;</span>, fileSize);fseek(fp, <span class="hljs-number">0</span>, SEEK_SET);<span class="hljs-comment">/* 再将文件指针移到文件开头 */</span>     <span class="hljs-comment">/* 根据文件大小分配内存，并读取文件到内存 */</span>     buf = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(fileSize * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, fileSize);    ret = fread(buf, fileSize, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), fp);    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)    &#123;        fclose(fp);        <span class="hljs-keyword">return</span>;    &#125;    fclose(fp);    <span class="hljs-comment">/* 把该字符串数据转成JSON数据 */</span>     cJSON *srcJsonData = cJSON_Parse(buf);    <span class="hljs-keyword">if</span>(srcJsonData == <span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;err\r\n&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;<span class="hljs-built_in">free</span>(buf);    <span class="hljs-comment">/* 解析JSON数据并输出显示 */</span>    <span class="hljs-comment">/*根据key值(url)获取对应的value*/</span>    cJSON *json_url = cJSON_GetObjectItem(srcJsonData, <span class="hljs-string">&quot;url&quot;</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;website: %s\r\n&quot;</span>, cJSON_Print(json_url));<span class="hljs-comment">/*根据key值(page)获取对应的value*/</span>    cJSON *json_page = cJSON_GetObjectItem(srcJsonData, <span class="hljs-string">&quot;page&quot;</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page: %d\r\n&quot;</span>, json_page-&gt;valueint);<span class="hljs-comment">/* 根据嵌套的key值(address)获取对应的value */</span>cJSON *json_address = cJSON_GetObjectItem(srcJsonData, <span class="hljs-string">&quot;address&quot;</span>);cJSON *json_street = cJSON_GetObjectItem(json_address, <span class="hljs-string">&quot;street&quot;</span>);cJSON *json_city = cJSON_GetObjectItem(json_address, <span class="hljs-string">&quot;city&quot;</span>);cJSON *json_country = cJSON_GetObjectItem(json_address, <span class="hljs-string">&quot;country&quot;</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address-street: %s; address-city: %s; address-country: %s\r\n&quot;</span>, cJSON_Print(json_street), \      cJSON_Print(json_city), cJSON_Print(json_country));      <span class="hljs-comment">// /* 根据数组key值(links)获取对应的value */</span>    cJSON* json_links = cJSON_GetObjectItem(srcJsonData, <span class="hljs-string">&quot;links&quot;</span>);    len = cJSON_GetArraySize(json_links); <span class="hljs-comment">/* 获取该数组的大小 */</span>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; i++)    &#123;        <span class="hljs-comment">/* 先获取每一条信息 */</span>        cJSON *tmpValue = cJSON_GetArrayItem(json_links, i);        <span class="hljs-comment">/* 再获取每条信息中的具体内容 */</span>         cJSON *nameValue = cJSON_GetObjectItem(tmpValue,<span class="hljs-string">&quot;name&quot;</span>);cJSON *urlValue = cJSON_GetObjectItem(tmpValue,<span class="hljs-string">&quot;url&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] %s \t %s \t %s\r\n&quot;</span>, i+<span class="hljs-number">1</span>, nameValue-&gt;valuestring, urlValue-&gt;valuestring);    &#125;<span class="hljs-comment">/* 释放内存 */</span>cJSON_Delete(json_url);cJSON_Delete(json_page);cJSON_Delete(json_address);cJSON_Delete(json_street);cJSON_Delete(json_city);cJSON_Delete(json_country);cJSON_Delete(json_links);  cJSON_Delete(srcJsonData);&#125;</code></pre></div><p>运行结果：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830132151235.png" alt="" /><figcaption>image-20230830132151235</figcaption></figure><h2 id="cjson使用过程中的内存问题">cJSON使用过程中的内存问题</h2><p>cJSON在使用过程中<strong>大量的使用<code>malloc</code>从堆中分配内存的，所以用完之后，应及时释放内存 <code>(void) cJSON_Delete(cJSON *item)</code></strong>。</p><p>另外，cJSON中还可以通过 <strong>cJSON_Hooks</strong> ，自定义malloc函数和free函数。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cJSON_Hooks</span> &#123;</span>      <span class="hljs-type">void</span> *(*malloc_fn)(<span class="hljs-type">size_t</span> sz);      <span class="hljs-type">void</span> (*free_fn)(<span class="hljs-type">void</span> *ptr);&#125; cJSON_Hooks;<span class="hljs-type">void</span> <span class="hljs-title function_">cJSON_InitHooks</span><span class="hljs-params">(cJSON_Hooks* hooks)</span>&#123;    <span class="hljs-keyword">if</span> (!hooks) &#123; <span class="hljs-comment">/* Reset hooks */</span>        cJSON_malloc = <span class="hljs-built_in">malloc</span>;        cJSON_free = <span class="hljs-built_in">free</span>;        <span class="hljs-keyword">return</span>;    &#125;cJSON_malloc = (hooks-&gt;malloc_fn)?hooks-&gt;malloc_fn:<span class="hljs-built_in">malloc</span>;cJSON_free = (hooks-&gt;free_fn)?hooks-&gt;free_fn:<span class="hljs-built_in">free</span>;&#125;</code></pre></div><p>工程文件已上传Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/cjson/cjson_demo.zip">cjson_demo</a></p><p><strong>链接：</strong></p><p><strong>JSON在线工具：</strong><a href="http://www.json.org.cn/tools/JSONEditorOnline2.0/index.htm">http://www.json.org.cn/tools/JSONEditorOnline2.0/index.htm</a></p><p><a href="https://blog.csdn.net/Mculover666/article/details/103796256">https://blog.csdn.net/Mculover666/article/details/103796256</a></p>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国内开源镜像站汇总</title>
    <link href="/2023/08/28/%E5%9B%BD%E5%86%85%E5%BC%80%E6%BA%90%E9%95%9C%E5%83%8F%E7%AB%99%E6%B1%87%E6%80%BB/"/>
    <url>/2023/08/28/%E5%9B%BD%E5%86%85%E5%BC%80%E6%BA%90%E9%95%9C%E5%83%8F%E7%AB%99%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="国内开源镜像站汇总">国内开源镜像站汇总</h2><h2 id="企业站点">企业站点</h2><ul><li><p>网易开源镜像站：<a href="http://mirrors.163.com/">http://mirrors.163.com/</a></p></li><li><p>搜狐开源镜像站：<a href="https://mirrors.sohu.com/">https://mirrors.sohu.com/</a></p></li><li><p>阿里云开源镜像站：<a href="https://mirrors.aliyun.com/">https://mirrors.aliyun.com/</a></p></li><li><p>腾讯软件源：<a href="https://mirrors.cloud.tencent.com/">https://mirrors.cloud.tencent.com/</a></p></li><li><p>华为开源镜像源：<a href="https://mirrors.huaweicloud.com/">https://mirrors.huaweicloud.com/</a></p></li><li><p>npmmirror 镜像站：<a href="https://npm.taobao.org/">https://npm.taobao.org/</a></p></li><li><p>开源社/Azure中国开源镜像站：<a href="https://mirror.azure.cn/">http://mirror.azure.cn/</a></p></li><li><p>中科院软件研究所开源镜像站：<a href="https://mirror.iscas.ac.cn/">https://mirror.iscas.ac.cn/</a></p></li><li><p>首都在线数据服务有限公司镜像站：<a href="http://mirrors.yun-idc.com/">http://mirrors.yun-idc.com/</a></p></li></ul><p>​</p><h2 id="高校站点">高校站点</h2><p>校园网联合镜像站：<a href="https://mirrors.cernet.edu.cn/">https://mirrors.cernet.edu.cn/</a> 本站提供对校园网镜像站的索引和跳转服务。</p><ul><li><p>OpenTUNA开源软件镜像站：<a href="https://opentuna.cn/">https://opentuna.cn/</a></p></li><li><p>清华大学开源软件镜像站：<a href="https://mirrors.tuna.tsinghua.edu.cn/">http://mirrors.tuna.tsinghua.edu.cn/</a></p></li><li><p>中国科学技术大学开源软件镜像站：<a href="https://mirrors.ustc.edu.cn/">http://mirrors.ustc.edu.cn/</a></p></li><li><p>北京大学开源镜像站：<a href="https://mirrors.pku.edu.cn/">http://mirrors.pku.edu.cn/</a></p></li><li><p>北京交通大学开源镜像站：<a href="https://mirror.bjtu.edu.cn/">https://mirror.bjtu.edu.cn/</a></p></li><li><p>北京邮电大学开源软件镜像站：<a href="https://mirrors.bupt.edu.cn/">http://mirrors.bupt.edu.cn/</a></p></li><li><p>北京外国语大学开源软件镜像站：<a href="https://mirrors.bfsu.edu.cn/">https://mirrors.bfsu.edu.cn/</a></p></li><li><p>哈尔滨工业大学开源镜像站: <a href="http://mirrors.hit.edu.cn">http://mirrors.hit.edu.cn</a></p></li><li><p>上海交通大学开源软件镜像站：<a href="https://ftp.sjtu.edu.cn/">http://ftp.sjtu.edu.cn/</a></p></li><li><p>南京大学开源镜像站：<a href="http://mirrors.nju.edu.cn/">http://mirrors.nju.edu.cn/</a></p></li><li><p>浙江大学开源软件镜像站：<a href="http://mirrors.zju.edu.cn/">http://mirrors.zju.edu.cn/</a></p></li><li><p>西安交通大学软件镜像站：<a href="https://mirrors.xjtu.edu.cn/">https://mirrors.xjtu.edu.cn/</a></p></li><li><p>兰州大学开源社区镜像站：<a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn/</a></p></li><li><p>重庆大学开源镜像站：<a href="http://mirrors.cqu.edu.cn/">http://mirrors.cqu.edu.cn/</a></p></li><li><p>吉林大学开源镜像站：<a href="https://mirrors.jlu.edu.cn/">https://mirrors.jlu.edu.cn/</a></p></li><li><p>南方科技大学开源镜像站：<a href="https://mirrors.sustech.edu.cn/">http://mirrors.sustech.edu.cn/</a></p></li><li><p>上海科技大学开源软件镜像站：<a href="https://mirrors.shanghaitech.edu.cn/">https://mirrors.shanghaitech.edu.cn/</a></p></li><li><p>东北大学开源镜像站：<a href="http://mirror.neu.edu.cn/">http://mirror.neu.edu.cn/</a></p></li><li><p>南京工业大学开源软件镜像站：<a href="https://mirrors.njtech.edu.cn/mirrors">https://mirrors.njtech.edu.cn/mirrors</a></p></li><li><p>华南农业大学开源镜像站：<a href="https://mirrors.scau.edu.cn/">https://mirrors.scau.edu.cn/</a></p></li><li><p>南阳理工学院开源软件镜像站：<a href="http://mirror.nyist.edu.cn/">http://mirror.nyist.edu.cn/</a></p></li><li><p>齐鲁工业大学开源软件镜像站：<a href="https://mirrors.qlu.edu.cn/">https://mirrors.qlu.edu.cn/</a></p></li><li><p>山东女子学院开源镜像站：<a href="http://mirrors.sdwu.edu.cn/">http://mirrors.sdwu.edu.cn/</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体struct详解</title>
    <link href="/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93struct%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93struct%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>结构体(struct)</strong>是 C 编程中一种用户自定义的数据结构，它可以包含不同基本类型(char,int,float...)的数据项，在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。<strong>需要注意的是，结构体是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，会占用内存空间。</strong></p><p>在实际应用中，我们一般会使用结构体将某个对象的属性和行为进行封装声明，然后定义一个独立的整体变量进行使用。</p><h1 id="结构体的声明与定义">结构体的声明与定义</h1><p>结构体的声明和定义有多种形式：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 1.声明一个结构体然后进行定义 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">int</span> a;    <span class="hljs-type">char</span> b;    <span class="hljs-type">double</span> c;&#125;;<span class="hljs-comment">//分号不能少</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> <span class="hljs-title">t1</span>, <span class="hljs-title">t2</span>[10], *<span class="hljs-title">t3</span>;</span> <span class="hljs-comment">//定义了三个struct变量</span><span class="hljs-comment">/* 2.声明一个结构体的同时进行定义 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">int</span> a;    <span class="hljs-type">char</span> b;    <span class="hljs-type">double</span> c;&#125;t1, t2;<span class="hljs-comment">/* 3.声明一个结构体的同时进行定义,同时去掉tag标签 */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><span class="hljs-class">&#123;</span>    <span class="hljs-type">int</span> a;    <span class="hljs-type">char</span> b;    <span class="hljs-type">double</span> c;&#125;t1, t2; <span class="hljs-comment">/* 4.用typedef创建新类型，比较常用 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">int</span> a;    <span class="hljs-type">char</span> b;    <span class="hljs-type">double</span> c;&#125;<span class="hljs-type">data_t</span>;<span class="hljs-type">data_t</span> t1, t2[<span class="hljs-number">10</span>], *t3; <span class="hljs-comment">//定义了三个struct变量</span></code></pre></div><h1 id="结构体变量的初始化">结构体变量的初始化</h1><p>和其它类型变量一样，对结构体变量可以在定义时指定初始值。用符号<code>&#123;&#125;</code>括起来，用逗号分隔各个数据项。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-type">int</span> a;  <span class="hljs-type">char</span> b;  <span class="hljs-type">double</span> c;&#125;;<span class="hljs-comment">//分号不能少</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> <span class="hljs-title">t1</span> =</span> &#123;  <span class="hljs-number">20</span>,  <span class="hljs-string">&quot;libs&quot;</span>,  <span class="hljs-number">890.234</span>&#125;; <span class="hljs-comment">//各个数据项要与声明时数据项一一对应</span></code></pre></div><p>在C99标准中，还支持给指定元素赋值：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tag</span> <span class="hljs-title">t1</span> =</span> &#123;  .c = <span class="hljs-number">890.234</span>  .a = <span class="hljs-number">20</span>,  .b = <span class="hljs-string">&quot;libs&quot;</span>,&#125;; <span class="hljs-comment">//各个数据项可以跟声明时数据项不对应</span></code></pre></div><h1 id="结构体成员变量的访问">结构体成员变量的访问</h1><p>如果定义的是结构体变量指针，我们需要用<code>-&gt;</code>来访问结构体的成员；如果定义的是结构体变量，我们需要用<code>.</code>来访问结构体成员。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">int</span> year;<span class="hljs-type">int</span> month;<span class="hljs-type">int</span> day;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">char</span> s_name[<span class="hljs-number">20</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span> <span class="hljs-title">birthday</span>;</span><span class="hljs-type">float</span> score;&#125;;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">stu</span> =</span> &#123; <span class="hljs-string">&quot;liuhai&quot;</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">99.5</span> &#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> *<span class="hljs-title">p_stu</span>;</span> <span class="hljs-comment">//定义一个结构体指针</span>p_stu = &amp;stu;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name=%s\n birtyday=%d.%d.%d\n score=%f\n&quot;</span>, stu.s_name, stu.birthday.year, stu.birthday.month, stu.birthday.day, stu.score);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name=%s\n birtyday=%d.%d.%d\n score=%f\n&quot;</span>, p_stu-&gt;s_name, p_stu-&gt;birthday.year, p_stu-&gt;birthday.month, p_stu-&gt;birthday.day, p_stu-&gt;score);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>运行如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830163315974.png" alt="" /><figcaption>image-20230830163315974</figcaption></figure><h1 id="函数与结构体参数">函数与结构体参数</h1><p>结构体和结构体指针都可以作为函数参数来使用。如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">school</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">char</span> s_name[<span class="hljs-number">20</span>];<span class="hljs-type">int</span> s_age;&#125;<span class="hljs-type">school_t</span>;<span class="hljs-comment">/* 结构体作为函数参数 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">print_a</span><span class="hljs-params">(<span class="hljs-type">school_t</span> sx)</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s age: %d\n&quot;</span>, sx.s_name, sx.s_age);&#125;<span class="hljs-comment">/* 结构体指针作为函数参数 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">print_b</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> school* sp)</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s age: %d\n&quot;</span>, sp-&gt;s_name, sp-&gt;s_age);&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">school</span> <span class="hljs-title">sx</span> =</span> &#123; <span class="hljs-string">&quot;wuhan&quot;</span>, <span class="hljs-number">20</span> &#125;;  print_a(sx);print_b(&amp;sx);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830180715263.png" alt="" /><figcaption>image-20230830180715263</figcaption></figure><p>在实际应用中，因为结构体作为行参在调用中是复制一份结构体实参，占用内存比较大，而结构体指针大小都一样，占用内存就不会太大，所以，使用结构体指针进行函数参数传递的方式更好一些。</p><h1 id="结构体大小的计算与对齐">结构体大小的计算与对齐</h1><p>不同的CPU架构，各种基础数据类型的大小不一样，具体如下：</p><table><thead><tr class="header"><th></th><th><strong>16位编译器</strong></th><th><strong>32位编译器</strong></th><th><strong>64位编译器</strong></th></tr></thead><tbody><tr class="odd"><td><strong>char/unsigned char</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>1</strong></td></tr><tr class="even"><td><strong>short/unsigned short</strong></td><td><strong>2</strong></td><td><strong>2</strong></td><td><strong>2</strong></td></tr><tr class="odd"><td><strong>int/unsigned int</strong></td><td><strong>2</strong></td><td><strong>4</strong></td><td><strong>4</strong></td></tr><tr class="even"><td><strong>float</strong></td><td><strong>4</strong></td><td><strong>4</strong></td><td><strong>4</strong></td></tr><tr class="odd"><td><strong>double</strong></td><td><strong>8</strong></td><td><strong>8</strong></td><td><strong>8</strong></td></tr><tr class="even"><td><strong>long</strong></td><td><strong>4</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr><tr class="odd"><td><strong>long long</strong></td><td><strong>8</strong></td><td><strong>8</strong></td><td><strong>8</strong></td></tr><tr class="even"><td><strong>long double</strong></td><td><strong>8</strong></td><td><strong>12</strong></td><td><strong>16</strong></td></tr><tr class="odd"><td><strong>pointer(*)</strong></td><td><strong>2</strong></td><td><strong>4</strong></td><td><strong>8</strong></td></tr></tbody></table><p>可使用 <code>sizeof()</code> 运算符进行计算，如下在64位CPU架构下的各个数据类型大小：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830165411454.png" alt="" /><figcaption>image-20230830165411454</figcaption></figure><p>关于结构体大小的计算，需要把握三个规则：</p><ul><li><p><strong>结构体变量的首地址，必须是结构体变量的“最大基本数据类型成员所占字节数”的整数倍；</strong></p></li><li><p><strong>结构体变量中的每个成员相对于结构体首地址的偏移量，都是该成员基本数据类型所占字节数的整数倍；</strong></p></li><li><p><strong>结构体变量的总大小，为结构体变量中“最大基本数据类型成员所占字节”的整数倍；</strong></p></li></ul><p>CPU并非逐字节读写内存，而是以2,4,或8的倍数的字节块来读写内存，因此会对基本数据类型的地址进行字节对齐排列。程序中预处理指令 <code># pragma pack(n)</code> 可以改变默认对齐数。n取值有 <strong>1,2,4,8,16 </strong>。</p><p>举例如下：</p><p><strong>32位系统</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830191705893.png" alt="" /><figcaption>image-20230830191705893</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/640.png" alt="" /><figcaption>图片</figcaption></figure><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830185815016.png" alt="image-20230830185815016" style="zoom:80%;" /></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/640-16933926647246.png" alt="" /><figcaption>图片</figcaption></figure><p>从上图可以看出S0占用6字节，S2占用内存8字节，S3占用内存12字节，SU2占用内存32字节，SS1占用内存12字节，SS2占用内存6字节。使用 <code>sizeof()</code> 运算符计算，得到的结果与上一致。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230830191935476.png" alt="" /><figcaption>image-20230830191935476</figcaption></figure><p><strong>参考：</strong></p><p><a href="https://huaweicloud.csdn.net/63a5662fb878a54545946303.html?spm=1001.2101.3001.6650.18&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-18-124280883-blog-127088224.235%5Ev38%5Epc_relevant_sort&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-18-124280883-blog-127088224.235%5Ev38%5Epc_relevant_sort&amp;utm_relevant_index=26#3.1%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE">C语言——结构体</a></p><p>https://mp.weixin.qq.com/s/VaIx5KjwqfQeLSlbcjywkQ</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>struct</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>共用体union详解</title>
    <link href="/2023/08/28/%E5%85%B1%E7%94%A8%E4%BD%93union%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/08/28/%E5%85%B1%E7%94%A8%E4%BD%93union%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>共用体（union）</strong>，也叫 <strong>联合体</strong>，是C语言中一种常用的构造复合数据结构，这种类型定义的变量也包含一系列成员，<strong>这些成员共用同一块内存空间，所以在同一时间，只能使用一个共用体成员。</strong></p><h2 id="共用体的定义">共用体的定义</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">/* 创建共用体模板，然后定义变量 */</span><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">stu</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-type">int</span> age;  <span class="hljs-type">char</span> name;&#125;;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">stu</span> <span class="hljs-title">ua</span>;</span><span class="hljs-comment">// 使用该共用体模板创建变量a</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;ua      :%p\n&quot;</span>, &amp;ua);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;ua.age  :%p\n&quot;</span>, &amp;(ua.age));<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;ua.name :%p\n&quot;</span>, &amp;(ua.name));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230828150049478.png" alt="" /><figcaption>image-20230828150049478</figcaption></figure><p>可以看到：它们共用同一个内存空间。</p><h2 id="共用体的内存大小计算">共用体的内存大小计算</h2><p>一般情况下，一个共用体变量的大小以成员变量中占用内存空间最大的成员来确定。但占用最大空间的成员没有字节对齐，则需要按照字节对齐处理的方式来计算。</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Un</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">short</span> c[<span class="hljs-number">5</span>];<span class="hljs-comment">//1个short类型占2字节，5个占10字节</span><span class="hljs-type">int</span> i;<span class="hljs-comment">//4字节</span>&#125;;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">union</span> Un));<span class="hljs-comment">//打印12</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="共用体的应用">共用体的应用</h2><h4 id="检测当前处理器大小端模式">1.检测当前处理器大小端模式</h4><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Un</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">char</span> c;<span class="hljs-type">int</span> i;&#125;u;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;u.i = <span class="hljs-number">1</span>; <span class="hljs-comment">//0x 00 00 00 01</span><span class="hljs-keyword">if</span> (u.c == <span class="hljs-number">1</span>)<span class="hljs-comment">//01 00 00 00 小端存储 低位放低地址</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Little Endian\n&quot;</span>);<span class="hljs-keyword">else</span> <span class="hljs-comment">//00 00 00 01 大端存储 低位放高地址</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Big Endian\n&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="浮点型转换与4字节整型之间转换">2.浮点型转换与4字节整型之间转换</h3><p>当我们使用串口传输浮点型数据时，常用的方法是将浮点数乘以一个倍数，变成整形数，然后进行字节传输。其实，使用共用体可以直接将浮点数据转换为4个单字节，然后就可以传输了，同理，也可以把4个单字节数转换为浮点型数。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-type">float</span> fdata;        <span class="hljs-comment">//fdata和dat共用存储空间</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> dat[<span class="hljs-number">4</span>];&#125; <span class="hljs-type">float_int_t</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;  <span class="hljs-type">float</span> f=<span class="hljs-number">123.567</span>;    <span class="hljs-comment">//要转换的浮点数</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> byte[<span class="hljs-number">4</span>]= &#123;<span class="hljs-number">0x4e</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0xf7</span>, <span class="hljs-number">0x42</span>&#125;; <span class="hljs-comment">//4个字节数据存放的数组</span>  <span class="hljs-type">float_int_t</span> fi;  <span class="hljs-meta">#<span class="hljs-keyword">if</span> 1  </span>  fi.fdata = f;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原始浮点数: %f\n&quot;</span>,fi.fdata);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;浮点数转Byte: %#x %#x %#x %#x \n&quot;</span>, fi.dat[<span class="hljs-number">0</span>], fi.dat[<span class="hljs-number">1</span>], fi.dat[<span class="hljs-number">2</span>], fi.dat[<span class="hljs-number">3</span>]);<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>  fi.dat[<span class="hljs-number">0</span>] = byte[<span class="hljs-number">0</span>];  fi.dat[<span class="hljs-number">1</span>] = byte[<span class="hljs-number">1</span>];  fi.dat[<span class="hljs-number">2</span>] = byte[<span class="hljs-number">2</span>];  fi.dat[<span class="hljs-number">3</span>] = byte[<span class="hljs-number">3</span>];  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Byte转浮点数: %f\n&quot;</span>,fi.fdata);     <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230828172122333.png" alt="image-20230828172122333" /> <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230828172218764.png" alt="image-20230828172218764" /></p><p>可以看到，它们之间相互转换是OK的，因为float类型在计算机中的存储位数和方式会导致精度的偏差，一般的偏差都很小，double的精度更高一些。</p><p>参考链接：</p><p>https://blog.csdn.net/m0_57180439/article/details/120417270</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>union</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法</title>
    <link href="/2023/08/26/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/08/26/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>排序算法是《数据结构与算法》中最基本的算法之一，常见的共有十种：</p><ol type="1"><li><a href="http://www.codebaoku.com/algorithm-sort/bubble-sort.html">冒泡排序（Bubble Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/selection-sort.html">选择排序（Selection Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/insertion-sort.html">插入排序（Insertion Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/shell-sort.html">希尔排序（Shell Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/merge-sort.html">归并排序（Merge Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/quick-sort.html">快速排序（Quick Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/heap-sort.html">堆排序（Heap Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/counting-sort.html">计数排序（Counting Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/bucket-sort.html">桶排序（Bucket Sort）</a></li><li><a href="http://www.codebaoku.com/algorithm-sort/radix-sort.html">基数排序（Radix Sort）</a></li></ol><p>其中，前面七种属于比较排序，即通过比较来决定元素的相对次序。后面三种则属于非比较排序。</p><p>这十种排序方式的复杂度如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230827112203238.png" alt="" /><figcaption>image-20230827112203238</figcaption></figure><p>下面分别来看看这十种排序方式：</p><h2 id="冒泡排序bubble-sort">冒泡排序（Bubble Sort）</h2><p>冒泡排序的基本思想是，从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻元素大小比较进行交换，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9a152a7e13500cf688efd8e5297f9f6e.gif" alt="" /><figcaption>冒泡排序的动图演示</figcaption></figure><p>在数据完全有序的时候展现出最优时间复杂度，为O(n)。其他情况下，几乎总是O( n2 )。因此，算法在数据基本有序的情况下，性能最好。 要使算法在最佳情况下有O(n)复杂度，需要做一些改进，增加一个<code>swap</code>的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> i, j, temp;    <span class="hljs-type">bool</span> swap;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)    &#123;        swap = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)        &#123;            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])             &#123;                temp = arr[j];                arr[j] = arr[j + <span class="hljs-number">1</span>];                arr[j + <span class="hljs-number">1</span>] = temp;                swap = <span class="hljs-literal">true</span>;            &#125;                    &#125;         <span class="hljs-keyword">if</span>(swap == <span class="hljs-literal">false</span>) <span class="hljs-comment">//有序</span>            <span class="hljs-keyword">break</span>;    &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">22</span>, <span class="hljs-number">34</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">82</span>, <span class="hljs-number">55</span>, <span class="hljs-number">89</span>, <span class="hljs-number">50</span>, <span class="hljs-number">37</span>, <span class="hljs-number">5</span>, <span class="hljs-number">64</span>, <span class="hljs-number">35</span>, <span class="hljs-number">9</span>, <span class="hljs-number">70</span> &#125;;    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);    bubble_sort(arr, len);    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高,基本为O(n2)，在数据量大的时候不适合使用。</p><h2 id="选择排序selection-sort">选择排序（Selection Sort）</h2><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p><p>它的排序思想是首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/c7322fccb46e3cc0ea3c107781d1e880.gif" alt="" /><figcaption>选择排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span> <span class="hljs-comment">//交互两个变量</span>&#123;    <span class="hljs-type">int</span> temp = *a;    *a = *b;    *b = temp;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">selection_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>&#123;    <span class="hljs-type">int</span> i,j;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; len - <span class="hljs-number">1</span> ; i++)    &#123;<span class="hljs-type">int</span> min = i;<span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; len; j++) <span class="hljs-comment">//遍历未排序的元素</span>        &#123;    <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min])    <span class="hljs-comment">//找到目前最小值</span>        min = j;      <span class="hljs-comment">//记录最小值序号            </span>        &#125;swap(&amp;arr[min], &amp;arr[i]);     <span class="hljs-comment">//做交換</span>     &#125;&#125;</code></pre></div><p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。</p><h2 id="插入排序insertion-sort">插入排序（Insertion Sort）</h2><p>插入排序的基本方法是：从待排序的n个元素中的第二个元素开始，依次与前面的元素比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6d867acd56e40fb32975f9e91d041fa9.gif" alt="" /><figcaption>插入排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertion_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>&#123;    <span class="hljs-type">int</span> i,j,key;    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;len;i++)    &#123;        key = arr[i];        j=i<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>((j&gt;=<span class="hljs-number">0</span>) &amp;&amp; (arr[j]&gt;key))         &#123;            arr[j+<span class="hljs-number">1</span>] = arr[j];            j--;        &#125;        arr[j+<span class="hljs-number">1</span>] = key;    &#125;&#125;</code></pre></div><p>插入排序由于O( n2 )的复杂度，在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。</p><h2 id="希尔排序shell-sort">希尔排序（Shell Sort）</h2><p>希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p>希尔排序基本思想是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/e250b339f4595451ca75ba3b83c83704.gif" alt="" /><figcaption>十大经典排序算法动画与解析，看我就够了！（配代码完全版）</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> gap, i, j;    <span class="hljs-type">int</span> temp;        <span class="hljs-keyword">for</span> (gap = len &gt;&gt; <span class="hljs-number">1</span>; gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>)    &#123;    <span class="hljs-keyword">for</span> (i = gap; i &lt; len; i++)         &#123;            temp = arr[i];            <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)            &#123;                arr[j + gap] = arr[j];            &#125;            arr[j + gap] = temp;    &#125;            &#125;&#125;</code></pre></div><p>Shell排序虽然快，但是毕竟是插入排序，其数量级并没有后起之秀--快速排序O(n㏒n)快。在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。</p><h2 id="归并排序merge-sort">归并排序（Merge Sort）</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p>它的基本思路是：</p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2f9f62d486be19b87a3f37f13eb75786.gif" alt="" /><figcaption>归并排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;    <span class="hljs-keyword">return</span> x &lt; y ? x : y;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> *a = arr;    <span class="hljs-type">int</span> *b = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));    <span class="hljs-type">int</span> seg, start;        <span class="hljs-keyword">for</span> (seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg)     &#123;        <span class="hljs-keyword">for</span> (start = <span class="hljs-number">0</span>; start &lt; len; start += seg * <span class="hljs-number">2</span>)         &#123;            <span class="hljs-type">int</span> low = start, mid = min(start + seg, len), high = min(start + seg * <span class="hljs-number">2</span>, len);            <span class="hljs-type">int</span> k = low;            <span class="hljs-type">int</span> start1 = low, end1 = mid;            <span class="hljs-type">int</span> start2 = mid, end2 = high;                        <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            <span class="hljs-keyword">while</span> (start1 &lt; end1)                b[k++] = a[start1++];            <span class="hljs-keyword">while</span> (start2 &lt; end2)                b[k++] = a[start2++];        &#125;        <span class="hljs-type">int</span> *temp = a;        a = b;        b = temp;    &#125;    <span class="hljs-keyword">if</span> (a != arr)     &#123;        <span class="hljs-type">int</span> i;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        &#123;            b[i] = a[i];                    &#125;        b = a;    &#125;    <span class="hljs-built_in">free</span>(b);&#125;</code></pre></div><p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。</p><h2 id="快速排序quick-sort">快速排序（Quick Sort）</h2><p>冒泡排序总的比较与移动次数较多，快速排序又称分区交换排序，是对冒泡排序的改进，快速排序采用的思想是分治思想。</p><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/eaca66d26efe27519e8c462d3a7d4593.gif" alt="" /><figcaption>快速排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//a：待排序数组，low：最低位的下标，high：最高位的下标</span><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span>&#123;    <span class="hljs-keyword">if</span>(low&gt;=high)    &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">int</span> left=low;    <span class="hljs-type">int</span> right=high;    <span class="hljs-type">int</span> key=a[left];    <span class="hljs-comment">/*用数组的第一个记录作为分区元素*/</span>    <span class="hljs-keyword">while</span>(left!=right)    &#123;        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[right]&gt;=key)    <span class="hljs-comment">/*从右向左扫描，找第一个码值小于key的记录，并交换到key*/</span>            --right;        a[left]=a[right];        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[left]&lt;=key)            ++left;        a[right]=a[left];    <span class="hljs-comment">/*从左向右扫描，找第一个码值大于key的记录，并交换到右边*/</span>    &#125;    a[left]=key;    <span class="hljs-comment">/*分区元素放到正确位置*/</span>    quickSort(a,low,left<span class="hljs-number">-1</span>);    quickSort(a,left+<span class="hljs-number">1</span>,high);&#125;</code></pre></div><p>快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。</p><h2 id="堆排序heap-sort">堆排序（Heap Sort）</h2><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序原理就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</p><figure><img src="https://ask.qcloudimg.com/http-save/yehe-8223537/2c40662fc38e7e7ba7882786f1ee19e2.gif" alt="" /><figcaption>十大经典排序算法动画与解析，看我就够了！（配代码完全版）</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> &#123;    <span class="hljs-type">int</span> temp = *b;    *b = *a;    *a = temp;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;    <span class="hljs-comment">// 建立父節點指標和子節點指標</span>    <span class="hljs-type">int</span> dad = start;    <span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (son &lt;= end)     &#123; <span class="hljs-comment">// 若子節點指標在範圍內才做比較</span>        <span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 先比較兩個子節點大小，選擇最大的</span>            son++;        <span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">//如果父節點大於子節點代表調整完畢，直接跳出函數</span>            <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">else</span>         &#123; <span class="hljs-comment">// 否則交換父子內容再繼續子節點和孫節點比較</span>            swap(&amp;arr[dad], &amp;arr[son]);            dad = son;            son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        &#125;    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;    <span class="hljs-type">int</span> i;    <span class="hljs-comment">// 初始化，i從最後一個父節點開始調整</span>    <span class="hljs-keyword">for</span> (i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)        max_heapify(arr, i, len - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢</span>    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);        max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, \                 <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(*arr);    heap_sort(arr, len);    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p><hr /><h2 id="计数排序counting-sort">计数排序（Counting Sort）</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>它的基本方法是：</p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/25fdb31acd81f931cd443cb932140ab9.gif" alt="" /><figcaption>冒泡排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">print_arr</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-type">int</span> i;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, arr[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">counting_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *ini_arr, <span class="hljs-type">int</span> *sorted_arr, <span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-type">int</span> *count_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100</span>);    <span class="hljs-type">int</span> i, j, k;    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">100</span>; k++)        count_arr[k] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)        count_arr[ini_arr[i]]++;    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">100</span>; k++)        count_arr[k] += count_arr[k - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (j = n; j &gt; <span class="hljs-number">0</span>; j--)        sorted_arr[--count_arr[ini_arr[j - <span class="hljs-number">1</span>]]] = ini_arr[j - <span class="hljs-number">1</span>];    <span class="hljs-built_in">free</span>(count_arr);&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> i;    <span class="hljs-type">int</span> *arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * n);    <span class="hljs-type">int</span> *sorted_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * n);    srand(time(<span class="hljs-number">0</span>));    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)        arr[i] = rand() % <span class="hljs-number">100</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ini_array: &quot;</span>);    print_arr(arr, n);    counting_sort(arr, sorted_arr, n);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sorted_array: &quot;</span>);    print_arr(sorted_arr, n);    <span class="hljs-built_in">free</span>(arr);    <span class="hljs-built_in">free</span>(sorted_arr);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>排序目标要能够映射到整数域，其最大值最小值应当容易辨别。例如高中生考试的总分数，显然用0-750就OK啦；又比如一群人的年龄，用个0-150应该就可以了，再不济就用0-200喽。另外，计数排序需要占用大量空间，它比较适用于数据比较集中的情况。</p><h2 id="桶排序bucket-sort">桶排序（Bucket Sort）</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9095a2947d144f4b960369dbc1d259d7.gif" alt="" /><figcaption>img</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 使用桶排序法对数列 [5，2，30，98，20，1，45，80] 从小到大排序 */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> m[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">30</span>,<span class="hljs-number">98</span>,<span class="hljs-number">20</span>,<span class="hljs-number">1</span>,<span class="hljs-number">45</span>,<span class="hljs-number">80</span>&#125;;    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组a存放[1,10]的数,将数组a赋值为零*/</span>    <span class="hljs-type">int</span> b[<span class="hljs-number">40</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组b存放[11,50]的数,将数组b赋值为零*/</span>    <span class="hljs-type">int</span> c[<span class="hljs-number">50</span>]=&#123;<span class="hljs-number">0</span>&#125;;        <span class="hljs-comment">/*数组c存放[51,100]的数,将数组c赋值为零*/</span>    <span class="hljs-type">int</span> i;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)    &#123;        <span class="hljs-comment">/* 定义三个桶 */</span>        <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">0</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">11</span>))             a[m[i]<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;               <span class="hljs-comment">/*假如i=0,那么m[i]=5;将5放在数组a的第5个位置，即a[4]中,所以是a[m[i]-1] */</span>        <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">10</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">51</span>))             b[m[i]<span class="hljs-number">-10</span><span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;           <span class="hljs-keyword">if</span>((m[i]&gt;<span class="hljs-number">51</span>)&amp;&amp;( m[i]&lt;<span class="hljs-number">101</span>))             c[m[i]<span class="hljs-number">-50</span><span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;        &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)                         <span class="hljs-comment">/*输出数组a的结果*/</span>      <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">40</span>;i++)                         <span class="hljs-comment">/*输出数组b的结果*/</span>      <span class="hljs-keyword">if</span>(b[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">11</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">50</span>;i++)                         <span class="hljs-comment">/*输出数组c的结果*/</span>      <span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">1</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d  &quot;</span>,i+<span class="hljs-number">51</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;</code></pre></div><p>桶排序可用于最大最小值相差较大的数据情况，但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。</p><h2 id="基数排序radix-sort">基数排序（Radix Sort）</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/88cb17eb223c8838182dcaff3dfcde17.gif" alt="" /><figcaption>基数排序的动图演示</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 20</span><span class="hljs-comment">//#define SHOWPASS</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> BASE 10</span><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-type">int</span> i;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)   &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, a[i]);  &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">radixsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span> &#123;  <span class="hljs-type">int</span> i, b[MAX], m = a[<span class="hljs-number">0</span>], <span class="hljs-built_in">exp</span> = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)   &#123;    <span class="hljs-keyword">if</span> (a[i] &gt; m)       m = a[i];  &#125;  <span class="hljs-keyword">while</span> (m / <span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">0</span>)   &#123;    <span class="hljs-type">int</span> bucket[BASE] = &#123; <span class="hljs-number">0</span> &#125;;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)     &#123;      bucket[(a[i] / <span class="hljs-built_in">exp</span>) % BASE]++;    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; BASE; i++)     &#123;      bucket[i] += bucket[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)     &#123;      b[--bucket[(a[i] / <span class="hljs-built_in">exp</span>) % BASE]] = a[i];    &#125;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)     &#123;      a[i] = b[i];    &#125;    <span class="hljs-built_in">exp</span> *= BASE;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SHOWPASS</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nPASS   : &quot;</span>);    print(a, n);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>  &#125;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <span class="hljs-type">int</span> arr[MAX];  <span class="hljs-type">int</span> i, n;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter total elements (n &lt;= %d) : &quot;</span>, MAX);  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  n = n &lt; MAX ? n : MAX;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter %d Elements : &quot;</span>, n);  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)   &#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);  &#125;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nARRAY  : &quot;</span>);  print(&amp;arr[<span class="hljs-number">0</span>], n);  radixsort(&amp;arr[<span class="hljs-number">0</span>], n);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nSORTED : &quot;</span>);  print(&amp;arr[<span class="hljs-number">0</span>], n);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>基数排序要求较高，元素必须是整数，整数时长度10W以上，最大值100W以下效率较好，但是基数排序比其他排序好在可以适用字符串，或者其他需要根据多个条件进行排序的场景，例如日期，先排序日，再排序月，最后排序年 ，其它排序算法可是做不了的。</p><p>参考链接：</p><p>https://zhuanlan.zhihu.com/p/42586566</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的开发概念及开源资源</title>
    <link href="/2023/08/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E5%8F%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BC%80%E6%BA%90%E8%B5%84%E6%BA%90/"/>
    <url>/2023/08/20/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E5%8F%91%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BC%80%E6%BA%90%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/gnu-100-b98545.png"><p align="center"><b style="font-size:25px">GNU</b></p></p><p>GNU是一个开源组织，同时也是一个100%自由软件的操作系统，包含了所有的官方GNU软件包，也包括非GNU自由软件。</p><p>官网：<a href="https://www.gnu.org/">https://www.gnu.org/</a></p><ul><li><p><strong>GCC/G++</strong>：GNU工具链中的编译器。</p></li><li><p><strong><a href="https://www.gnu.org/software/make/">Make</a></strong>：GNU工具链中的构建生成器，搭配makefile文件使用。</p></li><li><p><strong><a href="https://www.sourceware.org/gdb/">GDB（GNU Debuger）</a></strong>：GNU 开源组织发布的一个强大的UNIX 下的程序调试工具。</p></li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6ac65d24163b5b6e0.jpeg"><p align="center"><b style="font-size:25px">LLVM</b></p></p><p>LLVM是编译器和工具链技术的集合。</p><p>官网： <a href="https://clang.llvm.org/">https://clang.llvm.org/</a></p><p><strong>clang/clang++</strong> ：LLVM工具链中C/C++/Objective-C 编译器。</p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/weq.png"><p align="center"><b style="font-size:25px">Cygwin</b></p></p><p>Cygwin是GNU编译器和大量开源工具的集合，能够在Windows系统上提供类似于Linux系统的功能。它提供了大量的POSIX API功能。</p><p>官网：<a href="https://www.cygwin.com/index.html">https://www.cygwin.com/index.html</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/%EF%BC%ADinGW-w64-long.png"><p align="center"><b style="font-size:25px">MinGw</b></p></p><p>MinGW(Minimalist GNU for Windows)是一个开源的基于GNU的编译器套件，允许你在Windows平台生成本地的Windows程序而不需要系统运行库(C Runtime library，静态库lib或动态库dll)。</p><p>官网：<a href="https://www.mingw-w64.org/">https://www.mingw-w64.org/</a></p><p><a href="https://zhuanlan.zhihu.com/p/76613134?utm_source=QQ_article_bottom">MinGW-w64安装教程——著名C/C++编译器GCC的Windows版本</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/RE1Mu3b.png"><p align="center"><b style="font-size:25px">MSVC</b></p></p><p>MSVC(Microsoft Visual C/C++)是微软公司开发的Windows下编译器工具链，已经集成到Microsoft Visual Studio环境中。</p><p>官网：<a href="https://learn.microsoft.com/zh-cn/cpp/build/projects-and-build-systems-cpp?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/build/projects-and-build-systems-cpp?view=msvc-170</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/Cmake-logo-header.png"><p align="center"><b style="font-size:25px">CMake</b></p></p><p>CMake(Cross platform make)是比Make更高一层的工具,搭配CmakeList.txt文件，产生标准的建构档，再依一般的建构方式进行项目构建。</p><p>官网：<a href="https://cmake.org/">https://cmake.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/Qt-logo-neon-small.png" alt="img" style="zoom:33%;" /><p align="center"><b style="font-size:25px">qmake</b></p></p><p>qmake 是QT工程的项目构建生成器。</p><p>官网：<a href="https://www.qt.io/product/development-tools">https://www.qt.io/product/development-tools</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825103236069.png"><p align="center"><b style="font-size:25px">QCustomPlot</b></p></p><p>QCustomPlot 是用于Qt中绘图和数据可视化的一个开源C++库。该绘图库专注于制作精美、可打印的高质量2D图形表，并在应用程序内显示实时数据。</p><p>官网：<a href="https://www.qcustomplot.com/">https://www.qcustomplot.com/</a></p><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/SCons-Bricks.png"><p align="center"><b style="font-size:25px">SCons</b></p></p><p>SCons 是项目构建工具，使用 SConstruct 和 SConscript 文件来替代复杂规则的makefile文件，像RT-thread系统构建中有使用。</p><p>官网：<a href="https://www.scons.org/">https://www.scons.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/tux.png"><p align="center"><b style="font-size:25px">Linux</b></p></p><ul><li><p><strong>Linux Kernel</strong> ：Linux内核 ，Linux系统核心。</p><p>官网：<a href="https://kernel.org/">https://kernel.org/</a></p></li><li><p><strong>U-Boot</strong>：Linux系统启动引导代码。全称 Universal Boot Loader。</p><p>官网：<a href="https://u-boot.readthedocs.io/en/latest/">https://u-boot.readthedocs.io/en/latest/</a></p><p>源码网址：</p><ul><li><a href="https://source.denx.de/u-boot/u-boot">https://source.denx.de/u-boot/u-boot</a></li><li><a href="https://ftp.denx.de/pub/u-boot/">https://ftp.denx.de/pub/u-boot/</a> （或 <a href="ftp://ftp.denx.de/pub/u-boot/">ftp://ftp.denx.de/pub/u-boot/</a>）</li></ul></li><li><p><strong>BusyBox</strong>：BusyBox 是一个集成了众多最常用 linux 命令和工具的精简工具箱。它提供了一个比较完善的环境，可用于构建轻量级的根文件系统。</p><p>官网：<a href="https://busybox.net/">https://busybox.net/</a></p><p><a href="http://www.taodudu.cc/news/show-318004.html?action=onClick">busybox详解</a></p></li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818231609048.png" alt="image-20230818231609048" style="zoom:50%;" /><p align="center"><b style="font-size:25px">OpenOCD</b></p></p><p><strong>OpenOCD(Open On-Chip Debugger)</strong>是一个开源片上调试器，用于嵌入式系统的开发和调试。</p><p>官网：<a href="https://www.openocd.org/">https://www.openocd.org/</a></p><p>下载地址：<a href="https://sourceforge.net/projects/openocd/files/">https://sourceforge.net/projects/openocd/files/</a></p><p>Windows下openocd：<a href="https://gnutoolchains.com/arm-eabi/openocd/">https://gnutoolchains.com/arm-eabi/openocd/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818232211015.png" alt="image-20230818232211015" style="zoom:67%;" /><p align="center"><b style="font-size:25px">FatFs</b></p></p><p>FatFs 是用于小型嵌入式系统的通用 FAT/exFAT 文件系统开源项目。</p><p>官网：<a href="http://elm-chan.org/fsw/ff/00index_e.html">http://elm-chan.org/fsw/ff/00index_e.html</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/floating.png" alt="Back to Savannah Homepage" style="zoom:80%;" /><p align="center"><b style="font-size:25px">lwIP</b></p></p><p><strong>lwIP(light weight IP)</strong>是一个开源的小型轻量级的 TCP/IP 协议栈。</p><p>官网：<a href="http://savannah.nongnu.org/projects/lwip/">http://savannah.nongnu.org/projects/lwip/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/logo_lvgl.png" alt="logo" style="zoom: 67%;" /><p align="center"><b style="font-size:25px">LVGL</b></p></p><p><strong>LVGL(Light and Versatile Graphics Library )</strong>,是一个开源的轻量级嵌入式图形库，可为任何 MCU、MPU 和显示类型创建漂亮的 UI。</p><p>官网：<a href="https://lvgl.io/">https://lvgl.io/</a></p><p>源码：<a href="https://github.com/lvgl/lvgl/releases">https://github.com/lvgl/lvgl/releases</a></p><p>百问网LVGL：<a href="http://lvgl.100ask.net/8.2/index.html">http://lvgl.100ask.net/8.2/index.html</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230819001230032.png"><p align="center"><b style="font-size:25px">MQTT</b></p></p><p>MQTT(Message Queuing Telemetry Transport,消息队列遥测传输协议)是一种基于发布/订阅(PUBLISH/SUBSCRIBE)模式的轻量级的物联网通信协议。</p><p>官网：<a href="https://mqtt.org/">https://mqtt.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/logo.png"><p align="center"><b style="font-size:25px">OpenCV</b></p></p><p>OpenCV是一个开源跨平台的计算机视觉库，被用于各种各样的计算机视觉应用程序中，包括人脸检测、目标识别、图像分割、机器人视觉、运动跟踪、手势识别等。OpenCV提供了许多用于图像处理和计算机视觉的功能，包括图像滤波、特征检测、特征匹配、图像分割、摄像机校准、三维重建等。它还提供了C++、Python和Java等编程语言的接口，方便用户在各种平台上进行开发。</p><p>官网：<a href="https://opencv.org/">https://opencv.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230821084024530.png"><p align="center"><b style="font-size:25px">CMSIS</b></p></p><p><strong>CMSIS(Common Microcontroller Software Interface Standard)</strong> : ARM Cortex™通用微控制器软件接口标准，由ARM公司跟芯片软件厂商共同提出的，开源。它提供了一种内核与外设、实时操作系统和中间件接口的通用方法。参考：<a href="https://blog.csdn.net/m0_54929728/article/details/128695058?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-128695058-blog-126438165.235%5Ev38%5Epc_relevant_sort&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-128695058-blog-126438165.235%5Ev38%5Epc_relevant_sort&amp;utm_relevant_index=11">CMSIS到底是个什么东西</a></p><p>官网：<a href="https://www.arm.com/technologies/cmsis">https://www.arm.com/technologies/cmsis</a></p><p>CMSIS资源包含：</p><ul><li><a href="http://arm-software.github.io/CMSIS_5/RTOS2/html/index.html">CMSIS-RTOS</a> ：一个 API，能够使中间件和库组件实现一致的软件层</li><li><a href="http://arm-software.github.io/CMSIS_5/DSP/html/index.html">CMSIS-DSP</a> ：DSP库是Arm针对各种Cortex-M处理器内核优化的DSP功能的丰富集合</li><li><a href="http://arm-software.github.io/CMSIS_5/Driver/html/index.html">CMSIS-Driver</a>：CMSIS驱动程序接口可用于许多微控制器系列</li><li><a href="http://arm-software.github.io/CMSIS_5/Pack/html/index.html">CMSIS-Pack</a>：定义了包含软件组件的软件包结构</li><li><a href="http://arm-software.github.io/CMSIS_5/SVD/html/index.html">CMSIS-SVD</a>：该文件允许查看具有当前寄存器状态的设备外设的详细视图</li><li><a href="http://arm-software.github.io/CMSIS_5/DAP/html/index.html">CMSIS-DAP</a>：它是 Cortex 调试访问端口（DAP）的标准化接口</li><li><a href="http://arm-software.github.io/CMSIS_5/NN/html/index.html">CMSIS-NN</a>：这是高效神经网络内核的集合</li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/logo_new.jpg"><p align="center"><b style="font-size:25px">Modbus</b></p></p><p><strong>Modbus</strong>是一种免费的用于工业现场的总线协议，是Modicon公司（现在的施耐德电气 Schneider Electric）于1979年为使用可编程逻辑控制器（PLC）通信而开发的。现在已成为工业领域通信协议的业界标准，有了它，不同厂商生产的控制设备可以连成工业聚群，进行集中监控。Modbus协议目前存在用于串口、以太网以及其他支持互联网协议网络的版本。</p><p>值得注意的是2020年7月，Modbus组织委员会发布通知，设备间通信过程中使用 <strong>客户端-服务器端(Client-Server)</strong> 替换之前协议里的 <strong>主设备-从设备(Master-Slave)</strong> 的描述。</p><p>官网：<a href="https://modbus.org/">https://modbus.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230823133444089.png"><p align="center"><b style="font-size:25px">MIPI Alliance</b></p></p><p><strong>MIPI(Mobile Industry Processor Interface)移动行业处理器接口</strong>，MIPI联盟是一个全球协作组织，制定和推进移动设备接口技术标准，提供一个世界性，全面性的接口规范生态系统，有效地互连各种移动组件和受移动影响的设备。这些规范标准涵盖了设备所需的所有接口应用，包括调制解调器、应用处理器、相机、显示器、音频、存储、天线、调谐器、功率放大器、滤波器、开关、电池等的接口。</p><p>官网：<a href="https://www.mipi.org/">https://www.mipi.org/</a></p><p>MIPI联盟各接口规格及开发工作组主要有（非MIPI联盟成员只能查看接口公开版规格书）：</p><ul><li><strong>Audio</strong><ul><li><a href="https://www.mipi.org/groups/audio"><strong>Audio Working Group</strong></a></li></ul></li><li><strong>Camera &amp; Imaging</strong><ul><li><strong><a href="https://www.mipi.org/groups/camera">Camera Working Group</a></strong></li></ul></li><li><strong>Chip-to-chip/IPC</strong><ul><li><strong><a href="https://www.mipi.org/groups/unipro-working-group">UniPro Working Group</a></strong></li></ul></li><li><strong>Control &amp; Data</strong><ul><li><strong><a href="https://www.mipi.org/groups/i3c">I3C Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/rf-front-end">RF Front-End Control Working Group</a></strong></li></ul></li><li><strong>Debug &amp; Trace</strong><ul><li><strong><a href="https://www.mipi.org/groups/debug">Debug Working Group</a></strong></li></ul></li><li><strong>Display &amp; Touch</strong><ul><li><strong><a href="https://www.mipi.org/groups/display">Display Working Group</a></strong></li></ul></li><li><strong>Physical Layers</strong><ul><li><strong><a href="https://www.mipi.org/groups/phy">PHY Steering Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/a-phy">A-PHY Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/c-phy">C-PHY Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/d-phy">D-PHY Working Group</a></strong></li><li><strong><a href="https://www.mipi.org/groups/m-phy">M-PHY Working Group</a></strong></li></ul></li><li><strong>Software Integration</strong><ul><li><strong><a href="https://www.mipi.org/groups/software">Software Working Group</a></strong></li></ul></li></ul><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/sqlite370_banner.gif"><p align="center"><b style="font-size:25px">SQLite</b></p></p><p>SQLite 是一款开源的嵌入式轻型C语言数据库，它实现了一个独立的、无服务器的、零配置的事务性 SQL 数据库引擎，且是世界上使用最多的数据库引擎，占用资源非常低，处理速度快。参考教程：<a href="http://www.codebaoku.com/sqlite/sqlite-index.html">SQLite教程</a></p><p>官网：<a href="https://www.sqlite.org">https://www.sqlite.org</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825161343265.png"><p align="center"><b style="font-size:25px">Lua</b></p></p><p><a href="https://www.leixue.com/so/Lua">Lua</a> 是一个简洁、轻量、可扩展的脚本语言，由标准 C 编写而成，并以源代码形式开放，几乎在所有操作系统和平台上都可以编译，运行，主要用于嵌入式系统、游戏开发、网络编程、科学计算等领域。Lua 在葡萄牙语中的意思是月亮。参考：<a href="http://www.codebaoku.com/lua/lua-index.html">Lua 教程</a></p><p>官网：<a href="http://www.lua.org">http://www.lua.org</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825163324396.png"><p align="center"><b style="font-size:25px">Docker</b></p></p><p>Docker 是一个开源的应用容器引擎，可以轻松地为任何应用创建一个轻量级、可移植的、安全的容器。它可以让开发者打包他们的应用和依赖包到一个轻量级、可移植的容器中，然后发布到其它机器上，也可以实现虚拟化。、</p><p>容器和虚拟机具有类似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。</p><p>容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台计算机上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为隔离进程运行。容器占用的空间比 VM 少（容器映像大小通常为 数十 MB），可以处理更多应用程序，并且需要更少的 VM 和操作系统。</p><p>虚拟机 （VM） 是将一台服务器转换为多台服务器的物理硬件的抽象。虚拟机监控程序允许多个 VM 在一台计算机上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本，占用数十 GB。 VM 的启动速度也可能很慢。<strong>参考</strong>：<a href="https://baijiahao.baidu.com/s?id=1675253978950340809&amp;wfr=spider&amp;for=pc">什么是Docker？看这一篇干货文章就够了！</a></p><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p><a href="http://www.codebaoku.com/docker/docker-index.html">Docker 教程</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230908095902194.png"><p align="center"><b style="font-size:25px">Kubernetes</b></p></p><p><strong>Kubernetes</strong> 也称为 K8s，是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。可以在本地机器、云或你自己的数据中心上部署 Kubernetes 集群。</p><p><a href="https://zhuanlan.zhihu.com/p/87186261">Kubernetes和Docker到底有啥关系？ - 知乎 (zhihu.com)</a></p><p>官网：<a href="https://kubernetes.io/">https://kubernetes.io/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230908103944775.png"><p align="center"><b style="font-size:25px">openstack</b></p></p><p>OpenStack是一个开源的云操作系统，为了云计算服务的，通过数据中心可控制大型的计算、存储、网络等资源池。所有的管理通过前端界面管理员就可以完成，同样也可以通过web接口让最终用户部署资源。OpenStack拥有众多的组件，通过组件之间协同进行工作，除了标准的基础架构即服务功能外，其他组件还提供编排、故障管理和服务管理以及其他服务，以确保用户应用程序的高可用性。</p><p><a href="https://zhuanlan.zhihu.com/p/35598437">OpenStack入门科普，看这一篇就够啦！ - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/goldsunshine/p/9872142.html">OpenStack VS Kubernetes，谁是你心中的王者？ - 金色旭光 - 博客园 (cnblogs.com)</a></p><p>官网：<a href="https://www.openstack.org/">https://www.openstack.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825164813557.png"><p align="center"><b style="font-size:25px">POSTMAN</b></p></p><p>Postman 是一个用于API测试的最流行的软件测试工具。借助该工具，开发人员可以轻松地创建，测试，共享和文档化API。这是一个简单的图形用户界面，用于发送和查看HTTP请求和响应。 使用Postman进行测试时，不需要编写任何HTTP客户端网络代码。在此工具中，几乎嵌入了任何开发人员可能需要的所有功能。</p><p>官网：<a href="https://www.postman.com/">https://www.postman.com/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230825165153458.png"><p align="center"><b style="font-size:25px">Nginx</b></p></p><p>Nginx（engine x) 是一款免费开源的高性能、轻量级的 HTTP 和 反向代理 Web 服务器，Nginx 的功能可以分为：基本 HTTP 服务、高级 HTTP 服务和邮件服务等三大类。它以运行的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而闻名，其主要特点是占用内存少，并发能力强。Nginx 的并发能力在同类型的网页服务器中表现最好。在中国，所有大中型的网站几乎都在使用 Nginx：包括阿里、腾讯、百度、京东、新浪、网易等。</p><p>官网：<a href="http://www.nginx.org">http://www.nginx.org</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/vue-js_UzKKG.png"><p align="center"><b style="font-size:25px">Vue.js</b></p></p><p>Vue 是一个用于构建Web用户界面的渐进式JavaScript框架，需要了解关于 HTML、CSS 和 JavaScript 的相关知识，Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。对浏览器提供的修改 Dom 结构API进行封装，只需要对数据对象进行操作，由 Vue 负责调用底层浏览器 API。数据和视图双向绑定，当一方发生变化，另一方同时也会发生变化。</p><p>参考：<a href="http://www.codebaoku.com/vue3/vue3-index.html">Vue3 教程</a></p><p>官网：<a href="https://vuejs.org/">https://vuejs.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/circle_screenshot_1_Node.js.png"><p align="center"><b style="font-size:25px">Node.js</b></p></p><p>Node.js® 是一个开源、跨平台的 JavaScript 运行时环境。</p><p>官网：<a href="https://nodejs.org/">https://nodejs.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/circle_screenshot_1_About%20the%20Django%20Software%20Foundation%20Django.png"><p align="center"><b style="font-size:25px">Django</b></p></p><p>Python 目前主要流行的web框架：flask、Django、Tornado。Django 是使用 Python 开发的免费开源 MVC 风格的 Web 应用程序框架，自带大量常用工具和框架，可轻松、迅速开发出一个功能齐全的Web应用。强大的数据库访问组件，灵活的URL映射，丰富的模板语言，健全的后台管理系统，完整的错误信息提示和强大的缓存支持，并支持多种语言。使用这种架构，程序员可以方便、快捷地创建高品质、易维护、数据库驱动的应用程序。</p><p>参考：<a href="http://www.codebaoku.com/django/django-index.html">Django 教程</a></p><p>官网：<a href="https://www.djangoproject.com/">https://www.djangoproject.com/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230826175843615.png"><p align="center"><b style="font-size:25px">Flask</b></p></p><p>Flask 是一个 Python 实现的基于 WSGI 的 Web 开发微框架， 自由、灵活、可扩展性很强，很适用于开发小型应用。</p><p>参考：<a href="http://www.codebaoku.com/flask/flask-index.html">Flask 教程</a></p><p>官网：<a href="https://flask.palletsprojects.com">https://flask.palletsprojects.com</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/tornado.png"><p align="center"><b style="font-size:25px">Tornado</b></p></p><p>Tornado 是一个开源的 Python Web非阻塞轻量级服务器框架，速度相当快，其用于异步非阻塞IO的处理方式，具有实现高并发、高性能的特点。</p><p>官网：<a href="https://www.tornadoweb.org">https://www.tornadoweb.org</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/scrapylogo.png"><p align="center"><b style="font-size:25px">Scrapy</b></p></p><p>Scrapy 是一套用Python实现的基于 Twisted 异步处理网络爬虫和网络抓取框架，它应用广泛，从数据挖掘，到监控数据，及自动化测试。使用者只需要定制开发几个简单的模块，就能够轻松的实现一个爬虫，用来抓取网页内容以及各种图片，使用非常简单方便。</p><p>参考：<a href="http://www.codebaoku.com/scrapy/scrapy-index.html">Scrapy 教程</a></p><p>官网：<a href="https://scrapy.org/">https://scrapy.org/</a></p><hr /><p align="center"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/json160.gif"><p align="center"><b style="font-size:25px">JSON</b></p></p><p><strong>JSON</strong>(JavaScript Object Notation) 是一种轻量级的数据交换格式。它采用完全独立于编程语言的文本格式来存储和表示数据，语法简洁、层次结构清晰，易于人阅读和编写，同时也易于机器解析和生成，有效的提升了网络传输效率。</p><p>JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</p><p>官网：<a href="https://www.json.org/">https://www.json.org/</a></p><p>JSON在线格式化工具：<a href="http://www.json.org.cn/tools/JSONEditorOnline2.0/index.htm">http://www.json.org.cn/tools/JSONEditorOnline2.0/index.htm</a></p><p>为了方便和使用JSON，官网上有很多不同编程语言写的构建和解析JSON格式的库文件。在嵌入式中比较常用的有：</p><ul><li><p><a href="http://github.com/DaveGamble/cJSON">cJSON</a></p></li><li><p><a href="http://www.digip.org/jansson/">Jansson</a></p></li><li><p><a href="https://github.com/open-source-parsers/jsoncpp">jsoncpp</a></p></li></ul><hr />]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译工具链</title>
    <link href="/2023/08/18/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <url>/2023/08/18/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>在编写程序后，一般需要进行编译处理，生成可执行的程序文件，才能下载到芯片中运行，在IDE集成开发环境中，编译的过程都是由其内部的编译工具链进行处理。但在Linux开发过程中，一般需要自己进行编译器的配置等操作，下面简单了解下编译工具链的相关知识。</p><h2 id="编译工具链简介">编译工具链简介</h2><p>编译程序是一个由多个步骤组成的过程，每个步骤都需要使用不同的工具进行处理。这些工具紧密协作，前一个工具的输出会成为后一个工具的输入，故称之为工具链，习惯称为编译工具链。这个工具链中包含多种工具和相关C库，如预编译器，编译器，汇编器，链接器，调试器等等。</p><h2 id="编译工具链分类">编译工具链分类</h2><p>针对不同的应用平台和芯片架构，编译工具链种类有很多，有免费开源授权版和付费授权版。</p><p><strong>免费版工具链</strong> 主要有两大主流：</p><ul><li><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/gnu-100-b98545-16923412898262.png" alt="gnu-100-b98545" /> <a href="https://www.gnu.org/">GNU Toolchain</a></p></li><li><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/6ac54669f4b30cb07094375cbd65d24163b5b6e0.jpeg" alt="6ac54669f4b30cb07094375cbd65d24163b5b6e0" /> <a href="https://llvm.org/">LLVM Toolchain</a></p></li></ul><p>对于开源的这两大工具链，主要是ARM和Linaro开发社区提供：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818145258689.png" alt="image-20230818145258689" /> <a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain">arm Developer</a></p><p>arm主要提供GNU工具链。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230818131408554.png" alt="image-20230818131408554" /> <a href="https://www.linaro.org/">Linaro</a></p><p>Linaro两种都有提供。</p><p><strong>收费版工具链</strong> 主要是一些大公司开发的专用工具链，必须购买获取授权，才能使用，像ARM原厂提供的armcc、IAR EWARM，微软的MSVC等等。</p><h2 id="编译工具链一般命名规则">编译工具链一般命名规则</h2><p>编译工具链的命名规则为： <strong>arch [-vendor] [-os] [-(gnu)eabi]</strong></p><p><strong>arch</strong> - 芯片体系架构，如arm，mips，aarch64等。</p><p><strong>vendor</strong> - 工具链提供商，可以是none、unknow或者省略。</p><p><strong>os</strong> - 目标操作系统，这个字段一般是linux或者none。</p><p><strong>eabi</strong> - 嵌入式应用二进制接口（Embedded Application Binary Interface)，它指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。</p><p>如：</p><p>arm-none-eabi</p><p>aarch64-none-linux-gnu</p><p>arm-none-linux-gnueabihf</p><h2 id="gnu编译工具链">GNU编译工具链</h2><h4 id="arm-gnu-toolchain">Arm GNU Toolchain</h4><p>下载地址：https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain</p><p>由ARM公司开发用于Arm架构的GNU开源编译工具链（称作“Arm GNU Toolchain”），可以让合作伙伴，开发人员和社区能够使用新功能，这些功能来自最新Arm架构和GCC，Binutils，glibc，Newlib和GDB的开源项目。</p><ul><li><a href="https://gcc.gnu.org/"><strong>GNU C/C++ Compiler (GCC)</strong></a> ： 编译工具，把源程序编译为可执行文件。</li><li><a href="https://www.gnu.org/software/binutils/"><strong>Binutils</strong></a> ：一组二进制工具程序集合。</li><li><a href="https://www.sourceware.org/gdb/"><strong>GDB</strong></a>：GNU本地调试器，可以用来调试C、C++和其他语言编写的程序。<br /></li><li><a href="https://sourceware.org/newlib/"><strong>Newlib</strong></a>：C库</li><li><a href="https://www.gnu.org/software/libc/libc.html"><strong>Glibc</strong></a>：C库</li></ul><p><strong>注意</strong>： Arm发布的旧版GNU工具链有两种：一种针对A系列芯片，另一种是针对M系列和R系列芯片(<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads">GNU Toolchain for A-profile processors</a> 和 <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">GNU Arm Embedded Toolchain</a>)。现在已经合二为一。</p><h3 id="gnu-toolchain">GNU Toolchain</h3><p>其他开源组织开发的GNU编译工具链</p><p>https://gnutoolchains.com/download/</p><h3 id="llvm-toolchain">LLVM Toolchain</h3><p>下载地址：https://github.com/llvm/llvm-project/releases/</p><p>LLVM项目是一个模块化和可重用的编译器和工具链技术的集合。LLVM 核心库提供了一个独立的代码优化器，且支持大多数流行的CPU的代码生成。</p><ul><li><strong><a href="https://clang.llvm.org/">Clang compiler</a></strong>：LLVM工具链中的编译器。</li><li><a href="https://lldb.llvm.org/"><strong>LLDB debugger</strong></a>：本机调试器。</li><li><strong><a href="https://libcxx.llvm.org/">libc++</a></strong> :C++标准库</li><li><a href="https://compiler-rt.llvm.org/"><strong>Compiler-RT runtime libraries</strong></a>：编译运行库</li><li><strong><a href="https://lld.llvm.org/">LLD linker</a></strong>：链接器</li></ul><p>以上是关于编译器的一些介绍，如果不是做编译器底层开发的话，不建议深入学习，毕竟还是有点复杂，对于我们一般开发者而言，了解它的一般原理，知道在哪下载，怎么使用，这些已足够了。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存的分区(栈区、堆区、全局区、常量区和代码区)</title>
    <link href="/2023/08/13/%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E5%8C%BA-%E6%A0%88%E5%8C%BA%E3%80%81%E5%A0%86%E5%8C%BA%E3%80%81%E5%85%A8%E5%B1%80%E5%8C%BA%E3%80%81%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8C%BA/"/>
    <url>/2023/08/13/%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E5%8C%BA-%E6%A0%88%E5%8C%BA%E3%80%81%E5%A0%86%E5%8C%BA%E3%80%81%E5%85%A8%E5%B1%80%E5%8C%BA%E3%80%81%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="内存分区简介">内存分区简介</h2><p>内存一般分为四个区域：<strong>堆区、栈区、全局区（静态区）、代码区</strong>。而编译程序占用的内存分为以下五个部分：<strong>堆区、栈区、全局区（静态区）、常量区、代码区</strong> 。</p><p>C、C++程序在编译链接后生成的映像（image）中，将只包含 <strong>代码段(.Text)</strong>、<strong>只读数据段(.rodata)</strong> 和 <strong>读写数据段(.data)</strong> 。在程序运行之前，将生成 <strong>未初始化数据段(.bss)</strong>，在程序的运行时还将动态生成 <strong>堆(Heap)区域</strong> 和 <strong>栈(Stack)区域</strong> 。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230821192124971.png" alt="" /><figcaption>image-20230821192124971</figcaption></figure><h2 id="内存各分区功能">内存各分区功能</h2><ul><li><p><strong>栈区（Read and Write）</strong></p><ul><li>临时创建的局部变量和const定义的局部变量及函数形参、返回值存放在栈上。</li><li>栈区按内存地址由高到低方向生长，先进后出原则。</li><li>栈区由编译器自动分配释放，无须手动管理。栈上内容在函数运行结束就会自动销毁。</li></ul></li><li><p><strong>堆区（Read and Write）</strong></p><ul><li>由程序员分别调用malloc()和free()函数分配和释放内存。若申请了内存，忘记释放会造成内存泄漏。</li><li>堆区按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。</li></ul></li><li><p><strong>全局区(静态区)（Read and Write）</strong></p><ul><li><strong>.data段</strong>：存放初始化的全局变量和静态(static)变量。编译期间其大小及数据被确定，这些变量<strong>需要占用内存空间</strong>。</li><li><strong>.bss段(Block Started by Symbol)</strong>：存放未初始化的全局变量和静态(static)变量。程序运行之前被内核初始化为 0 或者空（NULL）。这些变量<strong>在程序运行之前不占内存空间</strong>。</li></ul></li><li><p><strong>常量区（Read Only）</strong></p><ul><li>存放 <strong>字符串</strong>、<strong>数字</strong> 等常量。</li><li>存放 <strong>const修饰的全局变量</strong>。</li></ul></li><li><p><strong>代码区（Read Only）</strong></p><ul><li><p>存放程序的编译后的可执行二进制代码，CPU执行的机器指令。</p></li><li><p>代码区的地址:函数的地址,程序的入口地址，函数的名称也是一个指针，可以通过查询函数名称所处的内存地址，查询函数存放的区域。</p></li><li><p>字符串常量和define定义的常量也有可能存放在代码区。</p></li></ul></li></ul><h2 id="举例">举例</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> a;   <span class="hljs-comment">//存放在全局未初始化区 .bss段</span><span class="hljs-type">char</span>* p1;   <span class="hljs-comment">//存放在全局未初始化区</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> b;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span> s[] = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span>* p2;<span class="hljs-comment">//栈区</span><span class="hljs-type">char</span>* p3 = <span class="hljs-string">&quot;123456&quot;</span>;<span class="hljs-comment">//123456\0在常量区，p3在栈区。</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>；<span class="hljs-comment">//全局(静态)初始化区 .data段</span>p1 = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);p2 = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);<span class="hljs-comment">//使用malloc分配得来得10和20字节的区域就在堆区。</span><span class="hljs-built_in">strcpy</span>(p1, <span class="hljs-string">&quot;123456&quot;</span>);<span class="hljs-comment">//123456\0在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span>&#125;</code></pre></div><p><strong>参考:</strong></p><p><a href="https://blog.csdn.net/u014470361/article/details/79297601?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%2279297601%22%2C%22source%22%3A%22zky0830%22%7D&amp;fromshare=blogdetail">什么是代码区、常量区、静态区（全局区）、堆区、栈区？</a></p><p><a href="https://blog.csdn.net/weixin_44364057/article/details/126541545">五大内存分区</a></p>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机结构</title>
    <link href="/2023/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/"/>
    <url>/2023/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>计算机的五个基本组成部分：<strong>运算器、控制器、存储器、输入设备、输出设备</strong> 。</p><p>计算机常见的两种结构，<strong>哈佛结构（Harvard Architecture）</strong>和 <strong>冯·诺依曼结构（Von Neumann Architecture）</strong>：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230813204135256.png" /></p><p>从这两种结构图上可以看出，它们的主要区别是内存存在方式的不同。</p><h3 id="哈佛结构">哈佛结构</h3><p>哈佛结构是一种将程序指令储存和数据储存分开的存储器结构。每个存储器独立编址，使用两条独立的总线传输，中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作(通常是执行)。程序指令储存和数据储存分开，<strong>数据和指令的储存可以同时进行</strong>，可以使指令和数据有不同的数据宽度。</p><p>哈佛结构的微处理器执行时可以预先读取下一条指令，因此具有较高的执行效率。</p><h3 id="冯诺依曼结构">冯诺依曼结构</h3><p>冯诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的结构。指令和数据统一编址，使用同一条总线传输，节约了资源。</p><p>冯.诺依曼结构中，将程序和数据一样看待，<strong>将程序编码为数据，然后与数据一同存放在存储器中</strong>，无论什么程序，最终都是会转换为数据的形式存储在存储器中，要执行相应的程序只需要从存储器中依次取出指令、执行，这样减少了硬件的连接。</p><h3 id="改进型哈佛结构">改进型哈佛结构</h3><p>现在的计算机，其实是这两种结构的混合体。对于一台计算机的整体来说，我们可以认为是冯·诺依曼结构，计算机中的内存是统一的，并没有明确分为指令内存还是数据内存。</p><p>相对于CPU的速度来说，从内存读取数据和写入数据都很慢的，因此CPU内部有另外一种速度更快的存储介质来存放数据和指令，我们称之为缓存（Cache），分为D-Cache和l-Cache，分别用于存储数据和程序指令。在CPU外部则使用RAM存储数据和指令。只有需要改变数据时，缓存才会到RAM中加载新的数据。现代计算机中缓存通常有多层，每一层都比下一层快，但比下一层可以存放的数据少。</p><p>实际上，这种结构从内部看属于哈佛结构，从外部看则属于冯诺依曼结构， 这是一种混合式结构，而现在的计算机CPU大多采用这样的结构， 已经不再是纯粹的冯诺依曼结构或者哈佛结构了。</p><h4 id="参考链接">参考链接</h4><p>https://zhuanlan.zhihu.com/p/63322067</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32 sct分散加载文件详解</title>
    <link href="/2023/08/09/stm32-sct%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/08/09/stm32-sct%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>keil软件在编译过程中会生成分散加载文件（Scatter-Loading Description File），它可以用来描述链接器生成映像文件时需要的信息，通过这些信息分配 Code、RO-Data，RW-Data，ZI-Data 等数据的存放地址。</p><p>一个sct文件主要由一个<strong>加载区（load region）</strong>和多个<strong>执行区（execution region）</strong>构成。</p><p>加载区是用来保存永久性数据（程序和只读变量）的区域；执行区是程序执行时，从加载区域将数据复制到相应执行区后才能被正确执行。</p><p>sct文件一般格式：</p><div class="code-wrapper"><pre><code class="hljs assembly">LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region  ER_IROM1 0x08000000 0x00080000  &#123;  ; load address = execution address   *.o (RESET, +First)    *(InRoot$$Sections)    .ANY (+RO)   &#125;  RW_IRAM1 0x20000000 0x00010000  &#123;  ; RW data   .ANY (+RW +ZI)   &#125;&#125;</code></pre></div><p>下面分别通过三个方面详细了解一下其格式语法：</p><h4 id="加载区域语法">1. 加载区域语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">加载区名(基地址|&quot;+&quot;偏移地址)[属性][大小]&#123;执行区操作+    ;+号表示可以有一个或者多个运行区&#125;</code></pre></div><p>属性列表：</p><ul><li>ABSOLUTE：绝对地址；</li><li>PI：与位置无关；</li><li>RELOC：可重定位；</li><li>OVERLAY：覆盖；</li><li>NOCOMPRESS：不能进行压缩。</li></ul><h4 id="执行区语法">2. 执行区语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">执行区名(基地址|&quot;+&quot;偏移地址)[属性][大小|&quot; &quot;长度]&#123;输入段内容&#125;</code></pre></div><p>属性列表：</p><ul><li><p>ABSOLUTE：绝对地址；</p></li><li><p>PI：与位置无关；</p></li><li><p>RELOC：可重定位；</p></li><li><p>OVERLAY：覆盖；</p></li><li><p>FIXED：固定地址。</p></li><li><p>ALIGNalignment：将执行区的对齐约束从 4 增加到 alignment。alignment 必须为 2 的正数幂。如果执行区具有 base_address，则它必须为 alignment 对齐。如果执行区具有 offset，则链接器将计算的区基址与 alignment 边界对齐；</p></li><li><p>EMPTY：在执行区中保留一个给定长度的空白内存块，通常供堆或堆栈使用。</p></li><li><p>ZEROPAD：零初始化的段作为零填充块写入 ELF 文件，因此，运行时无需使用零进行填充；</p></li><li><p>PADVALUE：定义任何填充的值。如果指定 PADVALUE，则必须为其赋值；</p></li><li><p>NOCOMPRESS：不能进行压缩；</p></li><li><p>UNINIT：未初始化的数据。</p></li></ul><h4 id="输入段内容语法">3. 输入段内容语法</h4><div class="code-wrapper"><pre><code class="hljs assembly">module_select_pattern [ &quot;(&quot; input_section_selector ( &quot;,&quot; input_section_selector )* &quot;)&quot; ](&quot;+&quot; input_section_attr | input_section_pattern | input_symbol_pattern)</code></pre></div><ul><li>module_select_pattern：目标文件滤波器，支持通配符“*”与“?”。字符不区分大小写。</li><li>input_section_selector: 模块选择器模式,有以下几种：<ul><li>包含段和目标文件的名称；</li><li>库成员名称（不带前导路径名）；</li><li>库的完整名称（包括路径名）。如果名称包含空格，则可以使用通配符简化。例如，使用*libname.lib 匹配 C:dir.lib。</li></ul></li><li>nput_section_attr：属性选择器与输入段属性相匹配。每个 input_section_attr 的前面有“+”号。如果指定一个模式以匹配输入段名称，名称前面必须有一个“+”号。可以省略紧靠“+”号前面的任何逗号。选择器不区分大小写。可以识别以下选择器：<ul><li>RO-CODE，RO-DATA，RO（RO-CODE 和 RO-DATA），CODE（RO-CODE）、CONST（RO-DATA），TEXT（RO）</li><li>RW-DATA，RW-CODE，RW（RW-CODE 和 RW-DATA），DATA（RW）</li><li>ZI，BSS（ZI）</li><li>ENTRY（即包含 ENTRY 点的段），FIRST，LAST</li></ul></li></ul><p>通过使用特殊模块选择器模式.ANY 可以将输入段分配给执行区，而无需考虑其父模块。可以使用一个或多个.ANY 模式以任意分配方式填充运行区。在大多数情况下，使用单个.ANY 等效于使用*模块选择器。</p><p>由以上语法分析，查看具体实例，如下所示：</p><div class="code-wrapper"><pre><code class="hljs assembly">; IROM1加载区，地址：0x08000000，大小：0x00080000LR_IROM1 0x08000000 0x00080000  &#123;    ; load region size_region  ; ER_IROM1执行区，地址：0x08000000，大小：0x00080000  ER_IROM1 0x08000000 0x00080000    &#123;  ; load address = execution address   *.o (RESET, +First) ;将REST段最先放到本区，+First表示强制放到首地址   *(InRoot$$Sections) ;将ARM相关库放进来，InRoot$$Sections即ARM库的链接器标号，主要作用COPY RW区到RAM，然后再RW区后面创建ZI区。   .ANY (+RO) ;执行所有目标文件的只读属性数据  &#125;    ; RW_IRAM1执行区，地址：0x20000000，大小：0x00010000  RW_IRAM1 0x20000000 0x00010000    &#123;  ; RW data   .ANY (+RW +ZI) ;执行所有目标文件的可读可写属性及初始化为零的数据  &#125;&#125;</code></pre></div><p>以上就是sct分散加载文件的简要介绍，一般作为了解内存的分布情况，若想尝试修改区域数据存放的内存位置，可参考附件内周立功老师关于其具体使用的介绍。</p><p><a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/stm32%20sct%20file%20.zip">附件</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sct</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32 map文件详解</title>
    <link href="/2023/08/09/stm32-map%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/08/09/stm32-map%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>MDK-ARM在编译时会生成很多类型的中间文件，最终通过这些中间文件生成可下载到MCU的hex文件。.map 文件就是其中编译器链接时生成的一个文件，主要包含了交叉链接信息。</p><p>通过 .map 文件，可以知晓工程中函数的大小，入口地址，变量、调用关系、FLASH 和 RAM 占用空间大小等信息，根据这些信息，可以对代码进行优化。</p><p>要生成 .map 文件，需要在keil软件中进行如下相应设置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809191148933.png" alt="image-20230809191148933" style="zoom: 80%;" /></p><p>为了更好的分析 map 文件，需要了解一些基础概念：</p><ul><li>Section：描述映像文件的代码或数据块，我们简称程序段</li><li>RO：包括只读数据（RO data）和代码（RO code）两部分内容，占用 FLASH 空间</li><li>RW：包含可读写数据（RW data，有初值，且不为 0），占用 FLASH（存储初值）和 RAM（读写操作）</li><li>ZI：Zero initialized 的缩写，包含初始化为 0 的数据（ZI data），占用 RAM 空间。</li><li>.text：相当于 RO code</li><li>.constdata：相当于 RO data</li><li>.bss：相当于 ZI data</li><li>.data：相当于 RW data</li></ul><p>使用notepad打开map文件，会发现map文件主要有 5 个组成部分：</p><ul><li><strong>程序段交叉引用关系（Section Cross References）</strong></li><li><strong>删除映像未使用的程序段（Removing Unused input sections from the image）</strong></li><li><strong>映像符号表（Image Symbol Table）</strong></li><li><strong>映像内存分布图（Memory Map of the image）</strong></li><li><strong>映像组件大小（Image component sizes）</strong></li></ul><p>下面分别进行介绍：</p><h4 id="程序段交叉引用关系section-cross-references">1.程序段交叉引用关系（Section Cross References）</h4><p>这部分内容描述了各个文件（.c/.s 等）之间函数（程序段）的调用关系。</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 1.程序段交叉引用关系</span><span class="hljs-comment"> * .o文件是.c源文件生成的中间文件，括号内是文件或函数入口地址，每句末尾表示被调用的函数或内容</span><span class="hljs-comment"> */</span>Section Cross References     startup_stm32f103xe.o(RESET) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    startup_stm32f103xe.o(RESET) refers to startup_stm32f103xe.o(.text) <span class="hljs-keyword">for</span> Reset_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.NMI_Handler) <span class="hljs-keyword">for</span> NMI_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.HardFault_Handler) <span class="hljs-keyword">for</span> HardFault_Handler    startup_stm32f103xe.o(RESET) refers to stm32f1xx_it.o(i.MemManage_Handler) <span class="hljs-keyword">for</span> MemManage_Handler    省略......    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash_ex.o(i.FLASH_OB_RDP_LevelConfig) <span class="hljs-keyword">for</span> FLASH_OB_RDP_LevelConfig    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash.o(i.FLASH_WaitForLastOperation) <span class="hljs-keyword">for</span> FLASH_WaitForLastOperation    stm32f1xx_hal_flash_ex.o(i.HAL_FLASHEx_OBProgram) refers to stm32f1xx_hal_flash.o(.bss) <span class="hljs-keyword">for</span> pFlash    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry10a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>D) <span class="hljs-keyword">for</span> __rt_final_cpp    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry11a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>F) <span class="hljs-keyword">for</span> __rt_final_exit    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry7b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000008</span>) <span class="hljs-keyword">for</span> _main_clock    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry8b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>A) <span class="hljs-keyword">for</span> _main_cpp_init    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry9a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>B) <span class="hljs-keyword">for</span> _main_init    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) <span class="hljs-keyword">for</span> _main_scatterload    entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) refers (Special) to entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000001</span>) <span class="hljs-keyword">for</span> _main_stk    entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000001</span>) refers to entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00002712</span>) <span class="hljs-keyword">for</span> __lit__00000000    entry2.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00002712</span>) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    entry2.o(__vectab_stack_and_reset_area) refers to startup_stm32f103xe.o(STACK) <span class="hljs-keyword">for</span> __initial_sp    entry2.o(__vectab_stack_and_reset_area) refers to entry.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000000</span>) <span class="hljs-keyword">for</span> __main    entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) refers to init.o(.text) <span class="hljs-keyword">for</span> __scatterload    entry9a.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>B) refers to main.o(i.main) <span class="hljs-keyword">for</span> main    entry9b.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">0000000</span>C) refers to main.o(i.main) <span class="hljs-keyword">for</span> main    init.o(.text) refers to entry5.o(.ARM.Collect<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><span class="hljs-number">00000004</span>) <span class="hljs-keyword">for</span> __main_after_scatterload</code></pre></div><h4 id="删除映像未使用的程序段removing-unused-input-sections-from-the-image">2.删除映像未使用的程序段（Removing Unused input sections from the image）</h4><p>这部分内容描述了工程中由于未被调用而被删除的冗余程序段（函数/数据）。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 2. 删除映像未使用的程序段</span><span class="hljs-comment"> * 每行显示删除的文件，位置及大小</span><span class="hljs-comment"> * 这部分最末显示删除的汇总信息。</span><span class="hljs-comment"> */</span>Removing Unused <span class="hljs-selector-tag">input</span> sections from the image.    Removing startup_stm32f103xe<span class="hljs-selector-class">.o</span>(HEAP), (<span class="hljs-number">512</span> bytes).    Removing <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>(.rev16_text), (<span class="hljs-number">4</span> bytes).    Removing <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>(.revsh_text), (<span class="hljs-number">4</span> bytes).    省略......    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_ClearConfigLine), (<span class="hljs-number">104</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_ClearPending), (<span class="hljs-number">20</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GenerateSWI), (<span class="hljs-number">20</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetConfigLine), (<span class="hljs-number">140</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetHandle), (<span class="hljs-number">12</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_GetPending), (<span class="hljs-number">24</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_IRQHandler), (<span class="hljs-number">36</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_RegisterCallback), (<span class="hljs-number">14</span> bytes).    Removing stm32f1xx_hal_exti<span class="hljs-selector-class">.o</span>(i.HAL_EXTI_SetConfigLine), (<span class="hljs-number">164</span> bytes).<span class="hljs-number">226</span> unused <span class="hljs-selector-tag">section</span>(s) (total <span class="hljs-number">11022</span> bytes) removed from the image.</code></pre></div><h4 id="映像符号表image-symbol-table">3.映像符号表（Image Symbol Table）</h4><p>映像符号表（Image Symbol Table）描述了被引用的各个符号（程序段/数据）在存储器中的存储地址、类型、大小等信息。映像符号表分为两类：本地符号（Local Symbols）和全局符号（Global Symbols）。</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 3. 映像符号表</span><span class="hljs-comment"> * 映像符号包括Local Symbols（本地符号）和Global Symbols（全局符号）</span><span class="hljs-comment"> * 每行描述映像符号的名称、地址、类型、大小及生成目标。</span><span class="hljs-comment"> */</span>Image Symbol Table    Local Symbols    Symbol Name                              Value     Ov Type        Size  <span class="hljs-built_in">Object</span>(Section)    ../Core/Src/dma<span class="hljs-selector-class">.c</span>                        <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  dma<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/gpio<span class="hljs-selector-class">.c</span>                       <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  gpio<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span>                       <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/stm32f1xx_hal_msp<span class="hljs-selector-class">.c</span>          <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_msp<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/stm32f1xx_it<span class="hljs-selector-class">.c</span>               <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_it<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/system_stm32f1xx<span class="hljs-selector-class">.c</span>           <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  system_stm32f1xx<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Core/Src/usart<span class="hljs-selector-class">.c</span>                      <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  usart<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_cortex<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_cortex<span class="hljs-selector-class">.o</span> ABSOLUTE    ../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_dma<span class="hljs-selector-class">.c</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  stm32f1xx_hal_dma<span class="hljs-selector-class">.o</span> ABSOLUTE    省略......    Global Symbols    Symbol Name                              Value     Ov Type        Size  <span class="hljs-built_in">Object</span>(Section)    BuildAttributes$<span class="hljs-variable">$THM_ISAv4</span><span class="hljs-variable">$P</span><span class="hljs-variable">$D</span><span class="hljs-variable">$K</span><span class="hljs-variable">$B</span><span class="hljs-variable">$S</span><span class="hljs-variable">$PE</span><span class="hljs-variable">$A</span>:L22UL41UL21<span class="hljs-variable">$X</span>:L11<span class="hljs-variable">$S22US41US21</span><span class="hljs-variable">$IEEE1</span><span class="hljs-variable">$IW</span><span class="hljs-variable">$USESV6</span>$~STKCKD<span class="hljs-variable">$USESV7</span>$~SHL<span class="hljs-variable">$OSPACE</span><span class="hljs-variable">$EBA8</span><span class="hljs-variable">$MICROLIB</span><span class="hljs-variable">$REQ8</span><span class="hljs-variable">$PRES8</span><span class="hljs-variable">$EABIv2</span> <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  anon$<span class="hljs-variable">$obj</span><span class="hljs-selector-class">.o</span> ABSOLUTE    __ARM_use_no_argv                        <span class="hljs-number">0</span>x00000000   Number         <span class="hljs-number">0</span>  <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> ABSOLUTE    __cpp_initialize__aeabi_                  - Undefined Weak Reference    __cxa_finalize                            - Undefined Weak Reference    __decompress                              - Undefined Weak Reference    _clock_init                               - Undefined Weak Reference    _microlib_exit                            - Undefined Weak Reference    __Vectors_Size                           <span class="hljs-number">0</span>x00000130   Number         <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span> ABSOLUTE    __Vectors                                <span class="hljs-number">0</span>x08000000   Data           <span class="hljs-number">4</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(RESET)    __Vectors_End                            <span class="hljs-number">0</span>x08000130   Data           <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(RESET)    __main                                   <span class="hljs-number">0</span>x08000131   Thumb Code     <span class="hljs-number">0</span>  entry<span class="hljs-selector-class">.o</span>(<span class="hljs-selector-class">.ARM</span>.Collect$$$$<span class="hljs-number">00000000</span>)    _main_stk                                <span class="hljs-number">0</span>x08000131   Thumb Code     <span class="hljs-number">0</span>  entry2<span class="hljs-selector-class">.o</span>(<span class="hljs-selector-class">.ARM</span>.Collect$$$$<span class="hljs-number">00000001</span>)    省略......    SystemCoreClock                          <span class="hljs-number">0</span>x20000030   Data           <span class="hljs-number">4</span>  system_stm32f1xx<span class="hljs-selector-class">.o</span>(.data)    uwTickFreq                               <span class="hljs-number">0</span>x20000034   Data           <span class="hljs-number">1</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    uwTickPrio                               <span class="hljs-number">0</span>x20000038   Data           <span class="hljs-number">4</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    uwTick                                   <span class="hljs-number">0</span>x2000003c   Data           <span class="hljs-number">4</span>  stm32f1xx_hal<span class="hljs-selector-class">.o</span>(.data)    huart1                                   <span class="hljs-number">0</span>x20000040   Data          <span class="hljs-number">72</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    hdma_usart1_rx                           <span class="hljs-number">0</span>x20000088   Data          <span class="hljs-number">68</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    hdma_usart1_tx                           <span class="hljs-number">0</span>x200000cc   Data          <span class="hljs-number">68</span>  usart<span class="hljs-selector-class">.o</span>(.bss)    __initial_sp                             <span class="hljs-number">0</span>x20000510   Data           <span class="hljs-number">0</span>  startup_stm32f103xe<span class="hljs-selector-class">.o</span>(STACK)</code></pre></div><h4 id="映像内存分布图memory-map-of-the-image">4.映像内存分布图（Memory Map of the image）</h4><p>映像文件分为加载域（Load Region）和运行域（Execution Region），一个加载域必须有至少一个运行域（可以有多个运行域），而一个程序又可以有多个加载域。加载域为映像程序的实际存储区域，而运行域则是 MCU 上电后的运行状态。加载域和运行域的简化关系（这里仅表示一个加载域的情况）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809213411201.png" alt="image-20230809213411201" style="zoom:80%;" /></p><div class="code-wrapper"><pre><code class="hljs dns">/* * <span class="hljs-number">4</span>. 映像内存分布图 * 映像文件分为加载域（Load Region）和运行域（Execution Region）。 */Memory Map of the image  /* 映象入口地址 */  Image Entry point : <span class="hljs-number">0x08000131</span>     /* LR_IROM1加载域地址及大小 */  Load Region LR_IROM1 (Base: <span class="hljs-number">0x08000000</span>, Size: <span class="hljs-number">0</span>x<span class="hljs-number">000017c8</span>, Max: <span class="hljs-number">0x00080000</span>, ABSOLUTE)     /* ER_IROM1运行域地址及大小 */  Execution Region ER_IROM1 (Base: <span class="hljs-number">0x08000000</span>, Size: <span class="hljs-number">0x00001788</span>, Max: <span class="hljs-number">0x00080000</span>, ABSOLUTE)     Base Addr    Size         Type   Attr      Idx    E Section Name        Object    <span class="hljs-number">0x08000000</span>   <span class="hljs-number">0x00000130</span>   Data   RO            <span class="hljs-number">3</span>    RESET               startup_stm32f103xe.o    <span class="hljs-number">0x08000130</span>   <span class="hljs-number">0x00000000</span>   Code   RO         <span class="hljs-number">1809</span>  * .ARM.Collect$$$$<span class="hljs-number">00000000</span>  mc_w.l(entry.o)    <span class="hljs-number">0x08000130</span>   <span class="hljs-number">0x00000004</span>   Code   RO         <span class="hljs-number">1816</span>    .ARM.Collect$$$$<span class="hljs-number">00000001</span>  mc_w.l(entry2.o)    <span class="hljs-number">0x08000134</span>   <span class="hljs-number">0x00000004</span>   Code   RO         <span class="hljs-number">1819</span>    .ARM.Collect$$$$<span class="hljs-number">00000004</span>  mc_w.l(entry5.o)    省略......    <span class="hljs-number">0x08001708</span>   <span class="hljs-number">0x00000034</span>   Code   RO           <span class="hljs-number">15</span>    i.main              main.o    <span class="hljs-number">0</span>x0800173c   <span class="hljs-number">0x00000010</span>   Data   RO          <span class="hljs-number">364</span>    .constdata          system_stm32f1xx.o    <span class="hljs-number">0</span>x0800174c   <span class="hljs-number">0x00000008</span>   Data   RO          <span class="hljs-number">365</span>    .constdata          system_stm32f1xx.o    <span class="hljs-number">0x08001754</span>   <span class="hljs-number">0x00000012</span>   Data   RO         <span class="hljs-number">1023</span>    .constdata          stm32f1xx_hal_rcc.o    <span class="hljs-number">0x08001766</span>   <span class="hljs-number">0x00000002</span>   PAD    <span class="hljs-number">0x08001768</span>   <span class="hljs-number">0x00000020</span>   Data   RO         <span class="hljs-number">1832</span>    Region$$Table       anon$$obj.o    /* RW_IRAM1运行域，地址，大小 */    Execution Region RW_IRAM1 (Base: <span class="hljs-number">0x20000000</span>, Size: <span class="hljs-number">0x00000510</span>, Max: <span class="hljs-number">0x00010000</span>, ABSOLUTE)     Base Addr    Size         Type   Attr      Idx    E Section Name        Object    <span class="hljs-number">0x20000000</span>   <span class="hljs-number">0</span>x0000002f   Data   RW           <span class="hljs-number">16</span>    .data               main.o    <span class="hljs-number">0</span>x2000002f   <span class="hljs-number">0x00000001</span>   PAD    <span class="hljs-number">0x20000030</span>   <span class="hljs-number">0x00000004</span>   Data   RW          <span class="hljs-number">366</span>    .data               system_stm32f1xx.o    <span class="hljs-number">0x20000034</span>   <span class="hljs-number">0</span>x0000000c   Data   RW          <span class="hljs-number">860</span>    .data               stm32f1xx_hal.o    <span class="hljs-number">0x20000040</span>   <span class="hljs-number">0</span>x<span class="hljs-number">000000d0</span>   Zero   RW          <span class="hljs-number">200</span>    .bss                usart.o    <span class="hljs-number">0x20000110</span>   <span class="hljs-number">0x00000400</span>   Zero   RW            <span class="hljs-number">1</span>    STACK               startup_stm32f103xe.o</code></pre></div><h4 id="映像组件大小image-component-sizes">5.映像组件大小（Image component sizes）</h4><p>各文件编译后所占代码空间的大小，keil IDE编译后输出框显示的文件占用空间大小与此部分一致。</p><div class="code-wrapper"><pre><code class="hljs tap">/* * 5. 映像组件大小 * 文件编译后所占代码空间的大小。 */Image component sizes/* 代码大小(内联函数大小) 只读大小  读写大小  零初始化大小  调试大小  文件名 */      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name       <span class="hljs-number"> 60 </span>        <span class="hljs-number"> 4 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 682 </span>  dma.o       <span class="hljs-number"> 28 </span>        <span class="hljs-number"> 6 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 663 </span>  gpio.o      <span class="hljs-number"> 150 </span>       <span class="hljs-number"> 10 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 47 </span>        <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 455148 </span>  main.o       <span class="hljs-number"> 36 </span>        <span class="hljs-number"> 8 </span>      <span class="hljs-number"> 304 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1024 </span>      <span class="hljs-number"> 760 </span>  startup_stm32f103xe.o      <span class="hljs-number"> 164 </span>       <span class="hljs-number"> 28 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 12 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 6105 </span>  stm32f1xx_hal.o      <span class="hljs-number"> 198 </span>       <span class="hljs-number"> 14 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 28331 </span>  stm32f1xx_hal_cortex.o     <span class="hljs-number"> 1236 </span>       <span class="hljs-number"> 52 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4358 </span>  stm32f1xx_hal_dma.o      <span class="hljs-number"> 504 </span>       <span class="hljs-number"> 42 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1928 </span>  stm32f1xx_hal_gpio.o       <span class="hljs-number"> 60 </span>        <span class="hljs-number"> 8 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 786 </span>  stm32f1xx_hal_msp.o     <span class="hljs-number"> 1240 </span>       <span class="hljs-number"> 84 </span>       <span class="hljs-number"> 18 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4604 </span>  stm32f1xx_hal_rcc.o     <span class="hljs-number"> 1500 </span>       <span class="hljs-number"> 24 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 10186 </span>  stm32f1xx_hal_uart.o       <span class="hljs-number"> 56 </span>       <span class="hljs-number"> 18 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 4700 </span>  stm32f1xx_it.o        <span class="hljs-number"> 2 </span>        <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 24 </span>        <span class="hljs-number"> 4 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 987 </span>  system_stm32f1xx.o      <span class="hljs-number"> 276 </span>       <span class="hljs-number"> 30 </span>        <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 0 </span>      <span class="hljs-number"> 208 </span>     <span class="hljs-number"> 1728 </span>  usart.o    -------------------------------------------------------------------<span class="language-yaml"><span class="hljs-meta">---</span></span><span class="language-yaml">      <span class="hljs-number">5522        </span><span class="hljs-number">328</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">520966</span>   <span class="hljs-string">Object</span> <span class="hljs-string">Totals</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>         <span class="hljs-number">32</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Generated)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器生成的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">        <span class="hljs-number">12</span>          <span class="hljs-number">0</span>          <span class="hljs-number">2</span>          <span class="hljs-number">1</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Padding)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器填充的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span>  <span class="hljs-string">库文件名</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Member</span> <span class="hljs-string">Name</span></span><span class="language-yaml"></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry10a.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry11a.o</span></span><span class="language-yaml">         <span class="hljs-number">8</span>          <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry2.o</span></span><span class="language-yaml">         <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry5.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry7b.o</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry8b.o</span></span><span class="language-yaml">         <span class="hljs-number">8</span>          <span class="hljs-number">4</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">entry9a.o</span></span><span class="language-yaml">        <span class="hljs-number">30</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">handlers.o</span></span><span class="language-yaml">        <span class="hljs-number">36</span>          <span class="hljs-number">8</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>         <span class="hljs-number">68</span>   <span class="hljs-string">init.o</span></span><span class="language-yaml">        <span class="hljs-number">36</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">108</span>   <span class="hljs-string">memseta.o</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Totals</span></span><span class="language-yaml">         <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">(incl.</span> <span class="hljs-string">Padding)</span> <span class="hljs-string">/*</span> <span class="hljs-string">链接器填充的大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span>  <span class="hljs-string">库文件名</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Name</span></span><span class="language-yaml"></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">mc_w.l</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml">       <span class="hljs-number">122</span>         <span class="hljs-number">16</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>        <span class="hljs-number">176</span>   <span class="hljs-string">Library</span> <span class="hljs-string">Totals</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">----------------------------------------------------------------------</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">/*</span> <span class="hljs-string">代码大小(内联函数大小)</span> <span class="hljs-string">只读大小</span>  <span class="hljs-string">读写大小</span>  <span class="hljs-string">零初始化大小</span>  <span class="hljs-string">调试大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-string">Code</span> <span class="hljs-string">(inc.</span> <span class="hljs-string">data)</span>   <span class="hljs-string">RO</span> <span class="hljs-string">Data</span>    <span class="hljs-string">RW</span> <span class="hljs-string">Data</span>    <span class="hljs-string">ZI</span> <span class="hljs-string">Data</span>      <span class="hljs-string">Debug</span>   </span><span class="language-yaml"></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">518434</span>   <span class="hljs-string">Grand</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">整个映像大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>       <span class="hljs-number">1232     </span><span class="hljs-number">518434</span>   <span class="hljs-string">ELF</span> <span class="hljs-string">Image</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">ELF可执行格式映像大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml">      <span class="hljs-number">5644        </span><span class="hljs-number">344</span>        <span class="hljs-number">380</span>         <span class="hljs-number">64</span>          <span class="hljs-number">0</span>          <span class="hljs-number">0</span>   <span class="hljs-string">ROM</span> <span class="hljs-string">Totals</span> <span class="hljs-string">/*</span> <span class="hljs-string">整个ROM大小</span> <span class="hljs-string">*/</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span><span class="language-yaml"></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">RO</span>  <span class="hljs-string">Size</span> <span class="hljs-string">(Code</span> <span class="hljs-string">+</span> <span class="hljs-string">RO</span> <span class="hljs-string">Data)</span>                 <span class="hljs-number">6024</span> <span class="hljs-string">(</span>   <span class="hljs-number">5.</span><span class="hljs-string">88kB)</span></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">RW</span>  <span class="hljs-string">Size</span> <span class="hljs-string">(RW</span> <span class="hljs-string">Data</span> <span class="hljs-string">+</span> <span class="hljs-string">ZI</span> <span class="hljs-string">Data)</span>              <span class="hljs-number">1296</span> <span class="hljs-string">(</span>   <span class="hljs-number">1.</span><span class="hljs-string">27kB)</span></span><span class="language-yaml">    <span class="hljs-string">Total</span> <span class="hljs-string">ROM</span> <span class="hljs-string">Size</span> <span class="hljs-string">(Code</span> <span class="hljs-string">+</span> <span class="hljs-string">RO</span> <span class="hljs-string">Data</span> <span class="hljs-string">+</span> <span class="hljs-string">RW</span> <span class="hljs-string">Data)</span>       <span class="hljs-number">6088</span> <span class="hljs-string">(</span>   <span class="hljs-number">5.</span><span class="hljs-string">95kB)</span></span><span class="language-yaml"></span><span class="language-yaml"><span class="hljs-string">==============================================================================</span></span></code></pre></div><p>Code是代码区，RO-data 代表常量区，RW-data 代表已初始化的全局变量和静态变量，属于静态区（全局区），ZI-data 代表未初始化但被编译器初始化为0的全局变量和静态变量，属于静态区（全局区）。</p><p><a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/stm32_map_file.zip">hal uart map文件与正点原子详解附件</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32启动文件详解</title>
    <link href="/2023/08/08/stm32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/08/08/stm32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>我们知道程序一般是从<code>main</code>函数开始运行的，但在<code>main</code>函数运行之前，程序已经做了一些准备工作，对于STM32F1芯片，这些准备工作是通过启动文件来完成的。下面来详细看看stm32库中的启动代码文件（STM32Cube_FW_F1_V1.8.532F1xx_stm32f103xe.s）。</p><p>启动文件是由汇编语言编写，是系统上电复位后第一个执行的程序。首先我们来看看启动文件使用的ARM汇编指令：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230809173349258.png" alt="" /><figcaption>image-20230809173349258</figcaption></figure><p>整个启动文件主要做了以下操作：</p><ul><li>**设置初始化堆栈指针SP = _initial_sp**</li><li><strong>设置初始化计数器指针PC = Reset_Handler</strong></li><li><strong>设置堆栈大小</strong></li><li><strong>初始化中断向量表</strong></li><li><strong>调用 SystemInit() 函数初始化系统时钟</strong></li><li>**跳转到C库中的 __main 函数初始化用户堆栈（最终调用main()函数）**</li></ul><div class="code-wrapper"><pre><code class="hljs assembly">;1-栈 ######;开辟栈的大小为 0X00000400（1K字节），名字为 STACK， NOINIT 即不初始化，可读可写， 8（2^3）字节对齐。;标号__initial_sp 表示栈的结束地址，即栈顶地址，栈是由高向低生长的。; Amount of memory (in bytes) allocated for Stack  ; Tailor this value to your application needs    ; &lt;h&gt; Stack Configuration   ;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;   ; &lt;/h&gt;Stack_Size      EQU     0x00000400                    AREA    STACK, NOINIT, READWRITE, ALIGN=3  Stack_Mem       SPACE   Stack_Size   __initial_sp</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;2-堆 ######;开辟堆的大小为 0X00000200（512字节），名字为 HEAP， 不初始化，可读可写， 8（2^3）字节对齐。;标号__heap_base 表示堆的起始地址， __heap_limit 表示堆的结束地址。堆是由低向高生长的，跟栈的生长方向相反。                                                  ; &lt;h&gt; Heap Configuration  ;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;  ; &lt;/h&gt;Heap_Size       EQU     0x00000200                  AREA    HEAP, NOINIT, READWRITE, ALIGN=3 __heap_baseHeap_Mem        SPACE   Heap_Size__heap_limit</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;3-向量表; 定义一个名为RESET的数据段，只读，并声明三个全局属性的标号 __Vectors、 __Vectors_End 和__Vectors_Size; Vector Table Mapped to Address 0 at Reset                AREA    RESET, DATA, READONLY                EXPORT  __Vectors                EXPORT  __Vectors_End                EXPORT  __Vectors_Size__Vectors       DCD     __initial_sp               ; Top of Stack #栈顶                DCD     Reset_Handler              ; Reset Handler                DCD     NMI_Handler                ; NMI Handler                DCD     HardFault_Handler          ; Hard Fault Handler                DCD     MemManage_Handler          ; MPU Fault Handler                DCD     BusFault_Handler           ; Bus Fault Handler                DCD     UsageFault_Handler         ; Usage Fault Handler                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     SVC_Handler                ; SVCall Handler                DCD     DebugMon_Handler           ; Debug Monitor Handler                DCD     0                          ; Reserved                DCD     PendSV_Handler             ; PendSV Handler                DCD     SysTick_Handler            ; SysTick Handler                ; External Interrupts #外部中断                DCD     WWDG_IRQHandler            ; Window Watchdog                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect                DCD     TAMPER_IRQHandler          ; Tamper                DCD     RTC_IRQHandler             ; RTC                DCD     FLASH_IRQHandler           ; Flash                DCD     RCC_IRQHandler             ; RCC                DCD     EXTI0_IRQHandler           ; EXTI Line 0                DCD     EXTI1_IRQHandler           ; EXTI Line 1                DCD     EXTI2_IRQHandler           ; EXTI Line 2                DCD     EXTI3_IRQHandler           ; EXTI Line 3                DCD     EXTI4_IRQHandler           ; EXTI Line 4                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7                DCD     ADC1_2_IRQHandler          ; ADC1 &amp; ADC2                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break                DCD     TIM1_UP_IRQHandler         ; TIM1 Update                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare                DCD     TIM2_IRQHandler            ; TIM2                DCD     TIM3_IRQHandler            ; TIM3                DCD     TIM4_IRQHandler            ; TIM4                DCD     I2C1_EV_IRQHandler         ; I2C1 Event                DCD     I2C1_ER_IRQHandler         ; I2C1 Error                DCD     I2C2_EV_IRQHandler         ; I2C2 Event                DCD     I2C2_ER_IRQHandler         ; I2C2 Error                DCD     SPI1_IRQHandler            ; SPI1                DCD     SPI2_IRQHandler            ; SPI2                DCD     USART1_IRQHandler          ; USART1                DCD     USART2_IRQHandler          ; USART2                DCD     USART3_IRQHandler          ; USART3                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10                DCD     RTC_Alarm_IRQHandler        ; RTC Alarm through EXTI Line                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break                DCD     TIM8_UP_IRQHandler         ; TIM8 Update                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare                DCD     ADC3_IRQHandler            ; ADC3                DCD     FSMC_IRQHandler            ; FSMC                DCD     SDIO_IRQHandler            ; SDIO                DCD     TIM5_IRQHandler            ; TIM5                DCD     SPI3_IRQHandler            ; SPI3                DCD     UART4_IRQHandler           ; UART4                DCD     UART5_IRQHandler           ; UART5                DCD     TIM6_IRQHandler            ; TIM6                DCD     TIM7_IRQHandler            ; TIM7                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5__Vectors_End__Vectors_Size  EQU  __Vectors_End - __Vectors</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;4-复位中断程序，系统上电后第一个要执行的程序;调用外部 SystemInit() 函数初始化系统时钟，然后调用 C 库函数_mian()，最终调用 main()函数去到 C 的世界。               ; Reset handlerReset_Handler   PROC                EXPORT  Reset_Handler             [WEAK]                IMPORT  __main                IMPORT  SystemInit                LDR     R0, =SystemInit                BLX     R0                               LDR     R0, =__main                BX      R0                ENDP</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;5-空的中断服务函数，[WEAK]弱声明无限循环函数，用户可以对其进行重定义。             ; Dummy Exception Handlers (infinite loops which can be modified)NMI_Handler     PROC                EXPORT  NMI_Handler                [WEAK]                B       .                ENDPHardFault_Handler\                PROC                EXPORT  HardFault_Handler          [WEAK]                B       .                ENDPMemManage_Handler\                PROC                EXPORT  MemManage_Handler          [WEAK]                B       .                ENDPBusFault_Handler\                PROC                EXPORT  BusFault_Handler           [WEAK]                B       .                ENDPUsageFault_Handler\                PROC                EXPORT  UsageFault_Handler         [WEAK]                B       .                ENDPSVC_Handler     PROC                EXPORT  SVC_Handler                [WEAK]                B       .                ENDPDebugMon_Handler\                PROC                EXPORT  DebugMon_Handler           [WEAK]                B       .                ENDPPendSV_Handler  PROC                EXPORT  PendSV_Handler             [WEAK]                B       .                ENDPSysTick_Handler PROC                EXPORT  SysTick_Handler            [WEAK]                B       .                ENDPDefault_Handler PROC                EXPORT  WWDG_IRQHandler            [WEAK]                EXPORT  PVD_IRQHandler             [WEAK]                EXPORT  TAMPER_IRQHandler          [WEAK]                EXPORT  RTC_IRQHandler             [WEAK]                EXPORT  FLASH_IRQHandler           [WEAK]                EXPORT  RCC_IRQHandler             [WEAK]                EXPORT  EXTI0_IRQHandler           [WEAK]                EXPORT  EXTI1_IRQHandler           [WEAK]                EXPORT  EXTI2_IRQHandler           [WEAK]                EXPORT  EXTI3_IRQHandler           [WEAK]                EXPORT  EXTI4_IRQHandler           [WEAK]                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]                EXPORT  ADC1_2_IRQHandler          [WEAK]                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]                EXPORT  CAN1_RX1_IRQHandler        [WEAK]                EXPORT  CAN1_SCE_IRQHandler        [WEAK]                EXPORT  EXTI9_5_IRQHandler         [WEAK]                EXPORT  TIM1_BRK_IRQHandler        [WEAK]                EXPORT  TIM1_UP_IRQHandler         [WEAK]                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]                EXPORT  TIM1_CC_IRQHandler         [WEAK]                EXPORT  TIM2_IRQHandler            [WEAK]                EXPORT  TIM3_IRQHandler            [WEAK]                EXPORT  TIM4_IRQHandler            [WEAK]                EXPORT  I2C1_EV_IRQHandler         [WEAK]                EXPORT  I2C1_ER_IRQHandler         [WEAK]                EXPORT  I2C2_EV_IRQHandler         [WEAK]                EXPORT  I2C2_ER_IRQHandler         [WEAK]                EXPORT  SPI1_IRQHandler            [WEAK]                EXPORT  SPI2_IRQHandler            [WEAK]                EXPORT  USART1_IRQHandler          [WEAK]                EXPORT  USART2_IRQHandler          [WEAK]                EXPORT  USART3_IRQHandler          [WEAK]                EXPORT  EXTI15_10_IRQHandler       [WEAK]                EXPORT  RTC_Alarm_IRQHandler        [WEAK]                EXPORT  USBWakeUp_IRQHandler       [WEAK]                EXPORT  TIM8_BRK_IRQHandler        [WEAK]                EXPORT  TIM8_UP_IRQHandler         [WEAK]                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK]                EXPORT  TIM8_CC_IRQHandler         [WEAK]                EXPORT  ADC3_IRQHandler            [WEAK]                EXPORT  FSMC_IRQHandler            [WEAK]                EXPORT  SDIO_IRQHandler            [WEAK]                EXPORT  TIM5_IRQHandler            [WEAK]                EXPORT  SPI3_IRQHandler            [WEAK]                EXPORT  UART4_IRQHandler           [WEAK]                EXPORT  UART5_IRQHandler           [WEAK]                EXPORT  TIM6_IRQHandler            [WEAK]                EXPORT  TIM7_IRQHandler            [WEAK]                EXPORT  DMA2_Channel1_IRQHandler   [WEAK]                EXPORT  DMA2_Channel2_IRQHandler   [WEAK]                EXPORT  DMA2_Channel3_IRQHandler   [WEAK]                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK]WWDG_IRQHandlerPVD_IRQHandlerTAMPER_IRQHandlerRTC_IRQHandlerFLASH_IRQHandlerRCC_IRQHandlerEXTI0_IRQHandlerEXTI1_IRQHandlerEXTI2_IRQHandlerEXTI3_IRQHandlerEXTI4_IRQHandlerDMA1_Channel1_IRQHandlerDMA1_Channel2_IRQHandlerDMA1_Channel3_IRQHandlerDMA1_Channel4_IRQHandlerDMA1_Channel5_IRQHandlerDMA1_Channel6_IRQHandlerDMA1_Channel7_IRQHandlerADC1_2_IRQHandlerUSB_HP_CAN1_TX_IRQHandlerUSB_LP_CAN1_RX0_IRQHandlerCAN1_RX1_IRQHandlerCAN1_SCE_IRQHandlerEXTI9_5_IRQHandlerTIM1_BRK_IRQHandlerTIM1_UP_IRQHandlerTIM1_TRG_COM_IRQHandlerTIM1_CC_IRQHandlerTIM2_IRQHandlerTIM3_IRQHandlerTIM4_IRQHandlerI2C1_EV_IRQHandlerI2C1_ER_IRQHandlerI2C2_EV_IRQHandlerI2C2_ER_IRQHandlerSPI1_IRQHandlerSPI2_IRQHandlerUSART1_IRQHandlerUSART2_IRQHandlerUSART3_IRQHandlerEXTI15_10_IRQHandlerRTC_Alarm_IRQHandlerUSBWakeUp_IRQHandlerTIM8_BRK_IRQHandlerTIM8_UP_IRQHandlerTIM8_TRG_COM_IRQHandlerTIM8_CC_IRQHandlerADC3_IRQHandlerFSMC_IRQHandlerSDIO_IRQHandlerTIM5_IRQHandlerSPI3_IRQHandlerUART4_IRQHandlerUART5_IRQHandlerTIM6_IRQHandlerTIM7_IRQHandlerDMA2_Channel1_IRQHandlerDMA2_Channel2_IRQHandlerDMA2_Channel3_IRQHandlerDMA2_Channel4_5_IRQHandler                B       .                ENDP                ALIGN</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">;6-将堆栈地址传递给C库函数_main()，利用C库函数初始化堆栈或由用户自己初始化堆栈。;*******************************************************************************; User Stack and Heap initialization;*******************************************************************************                 IF      :DEF:__MICROLIB  ;#keil-MDK IDE勾选MicroLIB宏                ;#赋予以下三个标号全局属性                 EXPORT  __initial_sp                 EXPORT  __heap_base                 EXPORT  __heap_limit                                 ELSE        ;#keil-MDK IDE没有勾选MicroLIB宏                                 IMPORT  __use_two_region_memory ;#导入双段存储器模式，需要用户自己实现。                 EXPORT  __user_initial_stackheap ;#赋予标号__user_initial_stackheap全局属性                 __user_initial_stackheap                 LDR     R0, =  Heap_Mem                 LDR     R1, =(Stack_Mem + Stack_Size)                 LDR     R2, = (Heap_Mem +  Heap_Size)                 LDR     R3, = Stack_Mem                 BX      LR                 ALIGN</code></pre></div><p><a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/startup_stm32f103xe.zip">启动文件与正点原子详解附件</a></p><p>参考链接：</p><p>https://www.elecfans.com/news/1802838.html</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>startup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_sd库的使用</title>
    <link href="/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/07/stm32f1xx-hal-sd%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Secure Digital,简称SD,SD内存卡是一种使用非常广泛的存储设备，以下来看看HAL库关于SD卡的使用方法。</p><h3 id="sd外设库的使用">SD外设库的使用</h3><p>这是一个通用分层的SDIO存储驱动，它使用HAL SDIO驱动函数来连接SD内存卡。</p><p><strong>1. 初始化SDIO底层。HAL_SD_MspInit()</strong></p><ul><li>使能SDIO接口时钟。__HAL_RCC_SDIO_CLK_ENABLE()</li><li>配置SDIO引脚<ul><li>使能SDIO GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置SDIO引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_SD_ReadBlocks_DMA() ， HAL_SD_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDIO和DMA中断优先级，DMA优先级高于SDIO。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code> ， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code> ，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_SD_ReadBlocks_IT()，HAL_SD_WriteBlocks_IT()<ul><li>配置SDIO中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDIO IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDIO中断。<code>__HAL_SD_ENABLE_IT()</code> ， <code>__HAL_SD_DISABLE_IT()</code></li><li>使用宏定义控制SDIO中断挂起位。<code>__HAL_SD_GET_IT()</code> ，<code>__HAL_SD_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. SD卡的初始化和配置</strong></p><p>使用HAL_SD_Init()函数来初始化SD卡，并进入睡眠状态（已准备好数据传输）。SD卡初始化后，就可以执行SD卡的读、写、擦除操作。</p><ul><li><p>以400KHz的频率配置初始化SD卡。</p><p>SD卡频率：SDIO_CK = SDIOCLK / (ClockDiv + 2)；</p><p>初始化时，根据SD卡标准，确保SDIO_CK频率不要超过400KHz，通过SDIO底层函数 SDIO_Init()和SDIO_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化SD卡。HAL_SD_InitCard()</p><p>这个函数用于初始化和识别SDIO及检查SD卡的类型（标准容量或高容量），此初始化流程与SD卡标准兼容。这个函数也可以在插拔时重新初始化SD卡。</p></li><li><p>配置SD卡数据传输频率，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据SD卡标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDIO外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的SD卡。</p></li><li><p>配置SD卡宽总线模式：4位数据。</p></li></ul><p><strong>3. SD卡的读操作</strong></p><ul><li><p>轮询模式下读取SD卡。HAL_SD_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态。</p></li><li><p>DMA模式下读取SD卡。HAL_SD_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Rx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取SD卡。HAL_SD_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Rx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. SD卡的写操作</strong></p><ul><li><p>轮询模式下向SD卡写操作。HAL_SD_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD卡的状态。</p></li><li><p>DMA模式下向SD卡写操作。HAL_SD_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Tx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向SD卡写操作。HAL_SD_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_SD_GetCardState()函数来检查SD的状态，通过SD Tx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取SD卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取SD卡信息。HAL_SDIO_GetCardInfo()</p><p>它会返回关于SD卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_SDIO_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_SDIO_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="sd-hal常用宏定义列表">SD HAL常用宏定义列表</h3><ul><li><p>__HAL_SD_ENABLE : 使能 SD设备</p></li><li><p>__HAL_SD_DISABLE : 禁止 SD 设备</p></li><li><p>__HAL_SD_DMA_ENABLE: 使能 SD DMA 传输</p></li><li><p>__HAL_SD_DMA_DISABLE: 禁止 SD DMA 传输</p></li><li><p>__HAL_SD_ENABLE_IT: 使能 SD 设备中断</p></li><li><p>__HAL_SD_DISABLE_IT: 禁止 SD 设备中断</p></li><li><p>__HAL_SD_GET_FLAG:检查 SD 标志是否设置</p></li><li><p>__HAL_SD_CLEAR_FLAG: 清除 SD 的挂起标志</p></li></ul><h3 id="sd回调函数的注册">SD回调函数的注册</h3><p>当 USE_HAL_SD_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_SD_RegisterCallback(), HAL_SD_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>ErrorCallback : 发生错误回调函数</li><li>AbortCpltCallback : 中止完成回调函数</li><li>MspInitCallback : SD 相关MCU初始化回调函数</li><li>MspDeInitCallback : SD 相关MCU去初始化回调函数</li></ul><p>默认情况下, SD 初始化（HAL_SD_Init()）后，当状态是 HAL_SD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SD_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_mmc库的使用</title>
    <link href="/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/07/stm32f1xx-hal-mmc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>MultiMediaCard,简称MMC,它属于SD卡的一种，是一种一体化、可拆卸、多功能的内存卡,以下来看看HAL库关于MMC的使用方法。</p><h3 id="mmc外设库的使用">MMC外设库的使用</h3><p>这是一个通用分层的MMC存储器驱动，它使用HAL SDMMC 驱动函数来连接MMC和eMMC卡。</p><p><strong>1. 初始化MMC底层。HAL_MMC_MspInit()</strong></p><ul><li>使能MMC接口时钟。__HAL_RCC_SDMMC_CLK_ENABLE()</li><li>配置MMC引脚<ul><li>使能MMC GPIO 时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置MMC引脚为复用上拉模式。HAL_GPIO_Init()</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_MMC_ReadBlocks_DMA() ， HAL_MMC_WriteBlocks_DMA()<ul><li>使能 DMAx 接口时钟。__HAL_RCC_DMAx_CLK_ENABLE()</li><li>配置DMA。HAL_DMA_Init()</li></ul></li><li>当DMA传输时，如果使用到中断过程，则配置NVIC。<ul><li>配置SDMMC和DMA中断优先级，DMA优先级高于SDMMC。HAL_NVIC_SetPriority()</li><li>使能NVIC DMA和SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code> ， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code> ，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li><li>如果使用到中断，则配置NVIC。HAL_MMC_ReadBlocks_IT()，HAL_MMC_WriteBlocks_IT()<ul><li>配置SDMMC中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC SDMMC IRQ。HAL_NVIC_EnableIRQ()</li><li>通信过程中使用宏定义管理SDMMC中断。<code>__HAL_MMC_ENABLE_IT()</code> ， <code>__HAL_MMC_DISABLE_IT()</code></li><li>使用宏定义控制SDMMC 中断挂起位。<code>__HAL_MMC_GET_IT()</code> ，<code>__HAL_MMC_CLEAR_IT()</code></li></ul></li></ul><p><strong>2. MMC的初始化和配置</strong></p><p>使用HAL_MMC_Init()函数来初始化SDMMC，并进入睡眠状态（已准备好数据传输）。MMC卡初始化后，就可以执行MMC 读、写、擦除操作。</p><ul><li><p>使用默认配置初始化SDMMC外设接口。默认频率：400KHz。</p><p>MMC频率：SDMMC_CK = SDMMCCLK / (ClockDiv + 2)；</p><p>初始化时，根据MMC标准，确保SDMMC_CK频率不要超过400KHz，通过SDMMC底层函数 SDMMC_Init()和SDMMC_PowerState_ON()完成初始化阶段。</p></li><li><p>初始化MMC卡。HAL_MMC_InitCard()</p><p>这个函数用于初始化和识别MMC及检查MMC卡的类型（标准容量或高容量），此初始化流程与MMC标准兼容。这个函数也可以在插拔时重新初始化MMC卡。</p></li><li><p>配置MMC卡数据传输频率，默认传输频率是24MHz，可以调整“ClockDiv”来改变传输频率，在传输模式下，根据MMC标准，要确保频率不要超过25MHz，在高速模式时则不要超过50MHz。为了使传输频率高于24MHz，必须要将SDMMC外设置于旁路模式，阅读相关参考手册获取更多细节。</p></li><li><p>根据以上第二步读到的地址选择相应的MMC卡。</p></li><li><p>配置MMC宽总线模式：4位数据。</p></li></ul><p><strong>3. MMC的读操作</strong></p><ul><li><p>轮询模式下读取MMC卡。HAL_MMC_ReadBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下读取MMC卡。HAL_MMC_ReadBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Rx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下读取MMC卡。HAL_MMC_ReadBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的读操作或多个block的读操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Rx中断事件来检查中断传输过程。</p></li></ul><p><strong>4. MMC的写操作</strong></p><ul><li><p>轮询模式下向MMC卡写操作。HAL_MMC_WriteBlocks()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态。</p></li><li><p>DMA模式下向MMC卡写操作。HAL_MMC_WriteBlocks_DMA()</p><p>此函数仅支持512字节块长度（块大小必须是512字节），通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Tx中断事件来检查DMA的传输过程。</p></li><li><p>中断模式下向MMC卡写操作。HAL_MMC_WriteBlocks_IT()</p><p>此函数仅支持512字节块长度，通过调整 "NumberOfBlocks"参数就可以进行单个block的写操作或多个block的写操作。之后为确保正确地完成传输，可通过 HAL_MMC_GetCardState()函数来检查MMC的状态，通过MMC Tx中断事件来检查中断传输过程。</p></li></ul><p><strong>5. 获取MMC卡信息及CSD寄存器和CID寄存器参数</strong></p><ul><li><p>获取MMC卡信息。HAL_MMC_GetCardInfo()</p><p>它会返回关于MMC卡的有用信息如：块大小，卡类型，块编号等等。</p></li><li><p>获取CSD寄存器参数。HAL_MMC_GetCardCSD()</p><p>CSD的某些参数对于卡的初始化和识别很有用。</p></li><li><p>获取CID寄存器参数。HAL_MMC_GetCardCID()</p><p>CID的某些参数对于卡的初始化和识别很有用。</p></li></ul><h3 id="mmc-hal常用宏定义列表">MMC HAL常用宏定义列表</h3><ul><li><p>__HAL_MMC_ENABLE : 使能 MMC设备</p></li><li><p>__HAL_MMC_DISABLE : 禁止 MMC 设备</p></li><li><p>__HAL_MMC_DMA_ENABLE: 使能 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_DMA_DISABLE: 禁止 SDMMC DMA 传输</p></li><li><p>__HAL_MMC_ENABLE_IT: 使能 MMC 设备中断</p></li><li><p>__HAL_MMC_DISABLE_IT: 禁止 MMC 设备中断</p></li><li><p>__HAL_MMC_GET_FLAG:检查 MMC 标志是否设置</p></li><li><p>__HAL_MMC_CLEAR_FLAG: 清除 MMC 的挂起标志</p></li></ul><h3 id="mmc回调函数的注册">MMC回调函数的注册</h3><p>当 USE_HAL_MMC_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_MMC_RegisterCallback(), HAL_MMC_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>ErrorCallback : 发生错误回调函数</li><li>AbortCpltCallback : 中止完成回调函数</li><li>MspInitCallback : MMC 相关MCU初始化回调函数</li><li>MspDeInitCallback : MMC 相关MCU去初始化回调函数</li></ul><p>默认情况下, MMC 初始化（HAL_MMC_Init()）后，当状态是 HAL_MMC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_MMC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_MMC_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mmc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_nor库的使用</title>
    <link href="/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/07/stm32f1xx-hal-nor%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于Nor flash存储器的使用方法。</p><h3 id="nor存储器外设库的使用">NOR存储器外设库的使用</h3><p>此驱动是一个通用的分层驱动程序，包含一组用于控制NOR闪存的API。它使用FSMC层函数来连接NOR 闪存。</p><ol type="1"><li><p>配置NOR flash 存储器的控制和时序参数。HAL_NOR_Init()</p></li><li><p>读取NOR flash 存储器制造商和设备ID。HAL_NOR_Read_ID()</p><p>读取的信息存储在函数调用的NOR_ID_TypeDef类型结构体中。</p></li><li><p>对NOR flash存储器进行读写操作。HAL_NOR_Read(), HAL_NOR_Program()</p></li><li><p>执行NOR flash块擦除或芯片擦除操作。 HAL_NOR_Erase_Block() , HAL_NOR_Erase_Chip()</p></li><li><p>读取NOR flash的通用闪存接口ID（CFI IDs）。HAL_NOR_Read_CFI()</p><p>读取的信息存储在被上述函数调用的已声明NOR_CFI_TypeDef结构体中。</p></li><li><p>可分别通过调用 HAL_NOR_WriteOperation_Enable() / HAL_NOR_WriteOperation_Disable()函数来使能/禁止 NOR Flash的写操作，从而控制NOR Flash设备。</p></li><li><p>监测NOR设备状态。 HAL_NOR_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通NOR flash操作APIs。如果NOR flash设备包含不同的操作和方法，应该单独实施。</p><h3 id="nor存储器外设常用宏定义">NOR存储器外设常用宏定义</h3><ul><li>NOR_WRITE : NOR 存储器向指定的地址写入数据。</li></ul><h3 id="nor存储器回调函数的注册">NOR存储器回调函数的注册</h3><p>当 USE_HAL_NOR_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_NOR_RegisterCallback(), HAL_NOR_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : NOR 相关MCU初始化回调函数</li><li>MspDeInitCallback : NOR 相关MCU去初始化回调函数</li></ul><p>默认情况下, NOR 初始化（HAL_NOR_Init()）后，当状态是 HAL_NOR_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_NOR_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_NOR_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_pccard库的使用</title>
    <link href="/2023/08/07/stm32f1xx-hal-pccard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/07/stm32f1xx-hal-pccard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于PCCARD存储器的使用方法。</p><h3 id="pccard存储器外设库的使用">PCCARD存储器外设库的使用</h3><p>此驱动是一个通用的分层驱动程序，包含一组用于控制PCCARD/小型闪存的API。它使用FSMC层函数来连接PCCARD存储器。</p><ol type="1"><li><p>配置PCCARD/小型闪存的控制和时序参数。HAL_PCCARD_Init()/HAL_CF_Init()</p></li><li><p>读取PCCARD/小型闪存制造商和设备ID。HAL_PCCARD_Read_ID()/HAL_CF_Read_ID()</p><p>读取的信息存储在函数调用的CompactFlash_ID结构体中。</p></li><li><p>对PCCARD/小型闪存进行扇区读写操作：</p><ul><li><p>HAL_PCCARD_Read_Sector()/ HAL_PCCARD_Write_Sector()</p></li><li><p>HAL_CF_Read_Sector()/HAL_CF_Write_Sector()</p></li></ul></li><li><p>执行PCCARD/小型闪存复位操作。HAL_PCCARD_Reset()/HAL_CF_Reset()</p></li><li><p>执行PCCARD/小型闪存扇区擦除操作。 HAL_PCCARD_Erase_Sector()/HAL_CF_Erase_Sector()</p></li><li><p>读取PCCARD/小型闪存的状态。HAL_PCCARD_ReadStatus()/HAL_CF_ReadStatus()</p></li><li><p>监测PCCARD/小型闪存的状态。 HAL_PCCARD_GetState()/HAL_CF_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通PCCARD/小型闪存操作API。如果PCCARD/小型闪存设备包含不同的操作和方法，应该单独实施。</p><h3 id="pccard存储器回调函数的注册">PCCARD存储器回调函数的注册</h3><p>当 USE_HAL_PCCARD_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_PCCARD_RegisterCallback(), HAL_PCCARD_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : PCCARD 相关MCU初始化回调</li><li>MspDeInitCallback : PCCARD 相关MCU去初始化回调</li></ul><p>默认情况下, PCCARD 初始化（HAL_PCCARD_Init()）后，当状态是 HAL_PCCARD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_PCCARD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_PCCARD_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pccard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_nand库的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-nand%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-nand%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于NAND flash存储器的使用方法。</p><h3 id="nand外设库的使用">NAND外设库的使用</h3><ol type="1"><li><p>配置NAND flash 存储器。HAL_NAND_Init()</p></li><li><p>读取NAND flash 存储器制造商和设备ID。HAL_NAND_Read_ID()</p><p>读取的信息存储在函数调用的NAND_ID_TypeDef类型结构体中。</p></li><li><p>对NAND flash存储器进行读写操作：</p><ul><li>HAL_NAND_Read_Page_8b()/HAL_NAND_Read_SpareArea_8b()</li><li>HAL_NAND_Write_Page_8b()/HAL_NAND_Write_SpareArea_8b()</li><li>HAL_NAND_Read_Page_16b()/HAL_NAND_Read_SpareArea_16b()</li><li>HAL_NAND_Write_Page_16b()/HAL_NAND_Write_SpareArea_16b()</li></ul><p>这些函数使用用户在 NAND_DeviceConfigTypeDef 结构体中预定义的设备信息(块、页面大小等)，结构体中包含读写地址信息。</p></li><li><p>执行NAND flash复位操作。HAL_NAND_Reset()</p></li><li><p>执行NAND flash块擦除操作。HAL_NAND_Erase_Block()</p><p>块擦除信息作为参数传入Nand_Address_Typedef结构体。</p></li><li><p>读取NAND flash的状态操作。HAL_NAND_Read_Status()</p></li><li><p>分别通过调用 HAL_NAND_ECC_Enable() / HAL_NAND_ECC_Disable()函数来使能/禁止 ECC码更正特性，或通过 HAL_NAND_GetECC() 函数获取 ECC更正码，从而控制NAND 设备。</p></li><li><p>监测NAND设备状态。 HAL_NAND_GetState()</p></li></ol><p>此驱动是一套通用的用于控制普通NAND flash操作APIs。如果NAND flash设备包含不同的操作和方法，应该单独实施。</p><h3 id="nand回调函数的注册">NAND回调函数的注册</h3><p>当 USE_HAL_NAND_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_NAND_RegisterCallback(), HAL_NAND_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : NAND 相关MCU初始化回调函数</li><li>MspDeInitCallback : NAND 相关MCU去初始化回调函数</li></ul><p>默认情况下, NAND 初始化（HAL_NAND_Init()）后，当状态是 HAL_NAND_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_NAND_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_NAND_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nand</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_rtc库的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-rtc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-rtc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Real Time Clock，简称RTC，实时时钟，以下来看看HAL库关于RTC的使用方法。</p><h3 id="rtc外设库的使用">RTC外设库的使用</h3><ol type="1"><li>使能RTC域。</li><li>配置RTC预分频系数(异步预分频器生成RTC 1Hz时基)。 HAL_RTC_Init()</li><li>配置时间和日期。<ul><li>配置RTC日历(时间和日期)。HAL_RTC_SetTime()，HAL_RTC_SetDate()</li><li>读RTC日历。HAL_RTC_GetTime() ，HAL_RTC_GetDate()</li></ul></li><li>闹钟配置。<ul><li>配置RTC闹钟。HAL_RTC_SetAlarm() ，HAL_RTC_SetAlarm_IT()</li><li>读RTC闹钟。HAL_RTC_GetAlarm()</li></ul></li><li>RTC 入侵检测配置。RTC Tamper<ul><li>使能RTC Tamper，配置Tamper电平。HAL_RTCEx_SetTamper()，HAL_RTCEx_SetTamper_IT()</li><li>TAMPER1 复用功能映射到PC13 。</li></ul></li><li>配置备份数据寄存器（Backup Data Registers）<ul><li>向RTC备份数据寄存器写数据。HAL_RTCEx_BKUPWrite()</li><li>读RTC备份数据寄存器。HAL_RTCEx_BKUPRead()</li></ul></li></ol><h3 id="提示-hal-rtc驱动的限制">==提示: HAL RTC驱动的限制==</h3><ul><li>STM32F1系列芯片上的RTC版本是V1，F1系列芯片不支持V2版本（其它系列）的所有特性。</li><li>对于V2版本，RTC主要的特性是通过硬件控制的。但在F1芯片，日期特性完全由软件控制。</li><li>跟其它系列芯片相比，F1系列芯片有一些限制：<ul><li>HAL库只支持24小时格式（不支持12小时）。</li><li>日期保存在SRAM中，当MCU处于停止或待机模式时，日期就会丢失。用户应该在进入低功耗模式之前保存日期。（基于备份寄存器的固件包提供了一个示例）</li><li>每次调用时间和日期函数时，日期就会自动更新。HAL_RTC_GetTime() ，HAL_RTC_GetDate()</li><li>闹钟检测被限制在一天内，它只会过期一次（无重复闹钟，需要编一个新的闹钟）。</li></ul></li></ul><h3 id="备用域操作条件">备用域操作条件</h3><ul><li>当主电源关闭时，可通过VBAT电源来给RTC和RTC备份寄存器供电。当VDD关闭，为了维持RTC备份寄存器的内容和给RTC供电，VBAT引脚连接到一个电池或其它电源的备用电源。</li><li>当主数字电源（VDD）关闭，为了RTC的操作，VBAT引脚需为以下模块供电：<ul><li>RTC</li><li>LSE振荡器</li><li>使能低功耗备用稳压器时的备用SRAM</li><li>PC13 ~ PC15 I/O引脚，加上 PI8引脚 (当可使用时)</li></ul></li><li>当备用域通过VDD（模拟开关连接到VDD）供电，可使用PC13引脚，用作入侵检测引脚。</li><li>当备用域通过VBAT（模拟开关连接到VBAT，因为VDD不存在）供电，可使用PC13引脚，用作入侵检测引脚。</li></ul><h3 id="备用域复位">备用域复位</h3><ul><li>备用域复位将所有的RTC寄存器和RCC_BDCR寄存器设为复位值。</li><li>当发生以下任一事件，就会产生备用域复位：<ul><li>设置RCC备用域控制寄存器（RCC_BDCR）中的BDRST位触发软件复位。</li><li>如果两个供电之前都关闭了，那么VDD或VBAT电压就会打开。</li><li>入侵检测事件复位所有的数据备份寄存器。</li></ul></li></ul><h3 id="访问备用域">访问备用域</h3><ul><li>复位后, 备用域 (RTC寄存器, RTC备份数据寄存器和备份SRAM)就会被保护，不能进行写操作。</li><li>为了访问RTC域和RTC寄存器，可通过以下方式：<ul><li>调用 HAL_RCCEx_PeriphCLKConfig()函数，其中PeriphClockSelection为RCC_PERIPHCLK_RTC，并选择RTCClockSelection (LSE, LSI 或 HSE)。</li><li>使能备用域时钟。__HAL_RCC_BKP_CLK_ENABLE()</li></ul></li></ul><h3 id="rtc和低功耗模式">RTC和低功耗模式</h3><ul><li>通过RTC复用函数可把MCU从低功耗模式中唤醒。</li><li>RTC复用函数是RTC闹钟（闹钟A）和检测RTC入侵事件。这些复用函数可将系统从停止和待机低功耗模式下唤醒。</li><li>系统还可以通过RTC闹钟从低功耗模式下唤醒，而无需依赖外部中断（自动唤醒模式）</li></ul><h3 id="rtc回调函数的注册">RTC回调函数的注册</h3><p>当 USE_HAL_RTC_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_RTC_RegisterCallback(), HAL_RTC_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>AlarmAEventCallback : RTC闹钟A 事件回调函数</p></li><li><p>Tamper1EventCallback : RTC入侵检测1事件回调函数</p></li><li><p>MspInitCallback : RTC相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : RTC相关MCU去初始化回调函数</p></li></ul><p>默认情况下, RTC 初始化（HAL_RTC_Init()）后，当状态是 HAL_RTC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_RTC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_RTC_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rtc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_spi库的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-spi%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-spi%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Serial Peripheral Interface，简称SPI，串行外设接口。以下来看看HAL库关于SPI的使用方法。</p><h3 id="spi外设库的使用">SPI外设库的使用</h3><ol type="1"><li><p>声明一个 SPI_HandleTypeDef 结构体,如：SPI_HandleTypeDef hspi;</p></li><li><p>初始化SPI底层。HAL_SPI_MspInit()</p></li></ol><ul><li>使能SPIx 接口时钟。</li><li>配置SPI引脚<ul><li>使能SPI GPIO 时钟</li><li>配置SPI引脚为复用推挽模式</li></ul></li><li>如果使用到中断，则配置NVIC。<ul><li>配置SPIx 中断优先级</li><li>使能NVIC SPI IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体参数。</li><li>配置DMA Tx或Rx通道。</li><li>将hdma_tx 或hdma_rx 跟 hspi DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置hspi初始化结构体中各参数。</li><li>调用 HAL_SPI_Init() 函数初始化 SPI寄存器。</li></ol><h3 id="循环模式规则">循环模式规则</h3><ul><li>当SPI配置在以下模式时，就不能使用DMA循环模式：<ul><li>主机2线只接收 (Master 2Lines RxOnly)</li><li>主机1线接收 (Master 1Line Rx)</li></ul></li><li>当使能DMA循环模式时，就不能使用CRC功能。</li><li>当使用了SPI DMA 暂停/停止功能时，必须只能在SPI回调函数中使用HAL_SPI_DMAPause()/ HAL_SPI_DMAStop()函数。</li></ul><h3 id="主机接收模式规则">主机接收模式规则</h3><p>在主机单向接收模式 (MSTR =1, BIDIMODE=0, RXONLY=1) 或 双向接收模式(MSTR=1, BIDIMODE=1, BIDIOE=0)，为了确保SPI没有发起新的数据传输，需要重视以下函数：</p><ul><li><p>HAL_SPI_DeInit()</p></li><li><p>HAL_SPI_Init()</p></li></ul><h3 id="spi回调函数的注册">SPI回调函数的注册</h3><p>当 USE_HAL_SPI_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_SPI_RegisterCallback(), HAL_SPI_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxCpltCallback : SPI 发送完成回调函数</p></li><li><p>RxCpltCallback : SPI 接收完成回调函数</p></li><li><p>TxRxCpltCallback : SPI 发送接收完成回调函数</p></li><li><p>TxHalfCpltCallback : SPI 发送过半回调函数</p></li><li><p>RxHalfCpltCallback : SPI 接收过半回调函数</p></li><li><p>TxRxHalfCpltCallback : SPI 发送接收过半回调函数</p></li><li><p>ErrorCallback : SPI 错误回调函数</p></li><li><p>AbortCpltCallback : SPI 中止回调函数</p></li><li><p>MspInitCallback : SPI 相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : SPI 相关MCU去初始化回调函数</p></li></ul><p>默认情况下, SPI 初始化（HAL_SPI_Init()）后，当状态是 HAL_SPI_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SPI_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SPI_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_smartcard库的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-smartcard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-smartcard%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Smart Card，智能卡，以下来看看HAL库关于SMARTCARD的使用方法。</p><h3 id="smartcard外设库的使用">SMARTCARD外设库的使用</h3><ol type="1"><li><p>声明一个 SMARTCARD_HandleTypeDef 结构体。</p></li><li><p>初始化SMARTCARD底层。HAL_SMARTCARD_MSMARTCARDnit()</p></li></ol><ul><li>使能SMARTCARDx关联到USARTx 的接口时钟。</li><li>配置SMARTCARD引脚<ul><li>使能SMARTCARD GPIO 时钟</li><li>配置SMARTCARD引脚为复用上拉模式</li></ul></li><li>如果使用到中断（HAL_SMARTCARD_Transmit_IT()，HAL_SMARTCARD_Receive_IT() ），则配置NVIC。<ul><li>配置USARTx中断优先级</li><li>使能NVIC USART IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_SMARTCARD_Transmit_DMA()，HAL_SMARTCARD_Receive_DMA()<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体Tx/Rx参数。</li><li>配置DMA Tx或Rx通道。</li><li>将DMA 跟 SMARTCARD DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置SMARTCARD初始化结构体中各参数。</li><li>调用 HAL_SMARTCARD_Init() 函数初始化 SMARTCARD寄存器。</li></ol><p>在发送和接收过程中，使用宏定义 __HAL_SMARTCARD_ENABLE_IT() 和 __HAL_SMARTCARD_DISABLE_IT() 来管理SMARTCARD 的中断(发送完成中断，接收非空中断，错误中断)。</p><h3 id="smartcard轮询模式io操作">SMARTCARD轮询模式IO操作</h3><ul><li>阻塞方式下，发送一定数量的数据。HAL_SMARTCARD_Transmit()</li><li>阻塞方式下，接收一定数量的数据。HAL_SMARTCARD_Receive()</li></ul><h3 id="smartcard中断模式io操作">SMARTCARD中断模式IO操作</h3><ul><li><p>非阻塞方式下，发送一定数量的数据。HAL_SMARTCARD_Transmit_IT()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_SMARTCARD_TxCpltCallback()</p></li><li><p>非阻塞方式下，接收一定数量的数据。HAL_SMARTCARD_Receive_IT()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_SMARTCARD_RxCpltCallback()</p></li><li><p>传输出错时，执行出错回调函数，用户自行添加代码。HAL_SMARTCARD_ErrorCallback()</p></li></ul><h3 id="smartcard-dma-模式io操作">SMARTCARD DMA 模式IO操作</h3><ul><li><p>非阻塞方式(DMA)下，发送一定数量的数据。HAL_SMARTCARD_Transmit_DMA()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_SMARTCARD_TxCpltCallback()</p></li><li><p>非阻塞方式(DMA)下，接收一定数量的数据。HAL_SMARTCARD_Receive_DMA()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_SMARTCARD_RxCpltCallback()</p></li><li><p>传输出错时，执行出错回调函数，用户自行添加代码。HAL_SMARTCARD_ErrorCallback()</p></li></ul><h3 id="smartcard-常用宏定义">SMARTCARD 常用宏定义</h3><ul><li><p>__HAL_SMARTCARD_ENABLE: 使能SMARTCARD 外设</p></li><li><p>__HAL_SMARTCARD_DISABLE: 禁止SMARTCARD 外设</p></li><li><p>__HAL_SMARTCARD_GET_FLAG : 检查SMARTCARD 标志是否设置</p></li><li><p>__HAL_SMARTCARD_CLEAR_FLAG : 清除 SMARTCARD 挂起标志</p></li><li><p>__HAL_SMARTCARD_ENABLE_IT: 使能 SMARTCARD 中断</p></li><li><p>__HAL_SMARTCARD_DISABLE_IT: 禁止 SMARTCARD 中断</p></li></ul><h3 id="smartcard回调函数的注册">SMARTCARD回调函数的注册</h3><p>当 USE_HAL_SMARTCARD_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_SMARTCARD_RegisterCallback(), HAL_SMARTCARD_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxCpltCallback : 发送完成回调函数</p></li><li><p>RxCpltCallback : 接收完成回调函数</p></li><li><p>ErrorCallback : 错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>AbortTransmitCpltCallback : 中止发送完成回调函数</p></li><li><p>AbortReceiveCpltCallback : 中止接收完成回调函数</p></li><li><p>MspInitCallback : SMARTCARD 相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : SMARTCARD 相关MCU去初始化回调函数</p></li></ul><p>默认情况下, SMARTCARD 初始化（HAL_SMARTCARD_Init()）后，当状态是 HAL_SMARTCARD_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SMARTCARD_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SMARTCARD_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>smartcard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_tim库的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-tim%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-tim%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>timer, 简称TIM，定时器是MCU控制中使用最广泛的外设，STM32中有多个TIM，下面来看看HAL库关于TIM的介绍和使用方法。</p><h3 id="tim外设库的一般特性">TIM外设库的一般特性</h3><ul><li>16位向上，向下，向上向下自动重装载计数器</li><li>16位可编程预分频系数，允许对计数器时钟进行 1 ~ 65536 的分频。</li><li>多达4各独立的通道：<ul><li>输入捕获 Input Capture</li><li>输出比较 Output Compare</li><li>产生PWM（边沿和中心对齐模式）</li><li>单脉冲模式输出 One-pulse mode output</li></ul></li><li>用外部信号的同步电路来控制定时器，并将多个定时器互连在一起。</li><li>支持增量编码器的定位目的</li></ul><h3 id="tim外设库的使用">TIM外设库的使用</h3><ol type="1"><li><p>根据所选的功能特性，初始化TIM底层：</p><ul><li>Time Base : HAL_TIM_Base_MspInit()</li><li>Input Capture : HAL_TIM_IC_MspInit()</li><li>Output Compare : HAL_TIM_OC_MspInit()</li><li>PWM generation : HAL_TIM_PWM_MspInit()</li><li>One-pulse mode output : HAL_TIM_OnePulse_MspInit()</li><li>Encoder mode output : HAL_TIM_Encoder_MspInit()</li><li>Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()</li></ul></li><li><p>使能TIM接口时钟。__HAL_RCC_TIMx_CLK_ENABLE()</p></li><li><p>配置TIM引脚。</p><ul><li>使能TIM GPIOs时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>配置TIM引脚复用功能。HAL_GPIO_Init()</li></ul></li><li><p>默认时钟是来自APBx的内部时钟，如果有需要，可配置外部时钟。HAL_TIM_ConfigClockSource()</p><p>该配置需在任何启动函数之前完成。</p></li><li><p>在所需的功能模式下配置TIM：</p><ul><li><p>使用定时器产生时基（time base）。HAL_TIM_Base_Init()</p></li><li><p>使用定时器产生输出比较信号。 HAL_TIM_OC_Init() , HAL_TIM_OC_ConfigChannel()</p></li><li><p>使用定时器产生PWM信号。HAL_TIM_PWM_Init() , HAL_TIM_PWM_ConfigChannel()</p></li><li><p>使用定时器测量外部信号。HAL_TIM_IC_Init() , HAL_TIM_IC_ConfigChannel()</p></li><li><p>单脉冲模式下使用定时器。HAL_TIM_OnePulse_Init() , HAL_TIM_OnePulse_ConfigChannel()</p></li><li><p>使用定时器编码接口。HAL_TIM_Encoder_Init()</p></li><li><p>使用定时器 Hall Sensor接口，如果有需要中断和DMA请求，则配置通信事件。HAL_TIMEx_HallSensor_Init() ， HAL_TIMEx_ConfigCommutEvent()</p><p><strong>注意</strong>：一个定时器用于与Hall sensor接口连接，另一个定时器用于通信事件。</p></li></ul></li><li><p>根据功能特性开启TIM外设：</p><ul><li>Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()</li><li>Input Capture : HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()</li><li>Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()</li><li>PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()</li><li>One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()</li><li>Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT()</li><li>Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OCN_Start_IT()</li><li>Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()</li><li>Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()</li><li>Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().</li></ul></li><li><p>管理控制DMA Busrt功能。HAL_TIM_DMABurst_WriteStart()， HAL_TIM_DMABurst_ReadStart()</p></li></ol><h3 id="tim回调函数的注册">TIM回调函数的注册</h3><p>当 USE_HAL_TIM_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_TIM_RegisterCallback(), HAL_TIM_UnRegisterCallback()</p><p>回调函数：</p><ul><li>Base_MspDeInitCallback : TIM 时基相关MCU去初始化回调函数</li><li>IC_MspInitCallback : TIM 输入捕获相关MCU初始化回调函数</li><li>IC_MspDeInitCallback : TIM 输入捕获相关MCU去初始化回调函数</li><li>OC_MspInitCallback : TIM 输出比较相关MCU初始化回调函数</li><li>OC_MspDeInitCallback : TIM 输出比较相关MCU去初始化回调函数</li><li>PWM_MspInitCallback : TIM PWM 相关MCU初始化回调函数</li><li>PWM_MspDeInitCallback : TIM PWM 相关MCU去初始化回调函数</li><li>OnePulse_MspInitCallback : TIM 单脉冲相关MCU初始化回调函数</li><li>OnePulse_MspDeInitCallback : TIM 单脉冲相关MCU去初始化回调函数</li><li>Encoder_MspInitCallback : TIM 编码器相关MCU初始化回调函数</li><li>Encoder_MspDeInitCallback : TIM 编码器相关MCU去初始化回调函数</li><li>HallSensor_MspInitCallback : TIM Hall Sensor 相关MCU初始化回调函数</li><li>HallSensor_MspDeInitCallback : TIM Hall Sensor 相关MCU去初始化回调函数</li><li>PeriodElapsedCallback : TIM 周期时间结束回调函数</li><li>PeriodElapsedHalfCpltCallback : TIM 半周期时间结束回调函数</li><li>TriggerCallback : TIM 触发回调函数</li><li>TriggerHalfCpltCallback : TIM 半触发回调函数</li><li>IC_CaptureCallback : TIM 输入捕获回调函数</li><li>IC_CaptureHalfCpltCallback : TIM 半输入捕获回调函数</li><li>OC_DelayElapsedCallback : TIM 输出比较延时回调函数</li><li>PWM_PulseFinishedCallback : TIM PWM 脉冲结束回调函数</li><li>PWM_PulseFinishedHalfCpltCallback : TIM PWM 半脉冲结束回调函数</li><li>ErrorCallback : TIM 错误回调函数</li><li>CommutationCallback : TIM 通信回调函数</li><li>CommutationHalfCpltCallback : TIM 半通信回调函数</li><li>BreakCallback : TIM 打断回调函数</li></ul><p>默认情况下, TIM初始化（HAL_TIM_Init()）后，当状态是 HAL_TIM_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_TIM_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_TIM_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_sram库的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-sram%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-sram%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看HAL库关于SRAM 内存的使用方法。</p><h3 id="sram外设库的使用">SRAM外设库的使用</h3><p>这是一个通用的分层驱动，包含一套控制SRAM内存的API。它使用FSMC层函数与SRAM设备进行连接。要配置FSMC与SRAM/PSRAM的连接，应遵循以下顺序：</p><ol type="1"><li><p>声明一个SRAM_HandleTypeDef类型结构体。如：SRAM_HandleTypeDef hsram;</p><ul><li>对SRAM_HandleTypeDef 句柄中“Init”中成员赋值。</li><li>对SRAM_HandleTypeDef 句柄中“Instance”填入预先定义的NOR或SRAM设备基地址寄存器实例。</li><li>对SRAM_HandleTypeDef 句柄中“Extended”填入预先定义的NOR或SRAM扩展模式基地址寄存器实例。</li></ul></li><li><p>为正常模式和扩展模式声明两个 FSMC_NORSRAM_TimingTypeDef 类型结构体，并进行赋值。如：</p><p>​ FSMC_NORSRAM_TimingTypeDef Timing ， FSMC_NORSRAM_TimingTypeDef ExTiming;</p></li><li><p>初始化 SRAM 控制器。HAL_SRAM_Init()</p><ul><li>配置底层硬件。HAL_SRAM_MspInit()</li><li>使用 FSMC NORSRAM 接口配置控制寄存器。FSMC_NORSRAM_Init()</li><li>使用 FSMC NORSRAM 接口配置时序寄存器。FSMC_NORSRAM_Timing_Init()</li><li>使用 FSMC NORSRAM 接口配置扩展模式时序寄存器。FSMC_NORSRAM_Extended_Timing_Init()</li><li>使能SRAM设备。__FSMC_NORSRAM_ENABLE()</li></ul></li><li><p>在这个阶段，你就可以执行内存与NOR/SRAM Bank之间的读、写操作。</p><ul><li>轮询模式下的读写：HAL_SRAM_Read()/HAL_SRAM_Write()</li><li>DMA模式下的读写：HAL_SRAM_Read_DMA()/HAL_SRAM_Write_DMA()</li></ul></li><li><p>你也可以通过调用HAL_SRAM_WriteOperation_Enable() / HAL_SRAM_WriteOperation_Disable() 函数来控制SRAM设备的写操作。</p></li><li><p>你可以持续监测SRAM设备的状态。HAL_SRAM_GetState()</p></li></ol><h3 id="sram回调函数的注册">SRAM回调函数的注册</h3><p>当 USE_HAL_SRAM_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_SRAM_RegisterCallback(), HAL_SRAM_UnRegisterCallback()</p><p>回调函数：</p><ul><li>MspInitCallback : SRAM 相关MCU初始化回调函数</li><li>MspDeInitCallback : SRAM 相关MCU去初始化回调函数</li></ul><p>默认情况下, SRAM 初始化（HAL_SRAM_Init()）后，当状态是 HAL_SRAM_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_SRAM_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_SRAM_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_hcd库和pcd的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-hcd%E5%BA%93%E5%92%8Cpcd%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-hcd%E5%BA%93%E5%92%8Cpcd%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Host Controller Driver 和 Peripheral Controller Driver，分别简称HCD，PCD，它们是USB外设控制器相关驱动，下面来看看HAL库关于HCD和PCD的使用方法介绍。</p><h3 id="hcd外设库的使用">HCD外设库的使用</h3><ol type="1"><li>声明一个 HCD_HandleTypeDef 类型结构体。如：HCD_HandleTypeDef hhcd;</li><li>对hhcd结构体的各参数进行赋值。</li><li>初始化 HCD外设。HAL_HCD_Init();</li><li>初始化HCD底层。HAL_HCD_MspInit();<ul><li>使能 HCD/USB 底层接口时钟。__HAL_RCC_USB_OTG_FS_CLK_ENABLE();</li><li>初始化相关GPIO时钟</li><li>配置HCD引脚为输出模式</li><li>配置HCD NVIC中断</li></ul></li><li>将上层USB主机栈关联到HAL HCD驱动。hhcd.pData = phost;</li><li>使能HCD发送和接收。HAL_HCD_Start();</li></ol><h3 id="pcd外设库的使用">PCD外设库的使用</h3><ol type="1"><li>声明一个 PCD_HandleTypeDef 类型结构体。如：PCD_HandleTypeDef hpcd;</li><li>对hpcd结构体的各参数进行赋值。</li><li>初始化 PCD外设。HAL_PCD_Init();</li><li>初始化PCD底层。HAL_PCD_MspInit();<ul><li>使能 PCD/USB 底层接口时钟。<ul><li>对于一般USB设备：__HAL_RCC_USB_CLK_ENABLE();</li><li>对于USB全速设备：__HAL_RCC_USB_OTG_FS_CLK_ENABLE();</li></ul></li><li>初始化相关GPIO时钟</li><li>配置PCD引脚为输出模式</li><li>配置PCD NVIC中断</li></ul></li><li>将上层USB设备栈关联到HAL PCD驱动。hpcd.pData = pdev;</li><li>使能PCD发送和接收。HAL_PCD_Start();</li></ol>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hcd</tag>
      
      <tag>pcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_eth库的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-eth%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-eth%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Ethernet，简称ETH，以太网，以下来看看HAL库关于ETH的使用方法。</p><h3 id="eth外设库的使用">ETH外设库的使用</h3><ol type="1"><li><p>声明一个ETH_HandleTypeDef 类型结构体，如：ETH_HandleTypeDef heth;</p></li><li><p>对初始化结构体heth中参数进行赋值。</p></li><li><p>初始化ETH。Call HAL_ETH_Init()</p></li><li><p>初始化ETH底层。HAL_ETH_MspInit()</p><ul><li><p>使能ETH接口时钟。<code>__HAL_RCC_ETHMAC_CLK_ENABLE()</code> ，<code>__HAL_RCC_ETHMACTX_CLK_ENABLE()</code>，<code>__HAL_RCC_ETHMACRX_CLK_ENABLE()</code></p></li><li><p>初始化相关GPIO时钟。</p></li><li><p>配置ETH引脚为输出</p></li><li><p>配置ETH NVIC中断（中断模式）</p></li></ul></li><li><p>以链模式（chain mode ）初始化ETH DMA描述符并指向已分配的缓冲区：</p></li></ol><ul><li>发送过程：HAL_ETH_DMATxDescListInit()</li><li>接收过程：HAL_ETH_DMARxDescListInit()</li></ul><ol start="6" type="1"><li><p>使能MAC并进行DMA发送和接收。HAL_ETH_Start()</p></li><li><p>准备好 ETH DMA 发送描述符，助力于ETH DMA传输数据帧到 MAC TX FIFO。HAL_ETH_TransmitFrame()</p></li><li><p>轮询接收ETH DMA接收描述符中的数据帧，并获取数据帧参数。HAL_ETH_GetReceivedFrame() (在无限循环中调用)</p></li><li><p>当ETH 接收中断发生时，获取一帧接收数据。HAL_ETH_GetReceivedFrame_IT() (仅在中断模式中调用)</p></li><li><p>与外部PHY通信:</p><ul><li>从PHY中读取指定寄存器。HAL_ETH_ReadPHYRegister();</li><li>向指定的PHY寄存器中写入数据。HAL_ETH_WritePHYRegister();</li></ul></li><li><p>当 ETH 外设初始化后配置MAC。HAL_ETH_ConfigMAC()</p><p>所有的MAC参数都应该赋值。</p></li><li><p>当 ETH 外设初始化后配置DMA 。HAL_ETH_ConfigDMA()</p><p>所有的DMA参数都应该赋值。</p></li></ol><p><strong>注意</strong>：本驱动不支持PTP 协议和DMA描述符环状模式（DMA descriptors ring mode）。</p><h3 id="eth回调函数的注册">ETH回调函数的注册</h3><p>当 USE_HAL_ETH_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_ETH_RegisterCallback(), HAL_ETH_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>RxCpltCallback : 接收完成回调函数</li><li>DMAErrorCallback : DMA 错误回调函数</li><li>MspInitCallback : ETH相关MCU初始化回调函数</li><li>MspDeInitCallback: ETH相关MCU去初始化回调函数</li></ul><p>默认情况下, ETH 初始化（HAL_ETH_Init()）后，当状态是 HAL_ETH_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_ETH_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_ETH_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_cec库的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-cec%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-cec%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Consumer Electronics Control ，简称CEC，消费电子控制，是一种允许用户通过一个遥控器控制多个电子设备的技术，通常用于家庭娱乐系统。以下来看看HAL库关于CEC的使用方法。</p><h3 id="cec外设库的使用">CEC外设库的使用</h3><ol type="1"><li><p>声明一个CEC_HandleTypeDef 类型结构体。</p></li><li><p>初始化CEC底层。HAL_CEC_MspInit()</p></li></ol><ul><li>使能CEC接口时钟。</li><li>配置CEC引脚<ul><li><p>使能CEC GPIO 时钟</p></li><li><p>配置CEC引脚为复用上拉模式</p></li><li><p>如果使用到中断，如：HAL_CEC_Transmit_IT() ， HAL_CEC_Receive_IT()</p><ul><li>配置CEC 中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC CEC IRQ。HAL_NVIC_EnableIRQ()</li><li>在发送和接收过程中使用宏定义 __HAL_CEC_ENABLE_IT() 和 __HAL_CEC_DISABLE_IT()来控制CEC的中断（发送完成中断，接收非空中断，错误中断）。</li></ul></li></ul></li></ul><ol start="3" type="1"><li>在hcec初始化结构体中设置位定时错误模式和位周期错误模式。Bit Timing Error Mode / Bit Period Error Mode</li><li>初始化CEC寄存器。HAL_CEC_Init()</li></ol><h3 id="cec回调函数的注册">CEC回调函数的注册</h3><p>当 USE_HAL_CEC_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_CEC_RegisterCallback(), HAL_CEC_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : 发送完成回调函数</li><li>ErrorCallback : 错误回调函数</li><li>MspInitCallback : CEC 底层初始化回调函数</li><li>MspDeInitCallback : CEC 底层析构回调函数</li></ul><p>默认情况下, CEC 初始化（HAL_CEC_Init()）后，当状态是 HAL_CEC_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_CEC_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_CEC_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_can库的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-can%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-can%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Controller Area Network，简称CAN，控制器局域网，是一种用于实现设备间通信的网络技术，广泛应用于汽车、工业自动化等领域。以下来看看HAL库关于CAN的使用方法。</p><h3 id="can外设库的使用">CAN外设库的使用</h3><ol type="1"><li><p>初始化CAN底层。HAL_CAN_MspInit()</p><ul><li>使能CAN接口时钟。__HAL_RCC_CANx_CLK_ENABLE()</li><li>配置CAN引脚<ul><li>使能CAN GPIO 时钟</li><li>配置CAN引脚为复用开漏模式</li></ul></li><li>如果使用到中断，如：HAL_CAN_ActivateNotification()<ul><li>配置CAN 中断优先级。HAL_NVIC_SetPriority()</li><li>使能NVIC CAN IRQ。HAL_NVIC_EnableIRQ()</li><li>调用HAL_CAN_IRQHandler()</li></ul></li></ul></li><li><p>初始化CAN外设。HAL_CAN_Init()</p><p>此初始化函数会使用HAL_CAN_MspInit() 为底层进行初始化。</p></li><li><p>配置接收过滤器。HAL_CAN_ConfigFilter()</p></li><li><p>开启CAN模组。HAL_CAN_Start()</p><p>此时CAN总线被激活，可以接收信息，也能发送信息。</p></li><li><p>为了管理信息发送，可以使用以下发送控制函数：</p><ul><li>请求发送新信息。HAL_CAN_AddTxMessage()</li><li>中止挂起信息的发送。HAL_CAN_AbortTxRequest()</li><li>获取空闲发送邮箱的数量 。HAL_CAN_GetTxMailboxesFreeLevel()</li><li>检查发送邮箱信息是否挂起。HAL_CAN_IsTxMessagePending()</li><li>当使能时间触发通信模式时，获取发送信息的时间戳。HAL_CAN_GetTxTimestamp()</li></ul></li><li><p>当CAN Rx FIFOs 接收到一条信息时，可使用HAL_CAN_GetRxMessage()函数获取信息。HAL_CAN_GetRxFifoFillLevel()函数允许知道Rx FIFO接收到多少信息。</p></li><li><p>停止CAN模组。HAL_CAN_Stop()</p></li><li><p>CAN的析构函数：HAL_CAN_DeInit()</p></li></ol><h3 id="can-轮询模式操作">CAN 轮询模式操作</h3><ul><li><p>接收</p><ul><li>监测信息的接收，直到至少接收到一条信息。HAL_CAN_GetRxFifoFillLevel()</li><li>获取信息。HAL_CAN_GetRxMessage()</li></ul></li><li><p>发送</p><ul><li>监测可用的发送邮箱，直到至少有一个发送邮箱是空闲的。HAL_CAN_GetTxMailboxesFreeLevel()</li><li>请求发送信息。HAL_CAN_AddTxMessage()</li></ul></li></ul><h3 id="can-中断模式操作">CAN 中断模式操作</h3><ul><li>使用 HAL_CAN_ActivateNotification()函数激活通知提示，然后通过HAL_CAN_xxxCallback()回调函数来控制，使用同样的APIs： HAL_CAN_GetRxMessage() 和 HAL_CAN_AddTxMessage()</li><li>可使用 HAL_CAN_DeactivateNotification()函数使通知提示失效。</li><li>需要特别留心 <strong>CAN_IT_RX_FIFO0_MSG_PENDING</strong> 和 <strong>CAN_IT_RX_FIFO1_MSG_PENDING</strong> 的通知提示，它们会触发 HAL_CAN_RxFIFO0MsgPendingCallback() 和 HAL_CAN_RxFIFO1MsgPendingCallback() 回调函数。这里有两种做法：<ul><li><ol type="1"><li>在回调函数中直接获取接收的信息。HAL_CAN_GetRxMessage()</li></ol></li><li><ol start="2" type="1"><li>在回调函数中让通知提示失效，而不获取接收的信息。之后使用 HAL_CAN_GetRxMessage()函数获取接收的信息，一旦读取接收的信息，通知提示就会被再次激活。</li></ol></li></ul></li></ul><h3 id="can-睡眠模式">CAN 睡眠模式</h3><ul><li><p>CAN 外设可进入睡眠模式（低功耗）。HAL_CAN_RequestSleep()</p><p>只要当前CAN完成发送或接收过程就能进入睡眠模式。</p></li><li><p>当进入睡眠模式时，可激活一个通知用来提示。</p></li><li><p>HAL_CAN_IsSleepActive()函数可用来检查CAN是否进入睡眠模式。<strong>注意</strong>：只要发送了睡眠模式请求（还没进入睡眠模式），CAN的状态（用 HAL_CAN_GetState()函数获取）是 HAL_CAN_STATE_SLEEP_PENDING，当睡眠模式生效，它的状态就是 HAL_CAN_STATE_SLEEP_ACTIVE</p></li><li><p>从睡眠模式中唤醒有两种方式：</p><ul><li><p>使用函数： HAL_CAN_WakeUp()</p><p>当从此函数返回，就会退出睡眠模式（返回状态是 HAL_OK）。</p></li><li><p>如果激活自动唤醒模式，当CAN外设检测到Rx CAN数据帧的开启。</p></li></ul></li></ul><h3 id="can回调函数的注册">CAN回调函数的注册</h3><p>当 USE_HAL_CAN_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_CAN_RegisterCallback(), HAL_CAN_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxMailbox0CompleteCallback : 邮箱0发送完成回调函数</li><li>TxMailbox1CompleteCallback : 邮箱1发送完成回调函数</li><li>TxMailbox2CompleteCallback : 邮箱2发送完成回调函数</li><li>TxMailbox0AbortCallback : 中止邮箱0的发送回调函数</li><li>TxMailbox1AbortCallback : 中止邮箱1的发送回调函数</li><li>TxMailbox2AbortCallback : 中止邮箱2的发送回调函数</li><li>RxFifo0MsgPendingCallback : Rx FIFO0 信息挂起回调函数</li><li>RxFifo0FullCallback : Rx FIFO0 已满回调函数</li><li>RxFifo1MsgPendingCallback : Rx FIFO1 信息挂起回调函数</li><li>RxFifo1FullCallback : Rx FIFO1 已满回调函数</li><li>SleepCallback : 睡眠回调函数</li><li>WakeUpFromRxMsgCallback : 从接收到信息唤醒回调函数</li><li>ErrorCallback : 错误回调函数</li><li>MspInitCallback : CAN 相关MCU初始化回调函数</li><li>MspDeInitCallback : CAN 相关MCU去初始化回调函数</li></ul><p>默认情况下, CAN 初始化（HAL_CAN_Init()）后，当状态是 HAL_CAN_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_CAN_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_CAN_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>can</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_i2s库的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-i2s%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-i2s%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Integrated Interchip Sound，简称I2S，是关于音频相关的驱动，下面来看看HAL库关于I2S的使用方法。</p><h3 id="i2s外设库的使用">I2S外设库的使用</h3><ol type="1"><li>声明一个 I2S_HandleTypeDef 结构体,如：I2S_HandleTypeDef hi2s;</li><li>初始化I2S底层。HAL_I2S_MspInit()</li></ol><ul><li>使能SPIx 接口时钟。</li><li>配置I2S引脚<ul><li>使能I2S GPIO 时钟</li><li>配置I2S引脚为复用上拉模式</li></ul></li><li>如果使用到中断，则配置NVIC。HAL_I2S_Transmit_IT() 和 HAL_I2S_Receive_IT()<ul><li>配置I2Sx 中断优先级</li><li>使能NVIC I2S IRQ</li></ul></li><li>如果使用到DMA，则配置DMA。HAL_I2S_Transmit_DMA() 和 HAL_I2S_Receive_DMA()<ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA结构体Tx、Rx参数。</li><li>配置DMA Tx或Rx通道。</li><li>将DMA句柄和hi2s DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置hi2s初始化结构体中各参数。</li><li>I2S中断模式（发送完成中断，接收非空中断，错误中断）下发送和接收过程中，使用宏定义 __HAL_I2S_ENABLE_IT() 和 __HAL_I2S_DISABLE_IT()来控制。</li><li>I2SxCLK 时钟源是系统时钟（由HSI、HSE或PLL提供，产生 AHB 时钟源）。对于互联型芯片，为了获得最大的精确度，I2SxCLK 时钟源可以由SYSCLK 时钟或 PLL3 VCO (2 x PLL3CLK)时钟提供。</li></ol><h3 id="i2s-io操作的三种模式">I2S IO操作的三种模式：</h3><ul><li><p>轮询模式IO操作</p><ul><li>阻塞模式下发送一定数量的数据。HAL_I2S_Transmit()</li><li>阻塞模式下接收一定数量的数据。HAL_I2S_Receive()</li></ul></li><li><p>中断模式IO操作</p><ul><li><p>非阻塞模式下发送一定数量的数据。HAL_I2S_Transmit_IT()</p><p>发送过半，执行发送过半回调函数，用户自行添加代码。HAL_I2S_TxHalfCpltCallback()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_I2S_TxCpltCallback()</p></li><li><p>非阻塞模式下接收一定数量的数据。HAL_I2S_Receive_IT()</p><p>接收过半，执行接收过半回调函数，用户自行添加代码。HAL_I2S_RxHalfCpltCallback()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_I2S_RxCpltCallback()</p></li><li><p>当传输发生错误时，执行错误回调函数，用户自行添加代码。HAL_I2S_ErrorCallback()</p></li></ul></li><li><p>DMA模式IO操作</p><ul><li><p>非阻塞模式下(DMA)发送一定数量的数据。HAL_I2S_Transmit_DMA()</p><p>发送过半，执行发送过半回调函数，用户自行添加代码。HAL_I2S_TxHalfCpltCallback()</p><p>发送完成，执行发送完成回调函数，用户自行添加代码。HAL_I2S_TxCpltCallback()</p></li><li><p>非阻塞模式下(DMA)接收一定数量的数据。HAL_I2S_Receive_DMA()</p><p>接收过半，执行接收过半回调函数，用户自行添加代码。HAL_I2S_RxHalfCpltCallback()</p><p>接收完成，执行接收完成回调函数，用户自行添加代码。HAL_I2S_RxCpltCallback()</p></li><li><p>当传输发生错误时，执行错误回调函数，用户自行添加代码。HAL_I2S_ErrorCallback()</p></li><li><p>暂停DMA传输。HAL_I2S_DMAPause()</p></li><li><p>恢复DMA传输。HAL_I2S_DMAResume()</p></li><li><p>停止DMA传输。HAL_I2S_DMAStop()</p><p>在从模式下，如果HAL_I2S_DMAStop()用来停止通信，当主机继续传输数据时，HAL_I2S_ERROR_BUSY_LINE_RX就会产生错误。当 __HAL_I2S_FLUSH_RX_DR 宏用来刷新数据寄存器中的剩余值时，要避免在下次传输时使用DeInit/Init进程。</p></li></ul></li></ul><h3 id="i2s-hal常用宏定义">I2S HAL常用宏定义</h3><ul><li>__HAL_I2S_ENABLE: 使能SPI外设 (I2S 模式)</li><li>__HAL_I2S_DISABLE: 禁止SPI外设 (I2S 模式)</li><li>__HAL_I2S_ENABLE_IT : 使能I2S中断</li><li>__HAL_I2S_DISABLE_IT : 禁止I2S中断</li><li>__HAL_I2S_GET_FLAG: 检查I2S标志是否设置</li><li>__HAL_I2S_FLUSH_RX_DR: 读取数据寄存器的值来刷新接收的数据</li></ul><h3 id="i2s回调函数的注册">I2S回调函数的注册</h3><p>当 USE_HAL_I2S_REGISTER_CALLBACKS为 1时，允许用户注册或注销回调函数。HAL_I2S_RegisterCallback(), HAL_I2S_UnRegisterCallback()</p><p>回调函数：</p><ul><li>TxCpltCallback : I2S 发送完成回调函数</li><li>RxCpltCallback : I2S 接收完成回调函数</li><li>TxHalfCpltCallback : I2S 发送过半回调函数</li><li>RxHalfCpltCallback : I2S 接收过半回调函数</li><li>ErrorCallback : I2S 错误回调函数</li><li>MspInitCallback : I2S 相关MCU初始化回调函数</li><li>MspDeInitCallback : I2S 相关MCU去初始化回调函数</li></ul><p>默认情况下, I2S 初始化（HAL_I2S_Init()）后，当状态是 HAL_I2S_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_I2S_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_I2S_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p><h3 id="i2s勘误">I2S勘误</h3><p>主机模式时，I2S仅支持无数据扩展的16位模式，和使用PCM长同步模式（PCM long synchronization mode）。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>i2s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_i2c库的使用</title>
    <link href="/2023/08/06/stm32f1xx-hal-i2c%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/06/stm32f1xx-hal-i2c%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Inter Integrated Circuit，简称I2C，下面来看看 I2C HAL库关于I2C的使用方法。</p><h3 id="i2c外设库的使用">I2C外设库的使用</h3><ol type="1"><li>声明一个 I2C_HandleTypeDef 结构体,如：I2C_HandleTypeDef hi2c;</li><li>初始化I2C底层。HAL_I2C_MspInit()</li></ol><ul><li><p>使能I2Cx 接口时钟。</p></li><li><p>配置I2C引脚</p><ul><li>使能I2C GPIO 时钟</li><li>配置I2C引脚为复用开漏模式</li></ul></li><li><p>如果使用到中断，则配置NVIC</p><ul><li>配置I2Cx 中断优先级</li><li>使能NVIC I2C IRQ通道</li></ul></li><li><p>如果使用到DMA，则配置DMA</p><ul><li>为发送或接收通道声明一个DMA_HandleTypeDef 结构体。</li><li>使能DMAx接口时钟。</li><li>配置DMA句柄参数。</li><li>配置DMA Tx或Rx通道。</li><li>将DMA句柄和hi2c DMA Tx 或 Rx句柄进行关联。</li><li>当DMA Tx或Rx通道发生传输完成中断时，则配置其优先级并使能NVIC。</li></ul></li></ul><ol start="3" type="1"><li>配置hi2c初始化结构体中各参数。</li><li>初始化I2C寄存器，HAL_I2C_Init()，同时配置底层硬件（GPIO，CLOCK，NVIC等等）HAL_I2C_MspInit() 。</li><li>检查目标设备是否已经准备好通信。HAL_I2C_IsDeviceReady()</li></ol><h3 id="i2c-io操作的三种模式">I2C IO操作的三种模式：</h3><ul><li><p>轮询模式IO操作</p><ul><li>主模式下，以阻塞方式发送一定数量的数据。HAL_I2C_Master_Transmit()</li><li>主模式下，以阻塞方式接收一定数量的数据。HAL_I2C_Master_Receive()</li><li>从模式下，以阻塞方式发送一定数量的数据。HAL_I2C_Slave_Transmit()</li><li>从模式下，以阻塞方式接收一定数量的数据。HAL_I2C_Slave_Receive()</li></ul></li><li><p>中断模式IO操作</p><ul><li><p>主模式下，以非阻塞方式发送一定数量的数据。HAL_I2C_Master_Transmit_IT()</p><p>发送完成后，执行回调函数，用户自行添加代码。HAL_I2C_MasterTxCpltCallback()</p></li><li><p>主模式下，以非阻塞方式接收一定数量的数据。HAL_I2C_Master_Receive_IT()</p><p>接收完成后，执行回调函数，用户自行添加代码。HAL_I2C_MasterRxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式发送一定数量的数据。HAL_I2C_Slave_Transmit_IT()</p><p>发送完成后，执行回调函数，用户自行添加代码。HAL_I2C_SlaveTxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式接收一定数量的数据。HAL_I2C_Slave_Receive_IT()</p><p>接收完成后，执行回调函数，用户自行添加代码。HAL_I2C_SlaveRxCpltCallback()</p></li><li><p>如果传输出错，则执行错误回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li><li><p>主模式下，使用中断中止通信。HAL_I2C_Master_Abort_IT()</p></li><li><p>中止通信后执行中止回调函数，用户自行添加代码。HAL_I2C_AbortCpltCallback()</p></li></ul></li><li><p>DMA模式IO操作</p><ul><li><p>主模式下，以非阻塞方式（DMA）传输一定数量的数据。HAL_I2C_Master_Transmit_DMA()</p><p>传输完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterTxCpltCallback()</p></li><li><p>主模式下，以非阻塞方式（DMA）接收一定数量的数据。HAL_I2C_Master_Receive_DMA()</p><p>接收完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterRxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式（DMA）传输一定数量的数据。HAL_I2C_Slave_Transmit_DMA()</p><p>传输完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveTxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式（DMA）接收一定数量的数据。HAL_I2C_Slave_Receive_DMA()</p><p>接收完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveRxCpltCallback()</p></li><li><p>当传输出错时，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li><li><p>中止主模式下的传输。HAL_I2C_Master_Abort_IT()</p><p>中止的末尾，执行回调函数，用户自行添加代码。HAL_I2C_AbortCpltCallback()</p></li></ul></li></ul><h3 id="i2c-io-内存操作的三种模式">I2C IO 内存操作的三种模式</h3><ul><li><p>轮询模式IO内存操作</p><ul><li>以阻塞方式向指定的内存地址写入一定数量的数据。HAL_I2C_Mem_Write()</li><li>以阻塞方式从指定的内存地址读出一定数量的数据。HAL_I2C_Mem_Read()</li></ul></li><li><p>中断模式下IO内存操作</p><ul><li><p>非阻塞方式下，向指定的内存地址写入一定数量的数据。HAL_I2C_Mem_Write_IT()</p><p>在内存写传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemTxCpltCallback()</p></li><li><p>非阻塞方式下，从指定的内存地址读出一定数量的数据。HAL_I2C_Mem_Read_IT()</p><p>在内存读传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemRxCpltCallback()</p></li><li><p>传输出错时，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li></ul></li><li><p>DMA模式IO内存操作</p><ul><li><p>以非阻塞方式（DMA）向指定的内存地址写入一定数量的数据。HAL_I2C_Mem_Write_DMA()</p><p>在内存写传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemTxCpltCallback()</p></li><li><p>以非阻塞方式（DMA）从指定的内存地址读出一定数量的数据。HAL_I2C_Mem_Read_DMA()</p><p>在内存读传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_MemRxCpltCallback()</p></li><li><p>当传输完成后，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li></ul></li></ul><h3 id="i2c中断或dma模式下-io-顺序操作-sequential-operation">I2C中断或DMA模式下 IO 顺序操作 （sequential operation）</h3><p>在传输过程中方向改变时，这些接口允许通过重复启动来控制传输顺序。</p><ul><li><p>通过一个指定的可选域（Option field）来控制顺序传输的步骤。</p></li><li><p>可选域的值通过 <strong>I2C_XferOptions_definition</strong> 来定义：</p><ol type="1"><li><p>I2C_FIRST_AND_LAST_FRAME：用于非顺序传输，功能与非顺序模式下的关联接口相同。</p></li><li><p>I2C_FIRST_FRAME：用于顺序传输，此选项允许控制传输有开启条件，地址和传输的数据而没有停止条件。</p></li><li><p>I2C_FIRST_AND_NEXT_FRAME：仅主模式下用于顺序传输，此选项允许控制传输有开启条件，地址和传输的数据而没有停止条件，然后允许多次调用主模式下顺序传输接口函数（如：HAL_I2C_Master_Seq_Transmit_IT() 或 HAL_I2C_Master_Seq_Transmit_DMA()）。</p></li><li><p>I2C_NEXT_FRAME：用于顺序传输，此选项允许控制传输有重新开启条件，地址以及当方向改变时新的传输数据或方向未改变时仅控制传输的新数据而没有停止条件。</p></li><li><p>I2C_LAST_FRAME：用于顺序传输，此选项允许控制传输有重新开启条件，地址以及当方向改变时新的传输数据或方向未改变时仅控制传输的新数据，最后加上停止条件。</p></li><li><p>I2C_LAST_FRAME_NO_STOP：仅主模式下用于顺序传输，当多次调用同一个主模式顺序接口（类同于I2C_FIRST_AND_NEXT_FRAME）后，此选项允许控制一个重新开启条件。用法是逐个传输多个字节：HAL_I2C_Master_Seq_Transmit_IT、HAL_I2C_Master_Seq_Receive_IT、HAL_I2C_Master_Seq_Transmit_DMA、HAL_I2C_Master_Seq_Receive_DMA(可选 I2C_FIRST_AND_NEXT_FRAME 然后I2C_NEXT_FRAME)。 I2C_LAST_FRAME_NO_STOP 的用途是在最后一个顺序传输或接收，允许调用相反的接口来接收或传输，而不需要停止通信和产生重新开启条件。</p></li><li><p>I2C_OTHER_FRAME: 仅主模式下用于顺序传输，当每次调用同一个主模式顺序接口后，此选项允许控制一个重新开启条件。用法是逐个传输多个字节，每个字节之间重新启动从设备地址： HAL_I2C_Master_Seq_Transmit_IT、HAL_I2C_Master_Seq_Receive_IT、HAL_I2C_Master_Seq_Transmit_DMA、HAL_I2C_Master_Seq_Receive_DMA（可选I2C_FIRST_FRAME 然后 I2C_OTHER_FRAME）。I2C_OTHER_AND_LAST_FRAME 的用途是在最后一个传输时帮助自动产生停止条件。</p></li></ol></li><li><p>不同顺序的I2C接口如下：</p><ol type="1"><li><p>主模式下,以非阻塞方式顺序发送一定数量的数据。HAL_I2C_Master_Seq_Transmit_IT()或HAL_I2C_Master_Seq_Transmit_DMA()</p><p>当前帧传输完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterTxCpltCallback()</p></li><li><p>主模式下,以非阻塞方式顺序接收一定数量的数据。HAL_I2C_Master_Seq_Receive_IT()或HAL_I2C_Master_Seq_Receive_DMA()</p><p>当前帧接收完成，执行回调函数，用户自行添加代码。HAL_I2C_MasterRxCpltCallback()</p></li><li><p>主模式下，以中断方式中止中断或DMA通信。HAL_I2C_Master_Abort_IT()</p><p>中止后，执行回调函数，用户自行添加代码。HAL_I2C_AbortCpltCallback()</p></li><li><p>从模式下，使能、禁止地址监听模式(Address listen mode)。HAL_I2C_EnableListen_IT() ，HAL_I2C_DisableListen_IT()</p><p>当从设备地址匹配，执行回调函数，用户自行添加地址匹配的检查代码和主设备请求的传输方向（写、读）代码。HAL_I2C_AddrCallback()</p><p>在监听模式末尾，执行回调函数，用户自行添加代码。HAL_I2C_ListenCpltCallback()</p></li><li><p>从模式下，以非阻塞方式顺序发送一定数量的数据。HAL_I2C_Slave_Seq_Transmit_IT()或HAL_I2C_Slave_Seq_Transmit_DMA()</p><p>当前帧发送完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveTxCpltCallback()</p></li><li><p>从模式下，以非阻塞方式顺序接收一定数量的数据。HAL_I2C_Slave_Seq_Receive_IT()或 HAL_I2C_Slave_Seq_Receive_DMA()</p><p>当前帧接收完成，执行回调函数，用户自行添加代码。HAL_I2C_SlaveRxCpltCallback()</p></li><li><p>当传输出错时，执行回调函数，用户自行添加代码。HAL_I2C_ErrorCallback()</p></li></ol></li></ul><h3 id="i2c-hal常用宏定义">I2C HAL常用宏定义</h3><ul><li>__HAL_I2C_ENABLE: 使能I2C外设</li><li>__HAL_I2C_DISABLE: 禁止 I2C 外设</li><li>__HAL_I2C_GET_FLAG: 检查I2C标志是否设置</li><li>__HAL_I2C_CLEAR_FLAG: 清除I2C挂起标志</li><li>__HAL_I2C_ENABLE_IT: 使能I2C中断</li><li>__HAL_I2C_DISABLE_IT: 禁止I2C中断</li></ul><h3 id="i2c回调函数的注册">I2C回调函数的注册</h3><p>当 USE_HAL_I2C_REGISTER_CALLBACKS 为 1时，允许用户注册或注销回调函数。HAL_I2C_RegisterCallback()或HAL_I2C_RegisterAddrCallback()，HAL_I2C_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>MasterTxCpltCallback : 主机发送完成回调函数</p></li><li><p>MasterRxCpltCallback : 主机接收完成回调函数</p></li><li><p>SlaveTxCpltCallback : 从机发送完成回调函数</p></li><li><p>SlaveRxCpltCallback : 从机接收完成回调函数</p></li><li><p>ListenCpltCallback : 监听模式完成回调函数</p></li><li><p>MemTxCpltCallback : 内存发送完成回调函数</p></li><li><p>MemRxCpltCallback : 内存接收完成回调函数</p></li><li><p>ErrorCallback : 错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>MspInitCallback : I2C相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : I2C相关MCU去初始化回调函数</p></li></ul><p>默认情况下, I2C 初始化（HAL_I2C_Init()）后，当状态是 HAL_I2C_STATE_RESET，所有的回调函数会被置为弱函数。</p><p>只有在 HAL_I2C_STATE_READY 状态下，回调函数才能被注册或注销。</p><p>当 USE_HAL_I2C_REGISTER_CALLBACKS 为0或未定义时，所有的回调函数已注册的特性不能使用，且都被置为弱函数。</p><h3 id="i2c勘误">I2C勘误</h3><p>i2c因为硅限制，会发生以下错误，所以对于 STM32F1xx 芯片，官方对 I2C HAL Driver给出了临时措施，详细内容查看 ErrataSheet：</p><ol type="1"><li><p>将错误的数据读到数据寄存器 (轮询和中断模式)</p></li><li><p>错位的停止条件后，不能产生开启条件。</p></li><li><p>在传输当前字节之前，必须管理一些软件事件。</p><p>临时措施：一般使用DMA，除了当主机正在接收一个字节。对于中断模式，I2C应该有最高优先级。</p></li><li><p>重启条件的Setup时间参数不匹配。</p><p>临时措施：减少频率到88kHz或当从机支持I2C快速模式，则使用快速模式。</p></li><li><p>数据有效时间 (tVD;DAT) 违反而没有设置OVR标志。</p><p>临时措施：如果从机允许，使用时钟扩展机制，在 HAL_I2C_Init()中将 NoStretchMode = I2C_NOSTRETCH_DISABLE 。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>i2c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_irda库的使用</title>
    <link href="/2023/08/05/stm32f1xx-hal-irda%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/05/stm32f1xx-hal-irda%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>infrared data association, 红外通信技术，简称 IRDA，通过USART同步串口进行数据传输。HAL库中关于IRDA外设库的使用方法如下：</p><h3 id="irda外设库的使用">IRDA外设库的使用</h3><ol type="1"><li>声明一个 IRDA_HandleTypeDef结构体句柄。如： IRDA_HandleTypeDef hirda。</li><li>初始化IRDA底层配置。HAL_IRDA_MspInit()<ul><li>使能串口 USARTx 时钟。</li><li>IRDA引脚的配置。<ul><li>使能IRDA GPIO时钟。</li><li>配置 IRDA 引脚为复用功能，上拉。</li></ul></li><li>如果需要使用中断，则配置NVIC。HAL_IRDA_Transmit_IT() ，HAL_IRDA_Receive_IT()<ul><li>配置串口 USARTx 中断优先级</li><li>使能NVIC USART IRQ中断。</li></ul></li><li>如果需要使用DMA，则配置DMA。HAL_IRDA_Transmit_DMA()，HAL_IRDA_Receive_DMA()<ul><li>为串口Tx和Rx通道声明一个DMA结构体句柄。</li><li>使能DMAx接口时钟。</li><li>配置刚声明的DMA结构体中所需要的Tx/Rx参数。</li><li>配置DMA Tx/Rx 通道。</li><li>将DMA句柄和串口Tx/Rx句柄进行关联。</li><li>当DMA Tx/Rx通道数据传输完成产生中断时，则配置NVIC的优先级并使能。</li><li>配置USART中断优先级并使能NVIC USART IRQ中断。（用于DMA非循环模式下的最后一个字节发送完成的检测）</li></ul></li></ul></li><li>在串口hirda初始化结构体中配置串口的波特率、字节长度，停止位，奇偶校验位，硬件流控和模式（接收/发送）。</li><li>初始化IRDA寄存器。HAL_IRDA_Init()</li></ol><p>指定的IRDA中断(传输完成中断，接收非空中断和错误中断）可使用宏定义控制。__HAL_IRDA_ENABLE_IT() , __HAL_IRDA_DISABLE_IT()</p><p>HAL_IRDA_Init()底层硬件初始化都会调用 HAL_IRDA_MspInit()。</p><h3 id="irda的操作模式">IRDA的操作模式</h3><ul><li>轮询模式IO的操作<ul><li>以阻塞模式发送一定数量的数据。HAL_IRDA_Transmit()</li><li>以阻塞模式接收一定数量的数据。HAL_IRDA_Receive()</li></ul></li><li>中断模式IO的操作<ul><li>非阻塞模式发送一定数量的数据。HAL_IRDA_Transmit_IT()</li><li>传输完成，执行HAL_IRDA_TxCpltCallback() 回调函数，用户自行添加代码。</li><li>非阻塞模式接收一定数量的数据。HAL_IRDA_Receive_IT()</li><li>接收完成，执行HAL_IRDA_RxCpltCallback() 回调函数，用户自行添加代码。</li><li>当传输出错时，执行HAL_IRDA_ErrorCallback() 回调函数，用户自行添加代码。</li></ul></li><li>DMA模式IO的操作<ul><li>非阻塞DMA模式发送一定数量的数据。HAL_IRDA_Transmit_DMA()</li><li>传输过半，执行 HAL_IRDA_TxHalfCpltCallback() 回调函数，用户自行添加代码。</li><li>传输完成，执行 HAL_IRDA_TxCpltCallback() 回调函数，用户自行添加代码。</li><li>非阻塞DMA模式接收一定数量的数据。HAL_IRDA_Receive_DMA()</li><li>接收过半，执行HAL_IRDA_RxHalfCpltCallback() 回调函数，用户自行添加代码。</li><li>接收完成，执行HAL_IRDA_RxCpltCallback() 回调函数，用户自行添加代码。</li><li>当传输出错时，执行HAL_IRDA_ErrorCallback() 回调函数，用户自行添加代码。</li><li>DMA传输暂停。 HAL_IRDA_DMAPause()</li><li>重新开始串口DMA传输。HAL_IRDA_DMAResume()</li><li>停止串口DMA传输。HAL_IRDA_DMAStop()</li></ul></li></ul><h3 id="irda-hal常用宏定义列表">IRDA HAL常用宏定义列表</h3><ul><li>__HAL_IRDA_ENABLE: 使能IRDA</li><li>__HAL_IRDA_DISABLE: 关闭IRDA</li><li>__HAL_IRDA_GET_FLAG : 获取IRDA标志是否设置</li><li>__HAL_IRDA_CLEAR_FLAG : 清除IRDA挂起标志</li><li>__HAL_IRDA_ENABLE_IT: 使能IRDA中断</li><li>__HAL_IRDA_DISABLE_IT: 关闭IRDA中断</li><li>__HAL_IRDA_GET_IT_SOURCE: 检查IRDA是否发生中断</li></ul><h3 id="回调函数的注册">回调函数的注册</h3><ol type="1"><li>USE_HAL_IRDA_REGISTER_CALLBACKS 设置为1，用户就可以使用回调函数了。回调函数的注册和注销函数分别是：HAL_IRDA_RegisterCallback()、HAL_IRDA_UnRegisterCallback()</li></ol><p>​ 回调函数ID：</p><ul><li><p>TxHalfCpltCallback : 发送过半回调函数</p></li><li><p>TxCpltCallback : 发送完成回调函数</p></li><li><p>RxHalfCpltCallback : 接收过半回调函数</p></li><li><p>RxCpltCallback : 接收完成回调函数</p></li><li><p>ErrorCallback : 发生错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>AbortTransmitCpltCallback : 中止发生完成回调函数</p></li><li><p>AbortReceiveCpltCallback : 中止接收完成回调函数</p></li><li><p>MspInitCallback : IRDA相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : IRDA相关MCU去初始化回调函数</p></li></ul><ol start="2" type="1"><li>默认情况下，IRDA初始化之后，当它的状态是 <strong>HAL_IRDA_STATE_RESET</strong> ，所有的回调函数被设置为相应的弱函数。如：HAL_IRDA_TxCpltCallback(), HAL_IRDA_RxHalfCpltCallback()。</li><li>只有在IRDA状态HAL_IRDA_STATE_READY 时，回调函数才能注册或注销。</li><li>当USE_HAL_IRDA_REGISTER_CALLBACKS设置为0，注册的回调函数特性就不能使用，回调函数就当作一个弱函数使用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>irda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_flash库的使用</title>
    <link href="/2023/08/05/stm32f1xx-hal-flash%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/05/stm32f1xx-hal-flash%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看 Flash HAL库关于Flash存储器的特性和使用方法。</p><h3 id="flash外设库的特性">Flash外设库的特性</h3><ul><li>Flash存储器接口管理着CPU AHB I-Code 和D-Code总线访问Flash 存储器。它实现了擦除和编程闪存操作以及读写保护机制。</li><li>Flash存储器接口使用系统预取方式加速了代码的执行。</li><li>Flash存储器的主要特性有：<ul><li>Flash存储器的读操作</li><li>Flash存储器的编程和擦除操作</li><li>读写保护</li><li>I-Code 总线的预取功能</li><li>选项字节编程 Option Bytes programming</li></ul></li></ul><h3 id="flash外设库的使用">Flash外设库的使用</h3><p>该Flash外设库对所有的 STM32F1xx 芯片都适用。</p><ul><li>Flash存储器 I/O编程函数：<ul><li>锁定和解锁Flash接口</li><li>擦除函数：页擦除，擦除所有的页</li><li>编程函数：半字写入，字写入和双字写入</li></ul></li><li>Flash可选项字节编程函数：<ul><li>锁定和解锁可选项字节</li><li>设置、复位写保护</li><li>设置读保护级别</li><li>编程用户可选项字节</li><li>加载启动可选项字节加载程序</li><li>擦除可选项字节</li><li>编程数据可选项字节</li><li>获取写保护</li><li>获取用户可选项字节</li></ul></li><li>中断和标志管理函数：<ul><li>处理Flash中断</li><li>根据当前Flash状态，等待最后一次Flash操作</li><li>获取错误标志状态</li></ul></li></ul><h3 id="flash外设库常用的宏定义">Flash外设库常用的宏定义</h3><ul><li><p>__HAL_FLASH_SET_LATENCY , __HAL_FLASH_GET_LATENCY():设置、获取等待时间</p></li><li><p>__HAL_FLASH_PREFETCH_BUFFER_ENABLE() , __HAL_FLASH_PREFETCH_BUFFER_DISABLE():使能、禁止预取缓冲</p></li><li><p>__HAL_FLASH_HALF_CYCLE_ACCESS_ENABLE() , __HAL_FLASH_HALF_CYCLE_ACCESS_DISABLE() : 使能、禁止半周期访问</p></li><li><p>__HAL_FLASH_ENABLE_IT() , __HAL_FLASH_DISABLE_IT():使能、禁止FLASH中断</p></li><li><p>__HAL_FLASH_GET_FLAG() : 获取FLASH标志状态</p></li><li><p>__HAL_FLASH_CLEAR_FLAG() : 清除FLASH标志</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_crc库的使用</title>
    <link href="/2023/08/05/stm32f1xx-hal-crc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/05/stm32f1xx-hal-crc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Cyclic Redundancy Check，简称CRC，冗余循环校验，ST官方库关于CRC的介绍很简单，下面来看看 Cyclic Redundancy Check HAL库关于CRC校验库的使用方法。</p><h3 id="crc外设库的使用">CRC外设库的使用</h3><ul><li>使能CRC AHB时钟。__HAL_RCC_CRC_CLK_ENABLE()</li><li>初始化CRC计算器<ul><li>指定生成的多项式polynomial（外设默认或非默认）</li><li>指定初始值（外设默认或非默认）</li><li>指定输入数据格式</li><li>如果可能，指定输入或输出反转模式</li></ul></li><li>使用HAL_CRC_Accumulate() 函数计算输入数据缓冲区的CRC值，从之前计算的CRC作为初始值开始。</li><li>使用 HAL_CRC_Calculate() 函数计算输入数据缓冲区的CRC值，从已定义的初始值（默认或非默认）来初始化CRC的计算开始。</li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>crc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_iwdg库的使用</title>
    <link href="/2023/08/05/stm32f1xx-hal-iwdg%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/05/stm32f1xx-hal-iwdg%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看 IWDG HAL库关于 独立看门狗的特性和使用方法。</p><h3 id="iwdg外设库的一般特性">IWDG外设库的一般特性</h3><ul><li><p>独立看门狗可以通过软件或硬件开启。 (通过可选字节（option byte）进行配置)</p></li><li><p>独立看门狗时钟时LSI提供（Low-Speed Internal clock），即使没有主时钟，它也能维持运行。</p></li><li><p>一旦独立看门狗开启，LSI 时钟就会被强制打开，这两者就不会关闭。计数值从复位值（0xFFF）向下计数，当计数到0，就会产生复位信号（IWDG复位）。</p></li><li><p>每当键值（key value）<strong>0x0000 AAAA</strong> 写入到IWDG_KR 寄存器，IWDG_RLR 值就会被重装载到计数器中，以阻止看门狗复位。</p></li><li><p>IWDG工作在 VDD电压域，在 停止（STOP） 和 待机（ STANDBY）模式下也能正常工作（IWDG复位能够把CPU从待机中唤醒）。RCC_CSR寄存器中复位标志用来提示独立看门狗发生了复位。</p></li><li><p>Debug模式：当微控制器进入debug模式（核心停止），IWDG计数器要么继续正常工作，要么停止，取决于DBG模块 DBG_IWDG_STOP 位，可通过宏定义配置：__HAL_DBGMCU_FREEZE_IWDG() 和 __HAL_DBGMCU_UNFREEZE_IWDG()</p></li><li><p>最小、最大的超时时间 <span class="citation" data-cites="32KHz">@32KHz</span> (LSI): 125us、32.7s</p><p>独立看门狗的超时时间可能会因为LSI时钟频率变化而发生变化。STM32F1xx芯片可以测量LSI时钟频率（LSI时钟内部连接到 TIM5_CH4输入捕获引脚）。测量值可用于IWDG超时时间，它具有可接受的精度。</p></li><li><p>默认的超时时间（IWDG_SR 状态寄存器进行更新）：</p><p>LSI_VALUE常量通过名义上的LSI时钟频率来决定，这个频率如上所述，会发生变化，所以默认的超时时间（通过 HAL_IWDG_DEFAULT_TIMEOUT定义）可能会变得很短，也可能会变得很长，这种情况下，默认的超时时间用户可以通过重定义LSI_VALUE 常量来进行微调。（比如：如上以测量的LSI时钟频率为基准）</p></li></ul><h3 id="iwdg外设库的使用">IWDG外设库的使用</h3><ol type="1"><li>IWDG的初始化。HAL_IWDG_Init()<ul><li>在IWDG_KEY寄存器中写入开启的键值来使能IWDG，LSI时钟被强制打开，IWDG计数器开始向下计数。</li><li>写使能配置寄存器： IWDG_PR 和 IWDG_RLR 。</li><li>配置IWDG 预分频系数和计数重装载值。每次看门狗重装载时，此值就会被装载到IWDG的计数器中，然后IWDG从这个值开始向下计数。</li><li>等待状态标志被重置。</li></ul></li><li>应用程序必须在正常运行期间定期刷新IWDG计数器，以防止MCU复位。HAL_IWDG_Refresh()</li></ol><h3 id="iwdg-hal常用宏定义">IWDG HAL常用宏定义</h3><ul><li>__HAL_IWDG_START: 使能IWDG外设</li><li>__HAL_IWDG_RELOAD_COUNTER: 把重装载寄存器中的值重装载到IWDG计数器</li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iwdg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_wwdg库的使用</title>
    <link href="/2023/08/05/stm32f1xx-hal-wwdg%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/05/stm32f1xx-hal-wwdg%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看 WWDG HAL库关于窗口看门狗的特性和使用方法。</p><h3 id="wwdg外设库的一般特性">WWDG外设库的一般特性</h3><p>WWDG一旦使能，在超过规定的时间段就会产生系统复位，除非在计数器值达到0x3F之前，应用程序刷新计数器的值（T[6:0] 向下计数）。 例如：当计数器值从0x40下降到0x3F时，就会产生复位。</p><ul><li><p>如果计数器值在计数器达到刷新窗口值之前被刷新，也会产生MCU复位。这意味着必须在限制的窗口中刷新计数器。</p></li><li><p>WWDG一旦启用，就不能被禁用，除非被系统重置。</p></li><li><p>如果有需要，可以触发一个早期唤醒中断（Early Wakeup Interrupt ），以便在WWDG计数结束前收到警告。如果特定的安全操作或数据记录必须执行在实际复位产生之前，那么就可以使用早期唤醒中断(EWI)。当向下计数器到达0x40，就会发生中断。这种机制需要WWDG中断线在NVIC中被启用。一旦使能，EWI中断不能被禁用，除非被系统重置。</p></li><li><p>RCC CSR寄存器中的 WWDGRST标志可以用来提示WWDG复位发生。</p></li><li><p>WWDG计数器输入时钟是由APB时钟通过可编程的预分频器分频而来。</p></li><li><p>WWDG clock (Hz) = PCLK1 / (4096 * Prescaler)</p></li><li><p>WWDG timeout (mS) = 1000 * (T[5:0] + 1) / WWDG clock (Hz)</p><p>​ 其中T[5:0] 是计数器低6位。</p></li><li><p>WWDG 计数器刷新时间区间：</p><p>最小时间 (mS) = 1000 * (Counter - Window) / WWDG clock</p><p>最大时间 (mS) = 1000 * (Counter - 0x40) / WWDG clock</p></li><li><p>典型值：</p><ul><li>max timeout：约910us （计数器最小值：T[5:0]=0x00, PCLK1=36MHz, prescaler=0）</li><li>max timeout: 约58.25ms （计数器最大值：T[5:0]=0x3F, PCLK1=36MHz, prescaler=8）</li></ul></li></ul><h3 id="wwdg外设库的使用">WWDG外设库的使用</h3><ul><li>使能 WWDG APB1时钟。 __HAL_RCC_WWDG_CLK_ENABLE()</li><li>通过初始化函数HAL_WWDG_Init() ，配置WWDG预分频系数，刷新的窗口值，计数器值和早期中断状态。它会自动使能WWDG和开启向下计数器，初始化函数退出时，获取参考时间，必须注意提供一个大于0x40的计数器值，以防止产生复位。</li><li>如果使能了早期唤醒中断（EWI）功能，当计数器达到0x40时就会产生中断。在中断服务程序中，会触发 HAL_WWDG_IRQHandler()函数，中断标志被自动清除，执行HAL_WWDG_WakeupCallback()回调函数，用户自行添加代码。</li><li>在正常操作中，为防止MCU复位，可通过 HAL_WWDG_Refresh() 函数来定期刷新WWDG计数器。只有当计数器低于已设置的刷新窗口值时，才必须执行此操作。</li></ul><h3 id="wwdg-回调函数注册">WWDG 回调函数注册</h3><p>当 USE_HAL_WWDG_REGISTER_CALLBACKS 为1时，用户可以注册或注销回调函数。HAL_WWDG_RegisterCallback()，HAL_WWDG_UnRegisterCallback()</p><p>回调函数：</p><ul><li>EwiCallback : 早期唤醒中断回调</li><li>MspInitCallback : WWDG 相关MCU初始化回调</li></ul><h3 id="wwdg-hal常用宏定义">WWDG HAL常用宏定义</h3><ul><li>__HAL_WWDG_ENABLE: 使能 WWDG 外设</li><li>__HAL_WWDG_GET_FLAG: 获取 WWDG的标志状态</li><li>__HAL_WWDG_CLEAR_FLAG: 清除 WWDG挂起标志</li><li>__HAL_WWDG_ENABLE_IT: 使能WWDG早期唤醒中断</li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wwdg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_usart库的使用</title>
    <link href="/2023/08/05/stm32f1xx-hal-usart%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/05/stm32f1xx-hal-usart%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看串口同步HAL库关于 USART使用方法。</p><h3 id="usart外设库的使用">USART外设库的使用</h3><ol type="1"><li>声明一个 USART_HandleTypeDef结构体句柄。如： USART_HandleTypeDef husart。</li><li>初始化USART底层配置。HAL_USART_MspInit()<ul><li>使能串口 USARTx 时钟。</li><li>串口USARTx引脚的配置。<ul><li>使能USART GPIO时钟。</li><li>配置 USART TX、RX引脚为复用功能，上拉。</li></ul></li><li>如果需要使用中断，则配置NVIC。HAL_USART_Transmit_IT() ，HAL_USART_Receive_IT()<ul><li>配置串口 USARTx 中断优先级</li><li>使能NVIC USART IRQ中断。</li></ul></li><li>如果需要使用DMA，则配置DMA。HAL_USART_Transmit_DMA()，HAL_USART_Receive_DMA()<ul><li>为串口Tx和Rx通道声明一个DMA结构体句柄。</li><li>使能DMAx接口时钟。</li><li>配置刚声明的DMA结构体中所需要的Tx/Rx参数。</li><li>配置DMA Tx/Rx 通道。</li><li>将DMA句柄和串口Tx/Rx句柄进行关联。</li><li>当DMA Tx/Rx通道数据传输完成产生中断时，则配置NVIC的优先级并使能。</li><li>配置USART中断优先级并使能NVIC USART IRQ中断。（用于DMA非循环模式下的最后一个字节发送完成的检测）</li></ul></li></ul></li><li>在串口husart 初始化结构体中配置串口的波特率、字节长度，停止位，奇偶校验位，硬件流控和模式（接收/发送）。</li><li>初始化串口寄存器。HAL_USART_Init()</li></ol><p>指定的串口中断(传输完成中断，接收非空中断和错误中断）可使用宏定义控制。__HAL_USART_ENABLE_IT() , __HAL_USART_DISABLE_IT()</p><p>HAL_UART_Init()底层硬件初始化都会调用 HAL_USART_MspInit()。</p><h3 id="usart的操作模式">USART的操作模式</h3><ul><li>轮询模式IO的操作<ul><li>以阻塞模式发送一定数量的数据。HAL_USART_Transmit()</li><li>以阻塞模式接收一定数量的数据。HAL_USART_Receive()</li></ul></li><li>中断模式IO的操作<ul><li>非阻塞模式发送一定数量的数据。HAL_USART_Transmit_IT()</li><li>传输完成，执行HAL_USART_TxCpltCallback() 回调函数，用户自行添加代码。</li><li>非阻塞模式接收一定数量的数据。HAL_USART_Receive_IT()</li><li>接收完成，执行HAL_USART_RxCpltCallback() 回调函数，用户自行添加代码。</li><li>当传输出错时，执行HAL_USART_ErrorCallback() 回调函数，用户自行添加代码。</li></ul></li><li>DMA模式IO的操作<ul><li>非阻塞DMA模式发送一定数量的数据。HAL_USART_Transmit_DMA()</li><li>传输过半，执行 HAL_USART_TxHalfCpltCallback() 回调函数，用户自行添加代码。</li><li>传输完成，执行 HAL_USART_TxCpltCallback () 回调函数，用户自行添加代码。</li><li>非阻塞DMA模式接收一定数量的数据。HAL_USART_Receive_DMA()</li><li>接收过半，执行HAL_USART_RxHalfCpltCallback() 回调函数，用户自行添加代码。</li><li>接收完成，执行HAL_USART_RxCpltCallback() 回调函数，用户自行添加代码。</li><li>当传输出错时，执行HAL_USART_ErrorCallback() 回调函数，用户自行添加代码。</li><li>DMA传输暂停。 HAL_USART_DMAPause()</li><li>重新开始串口DMA传输。HAL_USART_DMAResume()</li><li>停止串口DMA传输。HAL_USART_DMAStop()</li></ul></li></ul><h3 id="usart-hal常用宏定义列表">USART HAL常用宏定义列表</h3><ul><li>__HAL_USART_ENABLE: 使能串口</li><li>__HAL_USART_DISABLE: 关闭串口</li><li>__HAL_USART_GET_FLAG : 获取串口标志是否设置</li><li>__HAL_USART_CLEAR_FLAG : 清除串口挂起标志</li><li>__HAL_USART_ENABLE_IT: 使能串口中断</li><li>__HAL_USART_DISABLE_IT: 关闭串口中断</li></ul><h3 id="回调函数的注册">回调函数的注册</h3><p>USE_HAL_USART_REGISTER_CALLBACKS 设置为1，用户就可以使用回调函数了。回调函数的注册和注销函数分别是：HAL_USART_RegisterCallback()、HAL_USART_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxHalfCpltCallback : 发送过半回调函数</p></li><li><p>TxCpltCallback : 发送完成回调函数</p></li><li><p>RxHalfCpltCallback : 接收过半回调函数</p></li><li><p>RxCpltCallback : 接收完成回调函数</p></li><li><p>ErrorCallback : 发生错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>AbortTransmitCpltCallback : 中止发生完成回调函数</p></li><li><p>AbortReceiveCpltCallback : 中止接收完成回调函数</p></li><li><p>MspInitCallback : USART相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : USART相关MCU去初始化回调函数</p></li></ul><p>默认情况下，串口初始化之后，当串口状态是 <strong>HAL_USART_STATE_RESET</strong> ，所有的回调函数被设置为相应的弱函数。如：HAL_USART_TxCpltCallback(), HAL_USART_RxHalfCpltCallback()。</p><p>只有在串口状态HAL_USART_STATE_READY 时，回调函数才能注册或注销。</p><p>当USE_HAL_USART_REGISTER_CALLBACKS设置为0，注册的回调函数特性就不能使用，回调函数就当作一个弱函数使用。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>usart</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_uart库的使用</title>
    <link href="/2023/08/05/stm32f1xx-hal-uart%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/05/stm32f1xx-hal-uart%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看 UART HAL库关于 UART使用方法。</p><h3 id="uart外设库的使用">UART外设库的使用</h3><ol type="1"><li>声明一个 UART_HandleTypeDef 结构体句柄。如： UART_HandleTypeDef huart。</li><li>初始化UART底层配置。HAL_UART_MspInit()<ul><li>使能串口 USARTx 时钟。</li><li>串口USARTx引脚的配置。<ul><li>使能UART GPIO时钟。</li><li>配置 UART TX、RX引脚为复用功能，上拉。</li></ul></li><li>如果需要使用中断，则配置NVIC。HAL_UART_Transmit_IT() ，HAL_UART_Receive_IT()<ul><li>配置串口 USARTx 中断优先级</li><li>使能NVIC USART IRQ中断。</li></ul></li><li>如果需要使用DMA，则配置DMA。HAL_UART_Transmit_DMA()，HAL_UART_Receive_DMA()<ul><li>为串口Tx和Rx通道声明一个DMA结构体句柄。</li><li>使能DMAx接口时钟。</li><li>配置刚声明的DMA结构体中所需要的Tx/Rx参数。</li><li>配置DMA Tx/Rx 通道。</li><li>将DMA句柄和串口Tx/Rx句柄进行关联。</li><li>当DMA Tx/Rx通道数据传输完成产生中断时，则配置NVIC的优先级并使能。</li><li>配置USART中断优先级并使能NVIC USART IRQ中断。（用于DMA非循环模式下的最后一个字节发送完成的检测）</li></ul></li></ul></li><li>在串口huart 初始化结构体中配置串口的波特率、字节长度，停止位，奇偶校验位，硬件流控和模式（接收/发送）。</li><li>对于串口异步模式，初始化串口寄存器。HAL_UART_Init()</li><li>对于串口半双工模式，初始化串口寄存器。HAL_HalfDuplex_Init()</li><li>对于串口LIN模式，初始化串口寄存器。HAL_LIN_Init()</li><li>对于多处理器模式，初始化串口寄存器。HAL_MultiProcessor_Init()</li></ol><p>指定的串口中断(传输完成中断，接收非空中断和错误中断）可使用宏定义控制。__HAL_UART_ENABLE_IT() , __HAL_UART_DISABLE_IT()</p><p>HAL_UART_Init()和HAL_HalfDuplex_Init()等底层硬件初始化都会调用 HAL_UART_MspInit()。</p><h3 id="回调函数的注册">回调函数的注册</h3><p>USE_HAL_UART_REGISTER_CALLBACKS 设置为1，用户就可以使用回调函数了。回调函数的注册和注销函数分别是：HAL_UART_RegisterCallback()、HAL_UART_UnRegisterCallback()</p><p>回调函数：</p><ul><li><p>TxHalfCpltCallback : 发送过半回调函数</p></li><li><p>TxCpltCallback : 发送完成回调函数</p></li><li><p>RxHalfCpltCallback : 接收过半回调函数</p></li><li><p>RxCpltCallback : 接收完成回调函数</p></li><li><p>ErrorCallback : 发生错误回调函数</p></li><li><p>AbortCpltCallback : 中止完成回调函数</p></li><li><p>AbortTransmitCpltCallback : 中止发生完成回调函数</p></li><li><p>AbortReceiveCpltCallback : 中止接收完成回调函数</p></li><li><p>MspInitCallback : UART相关MCU初始化回调函数</p></li><li><p>MspDeInitCallback : UART相关MCU去初始化回调函数</p></li></ul><p>对于指定的接收事件回调，使用回调函数：HAL_UART_RegisterRxEventCallback() , HAL_UART_UnRegisterRxEventCallback()</p><p>默认情况下，串口初始化之后，当串口状态是 <strong>HAL_UART_STATE_RESET</strong> ，所有的回调函数被设置为相应的弱函数。如：HAL_UART_TxCpltCallback(), HAL_UART_RxHalfCpltCallback()。</p><p>只有在串口状态HAL_UART_STATE_READY 时，回调函数才能注册或注销。</p><p>当USE_HAL_UART_REGISTER_CALLBACKS设置为0，注册的回调函数特性就不能使用，回调函数就当作一个弱函数使用。</p><h3 id="uart的操作模式">UART的操作模式</h3><ul><li>轮询模式IO的操作<ul><li>以阻塞模式发送一定数量的数据。HAL_UART_Transmit()</li><li>以阻塞模式接收一定数量的数据。HAL_UART_Receive()</li></ul></li><li>中断模式IO的操作<ul><li>非阻塞模式发送一定数量的数据。HAL_UART_Transmit_IT()</li><li>传输完成，执行HAL_UART_TxCpltCallback() 回调函数，用户自行添加代码。</li><li>非阻塞模式接收一定数量的数据。HAL_UART_Receive_IT()</li><li>接收完成，执行HAL_UART_RxCpltCallback() 回调函数，用户自行添加代码。</li><li>当传输出错时，执行HAL_UART_ErrorCallback() 回调函数，用户自行添加代码。</li></ul></li><li>DMA模式IO的操作<ul><li>非阻塞DMA模式发送一定数量的数据。HAL_UART_Transmit_DMA()</li><li>传输过半，执行 HAL_UART_TxHalfCpltCallback() 回调函数，用户自行添加代码。</li><li>传输完成，执行 HAL_UART_TxCpltCallback () 回调函数，用户自行添加代码。</li><li>非阻塞DMA模式接收一定数量的数据。HAL_UART_Receive_DMA()</li><li>接收过半，执行HAL_UART_RxHalfCpltCallback() 回调函数，用户自行添加代码。</li><li>接收完成，执行HAL_UART_RxCpltCallback() 回调函数，用户自行添加代码。</li><li>当传输出错时，执行HAL_UART_ErrorCallback() 回调函数，用户自行添加代码。</li><li>DMA传输暂停。 HAL_UART_DMAPause()</li><li>重新开始串口DMA传输。HAL_UART_DMAResume()</li><li>停止串口DMA传输。HAL_UART_DMAStop()</li></ul></li></ul><h3 id="uart-hal常用宏定义列表">UART HAL常用宏定义列表</h3><ul><li>__HAL_UART_ENABLE: 使能串口</li><li>__HAL_UART_DISABLE: 关闭串口</li><li>__HAL_UART_GET_FLAG : 获取串口标志是否设置</li><li>__HAL_UART_CLEAR_FLAG : 清除串口挂起标志</li><li>__HAL_UART_ENABLE_IT: 使能串口中断</li><li>__HAL_UART_DISABLE_IT: 关闭串口中断</li><li>__HAL_UART_GET_IT_SOURCE: 检查串口中断是否发生</li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uart</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_dma库的使用</title>
    <link href="/2023/08/05/stm32f1xx-hal-dma%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/05/stm32f1xx-hal-dma%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看 DMA HAL库关于 DMA 使用方法。</p><h3 id="dma-外设库的使用">DMA 外设库的使用</h3><ul><li>使能和配置外设连接到 DMA通道。 (除了内部 SRAM / FLASH 内存: 不用初始化。) <strong>注意</strong>： 在内存到内存的传输模式中，不允许循环模式 。请阅读参考手册关于外设和DMA请求的内容。<ol type="1"><li>对于给定的通道，配置以下参数 HAL_DMA_Init()：<ul><li>通道请求 Channel request</li><li>传输方向 Transfer Direction</li><li>源数据和目标数据的格式 Source and Destination data formats</li><li>循环或正常模式 Circular or Normal mode</li><li>通道优先级水平 Channel Priority level</li><li>源数据和目标数据增量模式 Source and Destination Increment mode</li></ul></li><li>获取DMA状态，如果出错，获取错误信息。HAL_DMA_GetState()和HAL_DMA_GetError()</li><li>中止当前传输。HAL_DMA_Abort()</li></ol></li><li>轮询模式下IO的操作<ul><li>配置完源地址和目标地址以及数据长度后，开启DMA数据传输。HAL_DMA_Start()</li><li>传输完当前数据，用户可以在程序中添加超时时间。HAL_DMA_PollForTransfer()</li></ul></li><li>中断模式下IO的操作<ul><li>配置DMA中断优先级。HAL_NVIC_SetPriority()</li><li>使能DMA IRQ中断。HAL_NVIC_EnableIRQ()</li><li>配置完源地址和目标地址以及数据长度后，开启DMA中断模式下的数据传输。 HAL_DMA_Start_IT()</li><li>调用DMA中断函数。HAL_DMA_IRQHandler() ，DMA_IRQHandler()</li><li>数据传输完成，执行回调函数。HAL_DMA_IRQHandler() ，XferCpltCallback ，XferErrorCallback ...</li></ul></li><li>DMA HAL库常用宏定义列表<ul><li>__HAL_DMA_ENABLE: 使能指定的 DMA 通道。</li><li>__HAL_DMA_DISABLE: 关闭指定的 DMA 通道。</li><li>__HAL_DMA_GET_FLAG: 获取DMA通道挂起标志。</li><li>__HAL_DMA_CLEAR_FLAG: 清除DMA通道挂起标志。</li><li>__HAL_DMA_ENABLE_IT: 使能指定DMA通道中断。</li><li>__HAL_DMA_DISABLE_IT: 关闭指定DMA通道中断。</li><li>__HAL_DMA_GET_IT_SOURCE: 检查指定的DMA通道中断是否发生。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dma</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_exti库的使用</title>
    <link href="/2023/08/04/stm32f1xx-hal-exti%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/04/stm32f1xx-hal-exti%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看EXTI HAL库关于外部中断、事件的特性及使用方法。</p><h3 id="exti外设特性">EXTI外设特性</h3><ul><li>每个EXTI连接线都可以进行配置三种不同的模式：<ul><li>中断</li><li>事件</li><li>中断事件</li></ul></li><li>可配置的EXTI连接线可被配置三种不同的触发方式<ul><li>上升沿触发</li><li>下降沿触发</li><li>上升下降沿触发</li></ul></li><li>当设置为中断模式时，EXTI连接线有两个不同的中断挂起寄存器，用来区别发生了那种中断：<ul><li>上升沿挂起中断</li><li>下降沿挂起中断</li></ul></li><li>EXTI0 ~ EXTI15 连接线连接到GPIO0 ~ GPIO15引脚，GPIO端口可通过多路选择器进行选择。</li></ul><h3 id="exti外设库的使用">EXTI外设库的使用</h3><ul><li>配置EXTI连接线。HAL_EXTI_SetConfigLine()<ol type="1"><li>选择中断线。 EXTI_ConfigTypeDef 结构体中的 Line。</li><li>配置中断、事件模式。EXTI_ConfigTypeDef 结构体中的Mode。</li><li>对于可配置的连接线，配置触发方式。EXTI_ConfigTypeDef 结构体中的Trigger。</li><li>对于EXTI连接线连接到GPIO，选择GPIO端口。GPIO_InitTypeDef 结构体中GPIOSel。</li></ol></li><li>获取当前EXTI配置线。 HAL_EXTI_GetConfigLine()<ol type="1"><li>提供已存在的句柄（handle），作为第一参数。</li><li>提供EXTI_ConfigTypeDef 结构体指针作为第二参数。</li></ol></li><li>清除EXTI线的配置项。HAL_EXTI_ClearConfigLine()<ul><li>提供已存在的句柄（handle），作为参数。</li></ul></li><li>注册回调函数。HAL_EXTI_RegisterCallback()<ol type="1"><li>提供已存在的句柄（handle），作为第一参数。</li><li>提供哪一类回调函数。 EXTI_CallbackIDTypeDef</li><li>提供回调函数指针。</li></ol></li><li>获取中断挂起位。HAL_EXTI_GetPending()</li><li>清除中断挂起位。HAL_EXTI_ClearPending()</li><li>产生软中断。HAL_EXTI_GenerateSWI()</li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>exti</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_dac库的使用</title>
    <link href="/2023/08/04/stm32f1xx-hal-dac%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/04/stm32f1xx-hal-dac%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下面来看看DAC HAL库关于DAC外设的特性及使用方法。</p><h3 id="dac外设特性">DAC外设特性</h3><p><strong>1. DAC 的通道</strong></p><p>STM32F1 集成有两个12-bit 数字模拟转换器，这两个转换器可以独立使用，也可以同时使用（双模式）。</p><ul><li><p>DAC通道1以DAC_OUT1 (PA4)作为输出或连接到片上外设(例如定时器)。</p></li><li><p>DAC通道2以DAC_OUT2 (PA5)作为输出或连接到片上外设(例如定时器)。</p></li></ul><p><strong>2. DAC 的触发</strong></p><ul><li><p>使用 <strong>DAC_TRIGGER_NONE</strong> 可以不触发DAC转换，一旦写入DHRx寄存器，DAC_OUT1/DAC_OUT2可用。</p></li><li><p>DAC转换触发方式：</p><ul><li><p>外部事件: <strong>DAC_TRIGGER_EXT_IT9</strong>。GPIOx_PIN_9需要配置为输入模式。</p></li><li><p>定时器触发输出: TIM2, TIM4, TIM6, TIM7</p><p>STM32F10x 互联型和 STM32F100x : TIM3</p><p>STM32F10x 高容量和 超大容量: TIM8</p><p>STM32F100x 高容量: TIM15 替换 TIM5</p><p>(DAC_TRIGGER_T2_TRGO, DAC_TRIGGER_T4_TRGO...)</p></li></ul></li><li><p>软触发：<strong>DAC_TRIGGER_SOFTWARE</strong></p></li></ul><p><strong>3. DAC 缓冲模式特性</strong></p><ul><li>一个DAC通道有一个输出缓冲器，它能减少输出阻抗，可以直接驱动外部负载，而不用添加外部运算放大器。使能输出缓冲器：</li></ul><p>sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;</p><ul><li>DAC输出阻抗值的详细信息请参考数据手册。</li></ul><p><strong>4. GPIO 配置指南</strong></p><p>当一个DAC通道（如通道1：PA4）被使用，而另一个通道没有使用（如通道2：PA5配置为模拟模式，禁用）。通道1可能会以耦合方式干扰通道2，只要通道2一打开，就没有耦合效应。相邻通道耦合效应可以通过以下方式避免：</p><ul><li>当PA5不使用时，将其配置为输入上拉或下拉。</li><li>当PA5打开之前，将其配置为模拟模式。</li></ul><p><strong>5. DAC 发生波形特性</strong></p><p>两个DAC通道可用来产生干扰波和三角波。对于双模式和特定信号的产生，请参考 <code>stm32f1xx_hal_dac_ex.c</code> 。</p><p><strong>6. DAC数据格式</strong></p><ul><li>8-bit 右对齐 DAC_ALIGN_8B_R</li><li>12-bit 左对齐 DAC_ALIGN_12B_L</li><li>12-bit 右对齐 DAC_ALIGN_12B_R</li></ul><p><strong>7. DAC值转换为相应电压值</strong></p><p>每个DAC通道引脚的电压值转换公式：</p><p><strong>DAC_OUTx = VREF+ * DOR / 4096</strong></p><p>其中，DOR是数据输出寄存器值，VREF+是输入参考电压（参考数据手册）。</p><p>例如：假设 VREF+ = 3.3V, 要设置DAC_OUT1 为0.7V, 则 DAC_OUT1 = (3.3 * 868) / 4095 = 0.7V</p><p><strong>8. DMA请求</strong></p><p>如果 DMA1 请求使能（HAL_DAC_Start_DMA()），当外部触发产生时（非软件触发），就会产生DMA请求。DMA1请求的映射如下：</p><ul><li>STM32F100x 低容量，中容量，高容量 ，拥有DAC DMA重映射，DAC 通道1映射到DMA1的通道3。</li><li>STM32F100x 高容量没有DAC DMA重映射和其它 STM32F1 ，DAC 通道2映射到DMA2的通道3。</li></ul><h3 id="dac库的使用">DAC库的使用</h3><ul><li>使能DAC时钟。 HAL_DAC_Init()</li><li>配置DAC_OUTx (DAC_OUT1: PA4, DAC_OUT2: PA5) 为模拟模式</li><li>配置DAC通道。HAL_DAC_ConfigChannel()</li><li>使能DAC通道。HAL_DAC_Start() 或 HAL_DAC_Start_DMA()</li></ul><p><strong>1. 轮询模式IO的操作</strong></p><ul><li>开启DAC外设。HAL_DAC_Start()</li><li>读取DAC上一次输出值。HAL_DAC_GetValue()</li><li>停止DAC外设。HAL_DAC_Stop()</li></ul><p><strong>2. DMA模式IO的操作</strong></p><ul><li><p>开启DAC外设。HAL_DAC_Start_DMA()</p><p>这个阶段用户指定在每个转换后传输的数据长度，第一个触发会开始转换之前使用函数（HAL_DAC_SetValue()）设置的值。</p></li><li><p>数据传输过半时，会执行 HAL_DAC_ConvHalfCpltCallbackCh1() 或 HAL_DACEx_ConvHalfCpltCallbackCh2()函数，用户可以在其中添加代码。</p></li><li><p>数据传输完成时，会执行 HAL_DAC_ConvCpltCallbackCh1() 或 HAL_DACEx_ConvHalfCpltCallbackCh2()函数，用户可以在其中添加代码。</p></li><li><p>当传输出错时，会执行 HAL_DAC_ErrorCallbackCh1() 函数，用户可以在其中添加代码。</p></li><li><p>对于STM32F100x 特定特性: DMA自检（DMA underrun）</p></li></ul><p>当DMA 自检时，会执行 HAL_DAC_DMAUnderrunCallbackCh1() 或 HAL_DACEx_DMAUnderrunCallbackCh2()函数，用户可以在其中添加代码。并在HAL_DAC_ErrorCallbackCh1()函数中添加自己的代码。</p><ul><li>停止DAC外设。HAL_DAC_Stop_DMA()</li></ul><p><strong>3. 注册回调函数</strong></p><p>当 USE_HAL_DAC_REGISTER_CALLBACKS 设置为1时，则允许用户配置回调函数。HAL_DAC_RegisterCallback()</p><p>使用 HAL_DAC_UnRegisterCallback()函数可以注销回调函数。</p><p>DAC回调函数ID：</p><ul><li><p>ConvCpltCallbackCh1 : DAC通道1数据传输完成回调</p></li><li><p>ConvHalfCpltCallbackCh1 : DAC通道1数据传输过半回调</p></li><li><p>ErrorCallbackCh1 : DAC通道1数据传输错误回调</p></li><li><p>DMAUnderrunCallbackCh1 : 通道1自检错误回调</p></li><li><p>ConvCpltCallbackCh2 : DAC通道2数据传输完成回调</p></li><li><p>ConvHalfCpltCallbackCh2 : DAC通道2数据传输过半回调</p></li><li><p>ErrorCallbackCh2 : DAC通道2数据传输错误回调</p></li><li><p>DMAUnderrunCallbackCh2 : 通道2自检错误回调</p></li><li><p>MspInitCallback : DAC 相关MCU初始化回调</p></li><li><p>MspDeInitCallback : DAC 相关MCU去初始化回调</p></li></ul><p><strong>4. DAC HAL驱动常用宏定义列表</strong></p><ul><li><p>__HAL_DAC_ENABLE : 使能DAC外设 (For STM32F100x devices with specific feature: DMA underrun)</p></li><li><p>__HAL_DAC_DISABLE : 禁止DAC外设 (For STM32F100x devices with specific feature: DMA underrun)</p></li><li><p>__HAL_DAC_CLEAR_FLAG: 清除DAC挂起标志 (For STM32F100x devices with specific feature: DMA underrun)</p></li><li><p>__HAL_DAC_GET_FLAG: 获取DAC标志状态 (For STM32F100x devices with specific feature: DMA underrun)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_cortex库的使用</title>
    <link href="/2023/08/03/stm32f1xx-hal-cortex%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/03/stm32f1xx-hal-cortex%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在HAL库中，关于内核控制外设，初始化和析构的相关配置在 <code>stm32f1xx_hal_cortex.c</code> 文件中，下面来具体看看它怎么使用。</p><h3 id="配置nvic-interrupts-irq中断">配置NVIC interrupts (IRQ)中断</h3><ol type="1"><li><p>配置NVIC优先级分组。HAL_NVIC_SetPriorityGrouping()</p><ul><li><p>当选择 <strong>NVIC_PRIORITYGROUP_0</strong> 时，则无抢占优先级，中断优先级只由子优先级管理</p></li><li><p>中断最高到最低优先级顺序：</p><p>最低抢占优先级 -&gt; 最低子优先级 -&gt; 最低硬件优先级（IRQ数字越小，优先级越高）</p></li></ul></li><li><p>配置所选中断的优先级。HAL_NVIC_SetPriority()</p></li><li><p>使能所选中断。HAL_NVIC_EnableIRQ()</p></li><li><p>具体参考编程手册（programming manual）。</p></li></ol><h3 id="配置systick-timer">配置SysTick Timer</h3><ol type="1"><li><p>HAL_SYSTICK_Config() 函数调用 SysTick_Config() 函数：</p><ul><li><p>配置 SysTick Reload 寄存器</p></li><li><p>配置 SysTick IRQ 优先级为最低（0x0F）。</p></li><li><p>复位 SysTick Counter 寄存器。</p></li><li><p>配置 SysTick Counter 时钟源为核心时钟源(HCLK)。</p></li><li><p>使能 SysTick 中断。</p></li><li><p>开启 SysTick Counter。</p></li></ul></li><li><p>调用HAL_SYSTICK_Config()函数后，可以改变 SysTick时钟源到 HCLK_Div8。 __HAL_CORTEX_SYSTICKCLK_CONFIG(SYSTICK_CLKSOURCE_HCLK_DIV8)</p></li><li><p>调用HAL_SYSTICK_Config()函数后，可以改变 SysTick中断优先级。HAL_NVIC_SetPriority(SysTick_IRQn,...)</p></li><li><p>调整SysTick时基的公式：</p></li></ol><p>​ Reload Value = SysTick Counter 时钟(Hz) x Desired Time base (s)</p><p>​ 其中，Reload Value 是HAL_SYSTICK_Config()函数中传递的参数，它的值不能超过 <strong>0xFFFFFF</strong> 。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cortex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_adc库的使用</title>
    <link href="/2023/08/03/stm32f1xx-hal-adc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/03/stm32f1xx-hal-adc%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>同GPIO库一样，ST官方给出了ADC外设库的使用方法，下面具体看看ADC外设库中的步骤：</p><h3 id="配置adc顶层参数">1. 配置ADC顶层参数</h3><ul><li><strong>使能ADC接口</strong><ul><li>建议在 HAL_ADC_MspInit() 函数中配置ADC时钟 （<strong>STM32F1 ADC时钟频率最大14MHz</strong>）如：<ul><li>RCC_PeriphCLKInitTypeDef PeriphClkInit;</li><li>__ADC1_CLK_ENABLE();</li><li>PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;</li><li>PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2;</li><li>HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInit);</li></ul></li></ul></li><li><strong>配置ADC管脚</strong><ul><li>使能ADC GPIOs。__HAL_RCC_GPIOx_CLK_ENABLE()</li><li>在GPIO初始化函数中配置ADC管脚为 <strong>analog mode</strong>。 HAL_GPIO_Init()</li></ul></li><li><strong>当使用ADC中断时：</strong><ul><li>配置ADC的NVIC：HAL_NVIC_EnableIRQ(ADCx_IRQn)</li><li>将ADC中断处理函数HAL_ADC_IRQHandler()插入到相应ADC中断向量ADCx_IRQHandler()的函数中。</li></ul></li><li><strong>当使用ADC DMA时：</strong><ul><li>配置DMA (如：DMA 通道, 正常模式或循环模式等)。HAL_DMA_Init()</li><li>配置DMA的NVIC。HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)</li><li>将ADC中断处理函数HAL_ADC_IRQHandler()插入到相应的DMA中断向量DMAx_Channelx_IRQHandler()的函数中。</li></ul></li></ul><h3 id="配置adc常规组或注入组groups-regularinjected通道等参数">2. 配置ADC常规组或注入组(groups regular/injected)，通道等参数</h3><ul><li>配置ADC参数 (分辨率, 数据对齐方式等) 和 常规组或注入组参数 (转换触发, 序列等)。HAL_ADC_Init()</li><li>配置常规组通道参数(通道号, 通道排列顺序等) 。HAL_ADC_ConfigChannel()</li><li>当使用注入组时，配置注入组各参数。 HAL_ADCEx_InjectedConfigChannel()</li><li>当使用模拟看门狗时，配置其参数(监控的通道, 阈值等)。 HAL_ADC_AnalogWDGConfig()</li><li>当使用多个ADC时，配置多模式参数。HAL_ADCEx_MultiModeConfigChannel()</li></ul><h3 id="执行adc转换">3. 执行ADC转换</h3><ul><li>当需要提高转换精度时，执行ADC自动校准函数：HAL_ADCEx_Calibration_Start()。</li><li>ADC可在三种模式下转换: <strong>轮询（polling）,中断（interruption）和 DMA</strong><ul><li><strong>轮询转换</strong><ul><li>激活ADC外设，开启转换。HAL_ADC_Start()</li><li>等待转换完成。HAL_ADC_PollForConversion() 或 HAL_ADCEx_InjectedPollForConversion()(注入组)</li><li>得到转换结果。HAL_ADC_GetValue() 或 HAL_ADCEx_InjectedGetValue()(注入组)</li><li>停止转换并关闭ADC外设。HAL_ADC_Stop()</li></ul></li><li><strong>中断转换</strong><ul><li>激活ADC外设，开启转换。HAL_ADC_Start_IT()</li><li>等待转换完成并进入回调函数。HAL_ADC_ConvCpltCallback() 或 HAL_ADCEx_InjectedConvCpltCallback()(注入组)</li><li>得到转换结果。HAL_ADC_GetValue() 或 HAL_ADCEx_InjectedGetValue()(注入组)</li><li>停止转换并关闭ADC外设。HAL_ADC_Stop_IT()</li></ul></li><li><strong>DMA转换</strong><ul><li>激活ADC外设，开启转换。 HAL_ADC_Start_DMA()</li><li>等待转换完成并进入回调函数。HAL_ADC_ConvCpltCallback() 或HAL_ADC_ConvHalfCpltCallback()。</li><li>转换结果由DMA自动转换到目标地址。</li><li>停止转换并关闭ADC外设。HAL_ADC_Stop_DMA()</li></ul></li><li><strong>对于多个ADC设备多方式转换</strong><ul><li>激活ADC外设从设备，开启转换。HAL_ADC_Start()</li><li>激活ADC外设主设备，开启转换。HAL_ADCEx_MultiModeStart_DMA()</li><li>等待转换完成并进入回调函数。HAL_ADC_ConvCpltCallback() 或HAL_ADC_ConvHalfCpltCallback()</li><li>转换结果由DMA自动转换到目标地址。</li><li>停止转换并关闭ADC外设主设备。HAL_ADCEx_MultiModeStop_DMA()</li><li>停止转换并关闭ADC外设从设备。HAL_ADC_Stop_IT()</li></ul></li></ul></li><li>回调函数必须在用户程序中实现<ul><li>HAL_ADC_ErrorCallback()</li><li>HAL_ADC_LevelOutOfWindowCallback() (callback of analog watchdog)</li><li>HAL_ADC_ConvCpltCallback()</li><li>HAL_ADC_ConvHalfCpltCallback()</li><li>HAL_ADCEx_InjectedConvCpltCallback()</li></ul></li></ul><h3 id="adc的去初始化deinitialization">4. ADC的去初始化(Deinitialization)</h3><ul><li>关闭ADC外设接口<ul><li>ADC外设的硬复位。 __ADCx_FORCE_RESET(), __ADCx_RELEASE_RESET()</li><li>关闭ADC时钟。如：<ul><li>PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC</li><li>PeriphClkInit.AdcClockSelection = RCC_ADCPLLCLK2_OFF</li><li>HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInit)</li></ul></li></ul></li><li>关闭ADC GPIO管脚时钟 __HAL_RCC_GPIOx_CLK_DISABLE()</li><li>当使用ADC的中断时，则关闭ADC的NVIC。HAL_NVIC_EnableIRQ(ADCx_IRQn)</li><li>当使用ADC的DMA时<ul><li>析构DMA。HAL_DMA_Init()</li><li>关闭DMA的NVIC。HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)</li></ul></li></ul><h3 id="回调函数的注册">5. 回调函数的注册</h3><p>当 <strong>USE_HAL_ADC_REGISTER_CALLBACKS</strong> 设置为1时，允许用户配置回调函数HAL_ADC_RegisterCallback()</p><p>回调函数：</p><ul><li>ConvCpltCallback : ADC转换完成的回调</li><li>ConvHalfCpltCallback : ADC转换DMA传输过半的回调</li><li>LevelOutOfWindowCallback : ADC模拟看门狗1的回调</li><li>ErrorCallback : ADC错误的回调</li><li>InjectedConvCpltCallback : ADC注入组转换完成的回调</li><li>MspInitCallback : ADC 相关MCU初始化回调</li><li>MspDeInitCallback : ADC 相关MCU去初始化回调</li></ul><p>此函数以HAL外设句柄和回调ID和指向用户回调函数的指针作为参数。</p><p>函数 HAL_ADC_UnRegisterCallback() 用来复位回调函数到默认的弱定义函数。</p><ul><li>ConvCpltCallback : ADC转换完成的回调</li><li>ConvHalfCpltCallback : ADC转换DMA传输过半的回调</li><li>LevelOutOfWindowCallback : ADC模拟看门狗1的回调</li><li>ErrorCallback : ADC错误的回调</li><li>InjectedConvCpltCallback : ADC注入组转换完成的回调</li><li>MspInitCallback : ADC 相关MCU初始化回调</li><li>MspDeInitCallback : ADC 相关MCU去初始化回调</li></ul><p>默认情况下，ADC初始化后(HAL_ADC_Init()) ,当ADC的状态是 <strong>HAL_ADC_STATE_RESET</strong> 时，所有的回调被设置到相应的弱函数。（MspInit 和 MspDeInit除外，它们会被复位到传统弱函数）</p><p>如果MspInit或MspDeInit不为空, 无论ADC在哪种状态，HAL_ADC_Init()和HAL_ADC_DeInit()函数可保持和使用用户MspInit/MspDeInit回调函数(预先注册过)。</p><p>只有ADC状态在 HAL_ADC_STATE_READY时，回调函数才能注册或注销。</p><p>在调用 HAL_ADC_DeInit()或HAL_ADC_Init()之前，用户可以首先注册MspInit/MspDeInit用户回调函数</p><p>当 <strong>USE_HAL_ADC_REGISTER_CALLBACKS</strong> 设置为0或没有定义时，回调注册功能不可用，所有回调都被设置为相应的弱函数。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>adc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32f1xx_hal_gpio库的使用</title>
    <link href="/2023/08/03/stm32f1xx-hal-gpio%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/03/stm32f1xx-hal-gpio%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>怎么使用stm32库文件呢？在 <code>*.c</code>文件中, ST官方已经给出了使用方法，下面具体看看GPIO外设库中的特点和使用步骤：</p><h3 id="gpio外设库的特点">GPIO外设库的特点</h3><ol type="1"><li><p>GPIO外设库可独立配置模式：</p><ul><li><p><strong>输入模式 Input mode</strong></p></li><li><p><strong>模拟模式 Analog mode</strong></p></li><li><p><strong>输出模式 Output mode</strong></p></li><li><p><strong>复用功能模式 Alternate function mode</strong></p></li><li><p><strong>外部中断或事件模式 External interrupt/event lines</strong></p></li></ul></li><li><p>复位期间和之后，复用功能和外部中断线没有被激活，I/O端口被配置为输入浮空模式。</p></li><li><p>所有的GPIO引脚内部都有弱上拉和下拉电阻，可选择激活或不激活。</p></li><li><p>在输出或复用模式，每一个I/O端口可配置为开漏或推挽模式，根据VDD电压值可选择I/O速度。</p></li><li><p>所有的端口都有外部中断和事件的功能，当使用外部中断线时，端口必须配置为输入模式，所有的可用GPIO引脚连接到16个外部中断、事件线（EXTI0 ~ EXTI15）。</p></li><li><p>对于互联型MCU，外部中断、事件控制器包含多达20个边沿检测器，其它类型MCU，也有19个边沿检测器，这些检测器用于产生中断、事件请求。每条输入线都能进行独立配置选择类型（事件或中断），相应的触发条件（上升沿、下降沿、上升下降沿）。每条线也可以独立屏蔽，挂起寄存器来维持中断请求线的状态。</p></li></ol><h3 id="gpio外设库的使用步骤">GPIO外设库的使用步骤</h3><ol type="1"><li><p>使能GPIO APB2时钟。__HAL_RCC_GPIOx_CLK_ENABLE()</p></li><li><p>配置GPIO引脚。HAL_GPIO_Init()</p><ul><li><p>配置IO端口模式。GPIO_InitTypeDef结构体中Mode成员。</p></li><li><p>激活上下拉电阻。GPIO_InitTypeDef结构体中Pull成员。</p></li><li><p>当输出或复用模式时，配置I/O速度。GPIO_InitTypeDef结构体中Speed成员。</p></li><li><p>当引脚用于ADC或DAC时，配置IO端口模式为模拟模式。</p></li><li><p>当外部中断、事件时，配置IO端口模式为中断或事件模式，同时触发条件选择上升沿或下降沿或上升下降沿。</p></li></ul></li><li><p>当外部中断、事件时，配置NVIC IRQ映射到EXTI线的优先级，并使能。HAL_NVIC_SetPriority()，HAL_NVIC_EnableIRQ()</p></li><li><p>获取在输入模式下引脚的电平。HAL_GPIO_ReadPin()</p></li><li><p>设置或复位输出模式下引脚的电平。HAL_GPIO_WritePin()/HAL_GPIO_TogglePin()</p></li><li><p>锁定引脚配置直到下一次复位。HAL_GPIO_LockPin()</p></li><li><p>复位期间和之后，复用功能未激活，GPIO引脚被配置为输入浮空模式（JTAG引脚除外）。</p></li><li><p>当LSE振荡器关闭时，其引脚OSC32_IN/OSC32_OUT(PC14和PC15)可作为IO口使用，LSE的优先级高于GPIO的功能。</p></li><li><p>当HSE振荡器关闭时，其引脚OSC_IN/OSC_OUT(PD0和PD1)可作为IO口使用，HSE的优先级高于GPIO的功能。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gpio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一款浏览器翻译插件</title>
    <link href="/2023/07/26/%E4%B8%80%E6%AC%BE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6/"/>
    <url>/2023/07/26/%E4%B8%80%E6%AC%BE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>平时查看资料，会接触到很多英文文档，偶尔一篇英语短文章，阅读起来不成问题，但一旦碰到了一篇很长的文章且通篇都是一些专业名词，此时就不太想看下去了。日前发现一款免费的浏览器翻译插件（<a href="https://immersivetranslate.com/"><strong>沉浸式翻译</strong></a>），觉得挺实用的。</p><p>官网：https://immersivetranslate.com/</p><p>GitHub：https://github.com/immersive-translate/immersive-translate</p><h2 id="主要特性">主要特性</h2><ul><li><strong>沉浸式阅读外文网站</strong> 通过智能识别网页主内容区域并进行双语对照翻译，沉浸式翻译提供了全新的外文阅读体验，因此得名“沉浸式翻译”。</li><li><strong>强大的输入框翻译</strong>，将任何网页上的输入框化身为多语言翻译器，立刻解锁谷歌搜索，ChatGPT 等工具的双语实时对话体验。</li><li><strong>高效的文件翻译</strong> 一键导出双语电子书，同时支持 PDF、字幕、TXT 等文件的实时双语翻译。</li><li><strong>创新的鼠标悬停翻译</strong> 仅需将鼠标停留在任意网页的任意段落上，相应的译文就会立即出现在段落下方。段落在在沉浸式翻译的设计理念中被视为最小单位，保留其上下文，这样我们才能真正理解并学习外语。</li><li><strong>深度定制优化主流网站</strong> 针对 Google、Twitter、Reddit、YouTube、彭博社、华尔街日报等主流网站进行优化，无论是搜索、社交还是获取资讯，都更加流畅高效。</li><li><strong>全平台支持</strong> 除了各大桌面端浏览器，移动设备也可享受同样的沉浸式翻译体验。在 iOS Safari、安卓 Kiwi 浏览器等移动端浏览器上轻松实现双语浏览 Twitter,Reddit 等社交媒体。</li><li><strong>支持 10+种翻译服务</strong> 在沉浸式翻译中，你可以选择超过 10 种翻译服务，如 Deepl、OpenAI、微软翻译、谷歌翻译、腾讯翻译等等，这份名单还在不断增加中。</li></ul><h2 id="安装">安装</h2><p>目前这款插件只支持以下几款流行的浏览器，可以根据相应的浏览器扩展组件进行安装。</p><ul><li><a href="https://microsoftedge.microsoft.com/addons/detail/amkbmndfnliijdhojkpoglbnaaahippg">微软 Edge 浏览器</a></li><li><a href="https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh">谷歌 Chrome 浏览器</a></li><li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/immersive-translate">Firefox 火狐浏览器</a></li><li><a href="https://apps.apple.com/app/immersive-translate/id6447957425">苹果 Safari浏览器</a></li><li><a href="https://immersivetranslate.com/android/">沉浸式翻译安卓浏览器</a></li><li><a href="https://download.immersivetranslate.com/immersive-translate.user.js">通过油猴脚本安装</a></li></ul><h2 id="使用">使用</h2><p>安装插件后，浏览器右上角点击【沉浸式翻译扩展图标】，点击翻译即可进行翻译：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230726200030832.png" alt="" /><figcaption>image-20230726200030832</figcaption></figure><p>另外在网页上右键也会有相应的网页翻译选项。</p><h2 id="设置">设置</h2><p>在设置页面里我们可以进行一系列的个性化设置，如鼠标悬停翻译、翻译样式、本地PDF翻译、字幕文件翻译等。</p><p>好了，以上就是这款便携浏览器翻译插件的简要介绍，如果你也有翻译的需要，不妨赶紧试试这款插件吧，绝对不会让你失望。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始写C语言链表</title>
    <link href="/2023/07/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99C%E8%AF%AD%E8%A8%80%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/07/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99C%E8%AF%AD%E8%A8%80%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="链表的概念">链表的概念</h2><p><strong>链表（Linked List）</strong>是一种物理存储结构上非连续、非顺序的存储结构，数据元素（<strong>节点</strong>）的逻辑顺序是通过链表中的指针链接次序实现的 。</p><p>相比数组这种在定义即分配一段连续且固定空间大小的数据结构，链表可以根据需要动态分配离散的内存空间，解决了数组插入或删除元素需要移动大量元素的弊端，不过它的缺点就是需要牺牲更大的内存空间。一般链表在操作系统里面应用比较广泛。</p><h2 id="链表的结构">链表的结构</h2><p>链表由一系列 <strong>节点（node）</strong> 组成，每个节点包括两个部分：</p><ul><li>数据元素的 <strong>数据域</strong></li><li>下一个节点的 <strong>指针域</strong></li></ul><p>先来认识一个完整的简单链表，如下图所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720131138188.png" alt="" /><figcaption>image-20230720131138188</figcaption></figure><ul><li><strong>头指针</strong>：一个普通的指针，用于指明链表的位置，永远指向链表第一个节点的位置；</li><li><strong>头节点</strong>：通常头节点不是必须的，它的存在主要是为了方便对首元节点前做插入、删除操作的目的；</li><li><strong>首元节点</strong>：链表中第一个存有数据的节点为首元节点，只是一个称谓而已，没有实际意义；</li></ul><p>头节点和头指针的主要区别：头指针只声明而没有分配存储空间，头节点需要声明并分配一个节点的实际物理内存。</p><h2 id="链表的分类">链表的分类</h2><ul><li><strong>单向链表</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720131246792.png" alt="" /><figcaption>image-20230720131246792</figcaption></figure><ul><li><strong>双向链表</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720214051358.png" alt="" /><figcaption>image-20230720214051358</figcaption></figure><ul><li><strong>环形链表</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720213847180.png" alt="" /><figcaption>image-20230720213847180</figcaption></figure><h2 id="单向链表的操作">单向链表的操作</h2><p>以上直观了解了链表的实现方式，那么怎么来创建和操作一个链表呢？首先看单向链表，我们需要定义它的数据结构，具体实现代码为：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>    <span class="hljs-type">int</span> data;       <span class="hljs-comment">//数据类型，可以把int型的data换成任意数据类型，包括结构体struct等复合类型</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//单链表的指针域</span>&#125;<span class="hljs-type">node_t</span>;</code></pre></div><h4 id="单向链表的创建">单向链表的创建</h4><p>单向链表的数据结构定义好后，就可以着手创建链表了，创建单链表的节点，主要分以下步骤:</p><ul><li>给当前的每个节点的数据结构分配空间大小</li><li>将每个节点数据清零（分配的堆内存空间不一定是干净的）</li><li>给节点初始化数据</li><li>将该节点的指针域设置为NULL</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 创建一个节点的函数 */</span><span class="hljs-type">node_t</span> *<span class="hljs-title function_">linkedlist_create</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span>&#123;<span class="hljs-type">node_t</span> *node = (<span class="hljs-type">node_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<span class="hljs-comment">//1、定义一个头指针，然后分配内存空间</span><span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc error!\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-built_in">memset</span>(node,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<span class="hljs-comment">//2、清一下内存</span>node-&gt;data = data;  <span class="hljs-comment">//3、给链表节点的数据赋值</span>node-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//4、将链表的指针域指向空</span><span class="hljs-keyword">return</span> node;&#125;</code></pre></div><h4 id="遍历单向链表遍历修改查找"><strong>遍历单向链表（遍历，修改，查找）</strong></h4><p>进行遍历，修改，查找的思路极其简单，只需要建立一个指向链表L的节点，然后沿着链表L逐个向后搜索即可。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//打印链表数据</span><span class="hljs-type">void</span> <span class="hljs-title function_">linkedlist_print</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* pH)</span>&#123;  <span class="hljs-type">node_t</span> *temp = pH-&gt;next; <span class="hljs-comment">//临时指针指向第一个节点 </span>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">NULL</span> != temp)<span class="hljs-comment">//如果当前位置节点不为空</span>  &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d个元素的值为:%d\n&quot;</span>, ++i, temp-&gt;data);    temp = temp-&gt;next;  &#125;  &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//链表内容的修改，链表中值为val1的元素变为val2。</span><span class="hljs-type">node_t</span>* <span class="hljs-title function_">linkedlist_modify</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* pH,<span class="hljs-type">int</span> val1,<span class="hljs-type">int</span> val2)</span> &#123;  <span class="hljs-type">node_t</span> *p = pH-&gt;next;  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span>(p)  &#123;    <span class="hljs-keyword">if</span>(p-&gt;data == val1)    &#123;      p-&gt;data = val2;    &#125;    p = p-&gt;next;  &#125;  <span class="hljs-keyword">return</span> pH;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//p为原链表，elem表示被查找元素</span><span class="hljs-type">int</span> <span class="hljs-title function_">linkedlist_find</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* p, <span class="hljs-type">int</span> elem)</span> &#123;    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;        p = p-&gt;next;<span class="hljs-comment">//带头节点，p 指向首元节点</span>    <span class="hljs-keyword">while</span> (p) &#123;        <span class="hljs-keyword">if</span> (p-&gt;data == elem) &#123;            <span class="hljs-keyword">return</span> i;        &#125;        p = p-&gt;next;        i++;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//返回-1，表示未找到</span>&#125;</code></pre></div><h4 id="单向链表插入操作"><strong>单向链表插入操作</strong></h4><p>链表的插入操作主要有三种情况：</p><ul><li>头部插入</li><li>中部插入</li><li>尾部插入</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720201354416.png" alt="" /><figcaption>image-20230720201354416</figcaption></figure><p>不管是哪种方式，链表插入节点操作主要分为查找到第i个位置，将该位置的next指针修改为指向新插入的节点，而新插入的节点next指针指向(i+1)个位置的节点。其操作方式可以设置一个临时节点，利用循环找到第i个位置，再进行插入。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 链表的头部插入 */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">linkedlist_top_insert</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *pH , <span class="hljs-type">node_t</span> *new)</span>&#123;<span class="hljs-type">node_t</span> *p = pH ;<span class="hljs-comment">//获取当前的位置head </span>new-&gt;next = p-&gt;next ;<span class="hljs-comment">//新的节点的下一个节点设置为原来头节点的下一个节点</span>p-&gt;next = new ;<span class="hljs-comment">//原来的头节点的下一个节点设置为现在新插入的头节点 </span>&#125;<span class="hljs-comment">/* 链表的中部插入 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">linkedlist_tail_insert</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *pH , <span class="hljs-type">node_t</span> *new, <span class="hljs-type">int</span> pos)</span>&#123;<span class="hljs-type">node_t</span> *p = pH ; <span class="hljs-comment">//获取当前的位置 </span><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; pos; i++)&#123;p = p-&gt;next ;<span class="hljs-comment">//查找第pos个位置的节点 </span>&#125;p-&gt;next = new ;<span class="hljs-comment">//此时把新插入的节点赋值给这个位置 </span>&#125;<span class="hljs-comment">/* 链表的尾部插入 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">linkedlist_tail_insert</span><span class="hljs-params">(<span class="hljs-type">node_t</span> *pH , <span class="hljs-type">node_t</span> *new)</span>&#123;<span class="hljs-type">node_t</span> *p = pH ; <span class="hljs-comment">//获取当前的位置head </span><span class="hljs-keyword">while</span>(<span class="hljs-literal">NULL</span> != p-&gt;next)<span class="hljs-comment">//如果当前位置的下一个节点不为空 </span>&#123;p = p-&gt;next ;<span class="hljs-comment">//移动到下一个节点 </span>&#125;p-&gt;next = new ;<span class="hljs-comment">//此时把新插入的节点赋值给这个位置 </span>&#125;</code></pre></div><h4 id="单向链表删除操作"><strong>单向链表删除操作</strong></h4><p>删除元素要建立一个前驱节点和一个当前节点，当找到了我们需要删除的数据时，直接使用前驱节点跳过要删除的节点指向要删除节点的后一个节点，再将原有的节点通过free函数释放掉。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720201433074.png" alt="" /><figcaption>image-20230720201433074</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//单链表的删除，在链表中删除值为val的元素</span><span class="hljs-type">node_t</span>* <span class="hljs-title function_">linkedlist_remove</span><span class="hljs-params">(<span class="hljs-type">node_t</span>* L,<span class="hljs-type">int</span> val)</span> &#123;    <span class="hljs-type">node_t</span> *p,*pre;                   <span class="hljs-comment">//pre为前驱节点，p为查找的节点。</span>    p = L-&gt;next;         <span class="hljs-keyword">while</span>(p-&gt;data != val) &#123;              <span class="hljs-comment">//查找值为x的元素</span>        pre = p;        p = p-&gt;next;    &#125;    pre-&gt;next = p-&gt;next;          <span class="hljs-comment">//删除操作，将其前驱next指向其后继。</span>    <span class="hljs-built_in">free</span>(p);         <span class="hljs-keyword">return</span> L;&#125;</code></pre></div><h3 id="双向链表的操作">双向链表的操作</h3><p>双向链表的结构体程序如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span>&#123;</span>    <span class="hljs-type">int</span> data;           <span class="hljs-comment">//data</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> *<span class="hljs-title">pre</span>;</span>   <span class="hljs-comment">//previous node</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//next node</span>&#125;line;</code></pre></div><h4 id="双向链表的创建">双向链表的创建</h4><p>对于创建双向链表，我们需要先创建头节点再逐步的进行添加，请注意，双向链表的头节点是有数据元素的，这与一般的单链表是不同的。</p><p>开辟一段新的内存空间作为新的节点，为这个节点进行的data进行赋值，然后将已成链表的上一个节点的next指针指向自身，自身的pre指针指向上一个节点。</p><div class="code-wrapper"><pre><code class="hljs c">line* <span class="hljs-title function_">initLine</span><span class="hljs-params">(line * head)</span>&#123;    <span class="hljs-type">int</span> number,pos=<span class="hljs-number">1</span>,input_data;    <span class="hljs-comment">//三个变量分别代表节点数量，当前位置，输入的数据</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入创建节点的大小\n&quot;</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;number);    <span class="hljs-keyword">if</span>(number&lt;<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125; <span class="hljs-comment">//输入非法直接结束</span>    <span class="hljs-comment">//////头节点创建///////</span>    head=(line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(line));    head-&gt;pre=<span class="hljs-literal">NULL</span>;    head-&gt;next=<span class="hljs-literal">NULL</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入第%d个数据\n&quot;</span>,pos++);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;input_data);    head-&gt;data=input_data;      line* <span class="hljs-built_in">list</span>=head;    <span class="hljs-keyword">while</span> (pos&lt;=number) &#123;        line * body=(line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(line));        body-&gt;pre=<span class="hljs-literal">NULL</span>;        body-&gt;next=<span class="hljs-literal">NULL</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入第%d个数据\n&quot;</span>,pos++);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;input_data);        body-&gt;data=input_data;                <span class="hljs-built_in">list</span>-&gt;next=body;        body-&gt;pre=<span class="hljs-built_in">list</span>;        <span class="hljs-built_in">list</span>=<span class="hljs-built_in">list</span>-&gt;next;    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><h4 id="双向链表的遍历">双向链表的遍历</h4><p>如同单链表的遍历一样，利用next指针逐步向后进行索引即可。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">printLine</span><span class="hljs-params">(line* head)</span>&#123;    line *<span class="hljs-built_in">list</span> = head;    <span class="hljs-type">int</span> pos=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">list</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d个数据是:%d\n&quot;</span>,pos++,<span class="hljs-built_in">list</span>-&gt;data);        <span class="hljs-built_in">list</span>=<span class="hljs-built_in">list</span>-&gt;next;    &#125;&#125;</code></pre></div><h4 id="双向链表的插入操作">双向链表的插入操作</h4><p>对于双向链表的插入操作，也有三种形式：头部插入、中部插入和尾部插入。操作方式大同小异，首先创建一个独立的节点，将其的pre指针指向所需插入位置的前一个节点，同时，其所需插入的前一个节点的next指针修改指向为该新的节点，同理，该新的节点的next指针指向原本的下一个节点，而修改下一个节点的pre指针指向创建的新节点，如下图所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720220211252.png" alt="" /><figcaption>image-20230720220211252</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c">line* <span class="hljs-title function_">insertLine</span><span class="hljs-params">(line* head,<span class="hljs-type">int</span> data,<span class="hljs-type">int</span> add)</span>&#123;    <span class="hljs-comment">//三个参数分别为：进行此操作的双链表，插入的数据，插入的位置</span>    <span class="hljs-comment">//新建数据域为data的节点</span>    line* temp=(line*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(line));    temp-&gt;data=data;    temp-&gt;pre=<span class="hljs-literal">NULL</span>;    temp-&gt;next=<span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//插入到链表头，要特殊考虑</span>    <span class="hljs-keyword">if</span> (add==<span class="hljs-number">1</span>) &#123;        temp-&gt;next=head;        head-&gt;pre=temp;        head=temp;    &#125;<span class="hljs-keyword">else</span>&#123;        line * body=head;        <span class="hljs-comment">//找到要插入位置的前一个节点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;add<span class="hljs-number">-1</span>; i++) &#123;            body=body-&gt;next;        &#125;        <span class="hljs-comment">//判断条件为真，说明插入位置为链表尾</span>        <span class="hljs-keyword">if</span> (body-&gt;next==<span class="hljs-literal">NULL</span>) &#123;            body-&gt;next=temp;            temp-&gt;pre=body;        &#125;<span class="hljs-keyword">else</span>&#123;            body-&gt;next-&gt;pre=temp;            temp-&gt;next=body-&gt;next;            body-&gt;next=temp;            temp-&gt;pre=body;        &#125;    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><h4 id="双向链表的删除操作">双向链表的删除操作</h4><p>删除操作的过程是：首先将需要删除节点的前一个节点的next指针指向自己的下一个节点，同时将下一个节点的pre指针修改指向为自己的上一个节点，然后删除节点，释放空间。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230720221311648.png" alt="" /><figcaption>image-20230720221311648</figcaption></figure><div class="code-wrapper"><pre><code class="hljs c">line* <span class="hljs-title function_">deleteLine</span><span class="hljs-params">(line* head, <span class="hljs-type">int</span> data)</span>&#123;    <span class="hljs-comment">//输入的参数分别为进行此操作的双链表，需要删除的数据</span>    line* <span class="hljs-built_in">list</span>=head;    <span class="hljs-comment">//遍历链表</span>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">list</span>) &#123;        <span class="hljs-comment">//判断是否与此元素相等</span>        <span class="hljs-comment">//删除该点方法为将该节点前一节点的next指向该节点后一节点</span>        <span class="hljs-comment">//同时将该节点的后一节点的pre指向该节点的前一节点</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>-&gt;data==data) &#123;            <span class="hljs-built_in">list</span>-&gt;pre-&gt;next=<span class="hljs-built_in">list</span>-&gt;next;            <span class="hljs-built_in">list</span>-&gt;next-&gt;pre=<span class="hljs-built_in">list</span>-&gt;pre;            <span class="hljs-built_in">free</span>(<span class="hljs-built_in">list</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--删除成功--\n&quot;</span>);            <span class="hljs-keyword">return</span> head;        &#125;        <span class="hljs-built_in">list</span>=<span class="hljs-built_in">list</span>-&gt;next;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error:没有找到该元素，没有产生删除\n&quot;</span>);    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><p>附件：<a href="https://gitee.com/kayoungzhang/my_codehub/blob/master/Data%20Structures%20and%20Algorithms/linkedlist.drawio">链表图形编辑源图</a></p><h4 id="参考链接">参考链接：</h4><p>https://zhuanlan.zhihu.com/p/85504177</p><p>https://www.dotcpp.com/course/ds-link/</p><p>http://data.biancheng.net/view/166.html</p><p><a href="https://huaweicloud.csdn.net/63a56658b878a545459463d4.html?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-1-125701955-blog-123446098.235%5Ev38%5Epc_relevant_anti_t3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-1-125701955-blog-123446098.235%5Ev38%5Epc_relevant_anti_t3&amp;utm_relevant_index=2">链表基础知识详解（非常详细简单易懂）</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐几款小工具</title>
    <link href="/2023/07/16/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/07/16/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>在网上发现了几款小工具，有的时候应该会使用到，所以我就下载来使用了一番，觉得蛮好玩的，以下分享一下。</p><h2 id="关于鼠标和按键类小工具">关于鼠标和按键类小工具</h2><h3 id="按键可视化工具---keyviz">按键可视化工具 - Keyviz</h3><p><strong>官网：<a href="https://mularahul.github.io/keyviz/">Keyviz</a> </strong></p><p>这是一款印度免费开源的按键可视化工具，可以实时显示用户当前按下的按键，用户可自定义显示按键风格、样式，非常适合录屏、演示等场合。打开软件后，当按下按键或点击鼠标，在屏幕上就会实时显示当前的按键，如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716171550372.png" alt="image-20230716171550372" style="zoom:67%;" /></p><p>另外，可根据自己的喜好进行简单的配置。</p><h3 id="按键可视化工具---keystroke-visualizer">按键可视化工具 - Keystroke Visualizer</h3><p><strong>官网：<a href="https://vovsoft.com/software/keystroke-visualizer/">Keystroke Visualizer</a></strong></p><p>这也是一款免费开源的按键可视化工具，这一款可以设置中文。另外设置上更简单一些。其显示如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716173232343.png" alt="image-20230716173232343" style="zoom:67%;" /></p><h3 id="按键音效工具---tickeys">按键音效工具 - Tickeys</h3><p><strong>官网：<a href="http://www.yingdev.com/projects/tickeys">Tickeys</a></strong></p><p>这是一款中文版键盘音效工具，可以让你在敲键盘时，发出声音，有声音的节奏，会让你敲起来更带感。它有以下几种音效，可以根据自己的喜好进行设置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716174556296.png" alt="image-20230716174556296" style="zoom:67%;" /></p><p>当你快速敲击键盘按键时，伴随着悦耳的声音，明显感觉打字的速度变快了，这种感觉挺好的，哈哈。</p><h2 id="关于桌面涂鸦小工具">关于桌面涂鸦小工具</h2><h3 id="pointofix">Pointofix</h3><p><strong>官网：<a href="https://www.pointofix.de/download.php">Pointofix</a></strong></p><p>这是一款德国免费软件，可以随时将电脑桌面当作画布，然后在桌面上进行涂写标注，在讲解演示时很是方便，国内使用的比较多。这是一款德文软件，所以需要用户在软件下载页面同时下载语言包。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716183416023.png" alt="image-20230716183416023" style="zoom:67%;" /></p><p>打开软件后，点击 <strong>开始</strong>，电脑桌面就会被冻结，同时软件会伸展开，然后就可以在桌面上进行自由涂鸦标注了，若想退出来，点击软件上的 <strong>退出</strong> 按钮即可，同时软件会收缩成一个按钮图标，这样就不会占用屏幕空间。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716185103598.png" alt="image-20230716185103598" style="zoom:80%;" /> <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716185036872.png" alt="image-20230716185036872" style="zoom: 80%;" /></p><p><strong>注意：</strong> 如果使用语言包还是不能显示中文，那就在上述下载界面下载以下小工具，进行相应设置。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716185843116.png" alt="" /><figcaption>image-20230716185843116</figcaption></figure><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716190429416.png" alt="image-20230716190429416" style="zoom:80%;" /></p><h3 id="gink">gInk</h3><p>这也是一款非常优秀的屏幕标注，支持多种语言，设置比较简单，项目地址：https://github.com/geovens/gInk</p><p>镜像地址：https://gitcode.net/mirrors/geovens/gInk?utm_source=csdn_github_accelerator</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716191042266.png" alt="image-20230716191042266" style="zoom:80%;" /></p><h3 id="电子教鞭">电子教鞭</h3><p>这也是一款纯中文桌面涂鸦软件，不需要过多的设置，使用起来比较简单。下载地址：https://wwx.lanzoui.com/b08mbl9jg （密码：g18f）。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716191807139.png" alt="image-20230716191807139" style="zoom:67%;" /></p><p>打开软件后，显示界面如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230716192034228.png" alt="image-20230716192034228" style="zoom:80%;" /></p><p>相较于另两款，它没有悬浮窗功能，不能收缩，打开后就会一直维持原大小，这就会占用屏幕空间，影响视觉。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>key</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender基础</title>
    <link href="/2023/07/15/Blender%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/15/Blender%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>看到有些视频讲解时使用到了动画演示，比较生动形象，这种方式更有助于我们理解所讲解的知识内容，简单的了解了一下，它们是通过一些专业的软件进行设计的，以下要介绍的Blender软件就是其中的一款。</p><h2 id="blender简介">Blender简介</h2><ul><li>Blender是一个体积小巧，但完整集成的自由开源3D创作套件，提供了大量的基础工具，包括 <a href="https://docs.blender.org/manual/zh-hans/latest/modeling/introduction.html">建模</a> 、 <a href="https://docs.blender.org/manual/zh-hans/latest/render/introduction.html">渲染</a> 、 <a href="https://docs.blender.org/manual/zh-hans/latest/animation/introduction.html">动画 &amp; 绑定</a> 、 <a href="https://docs.blender.org/manual/zh-hans/latest/video_editing/index.html">视频编辑</a> 、 <a href="https://docs.blender.org/manual/zh-hans/latest/movie_clip/index.html">视觉效果</a> 、 <a href="https://docs.blender.org/manual/zh-hans/latest/compositing/introduction.html">合成</a> 、 <a href="https://docs.blender.org/manual/zh-hans/latest/editors/uv/introduction.html">贴图</a>， 以及多种类型的 <a href="https://docs.blender.org/manual/zh-hans/latest/physics/introduction.html">模拟</a>。</li><li>跨平台，使用了OpenGL的GUI可以在所有主流平台上都表现出一致的显示效果（并且可通过Python脚本来自定义界面）。</li><li>高质量的3D架构，带来了快速且高效的工作流。</li><li>它有着活跃的社区支持， <a href="https://www.blender.org/community">blender.org/community</a> 收录了大量的站点列表。</li></ul><p>官网：https://www.blender.org/</p><p>官网用户手册：https://docs.blender.org/manual/zh-hans/latest/</p><h2 id="blender界面基础操作">Blender界面基础操作</h2><h3 id="快捷键">快捷键：</h3><p>Blender可以设置中文界面，当鼠标停留在相应的图标上会显示其对应的名称和快捷键，以下是常用的快捷键：</p><ul><li>侧栏 ---&gt; N</li><li>工具栏 ---&gt; T</li><li>旋转 ---&gt; 鼠标中键拖动(R)</li><li>缩放 ---&gt;鼠标滚轮 (S)</li><li>平移 ---&gt;Shitf + 鼠标中键拖动(G)</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715120248555.png" alt="image-20230715120248555" style="zoom:67%;" /><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715124045066.png" alt="image-20230715124045066" style="zoom: 67%;" /></p><p><strong>注意：</strong>旋转、缩放、平移的同时，按下键盘的 <strong>x或y或z键</strong> 则物体会在相应的方向进行变化。</p><ul><li>四格视图 ---&gt; Ctrl + Alt + Q</li><li>其它视图（没有数字键盘则需要勾选 <strong>模拟数字键盘</strong>）：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715122303901.png" alt="image-20230715122303901" style="zoom:67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715121127963.png" alt="image-20230715121127963" style="zoom:67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715123423095.png" alt="image-20230715123423095" style="zoom:67%;" /></p><p>另外，<strong>`</strong> 键可以选择不同的视图。 <strong>/</strong> 键选中的物体独显示。</p><p>快捷键的修改设置：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715120553076.png" alt="image-20230715120553076" style="zoom:67%;" /></p><h3 id="游标定位和原点定位">游标定位和原点定位</h3><p><strong>游标</strong> 是物体创建时的定位点，当操作 <strong>物体-&gt;吸附-&gt;游标-&gt;世界原点</strong> ，游标会回到(0, 0, 0)。它的定位主要有以下两种方式：</p><ol type="1"><li>模糊定位：</li></ol><p>Shitf + 鼠标右键 ，然后选中定位位置。</p><ol start="2" type="1"><li>吸附定位(精确定位)：</li></ol><p>由 <strong>物体模式</strong> 切换到 <strong>编辑模式</strong> (按TAB键)，选中 <strong>点选择模式</strong>，然后选择物体定位点，之后选择 <strong>网络-&gt;吸附-&gt;游标-&gt;选中项</strong> 。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715131529396.png" alt="image-20230715131529396" style="zoom:67%;" /></p><p><strong>原点</strong> 是指物体的基准点，它是物体旋转，缩放，平移的基点，默认是在物体的中心位置。它的定位设置通过选中物体，鼠标右键即可进行设置。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230715132804522.png" alt="image-20230715132804522" style="zoom:67%;" /></p><h2 id="插件">插件</h2><ul><li><p>按键字符显示插件 ---&gt; Screencast Keys</p></li><li><p>网格其它图形形状 ---&gt; Add Mesh:Extra Objects</p></li><li><p>布尔操作---&gt; Bool Tool</p></li></ul><p>未完待续...</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态站点生成器</title>
    <link href="/2023/07/12/%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2023/07/12/%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>静态站点生成器（Static Site Generators，简称 SSG）是一种软件工具，可以快速轻松地生成静态站点，它采用模板、组件和内容源，然后生成网站所需的 HTML、CSS 和 JavaScript 文件，它已经改变或正在改变我们构建网站的方式。</p><p>静态站点生成器使网站加载速度更快，因为它会在用户请求之前预先构建网站所需的必要文件。它非常适合创建营销、文档和博客等网站。但不适用于想要显示经常变化的实时、动态数据的情况。</p><p>目前，有超过 350 多个静态站点生成器可供选择(https://jamstack.org/generators/)，但在选择静态站点生成器时要考虑一些因素：</p><ul><li><strong>项目性质</strong></li></ul><p>我们要根据构建的项目类型选择合适的站点生成工具。例如Hugo 是博客和文档的绝佳选择，而 Gatsby、Nuxt.js 和 Next.js 是营销网站的绝佳选择。</p><ul><li><strong>使用方便</strong></li></ul><p>很多情况下，几乎没有时间进行深入学习，所以在选择静态站点生成器时，更多会考虑以下问题：</p><ul><li><p>SSG 是用熟悉的技术构建的，还是需要学习一种新的编程语言才能正确使用它？</p></li><li><p>文档是否详细？</p></li><li><p>是否提供初学者教程和其他学习材料来帮助学习过程？</p></li><li><p>是否可以使用模板和主题来加快构建过程？</p></li><li><p><strong>开发者社区</strong></p></li></ul><p>确定 SSG 是否是一个好的选择的一个好方法就是去研究它的开发者社区。开发者往往会聚集在好的工具和软件周围，因此如果它经过充分审查，可能值得考虑。开发者社区对于获得支持和帮助也很重要，遇到问题时，可以更快的得到解决。</p><ul><li><strong>成熟度和采用率</strong></li></ul><p>决定使用哪种 SSG 的一个好方法是查看业内其他人使用的工具以及这些工具的成熟程度。Next.js 被广泛采用的一个原因是它是一个成熟的框架，具有很多强大的功能并且有 Vercel 的支持。这些因素促成了它在开发中被广泛采用。</p><p>下面是一些常用的静态站点生成器：</p><p>Next.js、Jekyll、Hugo、Hexo、GitBook、Gatsby、MkDocs、VuePress、Astro等。</p><p>参考链接：</p><p>https://www.51cto.com/article/748558.html</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>QPainter基本图形绘制用法</title>
    <link href="/2023/07/07/QPainter%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E7%94%A8%E6%B3%95/"/>
    <url>/2023/07/07/QPainter%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="qpainter概念">QPainter概念</h2><p>QPainter 是用于执行绘图操作的类，它可以绘制简单的点、线，也可以绘制饼图、文本、图像等复杂的形状。</p><p>QPainter 一般在绘图事件 <strong>paintEvent()</strong> 中进行绘制，当窗口需要改变或者重新绘制时，当使用 <strong>repaint()</strong>和 <strong>update()</strong> 后，就会自动调用成员函数 <strong>paintEvent()</strong>。</p><p>QPainter 的用法，简单的几个步骤:</p><ul><li><p>1.构造一个 <strong>QPainter</strong> 对象</p></li><li><p>2.设置画笔，画刷等</p></li><li><p>3.绘制图形</p></li><li><p>4.销毁绘图工具</p></li></ul><h2 id="qpainter主要属性">Qpainter主要属性</h2><ul><li><strong>font()</strong>用于绘制文本的字体。</li><li><strong>brush()</strong>定义用于填充形状的颜色或图案。</li><li><strong>pen()</strong>定义用于绘制的线条或边框，也可定义线条颜色。</li><li><strong>viewport()、window()、worldTransform()</strong> 构成了painter的坐标转换系统。</li></ul><h2 id="qpainter绘图">Qpainter绘图</h2><p>QPainter提供了绘制大多数基本图形的函数，如drawPoint()、drawLine()、drawRect()等，所有这些函数都有多个整数和浮点版本（推荐使用浮点数版本）。下面对常用的绘图功能进行说明：</p><ul><li><strong>绘制点</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event); <span class="hljs-comment">//不使用event事件</span>    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.drawPoint(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);    painter.drawPoint(QPoint(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>));    painter.drawPoint(QPointF(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>));    QPoint points[<span class="hljs-number">3</span>] = &#123;QPoint(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>),QPoint(<span class="hljs-number">60</span>,<span class="hljs-number">60</span>),QPoint(<span class="hljs-number">70</span>,<span class="hljs-number">70</span>)&#125;;    painter.drawPoints(points, <span class="hljs-number">3</span>);&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707150523540.png" alt="" /><figcaption>image-20230707150523540</figcaption></figure><ul><li><strong>绘制线</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event); <span class="hljs-comment">//不使用event事件</span>        QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.setPen(QColor(Qt::red));<span class="hljs-comment">//设置画笔颜色</span>        QLine <span class="hljs-title function_">line</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)</span>;    painter.drawLine(line);    painter.drawLine(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>);    painter.drawLine(QPoint(<span class="hljs-number">50</span>, <span class="hljs-number">0</span>), QPoint(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>));    QVector&lt;QLine&gt; vectorLine;    vectorLine &lt;&lt; QLine(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>);    vectorLine &lt;&lt; QLine(<span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">100</span>);    vectorLine &lt;&lt; QLine(<span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>);    vectorLine &lt;&lt; QLine(<span class="hljs-number">70</span>, <span class="hljs-number">0</span>, <span class="hljs-number">70</span>, <span class="hljs-number">100</span>);    vectorLine &lt;&lt; QLine(<span class="hljs-number">90</span>, <span class="hljs-number">0</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>);    painter.drawLines(vectorLine);&#125;</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707151808304.png" alt="" /><figcaption>image-20230707151808304</figcaption></figure><ul><li><strong>绘制矩形</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event); <span class="hljs-comment">//不使用event事件</span>    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.setPen(QColor(<span class="hljs-number">10</span>,<span class="hljs-number">60</span>,<span class="hljs-number">200</span>));<span class="hljs-comment">//设置画笔颜色</span>    painter.setBrush(QColor(<span class="hljs-number">200</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>));<span class="hljs-comment">//设置画刷颜色</span>    painter.drawRect(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">150</span>);    QRect <span class="hljs-title function_">rect</span><span class="hljs-params">(QPoint(<span class="hljs-number">160</span>, <span class="hljs-number">160</span>),QPoint(<span class="hljs-number">220</span>,<span class="hljs-number">220</span>))</span>;    painter.drawRect(rect);&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707153153942.png" alt="image-20230707153153942" style="zoom:67%;" /></p><ul><li><strong>绘制圆弧</strong></li></ul><p>0°在时钟三点的位置，圆弧是逆时针转动，起始角度和跨度角度都必须是度数的1/16，如：整个圆的角度就是 **16*360**.</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/20230707155314.png" alt="20230707155314" style="zoom: 67%;" /></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event); <span class="hljs-comment">//不使用event事件</span>    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    QRectF <span class="hljs-title function_">rectangle</span><span class="hljs-params">(<span class="hljs-number">50.0</span>, <span class="hljs-number">50.0</span>, <span class="hljs-number">60.0</span>, <span class="hljs-number">60.0</span>)</span>;    <span class="hljs-type">int</span> startAngle = <span class="hljs-number">30</span> * <span class="hljs-number">16</span>;    <span class="hljs-type">int</span> spanAngle = <span class="hljs-number">130</span> * <span class="hljs-number">16</span>;    painter.drawArc(rectangle, startAngle, spanAngle);    painter.setPen(QPen(Qt::blue,<span class="hljs-number">3</span>,Qt::DotLine));    painter.drawRect(rectangle);&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707155800251.png" alt="image-20230707155800251" style="zoom:80%;" /></p><ul><li><strong>绘制椭圆</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event);    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.setRenderHint(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<span class="hljs-comment">//抗锯齿</span>    painter.drawEllipse(QPointF(<span class="hljs-number">120</span>, <span class="hljs-number">60</span>), <span class="hljs-number">50</span>, <span class="hljs-number">20</span>);    painter.setBrush(QColor(<span class="hljs-number">255</span>, <span class="hljs-number">160</span>, <span class="hljs-number">90</span>)); <span class="hljs-comment">//设置画刷颜色</span>    painter.drawEllipse(QPointF(<span class="hljs-number">120</span>, <span class="hljs-number">140</span>), <span class="hljs-number">40</span>, <span class="hljs-number">40</span>); <span class="hljs-comment">//绘制圆</span>&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707161014066.png" alt="image-20230707161014066" style="zoom:67%;" /></p><ul><li><strong>绘制多边形</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event);    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.setRenderHint(QPainter::Antialiasing, <span class="hljs-literal">true</span>);<span class="hljs-comment">//抗锯齿</span>    QPointF points[<span class="hljs-number">4</span>] = &#123;QPointF(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>), QPointF(<span class="hljs-number">60</span>, <span class="hljs-number">150</span>), QPointF(<span class="hljs-number">150</span>, <span class="hljs-number">160</span>), QPointF(<span class="hljs-number">220</span>, <span class="hljs-number">100</span>)&#125;;    painter.drawPolygon(points, <span class="hljs-number">4</span>);&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707161401036.png" alt="image-20230707161401036" style="zoom:67%;" /></p><ul><li><strong>绘制文本</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event);    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    painter.setPen(QColor(<span class="hljs-number">0</span>, <span class="hljs-number">160</span>, <span class="hljs-number">230</span>));<span class="hljs-comment">//设置画笔颜色</span>    QFont font;<span class="hljs-comment">//设置字体属性</span>    font.setFamily(<span class="hljs-string">&quot;Microsoft YaHei&quot;</span>);<span class="hljs-comment">//字体样式</span>    font.setPointSize(<span class="hljs-number">50</span>);<span class="hljs-comment">//字体点大小</span>    font.setItalic(<span class="hljs-literal">true</span>);<span class="hljs-comment">//字体斜体</span>    painter.setFont(font);    painter.drawText(rect(), Qt::AlignCenter, <span class="hljs-string">&quot;QPainter&quot;</span>);<span class="hljs-comment">//绘制文本</span>&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707162043411.png" alt="image-20230707162043411" style="zoom:67%;" /></p><ul><li><strong>绘制图像</strong></li></ul><p>绘制图像函数有<strong>drawPixmap()、drawImage()</strong>，drawPixmap在屏幕设备上更快，drawImage()在QPrinter或其他设备上可能更快。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span>&#123;    Q_UNUSED(event);    QPainter <span class="hljs-title function_">painter</span><span class="hljs-params">(this)</span>;    QPixmap pixmap;    pixmap.load(<span class="hljs-string">&quot;:/pic/a.png&quot;</span>);    painter.drawPixmap(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">150</span>, <span class="hljs-number">150</span>, pixmap);    QImage image;    image.load(<span class="hljs-string">&quot;:/pic/b.png&quot;</span>);    painter.drawImage(<span class="hljs-number">160</span>, <span class="hljs-number">0</span>, image);&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230707163819634.png" alt="image-20230707163819634" style="zoom:67%;" /></p><p>工程文件：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/painter.zip">painter</a></p><p>参考链接：</p><p>http://t.csdn.cn/Q72tA</p><p>http://t.csdn.cn/acIsw</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法中的时间和空间复杂度</title>
    <link href="/2023/07/07/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2023/07/07/%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="算法简介">算法简介</h2><p>所谓算法（Algorithm），即解决问题的方法。同一个问题，使用不同的算法，虽然得到的结果相同，但耗费的时间和资源肯定有所差异。</p><p><strong>注意</strong>，程序和算法是完全不同的概念。算法是解决某个问题的想法、思路；而程序是在根据算法编写出来的真正可以运行的代码。例如，要依次输出一维数组中的数据元素的值，首先想到的是使用循环结构，在这个算法的基础上，我们才开始编写程序。</p><p>程序的运行效率具体可以从 2 个方面衡量，分别为：</p><ul><li>程序的运行时间。（时间维度）</li><li>程序运行所需内存空间的大小。（空间维度）</li></ul><p>程序运行时间越短，运行期间占用的内存越少，该程序运行效率就越高，这样算法也就更好。衡量一个算法所编写出程序的运行效率在数据结构中，用<strong>时间复杂度</strong>来衡量程序运行时间的多少；用<strong>空间复杂度</strong>来衡量程序运行所需内存空间的大小。</p><h2 id="算法中复杂度的表示方法">算法中复杂度的表示方法</h2><p>在数据结构中，每条语句的执行次数，被称为该语句的频度，整段代码的总执行次数，为整段代码的频度。所以算法复杂度的一般通用表示方法是：「 <strong>大O符号表示法</strong> 」，即 <strong>O(频度)</strong>。大O符号表示法是一种算法复杂度的相对表示方式。</p><h2 id="时间复杂度">时间复杂度</h2><h3 id="时间复杂度概念">时间复杂度概念</h3><p>一个算法所编程序运行时间的多少，并不是在计算机上运行所消耗的时间来度量的，而是根据合理方法得到的预估值。那么，如何预估一个算法所编程序的运行时间呢？就是计算程序中每行代码的执行次数，然后用总的执行次数间接表示程序的运行时间，即：</p><p><strong>T(n) = O(f(n))</strong></p><p>其中：<strong>T(n)</strong>表示程序执行的时间；<strong>f(n)</strong> 表示每行代码执行次数之和；而 <strong>O</strong> 表示 T(n) 与 f(n) 成正比关系，这个公式的全称是：<strong>算法的渐进时间复杂度</strong>。</p><p>我们先来看个例子：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)     <span class="hljs-comment">//&lt;- 从 0 到 n，执行 n+1 次</span>&#123;    a++;                         <span class="hljs-comment">//&lt;- 从 0 到 n-1，执行 n 次</span>&#125;</code></pre></div><p>因此，整段代码中所有语句共执行了 (n+1)+n 次，即 <strong>2n+1</strong> 次。</p><p>再看一个例子：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)           <span class="hljs-comment">// n+1次</span>&#123;     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j++)       <span class="hljs-comment">// n*(m+1)次</span>    &#123;        num++;                         <span class="hljs-comment">// n*m次</span>    &#125;&#125;</code></pre></div><p>这段代码一共执行的次数是：(2*n*m+2*n+1)。当 n、m 都无限大时，可认为 n==m，则可以简化为 <strong>2n²+2n+1</strong>，这就是此段程序在最坏情况下的运行频度。</p><p>在数据结构中，一般会使用 <strong>无限大的思想</strong> 来简化频度表达式。可以这样简化：</p><ul><li>首先去掉常数分子。例如 <strong>2n²+2n+1</strong> 简化为 <strong>2n²+2n</strong> ；</li><li>然后有多项无限大的变量的，只保留一个最高项变量,且最高项系数为1。例如 <strong>2n²+2n</strong> 简化为 <strong>n²</strong>；</li></ul><p>这样，就可以得到以上两个例子的时间复杂度分别为 <strong>O(n)</strong> 和 <strong>O(n²)</strong> 。</p><h3 id="常见的时间复杂度量级">常见的时间复杂度量级</h3><p>常见的时间复杂度量级有：</p><ul><li><strong>常数阶O(1)</strong></li><li><strong>对数阶O(logn)</strong></li><li><strong>线性阶O(n)</strong></li><li><strong>线性对数阶O(nlogn)</strong></li><li><strong>平方阶O(n²)</strong></li><li><strong>立方阶O(n³)</strong></li><li><strong>指数阶(2^n)</strong></li></ul><p>上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。<strong>注意</strong>，这里仅以最坏情况下的频度作为时间复杂度，而在某些实际场景中，还可以用最好情况下的频度和最坏情况下的频度的平均值来作为算法的平均时间复杂度。</p><p>下面分别举例说明：</p><ol type="1"><li><strong>常数阶O(1)</strong></li></ol><p>无论代码执行了多少行，哪怕执行上万行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1),如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;++i;j++;<span class="hljs-type">int</span> m = i + j;</code></pre></div><ol start="2" type="1"><li><strong>对数阶O(logn)</strong></li></ol><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;     <span class="hljs-comment">//执行1次</span><span class="hljs-keyword">while</span>(i&lt;n)     <span class="hljs-comment">//执行log2^n次</span>&#123;    i = i * <span class="hljs-number">2</span>; <span class="hljs-comment">//执行log2^n次</span>&#125;</code></pre></div><p>这段代码总的执行次数是 <strong>2log2^n + 1</strong>; 简化：<strong>log2^n</strong>, 对数的底是不确定的，这里恰好是2，一般会去掉对数的底，所以可以进一步简化：<strong>logn</strong>，即时间复杂度：<strong>O(logn)</strong> 。</p><ol start="3" type="1"><li><strong>线性阶O(n)</strong></li></ol><p>如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; ++i) <span class="hljs-comment">//执行了n次</span>&#123;   j++ = i;   <span class="hljs-comment">//执行了 n-1 次</span>&#125;</code></pre></div><p>这段代码执行了 <strong>2n-1</strong> 次，简化后，即时间复杂度 <strong>O(n)</strong> 。</p><ol start="4" type="1"><li><strong>线性对数阶O(nlogn)</strong></li></ol><p>将时间复杂度为O(logn)的代码循环n遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(m=<span class="hljs-number">1</span>; m&lt;n; m++) <span class="hljs-comment">//执行n次</span>&#123;    i = <span class="hljs-number">1</span>;       <span class="hljs-comment">//执行n次</span>    <span class="hljs-keyword">while</span>(i&lt;n)   <span class="hljs-comment">//执行 n*log2^n次</span>    &#123;        i = i * <span class="hljs-number">2</span>;  <span class="hljs-comment">//执行n*log2^n次</span>    &#125;&#125;</code></pre></div><p>这段代码执行了 <strong>2n+2nlog2^n</strong> 次，简化后，即时间复杂度 <strong>O(nlogn)</strong> 。</p><ol start="5" type="1"><li><strong>平方阶O(n²)</strong></li></ol><p>如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(x=<span class="hljs-number">1</span>; i&lt;=n; x++) <span class="hljs-comment">//执行n次</span>&#123;   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=n; i++) <span class="hljs-comment">//执行n*n次</span>    &#123;       j++ = i;  <span class="hljs-comment">//执行n*n次</span>    &#125;&#125;</code></pre></div><p>这段代码执行了 <strong>n+2n²</strong> 次，简化后，即时间复杂度 <strong>O(n²)</strong> 。</p><ol start="6" type="1"><li><strong>立方阶O(n³)</strong></li></ol><p>O(n³)相当于三层n循环，其它的类似。</p><ol start="7" type="1"><li><strong>指数阶(2^n)</strong></li></ol><p>在递归调用程序中，会有指数阶，如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;   <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   <span class="hljs-keyword">return</span> f(n<span class="hljs-number">-1</span>) + f(n - <span class="hljs-number">1</span>);&#125;</code></pre></div><p>这里执行的次数计算: 2^0 + 2^1 + 2^2 + …… + 2^n，即2^(n+1)-1,进一步简化则时间复杂度:<strong>O(2^n)</strong> 。</p><p>除此之外，其实还有 <strong>平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度</strong> ，有点复杂，这里这里就不展开了。</p><h2 id="空间复杂度">空间复杂度</h2><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。和时间复杂度类似，也用 「 <strong>大O符号表示法</strong> 」 来表示。</p><p>事实上，<strong>对算法的空间复杂度影响最大的，往往是程序运行过程中所申请的临时存储空间</strong>。如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> n;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];</code></pre></div><p>这段程序在运行时所申请的临时空间，并不随 n 的值而变化。而如果将第 3 行代码改为<code>int a[n]</code>, 此时程序运行所申请的临时空间，和 n 值有直接的关联。</p><p>所以，如果程序所占用的存储空间和输入值无关，则该程序的空间复杂度就为 <strong>O(1)</strong>；反之则需要进一步判断它们之间的关系：</p><ul><li>输入值 n 不断增大，程序申请的临时空间成线性增长，则程序的空间复杂度用 <strong>O(n)</strong> 表示;</li><li>输入值 n 不断增大，程序申请的临时空间成 n² 关系增长，则程序的空间复杂度用 <strong>O(n²)</strong> 表示；</li><li>输入值 n 不断增大，程序申请的临时空间成 n³ 关系增长，则程序的空间复杂度用 <strong>O(n³)</strong> 表示；</li></ul><blockquote><p><strong>在多数场景中，一个好的算法往往更注重的是时间复杂度的比较，而空间复杂度只要在一个合理的范围内就可以。空间复杂度比较常用的有：O(1)、O(n)、O(n²)</strong></p></blockquote><p>参考链接：</p><p>http://c.biancheng.net/view/8081.html</p><p>https://zhuanlan.zhihu.com/p/50479555</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora中常用HTML格式设置</title>
    <link href="/2023/07/05/Typora%E4%B8%AD%E5%B8%B8%E7%94%A8HTML%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/07/05/Typora%E4%B8%AD%E5%B8%B8%E7%94%A8HTML%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="颜色">1.颜色</h3><p>颜色的种类有很多，HTML和CSS中的颜色规格有140多个（17种标准颜色，再加130多个其它颜色）。17种标准颜色：</p><table><tr><td style="background-color:aqua">浅绿色<br>aqua</td><td style="background-color:black">黑色<br>black</td><td style="background-color:blue">蓝色<br>blue</td><td style="background-color:fuchsia">紫红色<br>fuchsia</td><td style="background-color:gray">灰色<br>gray</td><td style="background-color:green">绿色<br>green</td><td style="background-color:lime">浅绿色<br>lime</td><td style="background-color:maroon">褐红色<br>maroon</td><td style="background-color:navy">藏青色<br>navy</td></tr><tr><td style="background-color:olive">橄榄色<br>olive</td><td style="background-color:orange">橙色<br>orange</td><td style="background-color:purple">紫色<br>purple</td><td style="background-color:red">红色<br>red</td><td style="background-color:silver">银色<br>silver</td><td style="background-color:teal">青色<br>teal</td><td style="background-color:white">白色<br>white</td><td style="background-color:yellow">黄色<br>yellow</td></tr></table><ul><li><p>Hex颜色代码： &lt;span style="color:#FF0000"&gt;Red text&lt;/span&gt;</p></li><li><p>HTML颜色名称: &lt;span style="color:red"&gt;Red text&lt;/span&gt;</p></li><li><p>RGB颜色代码: &lt;span style="color:rgb(255,0,0)"&gt;Red text&lt;/span&gt;</p></li><li><p>HSL颜色代码： &lt;span style="color:hsl(0,100%,50%)"&gt;Red text&lt;/span&gt;</p><p>色相值：0-360，饱和度：0~100%，亮度：0~100% 。</p></li></ul><p>以上四种方式都能实现以下字体样式：</p><p align="center"; style="color:#FF0000">Red text</p><ul><li><p>RGBA颜色代码：&lt;span style="color:rgba(255,0,0,0.5)"&gt;Red text&lt;/span&gt;</p><p>a：0~1。0表示完全透明，1表示完全不透明</p></li></ul><p align="center"; style="color:rgba(255,0,0,0.5)">Red text</p><h3 id="字体">2.字体</h3><p>&lt;span style="color:yellow;font-size:2rem;font-weight:bold;font-family:微软雅黑;background:green"&gt;20号微软雅黑加粗黄色字体，绿色背景&lt;/span&gt;</p><p><span style="color:yellow;font-size:2rem;font-weight:bold;font-family:微软雅黑;background:green">20号微软雅黑加粗字体，绿色背景</span></p><h3 id="链接设置">3.链接设置</h3><ul><li><p>普通：&lt;a href="www.baidu.com"&gt;百度&lt;/a&gt; ---&gt; <a href="www.baidu.com">百度</a></p></li><li><p>颜色：&lt;a href="www.baidu.com" style="color:OrangeRed"&gt;百度&lt;/a&gt; ---&gt; <a href="www.baidu.com" style="color:OrangeRed">百度</a></p></li><li><p>清除下划线：&lt;a href="www.baidu.com" style="text-decoration:none"&gt;百度&lt;/a&gt; ---&gt; <a href="www.baidu.com" style="text-decoration:none">百度</a></p></li></ul><h3 id="其它">4.其它</h3><ul><li><p>换行：&lt;br&gt;</p></li><li><p>键盘按键组合：如：&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;F9&lt;/kbd&gt; ---&gt; <kbd>Ctrl</kbd>+<kbd>F9</kbd></p></li><li><p>带拼音文字：如：&lt;ruby&gt;中国&lt;rt&gt;zhongguo&lt;/rt&gt;&lt;/ruby&gt; ---&gt; <ruby>中国<rt>zhongguo</rt></ruby></p></li><li><p>内嵌图片和音视频:</p><ul><li>&lt;img src="xxx.png" /&gt;</li><li>&lt;audio src="xxx.mp3" /&gt;</li><li>&lt;video src="xxx.mp4" /&gt;</li></ul></li><li><p>对齐:</p><ul><li>&lt;p align="center";&gt;段落中心对齐&lt;/p&gt;</li></ul><p align="center";>段落中心对齐</p><ul><li><p>&lt;center&gt;内容中心对齐&lt;/center&gt;</p><center><p>内容中心对齐</p></center></li></ul></li></ul><h2 id="附录1html颜色名">附录1：HTML颜色名</h2><p>红色HTML颜色名：</p><table><tr><td style="background-color:IndianRed">IndianRed</td><td style="background-color:LightCoral">LightCoral</td><td style="background-color:Salmon">Salmon</td><td style="background-color:DarkSalmon">DarkSalmon</td><td style="background-color:LightSalmon">LightSalmon</td></tr><tr><td style="background-color:Crimson">Crimson</td><td style="background-color:Red">Red</td><td style="background-color:FireBrick">FireBrick</td><td style="background-color:DarkRed">DarkRed</td></tr></table><p>粉色HTML颜色名：</p><table><tr><td style="background-color:Pink">Pink</td><td style="background-color:LightPink">LightPink</td><td style="background-color:HotPink">HotPink</td><td style="background-color:DeepPink">DeepPink</td><td style="background-color:MediumVioletRed">MediumVioletRed</td><td style="background-color:PaleVioletRed">PaleVioletRed</td></tr></table><p>橙色HTML颜色名：</p><table><tr><td style="background-color:LightSalmon">LightSalmon</td><td style="background-color:Coral">Coral</td><td style="background-color:Tomato">Tomato</td><td style="background-color:OrangeRed">OrangeRed</td><td style="background-color:DarkOrange">DarkOrange</td><td style="background-color:Orange">Orange</td></tr></table><p>黄色HTML颜色名：</p><table><tr><td style="background-color:Gold">Gold</td><td style="background-color:Yellow">Yellow</td><td style="background-color:LightYellow">LightYellow</td><td style="background-color:LemonChiffon">LemonChiffon</td><td style="background-color:LightGoldenrodYellow">LightGoldenrodYellow</td><td style="background-color:PapayaWhip">PapayaWhip</td></tr><tr><td style="background-color:Moccasin">Moccasin</td><td style="background-color:PeachPuff">PeachPuff</td><td style="background-color:PaleGoldenrod">PaleGoldenrod</td><td style="background-color:Khaki">Khaki</td><td style="background-color:DarkKhaki">DarkKhaki</td></tr></table><p>紫色HTML颜色名：</p><table><tr><td style="background-color:Lavender">Lavender</td><td style="background-color:Thistle">Thistle</td><td style="background-color:Plum">Plum</td><td style="background-color:Violet">Violet</td><td style="background-color:Orchid">Orchid</td><td style="background-color:Fuchsia">Fuchsia</td></tr><tr><td style="background-color:MediumOrchid">MediumOrchid</td><td style="background-color:MediumPurple">MediumPurple</td><td style="background-color:RebeccaPurple">RebeccaPurple</td><td style="background-color:BlueViolet">BlueViolet</td><td style="background-color:DarkViolet">DarkViolet</td><td style="background-color:DarkOrchid">DarkOrchid</td></tr><tr><td style="background-color:DarkMagenta">DarkMagenta</td><td style="background-color:Purple">Purple</td><td style="background-color:Indigo">Indigo</td><td style="background-color:SlateBlue">SlateBlue</td><td style="background-color:DarkSlateBlue">DarkSlateBlue</td><td style="background-color:MediumSlateBlue">MediumSlateBlue</td></tr></table><p>绿色HTML颜色名：</p><table><tr><td style="background-color:GreenYellow">GreenYellow</td><td style="background-color:Chartreuse">Chartreuse</td><td style="background-color:LawnGreen">LawnGreen</td><td style="background-color:Lime">Lime</td><td style="background-color:LimeGreen">LimeGreen</td></tr><tr><td style="background-color:PaleGreen">PaleGreen</td><td style="background-color:LightGreen">LightGreen</td><td style="background-color:MediumSpringGreen">MediumSpringGreen</td><td style="background-color:SpringGreen">SpringGreen</td><td style="background-color:MediumSeaGreen">MediumSeaGreen</td></tr><tr><td style="background-color:SeaGreen">SeaGreen</td><td style="background-color:ForestGreen">ForestGreen</td><td style="background-color:Green">Green</td><td style="background-color:DarkGreen">DarkGreen</td><td style="background-color:YellowGreen">YellowGreen</td></tr><tr><td style="background-color:OliveDrab">OliveDrab</td><td style="background-color:Olive">Olive</td><td style="background-color:DarkOliveGreen">DarkOliveGreen</td><td style="background-color:MediumAquamarine">MediumAquamarine</td><td style="background-color:DarkSeaGreen">DarkSeaGreen</td></tr><tr><td style="background-color:LightSeaGreen">LightSeaGreen</td><td style="background-color:DarkCyan">DarkCyan</td><td style="background-color:Teal">Teal</td></tr></table><p>蓝色HTML颜色名：</p><table><tr><td style="background-color:Aqua">Aqua</td><td style="background-color:Cyan">Cyan</td><td style="background-color:LightCyan">LightCyan</td><td style="background-color:PaleTurquoise">PaleTurquoise</td><td style="background-color:Aquamarine">Aquamarine</td></tr><tr><td style="background-color:Turquoise">Turquoise</td><td style="background-color:MediumTurquoise">MediumTurquoise</td><td style="background-color:DarkTurquoise">DarkTurquoise</td><td style="background-color:CadetBlue">CadetBlue</td><td style="background-color:SteelBlue">SteelBlue</td></tr><tr><td style="background-color:LightSteelBlue">LightSteelBlue</td><td style="background-color:PowderBlue">PowderBlue</td><td style="background-color:LightBlue">LightBlue</td><td style="background-color:SkyBlue">SkyBlue</td><td style="background-color:LightSkyBlue">LightSkyBlue</td></tr><tr><td style="background-color:DeepSkyBlue">DeepSkyBlue</td><td style="background-color:DodgerBlue">DodgerBlue</td><td style="background-color:CornflowerBlue">CornflowerBlue</td><td style="background-color:MediumSlateBlue">MediumSlateBlue</td><td style="background-color:RoyalBlue">RoyalBlue</td></tr><tr><td style="background-color:Blue">Blue</td><td style="background-color:MediumBlue">MediumBlue</td><td style="background-color:DarkBlue">DarkBlue</td><td style="background-color:Navy">Navy</td><td style="background-color:MidnightBlue">MidnightBlue</td></tr></table><p>褐色HTML颜色名：</p><table><tr><td style="background-color:Cornsilk">Cornsilk</td><td style="background-color:BlanchedAlmond">BlanchedAlmond</td><td style="background-color:Bisque">Bisque</td><td style="background-color:NavajoWhite">NavajoWhite</td><td style="background-color:Wheat">Wheat</td><td style="background-color:BurlyWood">BurlyWood</td></tr><tr><td style="background-color:Tan">Tan</td><td style="background-color:RosyBrown">RosyBrown</td><td style="background-color:SandyBrown">SandyBrown</td><td style="background-color:Goldenrod">Goldenrod</td><td style="background-color:DarkGoldenrod">DarkGoldenrod</td><td style="background-color:Peru">Peru</td></tr><tr><td style="background-color:Chocolate">Chocolate</td><td style="background-color:SaddleBrown">SaddleBrown</td><td style="background-color:Sienna">Sienna</td><td style="background-color:Brown">Brown</td><td style="background-color:Maroon">Maroon</td></tr></table><p>白色HTML颜色名：</p><table><tr><td style="background-color:White">White</td><td style="background-color:Snow">Snow</td><td style="background-color:HoneyDew">HoneyDew</td><td style="background-color:MintCream">MintCream</td><td style="background-color:Azure">Azure</td><td style="background-color:AliceBlue">AliceBlue</td></tr><tr><td style="background-color:GhostWhite">GhostWhite</td><td style="background-color:WhiteSmoke">WhiteSmoke</td><td style="background-color:SeaShell">SeaShell</td><td style="background-color:Beige">Beige</td><td style="background-color:OldLace">OldLace</td><td style="background-color:FloralWhite">FloralWhite</td></tr><tr><td style="background-color:Ivory">Ivory</td><td style="background-color:AntiqueWhite">AntiqueWhite</td><td style="background-color:Linen">Linen</td><td style="background-color:LavenderBlush">LavenderBlush</td><td style="background-color:MistyRose">MistyRose</td></tr></table><p>灰色HTML颜色名：</p><table><tr><td style="background-color:Gainsboro">Gainsboro</td><td style="background-color:LightGray">LightGray</td><td style="background-color:Silver">Silver</td><td style="background-color:DarkGray">DarkGray</td><td style="background-color:Gray">Gray</td></tr><tr><td style="background-color:DimGray">DimGray</td><td style="background-color:LightSlateGray">LightSlateGray</td><td style="background-color:SlateGray">SlateGray</td><td style="background-color:DarkSlateGray">DarkSlateGray</td><td style="background-color:Black">Black</td></tr></table><h2 id="附录2html颜色hex值与rgb值">附录2：HTML颜色HEX值与RGB值</h2><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/material-design-color-chart.png" alt="" /><figcaption>material-design-color-chart</figcaption></figure><p><strong>链接：</strong></p><p><a href="https://www.runoob.com/tags/html-colorname.html">https://www.runoob.com/tags/html-colorname.html</a></p><p><a href="https://htmlcolorcodes.com/zh/yanse-ming/">https://htmlcolorcodes.com/zh/yanse-ming/</a></p><p><a href="https://typorachina.com/guide/quick-start/html-support-in-typora.html">Typora 中的 HTML 支持 | TyporaChina</a></p><h2 id="附录3typora中添加自定义格式">附录3：Typora中添加自定义格式</h2><p>在Typora中为了快速设置格式，可通过快捷键软件（如<a href="https://www.autohotkey.com/">AutoHotkey</a>）将设置的格式添加到快捷键中，也可以通过输入法的自定义短语添加格式，如下所示：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230706200028503.png" alt="" /><figcaption>image-20230706200028503</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt中标准对话框</title>
    <link href="/2023/07/02/Qt%E4%B8%AD%E6%A0%87%E5%87%86%E5%AF%B9%E8%AF%9D%E6%A1%86/"/>
    <url>/2023/07/02/Qt%E4%B8%AD%E6%A0%87%E5%87%86%E5%AF%B9%E8%AF%9D%E6%A1%86/</url>
    
    <content type="html"><![CDATA[<h5 id="标准对话框">标准对话框</h5><ul><li><p>1颜色对话框</p><ul><li>```c++ #include <QColorDialog> QColor color = QColorDialog::getColor(...); <div class="code-wrapper"><pre><code class="hljs dts">- <span class="hljs-number">2</span>文件对话框  - ```c++    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QFileDialog&gt;</span></span>    QString fileN<span class="hljs-attr">ame</span> <span class="hljs-operator">=</span> QFileDialog::getOpenFileName(...)<span class="hljs-punctuation">;</span>    QString fileSaveN<span class="hljs-attr">ame</span> <span class="hljs-operator">=</span> QFileDialog::getSaveFileName(...)<span class="hljs-punctuation">;</span>    QStringList <span class="hljs-attr">list</span> <span class="hljs-operator">=</span> QFileDialog::getOpenFileNames(...)<span class="hljs-punctuation">;</span></code></pre></div></li></ul></li><li><p>3字体对话框</p><ul><li>```c++ #include <QFontDialog> QFont font = QFontDialog::getFont(bool <em>ok, QWidget </em>parent = nullptr); <div class="code-wrapper"><pre><code class="hljs dts">- <span class="hljs-number">4</span>输入对话框  - ```c++    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QInputDialog&gt;</span></span>    QString inputT<span class="hljs-attr">ext</span> <span class="hljs-operator">=</span> QInputDialot::getText(...)<span class="hljs-punctuation">;</span>    int inputN<span class="hljs-attr">um</span> <span class="hljs-operator">=</span> QInputDialot::getInt(...)<span class="hljs-punctuation">;</span>    double inputD<span class="hljs-attr">ouble</span> <span class="hljs-operator">=</span> QInputDialot::getDouble(...)<span class="hljs-punctuation">;</span>    QString inputI<span class="hljs-attr">tem</span> <span class="hljs-operator">=</span> QInputDialot::getItem(...)<span class="hljs-punctuation">;</span></code></pre></div></li></ul></li><li><p>5消息对话框</p><ul><li>```c++ #include <QMessageBox> QMessageBox::information(...); QMessageBox::question(...); QMessageBox::warning(...); QMessageBox::critical(...); QMessageBox::about(this, "title", "<h2>Spreadsheet1.1</h2>" "<p>Copyright&amp;copy:2022 SoftwareInc." "<p>Spreadsheet is a small aplication that " "demonstrates QAction QMainWindow, QmenuBar"); <div class="code-wrapper"><pre><code class="hljs arduino">- <span class="hljs-number">6</span>进度条对话框  - ```c++    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QProgressDialog&gt;</span></span>    QProgressDialog *progress = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QProgressDialog</span>(...));    progress-&gt;<span class="hljs-built_in">setWindowModality</span>(Qt::WindowModal);</code></pre></div></li></ul></li><li><p>7向导对话框</p><ul><li>```c++ #include <QWizard> QWizard <em>wizard = new QWizard(this); QWizardPage </em>page1 = new QWizardPage(this); wizard-&gt;addPage(page1); <div class="code-wrapper"><pre><code class="hljs cpp">- <span class="hljs-number">8</span>打印对话框  - ```c++    QT += printsupport    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QPrintDialog&gt;</span></span>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QPrinter&gt;</span></span>    QPrintDialog <span class="hljs-built_in">printDialog</span>(printer, <span class="hljs-keyword">this</span>);</code></pre></div></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之表格控件QTableWidget</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E8%A1%A8%E6%A0%BC%E6%8E%A7%E4%BB%B6QTableWidget/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E8%A1%A8%E6%A0%BC%E6%8E%A7%E4%BB%B6QTableWidget/</url>
    
    <content type="html"><![CDATA[<p>QTableWidget是QT中的表格组件类,一般用来展示多行多列的数据。QTableWidget中的每一个单元格都是一个QTableWidgetItem对象。</p><h3 id="qtablewidgetitem的常用方法">QTableWidgetItem的常用方法</h3><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-title function_">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span>设置单元格中的文本。QIcon <span class="hljs-title function_">icon</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-title function_">setIcon</span><span class="hljs-params">(<span class="hljs-type">const</span> QIcon &amp;icon)</span>给单元格添加图标。QBrush <span class="hljs-title function_">background</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-title function_">setBackground</span><span class="hljs-params">(<span class="hljs-type">const</span> QBrush &amp;brush)</span>设置单元格的背景。QFont <span class="hljs-title function_">font</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   <span class="hljs-title function_">setFont</span><span class="hljs-params">(<span class="hljs-type">const</span> QFont &amp;font)</span>设置单元格中文本的字体。QBrush <span class="hljs-title function_">foreground</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-title function_">setForeground</span><span class="hljs-params">(<span class="hljs-type">const</span> QBrush &amp;brush)</span>设置单元格中字体的颜色。<span class="hljs-type">int</span> <span class="hljs-title function_">textAlignment</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-title function_">setTextAlignment</span><span class="hljs-params">(<span class="hljs-type">int</span> alignment)</span>设置单元格中文本的对齐方式。QString <span class="hljs-title function_">toolTip</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    <span class="hljs-title function_">setToolTip</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;toolTip)</span>给单元格设置提示信息。</code></pre></div><h3 id="qtablewidget控件属性和方法">QTableWidget控件属性和方法</h3><ul><li>构造 QTableWidgetItem</li></ul><div class="code-wrapper"><pre><code class="hljs c">QTableWidgetItem(<span class="hljs-type">const</span> QIcon &amp;icon, <span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">int</span> type = Type)QTableWidgetItem(<span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">int</span> type = Type)</code></pre></div><ul><li>获取和设置单元格是否可编辑</li></ul><div class="code-wrapper"><pre><code class="hljs c">QAbstractItemView::EditTriggers <span class="hljs-title function_">editTriggers</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setEditTriggers</span><span class="hljs-params">(QAbstractItemView::EditTriggers triggers)</span>QAbstractItemView::NoEditTriggers不允许编辑QAbstractItemView::CurrentChanged当前项发生更改才能编辑QAbstractItemView::DoubleClicked被双击时能编辑QAbstractItemView::SelectedClicked当单击已选中的单元格才能编辑QAbstractItemView::EditKeyPressed当在项目上按下编辑键时才能编辑。QAbstractItemView::AnyKeyPressed当在项目上按下任何键时才能编辑QAbstractItemView::AllEditTriggers包含以上所有编辑操作</code></pre></div><ul><li>获取和设置表格选择方式</li></ul><div class="code-wrapper"><pre><code class="hljs c">QAbstractItemView::SelectionBehavior <span class="hljs-title function_">selectionBehavior</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setSelectionBehavior</span><span class="hljs-params">(QAbstractItemView::SelectionBehavior behavior)</span>QAbstractItemView::SelectItems    选中单个单元格QAbstractItemView::SelectRows     选中一行QAbstractItemView::SelectColumns  选中一列</code></pre></div><ul><li>获取和设置表格选择模式</li></ul><div class="code-wrapper"><pre><code class="hljs c">QAbstractItemView::SelectionMode <span class="hljs-title function_">selectionMode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setSelectionMode</span><span class="hljs-params">(QAbstractItemView::SelectionMode mode)</span>QAbstractItemView::NoSelection  不可选择QAbstractItemView::SingleSelection  单行选择QAbstractItemView::MultiSelection 多行选择QAbstractItemView::ExtendedSelection 扩展选择，按shift键或ctrl键可以选中多行QAbstractItemView::ContiguousSelection  相邻选择，按shift键选中一个范围内的行</code></pre></div><ul><li>获取和设置指定行列位置的单元格</li></ul><div class="code-wrapper"><pre><code class="hljs c">QTableWidgetItem *<span class="hljs-title function_">item</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setItem</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column, QTableWidgetItem *item)</span></code></pre></div><ul><li>获取和设置行列数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rowCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setRowCount</span><span class="hljs-params">(<span class="hljs-type">int</span> rows)</span><span class="hljs-type">int</span> <span class="hljs-title function_">columnCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setColumnCount</span><span class="hljs-params">(<span class="hljs-type">int</span> columns)</span><span class="hljs-type">int</span> <span class="hljs-title function_">currentRow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">currentColumn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">insertRow</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">insertColumn</span><span class="hljs-params">(<span class="hljs-type">int</span> column)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">removeRow</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">removeColumn</span><span class="hljs-params">(<span class="hljs-type">int</span> column)</span>;</code></pre></div><ul><li>设置行、列头标签</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">setHorizontalHeaderLabels</span><span class="hljs-params">(<span class="hljs-type">const</span> QStringList &amp;labels)</span><span class="hljs-type">void</span> <span class="hljs-title function_">setVerticalHeaderLabels</span><span class="hljs-params">(<span class="hljs-type">const</span> QStringList &amp;labels)</span></code></pre></div><ul><li>设置列宽度</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">QHeaderView::setSectionResizeMode</span><span class="hljs-params">(QHeaderView::ResizeMode mode)</span>    HeaderView::Interactive  用户可拖动改变列宽QHeaderView::Fixed  固定列宽QHeaderView::Stretch 自适应列宽大小QHeaderView::ResizeToContents  根据内容设置列宽</code></pre></div><h3 id="信号与槽">信号与槽</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cellClicked</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span><span class="hljs-type">void</span> <span class="hljs-title function_">cellDoubleClicked</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemClicked</span><span class="hljs-params">(QTableWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemDoubleClicked</span><span class="hljs-params">(QTableWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">clearContents</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertColumn</span><span class="hljs-params">(<span class="hljs-type">int</span> column)</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertRow</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span><span class="hljs-type">void</span> <span class="hljs-title function_">removeColumn</span><span class="hljs-params">(<span class="hljs-type">int</span> column)</span><span class="hljs-type">void</span> <span class="hljs-title function_">removeRow</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span><span class="hljs-type">void</span> <span class="hljs-title function_">scrollToItem</span><span class="hljs-params">(<span class="hljs-type">const</span> QTableWidgetItem *item, QAbstractItemView::ScrollHint hint = EnsureVisible)</span></code></pre></div><h3 id="实例">实例</h3><p>新建工程，进入UI设计界面，进行如下设计：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230703221825023.png" alt="" /><figcaption>image-20230703221825023</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 首先需要设置行列数 */</span>    ui-&gt;tableWidget-&gt;setColumnCount(<span class="hljs-number">4</span>);    ui-&gt;tableWidget-&gt;setRowCount(<span class="hljs-number">1</span>);    <span class="hljs-comment">/* 添加行标签 */</span>    QStringList horizontalHeaderLabel;    horizontalHeaderLabel &lt;&lt; <span class="hljs-string">&quot;姓名&quot;</span> &lt;&lt; <span class="hljs-string">&quot;性别&quot;</span> &lt;&lt; <span class="hljs-string">&quot;年龄&quot;</span> &lt;&lt; <span class="hljs-string">&quot;籍贯&quot;</span>;    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(horizontalHeaderLabel);    <span class="hljs-comment">/* 添加初始化数据 */</span>    QTableWidgetItem *nameItem = new QTableWidgetItem(<span class="hljs-string">&quot;李彤&quot;</span>);    QTableWidgetItem *genderItem = new QTableWidgetItem(<span class="hljs-string">&quot;女&quot;</span>);    QTableWidgetItem *ageItem = new QTableWidgetItem(QString::number(<span class="hljs-number">20</span>));    QTableWidgetItem *provinceItem = new QTableWidgetItem(<span class="hljs-string">&quot;上海&quot;</span>);    ui-&gt;tableWidget-&gt;setItem(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,nameItem);    ui-&gt;tableWidget-&gt;setItem(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,genderItem);    ui-&gt;tableWidget-&gt;setItem(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,ageItem);    ui-&gt;tableWidget-&gt;setItem(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,provinceItem);    <span class="hljs-comment">/* 调节行高和列宽 */</span><span class="hljs-comment">//    ui-&gt;tableWidget-&gt;resizeRowsToContents();</span><span class="hljs-comment">//    ui-&gt;tableWidget-&gt;resizeColumnsToContents();</span>    ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setSectionResizeMode(QHeaderView::ResizeToContents);    ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setSectionResizeMode(QHeaderView::Interactive);    <span class="hljs-comment">/* 行列表头标签设置 */</span>    connect(ui-&gt;chekBox_row, &amp;QCheckBox::stateChanged, this, [=](<span class="hljs-type">int</span> state)&#123;        state = ui-&gt;chekBox_row-&gt;checkState(); <span class="hljs-comment">//获得当前checkBox状态</span>        <span class="hljs-keyword">if</span>(state == Qt::Unchecked)        &#123;            ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;hide();        &#125;        <span class="hljs-keyword">if</span>(state == Qt::Checked)        &#123;            ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;show();        &#125;    &#125;);    connect(ui-&gt;chekBox_column, &amp;QCheckBox::stateChanged, this, [=](<span class="hljs-type">int</span> state)&#123;        state = ui-&gt;chekBox_column-&gt;checkState();        <span class="hljs-keyword">if</span>(state == Qt::Unchecked)        &#123;            ui-&gt;tableWidget-&gt;verticalHeader()-&gt;hide();        &#125;        <span class="hljs-keyword">if</span>(state == Qt::Checked)        &#123;            ui-&gt;tableWidget-&gt;verticalHeader()-&gt;show();        &#125;    &#125;);    <span class="hljs-comment">/* 设置表格可编辑 */</span>    connect(ui-&gt;chekBox_editable, &amp;QCheckBox::stateChanged, this, [=](<span class="hljs-type">int</span> state)&#123;        state = ui-&gt;chekBox_editable-&gt;checkState();        <span class="hljs-keyword">if</span>(state == Qt::Unchecked)        &#123;            ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);        &#125;        <span class="hljs-keyword">if</span>(state == Qt::Checked)        &#123;            ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::DoubleClicked | QAbstractItemView::EditKeyPressed);        &#125;    &#125;);    <span class="hljs-comment">/* 交替显示背景 */</span>    connect(ui-&gt;chekBox_color, &amp;QCheckBox::stateChanged, this, [=](<span class="hljs-type">int</span> state)&#123;        state = ui-&gt;chekBox_color-&gt;checkState();        <span class="hljs-keyword">if</span>(state == Qt::Unchecked)        &#123;            ui-&gt;tableWidget-&gt;setAlternatingRowColors(<span class="hljs-literal">false</span>);        &#125;        <span class="hljs-keyword">if</span>(state == Qt::Checked)        &#123;            ui-&gt;tableWidget-&gt;setAlternatingRowColors(<span class="hljs-literal">true</span>);        &#125;    &#125;);    <span class="hljs-comment">/* 选择方式 */</span>    connect(ui-&gt;radioBtn_cell, &amp;QRadioButton::clicked, this, [=]()&#123;        <span class="hljs-keyword">if</span>(ui-&gt;radioBtn_cell-&gt;isChecked())        &#123;            ui-&gt;tableWidget-&gt;setSelectionBehavior(QAbstractItemView::SelectItems);        &#125;    &#125;);    connect(ui-&gt;radioBtn_row, &amp;QRadioButton::clicked, this, [=]()&#123;        <span class="hljs-keyword">if</span>(ui-&gt;radioBtn_row-&gt;isChecked())        &#123;            ui-&gt;tableWidget-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);        &#125;    &#125;);    connect(ui-&gt;radioBtn_column, &amp;QRadioButton::clicked, this, [=]()&#123;        <span class="hljs-keyword">if</span>(ui-&gt;radioBtn_column-&gt;isChecked())        &#123;            ui-&gt;tableWidget-&gt;setSelectionBehavior(QAbstractItemView::SelectColumns);        &#125;    &#125;);    <span class="hljs-comment">/* 添加一行 */</span>    connect(ui-&gt;btn_addRow, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> rows = ui-&gt;tableWidget-&gt;rowCount();        ui-&gt;tableWidget-&gt;setRowCount(rows + <span class="hljs-number">1</span>);    &#125;);    <span class="hljs-comment">/* 添加一列 */</span>    connect(ui-&gt;btn_addColumn, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> columns = ui-&gt;tableWidget-&gt;columnCount();        ui-&gt;tableWidget-&gt;setColumnCount(columns + <span class="hljs-number">1</span>);    &#125;);    <span class="hljs-comment">/* 插入一行 */</span>    connect(ui-&gt;btn_insertRow, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> currentRow = ui-&gt;tableWidget-&gt;currentRow();        ui-&gt;tableWidget-&gt;insertRow(currentRow);    &#125;);    <span class="hljs-comment">/* 插入一列 */</span>    connect(ui-&gt;btn_insertColumn, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> currentColumn = ui-&gt;tableWidget-&gt;currentColumn();        ui-&gt;tableWidget-&gt;insertColumn(currentColumn);    &#125;);    <span class="hljs-comment">/* 删除一行 */</span>    connect(ui-&gt;btn_deleteRow, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> currentRow = ui-&gt;tableWidget-&gt;currentRow();        ui-&gt;tableWidget-&gt;removeRow(currentRow);    &#125;);    <span class="hljs-comment">/* 删除一列 */</span>    connect(ui-&gt;btn_deleteColumn, &amp;QPushButton::clicked, this, [=]()&#123;        <span class="hljs-type">int</span> currentColumn = ui-&gt;tableWidget-&gt;currentColumn();        ui-&gt;tableWidget-&gt;removeColumn(currentColumn);    &#125;);    <span class="hljs-comment">/* 清空表格内容 */</span>    connect(ui-&gt;btn_clearContens, &amp;QPushButton::clicked, this, [=]()&#123;        ui-&gt;tableWidget-&gt;clearContents();    &#125;);    <span class="hljs-comment">/* 清空表格 */</span>    connect(ui-&gt;btn_deleteAll, &amp;QPushButton::clicked, this, [=]()&#123;        ui-&gt;tableWidget-&gt;clear();    &#125;);&#125;</code></pre></div><p>效果:</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230703221332574.png" alt="image-20230703221332574" style="zoom: 80%;" /></p><p>工程文件：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/tableWidget.zip">tableWidget</a></p><p>参考链接：</p><p>http://t.csdn.cn/pwGUJ</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之列表框QListWidget</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%88%97%E8%A1%A8%E6%A1%86QListWidget/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%88%97%E8%A1%A8%E6%A1%86QListWidget/</url>
    
    <content type="html"><![CDATA[<p>QListWidget用于显示结构简单的列表，相对于父类<strong>QListView</strong>，它是“简易版”的 QListView，创建和使用列表的方式更简单、门槛更低。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702185955407.png" alt="image-20230702185955407" style="zoom:67%;" /></p><p>QListWidget 类的继承关系如下：</p><p><code>QListWidget -&gt; QListView -&gt; QAbstractItemView -&gt; QAbstractScrollArea -&gt; QFrame -&gt; QWidget</code></p><h3 id="属性和方法">属性和方法</h3><ul><li>获取和设置显示模式（可以在属性窗口设置，也可以用以下代码实现）</li></ul><div class="code-wrapper"><pre><code class="hljs c">QListView::ViewMode <span class="hljs-title function_">viewMode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setViewMode</span><span class="hljs-params">(QListView::ViewMode mode)</span>QListView::ListMode  <span class="hljs-comment">//列表模式</span>QListView::IconMode  <span class="hljs-comment">//图标模式</span></code></pre></div><ul><li>添加条目</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">addItem</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;label)</span><span class="hljs-type">void</span> <span class="hljs-title function_">addItem</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">addItems</span><span class="hljs-params">(<span class="hljs-type">const</span> QStringList &amp;labels)</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">insertItem</span><span class="hljs-params">(<span class="hljs-type">int</span> row, QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertItem</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">const</span> QString &amp;label)</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertItems</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">const</span> QStringList &amp;labels)</span></code></pre></div><ul><li>删除条目</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 方法一 */</span>QListWidgetItem* item = ui-&gt;lwProvince-&gt;currentItem();ui-&gt;lwProvince-&gt;removeItemWidget(item);delete item;<span class="hljs-comment">/* 方法二 */</span><span class="hljs-type">int</span> row = ui-&gt;lwProvince-&gt;currentRow();QListWidgetItem* item = ui-&gt;lwProvince-&gt;takeItem(row);delete item;<span class="hljs-type">void</span> <span class="hljs-title function_">QListWidget::clear</span><span class="hljs-params">()</span><span class="hljs-comment">// 清空整个列表</span></code></pre></div><ul><li>信号</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">currentItemChanged</span><span class="hljs-params">(QListWidgetItem *current, QListWidgetItem *previous)</span><span class="hljs-type">void</span> <span class="hljs-title function_">currentRowChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> currentRow)</span><span class="hljs-type">void</span> <span class="hljs-title function_">currentTextChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;currentText)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemActivated</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemChanged</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemClicked</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemDoubleClicked</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemEntered</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemPressed</span><span class="hljs-params">(QListWidgetItem *item)</span><span class="hljs-type">void</span> <span class="hljs-title function_">itemSelectionChanged</span><span class="hljs-params">()</span></code></pre></div><h3 id="实例">实例</h3><p>新建工程，进入UI设计界面，设计如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702195728641.png" alt="" /><figcaption>image-20230702195728641</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 默认选中列表 */</span>    ui-&gt;radioButton_list-&gt;setChecked(<span class="hljs-literal">true</span>);    ui-&gt;listWidget-&gt;setViewMode(QListView::ListMode);    <span class="hljs-comment">/* radioBtn与listWidget对应 */</span>    connect(ui-&gt;radioButton_list, &amp;QRadioButton::clicked, this, [=]()&#123;       ui-&gt;listWidget-&gt;setViewMode(QListView::ListMode);<span class="hljs-comment">//列表模式</span>    &#125;);    connect(ui-&gt;radioButton_icon, &amp;QRadioButton::clicked, this, [=]()&#123;        ui-&gt;listWidget-&gt;setViewMode(QListView::IconMode);<span class="hljs-comment">//图标模式</span>    &#125;);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_add_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> iconIndex = QRandomGenerator::global()-&gt;bounded(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">//产生随机数1~5</span>    QString fileName = <span class="hljs-string">&quot;:/pic/city&quot;</span> + QString::number(iconIndex) + <span class="hljs-string">&quot;.png&quot;</span>;    QIcon <span class="hljs-title function_">icon</span><span class="hljs-params">(fileName)</span>;    QString str = ui-&gt;lineEdit-&gt;text();    QListWidgetItem *item = new QListWidgetItem(icon, str);    ui-&gt;listWidget-&gt;addItem(item);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_insert_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> iconIndex = QRandomGenerator::global()-&gt;bounded(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">//产生随机数1~5</span>    QString fileName = <span class="hljs-string">&quot;:/pic/city&quot;</span> + QString::number(iconIndex) + <span class="hljs-string">&quot;.png&quot;</span>;    QIcon <span class="hljs-title function_">icon</span><span class="hljs-params">(fileName)</span>;    QString str = ui-&gt;lineEdit-&gt;text();    <span class="hljs-type">int</span> row = ui-&gt;listWidget-&gt;currentRow();    QListWidgetItem *item = new QListWidgetItem(icon, str);    ui-&gt;listWidget-&gt;insertItem(row, item);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_del_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 方法一 */</span>    QListWidgetItem *item = ui-&gt;listWidget-&gt;currentItem();    ui-&gt;listWidget-&gt;removeItemWidget(item);    delete item;    <span class="hljs-comment">/* 方法二 */</span><span class="hljs-comment">//    int row = ui-&gt;listWidget-&gt;currentRow();</span><span class="hljs-comment">//    QListWidgetItem *item = ui-&gt;listWidget-&gt;takeItem(row);</span><span class="hljs-comment">//    delete item;</span>&#125;</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702212610974.png" alt="image-20230702212610974" style="zoom:67%;" /></p><p>工程代码：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/listWidget.zip">listWidget</a></p><p>参考链接：</p><p>http://t.csdn.cn/QPdEH</p><p>http://t.csdn.cn/O8I4u</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之进度条QProgressBar</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E8%BF%9B%E5%BA%A6%E6%9D%A1QProgressBar/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E8%BF%9B%E5%BA%A6%E6%9D%A1QProgressBar/</url>
    
    <content type="html"><![CDATA[<p><strong>QProgressBar</strong> 是一种横向或者纵向显示进度的控件，用来描述任务的完成情况。QProgressBar 继承于QWidget。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702155213581.png" alt="image-20230702155213581" style="zoom:67%;" /></p><h3 id="主要属性和方法">主要属性和方法</h3><ul><li>获取和设置当前值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;ui-&gt;progressBar-&gt;setValue(<span class="hljs-number">30</span>);  <span class="hljs-comment">//设置当前显示值</span></code></pre></div><ul><li>获取和设置最大、最小值。如果最小值和最大值都设置为0，进度条会显示了一个繁忙指示，而不会显示当前的值。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maximum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setMaximum</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">minimum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;ui-&gt;progressBar-&gt;setMinimum(<span class="hljs-number">0</span>);  <span class="hljs-comment">//设置最小值</span>ui-&gt;progressBar-&gt;setMaximum(<span class="hljs-number">100</span>);  <span class="hljs-comment">//设置最大值</span></code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702155419973.png" alt="image-20230702155419973" style="zoom:67%;" /></p><ul><li>获取和设置滑动条的方向</li></ul><div class="code-wrapper"><pre><code class="hljs c">Qt::Orientation <span class="hljs-title function_">orientation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setOrientation</span><span class="hljs-params">(Qt::Orientation)</span>ui-&gt;progressBar-&gt;<span class="hljs-title function_">setOrientation</span><span class="hljs-params">(Qt::Horizontal)</span>;  <span class="hljs-comment">//设置显示方向</span></code></pre></div><ul><li>获取和设置进度条的文本是否显示</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isTextVisible</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setTextVisible</span><span class="hljs-params">(<span class="hljs-type">bool</span> visible)</span>ui-&gt;progressBar-&gt;<span class="hljs-title function_">setTextVisible</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>;  <span class="hljs-comment">//设置文字可见</span></code></pre></div><ul><li>获取和设置显示文字的格式，“%p%”显示百分比，“%v”显示当前值，“%m”显示总步数。缺省为“%p%”</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">format</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;format)</span>ui-&gt;progressBar-&gt;<span class="hljs-title function_">setFormat</span><span class="hljs-params">(<span class="hljs-string">&quot;%p%&quot;</span>)</span>;  <span class="hljs-comment">//设置文字显示格式</span></code></pre></div><h3 id="信号">信号</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">valueChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></code></pre></div><h3 id="实例">实例</h3><p>创建新工程，在UI设计界面，拖拽相应控件，修改控件名字，完成布局。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702154508118.png" alt="" /><figcaption>image-20230702154508118</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 通过代码设置属性 */</span>    ui-&gt;progBar_download-&gt;setRange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);    ui-&gt;progBar_download-&gt;setValue(<span class="hljs-number">0</span>); <span class="hljs-comment">//初始值为0</span>    ui-&gt;label_download-&gt;setText(<span class="hljs-string">&quot;&quot;</span>);    ui-&gt;label_copy-&gt;setText(<span class="hljs-string">&quot;&quot;</span>);    <span class="hljs-comment">/* 创建download定时器，并设置时间间隔50ms */</span>    m_timer_download = new QTimer();    m_timer_download-&gt;setInterval(<span class="hljs-number">50</span>);    <span class="hljs-comment">/* 创建copy定时器，并设置时间间隔5ms */</span>    m_timer_copy = new QTimer();    m_timer_copy-&gt;setInterval(<span class="hljs-number">5</span>);    <span class="hljs-comment">/* 点击下载按钮开启计时 */</span>    connect(ui-&gt;btn_download, &amp;QPushButton::clicked, this, [=]()&#123;        ui-&gt;progBar_download-&gt;reset(); <span class="hljs-comment">//便于重新开起下载</span>        m_timer_download-&gt;start();        ui-&gt;label_download-&gt;setText(<span class="hljs-string">&quot;下载中...&quot;</span>);    &#125;);    <span class="hljs-comment">/* 定时时间间隔到，执行槽函数 */</span>    connect(m_timer_download, &amp;QTimer::timeout, this, &amp;Widget::timer1_timeout_slot);    <span class="hljs-comment">/* 点击拷贝按钮开启计时 */</span>    connect(ui-&gt;btn_copy, &amp;QPushButton::clicked, this, [=]()&#123;        ui-&gt;progBar_copy-&gt;reset(); <span class="hljs-comment">//便于重新开起拷贝</span>        m_timer_copy-&gt;start();        ui-&gt;label_copy-&gt;setText(<span class="hljs-string">&quot;拷贝中...&quot;</span>);    &#125;);    <span class="hljs-comment">/* 定时时间间隔到，执行槽函数 */</span>    connect(m_timer_copy, &amp;QTimer::timeout, this, &amp;Widget::timer2_timeout_slot);&#125;Widget::~Widget()&#123;    delete ui;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::timer1_timeout_slot</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">if</span>(ui-&gt;progBar_download-&gt;value() == ui-&gt;progBar_download-&gt;maximum())    &#123;        this-&gt;m_timer_download-&gt;stop();<span class="hljs-comment">//下载完成，停止计时</span>        ui-&gt;label_download-&gt;setText(<span class="hljs-string">&quot;下载完成!&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;progBar_download-&gt;setValue(ui-&gt;progBar_download-&gt;value() + <span class="hljs-number">1</span>);<span class="hljs-comment">//每隔50ms值加1</span>    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::timer2_timeout_slot</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">if</span>(ui-&gt;progBar_copy-&gt;value() == ui-&gt;progBar_copy-&gt;maximum())    &#123;        this-&gt;m_timer_copy-&gt;stop();        ui-&gt;label_copy-&gt;setText(<span class="hljs-string">&quot;拷贝完成!&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;progBar_copy-&gt;setValue(ui-&gt;progBar_copy-&gt;value() + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre></div><p>效果如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702154802368.png" alt="image-20230702154802368" style="zoom:67%;" /></p><p>工程文件：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/progressBar.zip">progressBar</a></p><p>参考链接：</p><p>http://t.csdn.cn/sxHV9</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之微调框QSpinBox</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%BE%AE%E8%B0%83%E6%A1%86QSpinBox/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%BE%AE%E8%B0%83%E6%A1%86QSpinBox/</url>
    
    <content type="html"><![CDATA[<p>QSpinBox 用于整数的显示和输入，QDoubleSpinBox则用于显示和输入浮点值。它们均派生自QAbstractSPinBox类，具有大多数相同的属性，只是参数类型不同（一个 <code>int</code>，一个<code>double</code>）。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702162506764.png" alt="image-20230702162506764" style="zoom:67%;" /></p><p>修改微调框数值的方式包括：</p><ul><li>单击右侧的向上/向下按钮</li><li>按键盘的向上/向下键</li><li>在微调框获取焦点时，通过鼠标滚轮的上下滚动</li></ul><h3 id="属性和方法">属性和方法</h3><ul><li>获取和设置当前值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></code></pre></div><ul><li>获取和设置最大、最小值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maximum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setMaximum</span><span class="hljs-params">(<span class="hljs-type">int</span> max)</span><span class="hljs-type">int</span> <span class="hljs-title function_">minimum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span> min)</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">setRange</span><span class="hljs-params">(<span class="hljs-type">int</span> minimum, <span class="hljs-type">int</span> maximum)</span></code></pre></div><ul><li>获取和设置步长</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">singleStep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setSingleStep</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></code></pre></div><ul><li>获取和设置变化值是否循环改变</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">wrapping</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setWrapping</span><span class="hljs-params">(<span class="hljs-type">bool</span> w)</span></code></pre></div><ul><li>获取和设置是否加速数值变化速度</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isAccelerated</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setAccelerated</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></code></pre></div><ul><li>获取和设置前缀和后缀</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">prefix</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setPrefix</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;prefix)</span>QString <span class="hljs-title function_">suffix</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setSuffix</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;suffix)</span></code></pre></div><ul><li>信号</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">textChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span><span class="hljs-type">void</span> <span class="hljs-title function_">valueChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-type">void</span> <span class="hljs-title function_">valueChanged</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span></code></pre></div><h3 id="实例">实例</h3><p>创建工程，进入UI设计界面，设计如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702170608521.png" alt="" /><figcaption>image-20230702170608521</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 设置SpinBox初始属性 */</span>    ui-&gt;spinBox_weight-&gt;setSuffix(<span class="hljs-string">&quot;kg&quot;</span>); <span class="hljs-comment">//后缀</span>    ui-&gt;spinBox_weight-&gt;setRange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">//范围0~100</span>    ui-&gt;spinBox_weight-&gt;setSingleStep(<span class="hljs-number">1</span>); <span class="hljs-comment">//步长为1</span>    ui-&gt;spinBox_weight-&gt;setAccelerated(<span class="hljs-literal">true</span>); <span class="hljs-comment">//允许加速</span>    ui-&gt;spinBox_weight-&gt;setWrapping(<span class="hljs-literal">true</span>); <span class="hljs-comment">//允许循环</span>    connect(ui-&gt;doubleSpinBox_price, SIGNAL(valueChanged(<span class="hljs-type">double</span>)), this, SLOT(price_value_slot(<span class="hljs-type">double</span>)));    connect(ui-&gt;spinBox_weight, SIGNAL(valueChanged(<span class="hljs-type">int</span>)), this, SLOT(weight_value_slot(<span class="hljs-type">int</span>)));&#125;Widget::~Widget()&#123;    delete ui;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::price_value_slot</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span>&#123;    <span class="hljs-type">double</span> total = ui-&gt;spinBox_weight-&gt;value() * price;    ui-&gt;lineEdit_total-&gt;setText(QString::number(total) + <span class="hljs-string">&quot;元&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::weight_value_slot</span><span class="hljs-params">(<span class="hljs-type">int</span> weight)</span>&#123;    <span class="hljs-type">double</span> total = ui-&gt;doubleSpinBox_price-&gt;value() * weight;    ui-&gt;lineEdit_total-&gt;setText(QString::number(total) + <span class="hljs-string">&quot;元&quot;</span>);&#125;</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702173148063.png" alt="image-20230702173148063" style="zoom:67%;" /></p><p>工程代码：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/spinBox.zip">spinBox</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之滑动条QSlider</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%BB%91%E5%8A%A8%E6%9D%A1QSlider/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%BB%91%E5%8A%A8%E6%9D%A1QSlider/</url>
    
    <content type="html"><![CDATA[<p>QSlider 是滑动条控件，滑动条可以在一个范围内拖动，并将其位置转换为整数。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702175627021.png" alt="image-20230702175627021" style="zoom:67%;" /></p><h3 id="属性和方法">属性和方法</h3><p>QSlider 绝大多数属性和方法都是从 <strong>QAbstractSlider</strong> 继承而来。</p><ul><li>获取和设置当前值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;</code></pre></div><ul><li>获取和设置最大、最小值</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maximum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setMaximum</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">minimum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setMinimum</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setRange</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)</span></code></pre></div><ul><li>获取和设置滑动条的方向</li></ul><div class="code-wrapper"><pre><code class="hljs c">Qt::Orientation <span class="hljs-title function_">orientation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setOrientation</span><span class="hljs-params">(Qt::Orientation)</span>;</code></pre></div><ul><li>获取和设置步长</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 键盘的左右箭头 */</span><span class="hljs-type">int</span> <span class="hljs-title function_">singleStep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setSingleStep</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">/* 键盘的PageUp PageDown */</span><span class="hljs-type">int</span> <span class="hljs-title function_">pageStep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setPageStep</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;</code></pre></div><ul><li>获取和设置刻度位置</li></ul><div class="code-wrapper"><pre><code class="hljs c">QSlider::TickPosition <span class="hljs-title function_">tickPosition</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setTickPosition</span><span class="hljs-params">(QSlider::TickPosition position)</span>    QSlider::NoTicks            <span class="hljs-comment">//不显示刻度</span>QSlider::TicksBothSides     <span class="hljs-comment">//标尺两侧都显示刻度</span>QSlider::TicksAbove         <span class="hljs-comment">//标尺上方显示刻度</span>QSlider::TicksBelow         <span class="hljs-comment">//标尺下方显示刻度</span>QSlider::TicksLeft          <span class="hljs-comment">//标尺左侧显示刻度</span>QSlider::TicksRight         <span class="hljs-comment">//标尺右侧显示刻度    </span></code></pre></div><ul><li>信号</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">valueChanged</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">sliderPressed</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">sliderMoved</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">sliderReleased</span><span class="hljs-params">()</span></code></pre></div><h3 id="实例">实例</h3><p>新建工程，进入UI设计界面，设计如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702182410401.png" alt="" /><figcaption>image-20230702182410401</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 横向滑动条属性在UI界面已经设置，下面进行竖向滑动条属性设置 */</span>ui-&gt;slider_v-&gt;setRange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);ui-&gt;slider_v-&gt;setSingleStep(<span class="hljs-number">1</span>);ui-&gt;slider_v-&gt;setPageStep(<span class="hljs-number">10</span>);ui-&gt;slider_v-&gt;setTickPosition(QSlider::TicksRight);ui-&gt;slider_v-&gt;setTickInterval(<span class="hljs-number">5</span>);<span class="hljs-comment">/* 数值改变将值显示在文本框中 */</span>connect(ui-&gt;slider_h, &amp;QSlider::valueChanged, this, [=]()&#123;    <span class="hljs-type">int</span> value = ui-&gt;slider_h-&gt;value();    ui-&gt;lineEdit_value-&gt;setText(QString::number(value));&#125;);connect(ui-&gt;slider_v, &amp;QSlider::valueChanged, this, [=]()&#123;    <span class="hljs-type">int</span> value = ui-&gt;slider_v-&gt;value();    ui-&gt;lineEdit_value-&gt;setText(QString::number(value));&#125;);</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230702183709747.png" alt="image-20230702183709747" style="zoom:67%;" /></p><p>工程代码：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/slider.zip">slider</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之组合框QComboBox</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%BB%84%E5%90%88%E6%A1%86QComboBox/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%BB%84%E5%90%88%E6%A1%86QComboBox/</url>
    
    <content type="html"><![CDATA[<p>Qt中组合框（QComboBox）提供了一种占用空间最小的方式，其表现形式如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701112012020.png" alt="image-20230701112012020" style="zoom:67%;" /></p><h3 id="属性">属性</h3><ul><li><code>count: const int</code> --&gt;组合框中的项目数</li><li><code>currentData : const QVariant</code> --&gt;当前项目的数据</li><li><code>currentIndex : int</code> --&gt;组合框中当前项目的索引</li><li><code>currentText : QString</code> --&gt;当前文本</li><li><code>insertPolicy : InsertPolicy</code> --&gt;插入的项目在组合框中的位置策略</li><li><code>maxCount : int</code> --&gt;组合框中允许的最大项目数</li><li><code>minimumContentsLength : int</code> --&gt;组合框的最小字符数</li><li><code>modelColumn : int</code> --&gt;模型中可见的列</li><li><code>sizeAdjustPolicy : SizeAdjustPolicy</code> --&gt;组合框大小的更改策略</li></ul><h3 id="信号">信号</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">activated</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>  <span class="hljs-comment">//当选择组合框中的项目时发送此信号。</span><span class="hljs-type">void</span> <span class="hljs-title function_">currentIndexChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>  <span class="hljs-comment">//当组合框中的 currentIndex更改时，就会发送此信号。如果组合框变空则index为 -1。 </span><span class="hljs-type">void</span> <span class="hljs-title function_">currentTextChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span>  <span class="hljs-comment">//当组合框中的项目更改时，就会发送此信号。</span><span class="hljs-type">void</span> <span class="hljs-title function_">editTextChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span> <span class="hljs-comment">//当组合框的行编辑小部件中的文本发生更改时，会发出此信号。</span></code></pre></div><h3 id="槽函数与成员函数">槽函数与成员函数</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>  <span class="hljs-comment">//清除组合框，删除所有项目。</span><span class="hljs-type">void</span> <span class="hljs-title function_">clearEditText</span><span class="hljs-params">()</span>  <span class="hljs-comment">//清除组合框中用于编辑的行编辑的内容。</span><span class="hljs-type">void</span> <span class="hljs-title function_">setCurrentIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>  <span class="hljs-comment">//设置当前项目索引</span><span class="hljs-type">void</span> <span class="hljs-title function_">setCurrentText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span> <span class="hljs-comment">//设置当前项目文字</span><span class="hljs-type">void</span> <span class="hljs-title function_">setEditText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span>  <span class="hljs-comment">//设置项目编辑的文字</span><span class="hljs-comment">/* 添加项目和删除项目及获取或设置项目 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">addItem</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">const</span> QVariant &amp;userData = QVariant())</span><span class="hljs-type">void</span> <span class="hljs-title function_">addItem</span><span class="hljs-params">(<span class="hljs-type">const</span> QIcon &amp;icon, <span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">const</span> QVariant &amp;userData = QVariant())</span><span class="hljs-type">void</span> <span class="hljs-title function_">addItems</span><span class="hljs-params">(<span class="hljs-type">const</span> QStringList &amp;texts)</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">insertItem</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">const</span> QVariant &amp;userData = QVariant())</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertItem</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> QIcon &amp;icon, <span class="hljs-type">const</span> QString &amp;text, <span class="hljs-type">const</span> QVariant &amp;userData = QVariant())</span><span class="hljs-type">void</span> <span class="hljs-title function_">insertItems</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> QStringList &amp;<span class="hljs-built_in">list</span>)</span><span class="hljs-type">void</span> <span class="hljs-title function_">removeItem</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><span class="hljs-type">void</span> <span class="hljs-title function_">setInsertPolicy</span><span class="hljs-params">(QComboBox::InsertPolicy policy)</span> <span class="hljs-comment">//设置插入策略</span><span class="hljs-type">int</span> <span class="hljs-title function_">currentIndex</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>QString <span class="hljs-title function_">currentText</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">setItemText</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> QString &amp;text)</span></code></pre></div><p>这里主要说一下增加项目的方法，既可以通过以上函数增加，也可以在UI设计界面进行增加</p><ul><li>通过函数</li></ul><div class="code-wrapper"><pre><code class="hljs c">QStringList cityList = &#123;<span class="hljs-string">&quot;广州市&quot;</span>, <span class="hljs-string">&quot;深圳市&quot;</span>, <span class="hljs-string">&quot;珠海市&quot;</span>, <span class="hljs-string">&quot;东莞市&quot;</span>&#125;;<span class="hljs-comment">// 添加城市</span>ui-&gt;comboBox_province-&gt;addItem(<span class="hljs-string">&quot;广东省&quot;</span>);ui-&gt;comboBox_city-&gt;addItems(cityList);</code></pre></div><ul><li>在组合框上右键-&gt;【编辑项目…】，在打开的编辑窗口中可以增加删除条目</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701132003241.png" alt="image-20230701132003241" style="zoom:67%;" /></p><h3 id="案例">案例</h3><p>创建一个基类为QWidget的工程，如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701182531243.png" alt="" /><figcaption>image-20230701182531243</figcaption></figure><p>下面进行工程实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 创建城市列表 */</span>    gdCityList = QStringList&#123;<span class="hljs-string">&quot;广州市&quot;</span>, <span class="hljs-string">&quot;深圳市&quot;</span>, <span class="hljs-string">&quot;珠海市&quot;</span>&#125;;    hnCityList = QStringList&#123;<span class="hljs-string">&quot;郑州市&quot;</span>, <span class="hljs-string">&quot;洛阳市&quot;</span>, <span class="hljs-string">&quot;信阳市&quot;</span>&#125;;    hbCityList = QStringList&#123;<span class="hljs-string">&quot;武汉市&quot;</span>, <span class="hljs-string">&quot;黄石市&quot;</span>, <span class="hljs-string">&quot;宜昌市&quot;</span>&#125;;    sdCityList = QStringList&#123;<span class="hljs-string">&quot;济南市&quot;</span>, <span class="hljs-string">&quot;青岛市&quot;</span>, <span class="hljs-string">&quot;烟台市&quot;</span>&#125;;    zjCityList = QStringList&#123;<span class="hljs-string">&quot;杭州市&quot;</span>, <span class="hljs-string">&quot;宁波市&quot;</span>, <span class="hljs-string">&quot;温州市&quot;</span>&#125;;    <span class="hljs-comment">/* 创建大学列表 */</span>    gdUniversityList = QStringList&#123;<span class="hljs-string">&quot;中山大学&quot;</span>, <span class="hljs-string">&quot;广州大学&quot;</span>, <span class="hljs-string">&quot;深圳大学&quot;</span>, <span class="hljs-string">&quot;南方科技大学&quot;</span>&#125;;    hnUniversityList = QStringList&#123;<span class="hljs-string">&quot;郑州大学&quot;</span>, <span class="hljs-string">&quot;河南大学&quot;</span>, <span class="hljs-string">&quot;信阳师范大学&quot;</span>, <span class="hljs-string">&quot;河南科技大学&quot;</span>&#125;;    hbUniversityList = QStringList&#123;<span class="hljs-string">&quot;武汉大学&quot;</span>, <span class="hljs-string">&quot;华中科技大学&quot;</span>, <span class="hljs-string">&quot;湖北师范大学&quot;</span>, <span class="hljs-string">&quot;三峡大学&quot;</span>&#125;;    sdUniversityList = QStringList&#123;<span class="hljs-string">&quot;济南大学&quot;</span>, <span class="hljs-string">&quot;青岛大学&quot;</span>, <span class="hljs-string">&quot;青岛理工大学&quot;</span>, <span class="hljs-string">&quot;烟台大学&quot;</span>&#125;;    zjUniversityList = QStringList&#123;<span class="hljs-string">&quot;浙江大学&quot;</span>, <span class="hljs-string">&quot;杭州师范大学&quot;</span>, <span class="hljs-string">&quot;宁波大学&quot;</span>, <span class="hljs-string">&quot;温州大学&quot;</span>&#125;;    <span class="hljs-comment">/* 为comboBox_province添加省份 */</span>    ui-&gt;comboBox_province-&gt;addItem(QIcon(<span class="hljs-string">&quot;:/pic/guangdong.png&quot;</span>), <span class="hljs-string">&quot;广东省&quot;</span>);    ui-&gt;comboBox_province-&gt;addItem(QIcon(<span class="hljs-string">&quot;:/pic/henan.png&quot;</span>), <span class="hljs-string">&quot;河南省&quot;</span>);    ui-&gt;comboBox_province-&gt;addItem(QIcon(<span class="hljs-string">&quot;:/pic/hubei.png&quot;</span>), <span class="hljs-string">&quot;湖北省&quot;</span>);    ui-&gt;comboBox_province-&gt;addItem(QIcon(<span class="hljs-string">&quot;:/pic/shandong.png&quot;</span>), <span class="hljs-string">&quot;山东省&quot;</span>);    ui-&gt;comboBox_province-&gt;addItem(QIcon(<span class="hljs-string">&quot;:/pic/zhejiang.png&quot;</span>), <span class="hljs-string">&quot;浙江省&quot;</span>);    <span class="hljs-comment">/* 为comboBox_city和comboBox_school添加默认城市和学校 */</span>    ui-&gt;comboBox_province-&gt;setCurrentIndex(<span class="hljs-number">0</span>);    ui-&gt;comboBox_city-&gt;addItems(gdCityList);    ui-&gt;comboBox_school-&gt;addItems(gdUniversityList);    <span class="hljs-comment">/* 自定义槽函数，当省份改变，触发槽机制，连接信号与槽 */</span>    connect(ui-&gt;comboBox_province, SIGNAL(currentIndexChanged(<span class="hljs-type">int</span>)), this, SLOT(province_changed_slot(<span class="hljs-type">int</span>)));&#125;<span class="hljs-comment">/* 当省份改变时，城市和学校相应发生变化 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::province_changed_slot</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;    ui-&gt;comboBox_city-&gt;clear();<span class="hljs-comment">//清空之前的项目内容</span>    ui-&gt;comboBox_school-&gt;clear();    <span class="hljs-keyword">switch</span> (index)    &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            ui-&gt;comboBox_city-&gt;addItems(gdCityList);            ui-&gt;comboBox_school-&gt;addItems(gdUniversityList);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            ui-&gt;comboBox_city-&gt;addItems(hnCityList);            ui-&gt;comboBox_school-&gt;addItems(hnUniversityList);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:            ui-&gt;comboBox_city-&gt;addItems(hbCityList);            ui-&gt;comboBox_school-&gt;addItems(hbUniversityList);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:            ui-&gt;comboBox_city-&gt;addItems(sdCityList);            ui-&gt;comboBox_school-&gt;addItems(sdUniversityList);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:            ui-&gt;comboBox_city-&gt;addItems(zjCityList);            ui-&gt;comboBox_school-&gt;addItems(zjUniversityList);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 获取姓名、大学、省份、城市 */</span>    QString name = ui-&gt;comboBox_name-&gt;currentText();    QString province = ui-&gt;comboBox_province-&gt;currentText();    QString city = ui-&gt;comboBox_city-&gt;currentText();    QString university = ui-&gt;comboBox_school-&gt;currentText();    QString info = name + <span class="hljs-string">&quot; 来自于&quot;</span> + province + city + <span class="hljs-string">&quot;的&quot;</span> + university;    QMessageBox::information(this, <span class="hljs-string">&quot;学生信息&quot;</span>, info);&#125;</code></pre></div><p>效果如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701185527403.png" alt="image-20230701185527403" style="zoom:67%;" /></p><p>工程代码：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/comboBox.zip">comboBox</a></p><p>参考链接：</p><p>http://t.csdn.cn/8Aesg</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之单选按钮QradioButton与复选按钮QCheckBox</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AEQradioButton%E4%B8%8E%E5%A4%8D%E9%80%89%E6%8C%89%E9%92%AEQCheckBox/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AEQradioButton%E4%B8%8E%E5%A4%8D%E9%80%89%E6%8C%89%E9%92%AEQCheckBox/</url>
    
    <content type="html"><![CDATA[<p>QRadioButton是单选按钮，常用作表单互斥选择选项，在“多选一”的场景中使用，也就是说在一组单选按钮中，一次只能选中一个单选按钮。如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701191912177.png" alt="image-20230701191912177" style="zoom:67%;" /></p><p>QCheckBox是复选按钮，常用在”多选多“的场景中。如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701194047634.png" alt="image-20230701194047634" style="zoom:80%;" /></p><h3 id="属性和方法">属性和方法</h3><p>QRadioButton和QCheckBox的属性和方法主要继承于父类 <strong>QAbstractButton</strong> 。</p><ul><li>获取和设置显示的文本</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span></code></pre></div><ul><li>获取和设置单选按钮的选中状态</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isChecked</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setChecked</span><span class="hljs-params">(<span class="hljs-type">bool</span>)</span></code></pre></div><ul><li>获取和设置自动互斥，单选按钮默认是互斥的，复选按钮默认不是互斥的。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">autoExclusive</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setAutoExclusive</span><span class="hljs-params">(<span class="hljs-type">bool</span>)</span></code></pre></div><p>单选按钮“多选一” 要满足以下两个条件：</p><ol type="1"><li>同一组的单选按钮，在同一个布局中。</li><li>单选按钮的 <code>autoExclusive</code> 属性设置为 <code>true</code>，默认是使能的。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701192850832.png" alt="image-20230701192850832" style="zoom:67%;" /></p><ul><li>设置和获取复选按钮的状态</li></ul><div class="code-wrapper"><pre><code class="hljs c">Qt::CheckState <span class="hljs-title function_">checkState</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setCheckState</span><span class="hljs-params">(Qt::CheckState state)</span></code></pre></div><h3 id="信号">信号</h3><p>QRadioButton的信号与槽同样主要继承父类 <strong>QAbstractButton</strong> 。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">clicked</span><span class="hljs-params">(<span class="hljs-type">bool</span> checked = <span class="hljs-literal">false</span>)</span><span class="hljs-type">void</span> <span class="hljs-title function_">pressed</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">released</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">toggled</span><span class="hljs-params">(<span class="hljs-type">bool</span> checked)</span> <span class="hljs-comment">//选中与未选中的状态变化</span></code></pre></div><p>QCheckBox的信号：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">stateChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span> <span class="hljs-comment">//选中，未选中，部分选中</span></code></pre></div><p>state的值主要有三种：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701194849109.png" alt="image-20230701194849109" style="zoom:67%;" /></p><h3 id="案例">案例</h3><p>创建一个新工程，在UI设计界面设计如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701211442724.png" alt="" /><figcaption>image-20230701211442724</figcaption></figure><p>功能实现：</p><div class="code-wrapper"><pre><code class="hljs c">Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    <span class="hljs-comment">/* 设置国籍默认选项 */</span>    ui-&gt;radioButton_China-&gt;setChecked(<span class="hljs-literal">true</span>);    <span class="hljs-comment">/* 连接信号与槽 */</span>    connect(ui-&gt;checkBox_clibling, &amp;QCheckBox::clicked, this, &amp;Widget::checkBox_hobby_slot);    connect(ui-&gt;checkBox_playball, &amp;QCheckBox::clicked, this, &amp;Widget::checkBox_hobby_slot);    connect(ui-&gt;checkBox_reading, &amp;QCheckBox::clicked, this, &amp;Widget::checkBox_hobby_slot);    connect(ui-&gt;checkBox_swimming, &amp;QCheckBox::clicked, this, &amp;Widget::checkBox_hobby_slot);    connect(ui-&gt;btn, &amp;QPushButton::clicked,[=]()&#123;        btn_info_slot();    &#125;);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_checkBox_all_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">if</span>(ui-&gt;checkBox_all-&gt;isChecked())    &#123;        ui-&gt;checkBox_clibling-&gt;setChecked(<span class="hljs-literal">true</span>);        ui-&gt;checkBox_playball-&gt;setChecked(<span class="hljs-literal">true</span>);        ui-&gt;checkBox_reading-&gt;setChecked(<span class="hljs-literal">true</span>);        ui-&gt;checkBox_swimming-&gt;setChecked(<span class="hljs-literal">true</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;checkBox_clibling-&gt;setChecked(<span class="hljs-literal">false</span>);        ui-&gt;checkBox_playball-&gt;setChecked(<span class="hljs-literal">false</span>);        ui-&gt;checkBox_reading-&gt;setChecked(<span class="hljs-literal">false</span>);        ui-&gt;checkBox_swimming-&gt;setChecked(<span class="hljs-literal">false</span>);    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::checkBox_hobby_slot</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 获取爱好是否选中的状态 */</span>    <span class="hljs-type">bool</span> ischeck_clibling = ui-&gt;checkBox_clibling-&gt;isChecked();    <span class="hljs-type">bool</span> ischeck_playball = ui-&gt;checkBox_playball-&gt;isChecked();    <span class="hljs-type">bool</span> ischeck_reading = ui-&gt;checkBox_reading-&gt;isChecked();    <span class="hljs-type">bool</span> ischeck_swimming = ui-&gt;checkBox_swimming-&gt;isChecked();    <span class="hljs-comment">/* 全部选中 */</span>    <span class="hljs-keyword">if</span>(ischeck_clibling &amp;&amp; ischeck_playball &amp;&amp; ischeck_reading &amp;&amp; ischeck_swimming)    &#123;        ui-&gt;checkBox_all-&gt;setCheckState(Qt::Checked);    &#125;    <span class="hljs-comment">/* 全部未选中 */</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!ischeck_clibling &amp;&amp; !ischeck_playball &amp;&amp; !ischeck_reading &amp;&amp; !ischeck_swimming)    &#123;        ui-&gt;checkBox_all-&gt;setCheckState(Qt::Unchecked);    &#125;    <span class="hljs-comment">/* 部分选中 */</span>    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;checkBox_all-&gt;setCheckState(Qt::PartiallyChecked);    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::btn_info_slot</span><span class="hljs-params">()</span>&#123;    QString str;    <span class="hljs-comment">/* 性别 */</span>    str = <span class="hljs-string">&quot;性别：&quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;radioButton_male-&gt;isChecked())        str += ui-&gt;radioButton_male-&gt;text();    <span class="hljs-keyword">else</span>        str += ui-&gt;radioButton_female-&gt;text();    <span class="hljs-comment">/* 婚姻 */</span>    str += <span class="hljs-string">&quot;; 婚姻状况：&quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;radioButton_lady-&gt;isChecked())        str += ui-&gt;radioButton_lady-&gt;text();    <span class="hljs-keyword">else</span>        str += ui-&gt;radioButton_woman-&gt;text();    <span class="hljs-comment">/* 学历 */</span>    str += <span class="hljs-string">&quot;; 学历：&quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;radioButton_junior-&gt;isChecked())        str += ui-&gt;radioButton_junior-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_bachelor-&gt;isChecked())        str += ui-&gt;radioButton_bachelor-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_doctor-&gt;isChecked())        str += ui-&gt;radioButton_doctor-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_master-&gt;isChecked())        str += ui-&gt;radioButton_master-&gt;text();    <span class="hljs-comment">/* 国籍 */</span>    str += <span class="hljs-string">&quot;; 国籍：&quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;radioButton_America-&gt;isChecked())        str += ui-&gt;radioButton_America-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_China-&gt;isChecked())        str += ui-&gt;radioButton_China-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_France-&gt;isChecked())        str += ui-&gt;radioButton_France-&gt;text();    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ui-&gt;radioButton_German-&gt;isChecked())        str += ui-&gt;radioButton_German-&gt;text();    <span class="hljs-comment">/* 爱好 */</span>    str += <span class="hljs-string">&quot;; 爱好：&quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;checkBox_clibling-&gt;isChecked())        str += ui-&gt;checkBox_clibling-&gt;text() + <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;checkBox_playball-&gt;isChecked())        str += ui-&gt;checkBox_playball-&gt;text() + <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;checkBox_reading-&gt;isChecked())        str += ui-&gt;checkBox_reading-&gt;text() + <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-keyword">if</span>(ui-&gt;checkBox_swimming-&gt;isChecked())        str += ui-&gt;checkBox_swimming-&gt;text() + <span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-comment">/* 信息输出 */</span>    QMessageBox::information(this, <span class="hljs-string">&quot;您的个人信息：&quot;</span>, str);&#125;</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230701225352502.png" alt="image-20230701225352502" style="zoom:70%;" /></p><p>工程代码：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/radioBtnAndCheckBox.zip">radioBtnAndCheckBox</a></p><p>s</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之文本框QLineEdit</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%96%87%E6%9C%AC%E6%A1%86QLineEdit/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%96%87%E6%9C%AC%E6%A1%86QLineEdit/</url>
    
    <content type="html"><![CDATA[<p>QLineEdit是一个单行文本输入框,允许用户输入和编辑单行纯文本，它自带一些如撤销、重做、剪切、粘贴、拖拽等文本编辑功能。</p><h2 id="类型成员">类型成员</h2><p><strong>enum ActionPosition { LeadingPoisition, TrailingPosition }</strong></p><p>此枚举类型描述QLineEdit应该如何显示要添加的Action小部件。</p><ul><li><code>QLineEdit::LeadingPosition</code>：当使用 Qt::LeftToRight 布局方向时，小部件显示在文本的左侧，当使用 Qt::RightToLeft 时，小部件则显示在文本的右侧。</li><li><code>QLineEdit::TrailingPosition</code>：当使用 Qt::LeftToRight 布局方向时，小部件显示在文本的右侧，当使用 Qt::RightToLeft 时，小部件则显示在文本的左侧。</li></ul><p><strong>enum EchoMode { Normal, NoEcho, Password, PasswordEchoOnEdit }</strong></p><p>此枚举类型描述QLineEdit应如何显示其内容。</p><ul><li><code>QLineEdit::Normal</code> :输入时显示字符, 默认设置。</li><li><code>QLineEdit::NoEcho</code> :不显示任何输入内容。</li><li><code>QLineEdit::Password</code> ：输入字符一般以<code>●</code>号表示。</li><li><code>QLineEdit::PasswordEchoOnEdit</code> ：在输入时显示输入的字符，输入完成后一般以<code>●</code>号显示。</li></ul><h2 id="属性和方法">属性和方法</h2><p>QLineEdit有很多属性和方法，这里列举一些常用的：</p><ul><li>获取和设置占位字符串</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">placeholderText</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setPlaceholderText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;)</span>    <span class="hljs-comment">//设置QLineEdit 编辑行显示灰色占位符文本</span></code></pre></div><ul><li>获取和设置文本的对齐方式</li></ul><div class="code-wrapper"><pre><code class="hljs c">Qt::Alignment <span class="hljs-title function_">alignment</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setAlignment</span><span class="hljs-params">(Qt::Alignment flag)</span></code></pre></div><ul><li>获取和设置回显模式</li></ul><div class="code-wrapper"><pre><code class="hljs c">QLineEdit::EchoMode <span class="hljs-title function_">echoMode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setEchoMode</span><span class="hljs-params">(QLineEdit::EchoMode)</span></code></pre></div><ul><li>设置文本框是否可编辑</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isReadOnly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setReadOnly</span><span class="hljs-params">(<span class="hljs-type">bool</span>)</span></code></pre></div><ul><li>设置文本框是否使能</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isEnabled</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setEnabled</span><span class="hljs-params">(<span class="hljs-type">bool</span>)</span></code></pre></div><ul><li>设置和获取文本框内容格式</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">inputMask</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> <span class="hljs-title function_">setInputMask</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;inputMask)</span></code></pre></div><ul><li>信号与槽函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 信号 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">cursorPositionChanged</span><span class="hljs-params">(<span class="hljs-type">int</span> oldPos, <span class="hljs-type">int</span> newPos)</span><span class="hljs-type">void</span> <span class="hljs-title function_">editingFinished</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">inputRejected</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">returnPressed</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">selectionChanged</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">textChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span><span class="hljs-type">void</span> <span class="hljs-title function_">textEdited</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span><span class="hljs-comment">/* 槽函数 */</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">cut</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">paste</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">redo</span><span class="hljs-params">()</span> <span class="hljs-comment">//恢复上一次操作</span><span class="hljs-type">void</span> <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;)</span><span class="hljs-type">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span> <span class="hljs-comment">//撤销上一次操作</span></code></pre></div><p>其它详细内容，参考帮助文档。</p><h2 id="应用实例">应用实例</h2><p>新建一个 lineEdit 的工程，进入UI设计界面，设计如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230629230058729.png" alt="" /><figcaption>image-20230629230058729</figcaption></figure><p>下面进行功能实现：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_print_clicked</span><span class="hljs-params">()</span>&#123;    QMessageBox::information(this, <span class="hljs-string">&quot;信息输出&quot;</span>, ui-&gt;lineEdit_content-&gt;text());&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_normal_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setEchoMode(QLineEdit::Normal);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;Normal&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_noecho_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setEchoMode(QLineEdit::NoEcho);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;NoEcho&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_password_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setEchoMode(QLineEdit::Password);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;Password&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_pwdAndEcho_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setEchoMode(QLineEdit::PasswordEchoOnEdit);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;PasswordEchoOnEdit&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_placeholder_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;请输入名字：&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_clearbtn_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setClearButtonEnabled(<span class="hljs-literal">true</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_rw_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;setReadOnly(<span class="hljs-literal">false</span>);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;ReadAndWrite&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_ro_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;setReadOnly(<span class="hljs-literal">true</span>);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;ReadOnly&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_disable_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;setEnabled(<span class="hljs-literal">false</span>);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;Disabled&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_enable_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;setEnabled(<span class="hljs-literal">true</span>);    ui-&gt;lineEdit_content-&gt;setPlaceholderText(<span class="hljs-string">&quot;Enabled&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_none_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setInputMask(<span class="hljs-string">&quot;&quot;</span>);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_phone_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setInputMask(<span class="hljs-string">&quot;99999999999;#&quot;</span>); <span class="hljs-comment">//要求输入0-9的数字 ,未输入时显示#</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_key_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setInputMask(<span class="hljs-string">&quot;&gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;#&quot;</span>); <span class="hljs-comment">//要求输入大写字母 ,未输入时显示#</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_data_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setInputMask(<span class="hljs-string">&quot;0000-00-00&quot;</span>); <span class="hljs-comment">//要求输入0-9的数字</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_ip_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;lineEdit_content-&gt;clear();    ui-&gt;lineEdit_content-&gt;setInputMask(<span class="hljs-string">&quot;000.000.000.000;_&quot;</span>); <span class="hljs-comment">//要求输入0-9的数字,未输入时显示_</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_lineEdit_num2_editingFinished</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> sum = ui-&gt;lineEdit_num1-&gt;text().toInt() + ui-&gt;lineEdit_num2-&gt;text().toInt();    ui-&gt;lineEdit_sum-&gt;setText(QString::number(sum));&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_lineEdit_num4_textChanged</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;arg1)</span>&#123;    <span class="hljs-type">int</span> minus = ui-&gt;lineEdit_num3-&gt;text().toInt()- arg1.toInt();    ui-&gt;lineEdit_minus-&gt;setText(QString::number(minus));&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_lineEdit_num6_returnPressed</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> multi = ui-&gt;lineEdit_num5-&gt;text().toInt() * ui-&gt;lineEdit_num6-&gt;text().toInt();    ui-&gt;lineEdit_muliti-&gt;setText(QString::number(multi));&#125;</code></pre></div><p>工程代码：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/lineEdit.zip">lineEdit</a></p><p>参考链接：</p><p>http://t.csdn.cn/eRQsV</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之标签QLabel</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%A0%87%E7%AD%BEQLabel/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%A0%87%E7%AD%BEQLabel/</url>
    
    <content type="html"><![CDATA[<h3 id="qlabel属性和方法">QLabel属性和方法</h3><p>QLabel用于显示文本或图像，它有很多属性和方法，常用的主要有：</p><ul><li>获取和设置文本</li></ul><div class="code-wrapper"><pre><code class="hljs c">String <span class="hljs-title function_">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span>;</code></pre></div><ul><li>设置标签中内容的对齐方式</li></ul><div class="code-wrapper"><pre><code class="hljs c">Qt::Alignment <span class="hljs-title function_">alignment</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setAlignment</span><span class="hljs-params">(Qt::Alignment)</span>;</code></pre></div><p><code>Qt::Alignment</code> 是一个宏，常用取值如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230628190853765.png" alt="image-20230628190853765" style="zoom:67%;" /></p><ul><li>标签内容换行</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">wordWrap</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setWordWrap</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span>;</code></pre></div><ul><li>获取和设置标签上显示的图像</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> QPixmap *<span class="hljs-title function_">pixmap</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">setPixmap</span><span class="hljs-params">(<span class="hljs-type">const</span> QPixmap &amp;)</span>;</code></pre></div><ul><li>设置动图</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">setMovie</span><span class="hljs-params">(QMovie *movie)</span>;</code></pre></div><h3 id="qlabel的使用">QLabel的使用</h3><p>创建基类为QWidget的工程，进入UI设计界面，进行如下设计：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230628202616484.png" alt="" /><figcaption>image-20230628202616484</figcaption></figure><p>下面进行功能实现：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 缩放widget，标签文本允许换行 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_enableWrap_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setWordWrap(<span class="hljs-literal">true</span>);&#125;<span class="hljs-comment">/* 缩放widget，标签文本不允许换行 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_disableWrap_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setWordWrap(<span class="hljs-literal">false</span>);&#125;<span class="hljs-comment">/* 设置标签文本对齐方式 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_left_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setAlignment(Qt::AlignLeft | Qt::AlignVCenter);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_center_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setAlignment(Qt::AlignCenter);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_right_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setAlignment(Qt::AlignRight | Qt::AlignVCenter);&#125;<span class="hljs-comment">/* 弹出消息对话框信息 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_getText_clicked</span><span class="hljs-params">()</span>&#123;    QMessageBox::information(this, <span class="hljs-string">&quot;文本信息&quot;</span>, ui-&gt;label_text-&gt;text());<span class="hljs-comment">//需要添加头文件&lt;QMessageBox&gt;</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setText_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 获取当前时间并转换为字符串 */</span>    QString str = QTime::currentTime().toString(); <span class="hljs-comment">//需要添加头文件&lt;QTime&gt;</span>    ui-&gt;label_text-&gt;setText(str);    QFont font = QFont(<span class="hljs-string">&quot;宋体&quot;</span>, <span class="hljs-number">15</span>);    ui-&gt;label_text-&gt;setFont(font); <span class="hljs-comment">//设置字体</span>    ui-&gt;label_text-&gt;setAlignment(Qt::AlignCenter);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setlink_clicked</span><span class="hljs-params">()</span>&#123;    ui-&gt;label_text-&gt;setText(<span class="hljs-string">&quot;&lt;h1&gt;&lt;a href=\&quot;https://www.baidu.com\&quot;&gt;百度一下&lt;/a&gt;&lt;/h1&gt;&quot;</span>);    <span class="hljs-comment">/* 开启点击自动跳转到超链接地址 */</span>    ui-&gt;label_text-&gt;setOpenExternalLinks(<span class="hljs-literal">true</span>);    ui-&gt;label_text-&gt;setAlignment(Qt::AlignCenter);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_change_clicked</span><span class="hljs-params">()</span>&#123;    QPixmap pixmap;    <span class="hljs-comment">/* 首先判断图片切换的位置 */</span>    <span class="hljs-keyword">if</span>(index &gt; <span class="hljs-number">12</span>)    &#123;        index = <span class="hljs-number">1</span>;    &#125;    QString str = <span class="hljs-string">&quot;:/png/&quot;</span> + QString::number(index) + <span class="hljs-string">&quot;.png&quot;</span>; <span class="hljs-comment">//拼接图片路径</span>    index++; <span class="hljs-comment">//切换到下一张图片</span>    pixmap.load(str);    ui-&gt;label_pic-&gt;setPixmap(pixmap);    ui-&gt;label_pic-&gt;setScaledContents(<span class="hljs-literal">false</span>); <span class="hljs-comment">//不要缩放，否则拉伸导致失真</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_disp_clicked</span><span class="hljs-params">()</span>&#123;    QMovie *movie = new QMovie(<span class="hljs-string">&quot;:/png/movie.gif&quot;</span>);<span class="hljs-comment">//添加头文件&lt;QMovie&gt;</span>    movie-&gt;start(); <span class="hljs-comment">//播放动画</span>    ui-&gt;label_pic-&gt;setMovie(movie);&#125;</code></pre></div><p>工程文件：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/label.zip">label</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之按钮QPushButton</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%8C%89%E9%92%AEQPushButton/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E6%8C%89%E9%92%AEQPushButton/</url>
    
    <content type="html"><![CDATA[<p><code>QPushButton</code> 是 <code>Qt</code> 中的按钮类，属于最常用的控件，当点击按钮时，就可执行相应的操作。</p><p>可以在UI设计界面直接拖动push button来创建按钮，也可以通过代码进行new创建，如 :</p><div class="code-wrapper"><pre><code class="hljs c">QPushButton *button = new QPushButton(<span class="hljs-string">&quot;&amp;Download&quot;</span>, this);</code></pre></div><p>以上创建了一个带有文字 <code>Download</code> 的按钮，快捷键为 <code>Alt + D</code>, 这里的 <strong>&amp;</strong> 符号为快捷键标识。</p><h2 id="qpushbutton的属性和方法">QpushButton的属性和方法</h2><ul><li>获取和设置按钮的文本</li></ul><div class="code-wrapper"><pre><code class="hljs c">QString <span class="hljs-title function_">text</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;text)</span></code></pre></div><ul><li>获取和设置按钮的图标</li></ul><div class="code-wrapper"><pre><code class="hljs c">QIcon <span class="hljs-title function_">icon</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setIcon</span><span class="hljs-params">(<span class="hljs-type">const</span> QIcon &amp;icon)</span></code></pre></div><ul><li>样式表可以设置包括文本颜色、背景色、边框、字体等很多样式</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 只要继承自QWidget类的控件，都有该属性</span>QString <span class="hljs-title function_">styleSheet</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-type">void</span> <span class="hljs-title function_">setStyleSheet</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;styleSheet)</span></code></pre></div><ul><li>Signals &amp; Slots</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">clicked</span><span class="hljs-params">(<span class="hljs-type">bool</span> checked = <span class="hljs-literal">false</span>)</span> <span class="hljs-comment">//通常不需要传递这个默认参数</span><span class="hljs-type">void</span> <span class="hljs-title function_">pressed</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">released</span><span class="hljs-params">()</span><span class="hljs-type">void</span> <span class="hljs-title function_">toggled</span><span class="hljs-params">(<span class="hljs-type">bool</span> checked)</span>    <span class="hljs-type">void</span> <span class="hljs-title function_">showMenu</span><span class="hljs-params">()</span> <span class="hljs-comment">//弹出菜单</span></code></pre></div><p>其它函数具体参看帮助文档。</p><h2 id="实例">实例</h2><p>新建一个基类为QWidget的工程，勾选 'Generate form'。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230626222427044.png" alt="image-20230626222427044" style="zoom:67%;" /></p><p>在UI设计界面，拖拽对应的控件，进行如下设置：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230626230434261.png" alt="" /><figcaption>image-20230626230434261</figcaption></figure><p>下面进行功能实现：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_stop_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 获取按钮文本 */</span>    QString text = ui-&gt;btn_stop-&gt;text();    <span class="hljs-comment">/* 判断处理 */</span>    <span class="hljs-keyword">if</span>(text == <span class="hljs-string">&quot;启动&quot;</span>)    &#123;        ui-&gt;btn_stop-&gt;setText(<span class="hljs-string">&quot;停止&quot;</span>);<span class="hljs-comment">// 设置文本和字体</span>        ui-&gt;btn_stop-&gt;setIcon(QIcon(<span class="hljs-string">&quot;:/stop.ico&quot;</span>));<span class="hljs-comment">// 设置图标和图标大小</span>        ui-&gt;btn_stop-&gt;setIconSize(QSize(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>));    &#125;    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;btn_stop-&gt;setText(<span class="hljs-string">&quot;启动&quot;</span>);        ui-&gt;btn_stop-&gt;setIcon(QIcon(<span class="hljs-string">&quot;:/start.ico&quot;</span>));        ui-&gt;btn_stop-&gt;setIconSize(QSize(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>));    &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_connect_clicked</span><span class="hljs-params">()</span>&#123;    QString s = ui-&gt;btn_connect-&gt;text();    <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;连接&quot;</span>)    &#123;        ui-&gt;btn_connect-&gt;setText(<span class="hljs-string">&quot;断开连接&quot;</span>);        ui-&gt;btn_send-&gt;setEnabled(<span class="hljs-literal">true</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        ui-&gt;btn_connect-&gt;setText(<span class="hljs-string">&quot;连接&quot;</span>);        ui-&gt;btn_send-&gt;setEnabled(<span class="hljs-literal">false</span>);    &#125;&#125;<span class="hljs-comment">/* 按钮信号演示 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_signal_clicked</span><span class="hljs-params">()</span>&#123;    qDebug() &lt;&lt; <span class="hljs-string">&quot;clicked...&quot;</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_signal_pressed</span><span class="hljs-params">()</span>&#123;     qDebug() &lt;&lt; <span class="hljs-string">&quot;pressed...&quot;</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_signal_released</span><span class="hljs-params">()</span>&#123;     qDebug() &lt;&lt; <span class="hljs-string">&quot;released...&quot;</span>;&#125;</code></pre></div><p>对于样式表：</p><p>在右侧的属性窗口中，或者在按钮上右键-&gt;【改变样式表…】，打开编辑样式表的对话框，设置了按钮的字体颜色和背景渐变‘RainBow’。</p><p>工程代码：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/pushButton.zip">pushButton</a></p><p>参考链接：</p><p>http://t.csdn.cn/qxhG0</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt常用控件之窗口基类 QWidget</title>
    <link href="/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%B1%BB%20QWidget/"/>
    <url>/2023/06/25/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%B1%BB%20QWidget/</url>
    
    <content type="html"><![CDATA[<p>QWidget 类是所有控件类的父类，Qt为此控件提供有很多属性和方法：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625220627151.png" alt="image-20230625220627151" style="zoom:80%;" /></p><p>详细内容可查看帮助文档。</p><p>下面使用一个案例来展示 <code>QWidget</code> 中常用的方法：</p><p>新建一个基类为QWidget的工程，勾选 'Generate form'。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625223310755.png" alt="image-20230625223310755" style="zoom: 67%;" /></p><p>打开ui设计文件，添加几个Push Button，并进行如下设置：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625224821724.png" alt="image-20230625224821724" style="zoom:67%;" /></p><p>运行，弹出如下窗口：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625224918704.png" alt="image-20230625224918704" style="zoom:67%;" /></p><p>下面进行功能实现，其中添加图标需要进行如下操作，首先添加资源文件，然后复制图标路径，粘贴到代码中：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625231034328.png" alt="image-20230625231034328" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230625231046114.png" alt="image-20230625231046114" style="zoom:80%;" /></p><p>主要代码：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_getPosAndSize_clicked</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">/* 获取窗口位置信息 */</span>    QRect rect = this-&gt;geometry();    <span class="hljs-comment">/* 在输出打印当前窗口位置信息，注意添加头文件&lt;QDebug&gt; */</span>    qDebug() &lt;&lt; <span class="hljs-string">&quot;左上角: &quot;</span> &lt;&lt; rect.topLeft();    qDebug() &lt;&lt; <span class="hljs-string">&quot;右上角: &quot;</span> &lt;&lt; rect.topRight();    qDebug() &lt;&lt; <span class="hljs-string">&quot;左下角: &quot;</span> &lt;&lt; rect.bottomLeft();    qDebug() &lt;&lt; <span class="hljs-string">&quot;右下角: &quot;</span> &lt;&lt; rect.bottomRight();    qDebug() &lt;&lt; <span class="hljs-string">&quot;宽度: &quot;</span> &lt;&lt; rect.width();    qDebug() &lt;&lt; <span class="hljs-string">&quot;高度: &quot;</span> &lt;&lt; rect.height();&#125;<span class="hljs-comment">/* 设置窗口大小 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setSize_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;resize(<span class="hljs-number">450</span>, <span class="hljs-number">450</span>);&#125;<span class="hljs-comment">/* 固定窗口大小 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setFixSize_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;setFixedSize(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);&#125;<span class="hljs-comment">/* 最小缩放400*400 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setMinSize_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;setMinimumSize(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>);&#125;<span class="hljs-comment">/* 最大缩放600*600 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setMaxSize_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;setMaximumSize(<span class="hljs-number">600</span>, <span class="hljs-number">600</span>);&#125;<span class="hljs-comment">/* 移动窗口到具体位置 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_move_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;move(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);&#125;<span class="hljs-comment">/* 设置窗口标题 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setTitle_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;setWindowTitle(<span class="hljs-string">&quot;QWidget测试&quot;</span>);&#125;<span class="hljs-comment">/* 设置窗口logo */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Widget::on_btn_setLogo_clicked</span><span class="hljs-params">()</span>&#123;    this-&gt;setWindowIcon(QIcon(<span class="hljs-string">&quot;:/logo.png&quot;</span>));&#125;</code></pre></div><p>工程代码Gitee: <a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/QWidget.zip">QWidget</a></p><p>参考链接：</p><p>http://t.csdn.cn/xT6vf</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI绘画</title>
    <link href="/2023/06/19/AI%E7%BB%98%E7%94%BB/"/>
    <url>/2023/06/19/AI%E7%BB%98%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<p>偶然看到网上一篇文章（https://stable-diffusion-art.com/qr-code/），觉得挺炫酷，因为看到文章内有具体的操作步骤，所以我也想尝试一下，然后利用周末的两天，认真地了解和操作了一番。</p><h3 id="stable-diffusion的简介">Stable Diffusion的简介</h3><p>目前AI绘画最火的当属 <strong>Midjorney</strong> 和 <strong>Stable Diffusion</strong>，<strong>Midjourney</strong>没有开源，<strong>Stable Diffusion</strong> 免费开源。<strong>Stable Diffusion</strong> 是StabilityAI公司于2022年提出的，它是一个基于潜在 <strong>扩散模型</strong>（Latent Diffusion Models），能够根据文本描述生成高质量、高分辨率、高逼真的图像。</p><p>至于其原理，不做过多介绍，如果想深入了解，可查看：</p><p>源码：https://github.com/CompVis/stable-diffusion</p><p>论文：https://arxiv.org/pdf/2112.10752.pdf</p><p>Stable Diffusion本身没有类似exe的可直接运行的软件，好在有一些基于 <code>stable-diffusion</code> 封装的 <code>webui</code> 开源项目，其中，<strong>AUTOMATIC1111大神</strong> 部署的框架 <a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">stable-diffusion-webui</a> ，得到了广泛的应用。它是一套无代码、可视化的Stable Diffusion集成运行环境。让我们能通过web可视化界面而不是通过命令行参数使用Stable Diffusion进行绘画创作。</p><p>因为每个人的电脑环境不一样，本地部署免不了会出现各种各样的问题，如果不想折腾，可直接下载使用别人的整合包，下载了这些整合包，直接解压就可以使用，现在国内热度比较高的有两个整合包：</p><p>秋叶aaaki v4整合包：https://pan.baidu.com/s/13_B9lotU7UDcET7wYcDF7g?pwd=bang#list/path=%2F</p><p>独立研究员-星空整合包：<a href="https://link.zhihu.com/?target=https%3A//pan.baidu.com/s/1_FYbDpkX6Q6hDVHJpCMRxA%3Fpwd%3Do852">https://pan.baidu.com/s/1_FYbDpkX6Q6hDVHJpCMRxA?pwd=o852</a></p><p>在了解之前，我是直接进行本地部署的，下面将详细介绍部署stable-diffusion-webui的具体流程。</p><h3 id="系统配置需求">系统配置需求</h3><p>Stable Diffusion是比较耗资源的，因此对电脑硬件有一定要求。</p><p>NVIDIA GPU 至少 4GB 显存，至少8GB 内存，至少 20GB 可用硬盘空间，如果想要生成速度快，显卡配置自然是越高越好，显存最好也上到8G。如果本地机器配置达不到，可使用云端部署，可参考：https://b23.tv/KLk8gPg</p><h3 id="环境准备">环境准备</h3><ul><li><strong>Python</strong></li></ul><p>请注意，为保证准确性，Python版本至少为 <strong>3.10.6</strong>，<a href="https://www.python.org/ftp/python/3.10.6/python-3.10.6-amd64.exe">点击这里直接下载</a></p><ul><li><strong>git</strong></li></ul><p>为避免不必要的麻烦，git安装时一定要勾选 <strong>将PATH添加到系统环境变量中</strong></p><ul><li><strong>stable-diffusion-webui库</strong></li></ul><p>打开 <code>git bash</code> ,输入命令 <code>git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git</code> ,下载stable-diffusion-webui库。</p><ul><li><strong>CUDA</strong></li></ul><p><code>stable-diffusion-webui</code> 运行使用的是 GPU 算力，这里我们需要安装 CUDA 驱动，打开cmd命令行，输入 <code>nvidia-smi</code>, 查看电脑CUDA的版本号：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230619212839698.png" alt="image-20230619212839698" style="zoom:80%;" /></p><p>然后进入Nvidia CUDA 官网：https://developer.nvidia.com/cuda-toolkit-archive， 找到对应的系统版本号，下载安装。</p><ul><li><strong>模型Stable Diffusion checkpoint</strong></li></ul><p>stable-diffusion-webui需要有已经训练过的模型才能进行使用，两个常用的下载模型网站：</p><p><strong>huggingface</strong>：https://huggingface.co/</p><p><strong>civitai</strong> ：https://civitai.com/</p><p>这里下载官方模型<a href="https://huggingface.co/CompVis/stable-diffusion-v-1-4-original/resolve/main/sd-v1-4.ckpt">sd-v1-4</a></p><ul><li><strong>网络控制扩展包ControlNet extension</strong></li></ul><p>打开 <code>git bash</code> ,输入命令 <code>git clone https://github.com/Mikubill/sd-webui-controlnet.git</code> ,下载sd-webui-controlnet extension.</p><h3 id="安装部署">安装部署</h3><ol type="1"><li><p>依次安装以上python和git软件，CUDA软件。</p></li><li><p>将之前下载的模型（sd-v1-4.ckpt）放到 stable-diffusion-webui-diffusion下。将ControlNet extension文件夹放到 stable-diffusion-webui。</p></li><li><p>打开刚刚下载的 stable-diffusion-webui文件夹，找到如下bash文件，针对不同的电脑，双击不同的bat文件。</p></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230619210447451.png" alt="image-20230619210447451" style="zoom:80%;" /></p><ol start="4" type="1"><li>弹出命令窗口后，它会自动下载相关内容，<strong>注意：这一步可能会出现很多问题，根据提示，进行一一解决</strong></li></ol><p>如：提示你升级pip版本，重新打开一个命令窗口，cd进入到stable-diffusion-webui，运行命令<code>python.exe -m pip install --upgrade pip</code>升级一下pip就行。然后重新运行以上bat文件。</p><p>再如：<code>torch.cuda.OutOfMemoryError: CUDA out of memory.</code>这表示显卡内存不足，因为我电脑显存只有2GB，所以折腾很久，最后找到了解决方法，打开 webui-user.bat文件，进行如下参数设置（主要是跳过cuda test和lowvram）：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230619214107835.png" alt="" /><figcaption>image-20230619214107835</figcaption></figure><p>具体参考：https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Command-Line-Arguments-and-Settings</p><ol start="5" type="1"><li>问题都解决后，会出现界面。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230619220104534.png" alt="image-20230619220104534" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230619215525485.png" alt="image-20230619215525485" style="zoom:80%;" /></p><h3 id="运用">运用</h3><p>本地部署完成，接下来就是设置不同的参数，生成不同的图像了。具体学习可查看 https://b23.tv/YKS6EWl</p><p>以下是我参照最开始的网址文章进行简单的设置生成的图像：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/00000-1838255928.png" alt="00000-1838255928" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/00000-313235722.png" alt="00000-313235722" style="zoom:80%;" /></p><p>如果想生成更漂亮的图片，需要更好的电脑配置和更深层的学习，通过改变提示词、改变权重、多次生成等方式，可以让你得到想要的图片，这里我只是做简单的了解，同时记录一下本地部署AI绘图的内容。</p><p>像文章开头那种图像实现，目前市面上有很多推广应用，如 <a href="https://hysli.io/#/mobile">Hysli.io</a> 、<a href="https://qrbtf.com/ai">QRBTF.AI</a> 、<a href="https://yima.me">艺码</a> 等，如果你的电脑配置比较好，也有兴趣和耐心自己尝试一番，可以参考以下两篇博文：<a href="https://antfu.me/posts/ai-qrcode-refine">Refining AI Generated QR Code</a> 和 <a href="https://antfu.me/posts/ai-qrcode-101">Stable Diffusion QR Code 101</a></p><h3 id="参考链接">参考链接：</h3><p>https://www.bilibili.com/read/mobile?id=23488766</p><p>https://it.cha138.com/nginx/show-4623870.html</p><p>http://t.csdn.cn/T2uR1</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt的信号与槽机制</title>
    <link href="/2023/06/15/Qt%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/06/15/Qt%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="qt信号与槽简介">Qt信号与槽简介</h3><p>Qt对标准C++进行了扩展，引入了一些新的概念和功能，例如信号与槽机制，对象属性等。Qt中有一个预处理器，称为元对象编译器（Meta-Object Compiler，MOC），它会将Qt源程序在编译前先转换为标准C++兼容形式，再由C++标准编译器进行编译，所以，信号与槽机制中，必须添加宏： <strong>Q_OBJECT</strong>，这样MOC才能对信号与槽程序进行代码预处理。</p><p>信号与槽是Qt的一个核心特点，也是区别于其它框架的重要特性。Qt使用信号与槽的机制实现对象间通信，它隐藏了复杂的底层实现。与回调函数相比，应用起来会更灵活。</p><p><strong>信号（Signals）</strong>就是在指定情况下发生的事件，Qt Widgets 提供了很多信号，例如 QPushButton 最常见的信号就是鼠标单击时的clicked() 信号，同时，我们也可以自己定义信号。</p><p><strong>槽（Slots）</strong>就是对信号响应的函数。槽就是一个函数，可以具有任何参数，也可以被直接调用。当槽函数与信号关联后，如果信号发生，那么关联的槽函数就会被执行。Qt Widgets提供有很多槽函数，我们也可以自己定义槽函数。</p><p>信号与槽关联是用 QObject::connect() 函数实现的，connect() 是 QObject 类的一个静态函数，而QObject 是所有 Qt 类的基类，在实际调用时可以忽略前面的限定符。</p><p>一个信号可以连接多个槽，多个信号可以连接同一个槽，一个信号可以连接另外一个信号。如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230615203504152.png" alt="" /><figcaption>image-20230615203504152</figcaption></figure><p>connect函数有多重参数形式，一般使用最广的是以下三种：</p><ul><li><strong>一般参数形式</strong></li></ul><p><code>QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)</code></p><p>简化：<strong>connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</strong></p><p>这里使用宏SIGNAL()和SLOT()指定信号和槽函数，如果信号和槽带有参数，还需要注明参数类型，且参数类型要一致，如：</p><p><strong>connect(scrollBar, SIGNAL(valueChanged(int)), label, SLOT(setNum(int)));</strong></p><ul><li><strong>函数指针形式</strong></li></ul><p><code>QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &amp;signal, const QObject *receiver, const QMetaMethod &amp;method, Qt::ConnectionType type = Qt::AutoConnection)</code></p><p>简化：<strong>connect(sender, &amp;Sender::signal, receiver, &amp;Receiver::slot);</strong></p><p>如： <strong>connect(ui-&gt;lineEdit, &amp;QLineEdit::textChanged, ui-&gt;label, &amp;QLabel::setText);</strong></p><ul><li><strong>lambda 表达式形式</strong></li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//Qt不传递参数lambda</span><span class="hljs-built_in">connect</span>(ui-&gt;button, &amp;QButton::clicked,[=]&#123;    <span class="hljs-built_in">qDebug</span>()&lt;&lt;<span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;test&quot;</span>);&#125;);<span class="hljs-comment">//Qt带传递参数lambda</span><span class="hljs-built_in">connect</span>(UI-&gt;button, &amp;QButton::clicked,[=](QString path)&#123;    <span class="hljs-built_in">qDebug</span>()&lt;&lt;path;&#125;);</code></pre></div><p>lamdba表达式介绍:</p><p>[] 不捕获任何变量。</p><p>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</p><p>[&amp;, a] a以传值方式捕获，其余变量以传引用的方式在函数体中使用（a按值，其余按引用捕获）。</p><p>[a，&amp;b] a以传值方式捕获，b以传引用方式捕获（a按值捕获，b按引用捕获）。</p><p>[=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</p><p>[=，&amp;b] 按值捕获外部作用域中所有变量，并按引用捕获 b 变量。</p><p>[a] 仅按值捕获 a 变量，但不捕获其他变量。</p><h3 id="信号与槽的创建">信号与槽的创建</h3><p>Qt中信号与槽的创建一般有以下几种方式：</p><ul><li>在UI设计界面的控件上右键-&gt;转到槽，在ui.widget.h文件中将会通过connectSlotsByName，为每个信号/槽创建connect。如希望点击关闭按钮，窗口会关闭，操作如下：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230615214658423.png" alt="image-20230615214658423" style="zoom:80%;" /></p><p>这样，就会自动创建一个槽函数的声明和一个空的槽函数，需要自己添加相应执行的内容，这里调用的是widget的close()槽函数。<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230615215256504.png" alt="image-20230615215256504" /></p><ul><li>通过UI设计界面中Signals &amp; Slots Editor添加信号/槽，它们就会在系统内建立关联。如下，同样可以实现上面的功能：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230615220602008.png" alt="image-20230615220602008" style="zoom:80%;" /></p><ul><li>手动创建信号/槽。</li></ul><p>在widget.h文件中手动创建信号（signals:）或槽函数（slots:）声明，在widget.cpp文件中定义槽函数并手动创建connect函数，将信号与槽函数进行连接。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230615222721918.png" alt="image-20230615222721918" style="zoom:80%;" /></p><p>以上是Qt中信号与槽机制的基本使用方式，需要熟练掌握，另外，通过Qt的帮助文档，可以详细查看Qt已为各个类定义好的信号与槽函数。</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt Creator的使用</title>
    <link href="/2023/06/14/Qt-Creator%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/06/14/Qt-Creator%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="qt-creator的设置">Qt Creator的设置</h3><p>打开Qt Creator, 选择Tools -&gt; Options 进入设置界面：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190132386.png" alt="image-20230614190132386" style="zoom:80%;" /></p><ul><li>Environment：可以设置相应的主题和语言环境及UI颜色。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190238354.png" alt="image-20230614190238354" style="zoom:80%;" /></p><ul><li>Text Editor：可以进行相应的文本编辑设置。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190418754.png" alt="image-20230614190418754" style="zoom:80%;" /></p><ul><li>Build &amp; Run：进行编译和运行的设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614190635317.png" alt="image-20230614190635317" style="zoom:80%;" /></p><h3 id="新建qt-widget项目">新建Qt Widget项目</h3><ul><li>依次点击 File -&gt; New File or Project,选择Qt Widget Application</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614191012944.png" alt="image-20230614191012944" style="zoom:80%;" /></p><ul><li>填写工程名和选择存储路径，选择 qmake 编译，用 qmake 生成 Makefile 用于项目的编译。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614191554835.png" alt="image-20230614191554835" style="zoom:80%;" /></p><ul><li>选择基类：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614192700423.png" alt="image-20230614192700423" style="zoom:80%;" /></p><ul><li>选择目标平台的编译器：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614192942055.png" alt="image-20230614192942055" style="zoom:80%;" /></p><ul><li>可选择版本控制：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614193215345.png" alt="image-20230614193215345" style="zoom:80%;" /></p><ul><li>完成项目创建，可点击左下角绿色图标编译运行，此时会弹出一个空白框。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614193358548.png" alt="image-20230614193358548" style="zoom:80%;" /></p><h3 id="项目文件介绍">项目文件介绍</h3><ul><li>demo.pro: 项目管理文件。</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614194650370.png" alt="" /><figcaption>image-20230614194650370</figcaption></figure><p>还可以在其中设置应用程序其他信息：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#程序版本</span>VERSION = 1.0.0.0<span class="hljs-comment">#程序图标</span>RC_ICONS = client.ico<span class="hljs-comment">#公司名称</span>QMAKE_TARGET_COMPANY =<span class="hljs-string">&quot;KayoungZhang&quot;</span><span class="hljs-comment">#程序说明</span>QMAKE_TARGET_DESCRIPTION = <span class="hljs-string">&quot;TCP Client&quot;</span><span class="hljs-comment">#版权信息</span>QMAKE_TARGET_COPYRIGHT = <span class="hljs-string">&quot;Copyright(C) 2022&quot;</span><span class="hljs-comment">#程序名称</span>QMAKE_TARGET_PRODUCT = <span class="hljs-string">&quot;app&quot;</span><span class="hljs-comment">#程序语言</span><span class="hljs-comment">#0x0800代表和系统当前语言一致</span>RC_LANG = 0x0800</code></pre></div><ul><li><p>Header 分组，存放的是项目内所有的头文件*.h。</p></li><li><p>Source 分组，存放的是项目内的所有C++源码文件*.cpp。</p></li><li><p>Forms 分组，存放项目内所有界面文件*.ui。双击ui文件就可以进入图形设计界面，返回时则点击左边Edit图标。</p></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614195710035.png" alt="" /><figcaption>image-20230614195710035</figcaption></figure><p>在控件区，拖拽一个<strong>Label</strong>组件到中间的设计区，编辑文字内容为：“<strong>Hello，Qt！</strong>”，选择此 <strong>Lable</strong> 然后在其属性区，找到 <strong>geometry</strong> ,将 <strong>Width</strong> 改为 <strong>80</strong>， <strong>Height</strong> 改为 <strong>30</strong>，然后找到 <strong>font</strong>，将 <strong>Point Size</strong>设置为 <strong>12</strong>，勾选 <strong>Bold</strong>。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614201322669.png" alt="" /><figcaption>image-20230614201322669</figcaption></figure><h3 id="项目的编译和运行">项目的编译和运行</h3><p>单击左窗口的 <strong>Projects</strong> 图标，查看编译工具。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614201800354.png" alt="" /><figcaption>image-20230614201800354</figcaption></figure><p>然后点击左下角编译运行：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614201932984.png" alt="image-20230614201932984" style="zoom:80%;" /></p><p>至此完成一个简单的项目创建。</p><h3 id="项目的发布">项目的发布</h3><p>当项目全部完成后，就可以进行打包发行了。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614202600194.png" alt="image-20230614202600194" style="zoom:80%;" /></p><p>选择<strong>Release</strong>后，编译运行完，打开项目工程目录，找到编译后的exe文件，双击运行，会发现运行不了，是因为缺少dll动态链接库。可以将Qt的bin目录添加到电脑系统的Path环境变量中，为了保证在其他电脑上也可以正常运行，需要找到相应的dll文件，Qt提供了一个 <strong>windeployqt</strong> 工具，可以自动创建可部署的文件夹，具体操作如下：</p><ol type="1"><li>将生成的exe文件复制到一个空的文件夹中。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614203121788.png" alt="image-20230614203121788" style="zoom:80%;" /></p><ol start="2" type="1"><li>打开Qt的Min GW命令行，进入刚才的文件夹，然后输入命令：<strong>windeployqt</strong>后面跟程序名。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614204728719.png" alt="image-20230614204728719" style="zoom:80%;" /></p><ol start="3" type="1"><li>可以将部分不需要的内容删除，如下所示：</li></ol><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614205216379.png" alt="" /><figcaption>image-20230614205216379</figcaption></figure><ol start="4" type="1"><li><p>将精简后的程序压缩即可在其他同平台电脑运行了,也可以使用工具 “单文件制作封装工具(Enigma Virtual Box)”将其打包成独立版程序。如果需要整理成一个安装程序，就需要专用工具进行打包处理，一般用到的工具有：</p><ul><li>HM NIS Edit（https://hmne.sourceforge.net/）</li><li>NSIS</li><li>Inno setup（https://jrsoftware.org/）</li></ul><p>后面再做详细介绍。</p></li></ol><p>工程文件：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/Qt/demo.zip">Qt demo</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt开发环境的搭建</title>
    <link href="/2023/06/14/Qt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/06/14/Qt%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="qt简介">Qt简介</h3><p>Qt 是一个跨平台的 C++开发库，主要用来开发图形用户界面（Graphical User Interface，简称 GUI）程序。Qt 是跨平台的，支持 Windows、Linux、macOS、Android、iOS、WinRT 等平台，将已编写好的 Qt 程序移植到这些平台，只需重新编译一次源代码即可。</p><h3 id="qt-creator的下载安装">Qt Creator的下载安装</h3><p>Qt Creator是Qt集成开发环境（IDE），包括C++代码编辑器，集成的GUI外观和版式设计器（Qt Designer），项目生成和管理工具，集成的上下文相关帮助系统，图形化调试器，代码管理和浏览工具等。</p><h4 id="下载qt-creator">1.下载Qt Creator</h4><p>官网地址：https://download.qt.io/</p><p>5.14及之前版本可以下载完整安装包，进行离线安装，5.15版本之后不再提供离线安装包，只能通过下载器进行在线安装。</p><p>离线版：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614174035183.png" alt="" /><figcaption>image-20230614174035183</figcaption></figure><p>在线版：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614174826980.png" alt="" /><figcaption>image-20230614174826980</figcaption></figure><p>一般从官网下载比较慢，可以通过国内镜像网站进行下载安装，国内著名的 Qt 镜像网站，主要是各个高校的：</p><ul><li>中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/</li><li>清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/</li><li>中国互联网络信息中心：https://mirrors.cnnic.cn/qt/</li></ul><h4 id="安装qt-creator">2.安装Qt Creator</h4><p>这里我下载的是离线版本：qt-opensource-windows-x86-5.14.2.exe。</p><p><strong>注意：</strong> 若已经安装了其他版本的Qt，请先卸载，再安装，否则会发生一些奇奇怪怪的错误。</p><ul><li>双击安装包进行安装，登录Qt账户，如果没有账号，进行注册。（断网后重新安装可跳过此步骤）</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614181334729.png" alt="image-20230614181334729" style="zoom:80%;" /></p><ul><li>选择安装路径</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614180858111.png" alt="image-20230614180858111" style="zoom:80%;" /></p><ul><li>按需选择组件，一般只需选择对应的编译环境即可，其他组件后续可以再进行补充安装。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614182944200.png" alt="image-20230614182944200" style="zoom:80%;" /></p><ul><li>完成安装</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614185126853.png" alt="image-20230614185126853" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230614183307230.png" alt="image-20230614183307230" style="zoom:80%;" /></p><h3 id="参考链接">参考链接</h3><p>http://t.csdn.cn/VNaHm</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32以太网通信</title>
    <link href="/2023/06/07/STM32%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9CEthernet/"/>
    <url>/2023/06/07/STM32%E6%9C%89%E7%BA%BF%E7%BD%91%E7%BB%9CEthernet/</url>
    
    <content type="html"><![CDATA[<h3 id="ositcpip-和-lwip-简介">OSI、TCP/IP 和 LwIP 简介</h3><p><strong>OSI</strong>（Open System Interconnect），即开放式系统互联， 一般都叫OSI参考模型。</p><p><strong>TCP/IP</strong>（Transmission Control Protocol/Internet Protocol），传输控制协议/网际协议，又名网络通讯协议，是 Internet 最基本的协议、Internet 国际互联网络的基础，由网络层的 IP 协议和传输层的 TCP 协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。</p><p><strong>LwIP</strong>（Light weight IP），一种开源轻量级的 IP 协议,占用内存少，它只需十几 KB 的 RAM 和 40K 左右的 ROM 就可以运行。其网址：http://savannah.nongnu.org/projects/lwip/。</p><p><strong>MAC</strong> （Medium Access Control），简称媒体访问控制，数据链路层的芯片称之为MAC控制器。</p><p><strong>PHY</strong>（Physical），端口物理层，物理层的芯片称之为PHY，是IEEE 802.3规定的一个标准模块。IEEE定义了0~15这16个寄存器的功能，16~31这16个寄存器由厂商自行实现。</p><h3 id="网络模型">网络模型</h3><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606202025717.png" alt="" /><figcaption>image-20230606202025717</figcaption></figure><h3 id="通信实现">通信实现</h3><p>实现以太网通信硬件电路一般情况是SOC+MAC+PHY+网络变压器+RJ45，如下图：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230512193517675.png" alt="" /><figcaption>image-20230512193517675</figcaption></figure><p>通信硬件主要部分：MAC和PHY。对于内置MAC的SOC，其外部必须搭配一个PHY芯片。内部没有MAC的SOC芯片，就需要使用外置的MAC+PHY一体芯片了。具体实现有以下几种方式：</p><ul><li><strong>SOC（集成MAC层），外接一个PHY芯片（比如DM9162，LAN8720等），网络变压器和RJ45，总计4个器件，需单片机需处理TCP/IP协议栈。</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230512192817057.png" alt="" /><figcaption>image-20230512192817057</figcaption></figure><ul><li><p><strong>SOC，外加一个MAC和PHY集成一体芯片（包含MAC和PHY，比如DM9000、ENC28J60等），外加RJ45（集成网络变压器），总计3个电子器件，需单片机处理TCP/IP协议栈</strong>。</p></li><li><p><strong>SOC，外加一个MAC和PHY集成一体芯片（包含MAC+PHY+TCP/IP协议栈，如W5500,CH9121,CH395等），外加RJ45（集成网络变压器），总计3个电子器件，无需详细了解TCP/IP协议栈，开发方便。</strong></p></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230512192748527.png" alt="" /><figcaption>image-20230512192748527</figcaption></figure><ul><li><strong>SOC，加一个MAC芯片和一个PHY芯片，外加RJ45（集成网络变压器），总共4个器件。需单片机需处理TCP/IP协议栈。此方式使用较少。</strong></li></ul><p>其中：</p><p>MII/RMII接口用来传输网络数据，MIDO接口用来读写PHY的内部寄存器。</p><p><strong>MII</strong>(Media Independent Interface)，介质独立接口，它是IEEE-802.3定义的以太网标准接口，用于以太网MAC连接PHY芯片。</p><p><strong>RMII</strong>(Reduced Media Independent Interface)，精简的介质独立接口。</p><p><strong>MDIO</strong>(Management Data Input/Output)，管理数据输入输出接口，是一个两线串行接口，一根MDIO数据线，一根MDC时钟线。可以通过MDIO和MDC这两根线访问PHY芯片的任意一个寄存器。</p><p>网络变压器用于隔离以及滤波等，现在很多RJ45座子内部已经集成了网络变压器，比如最常用的HR911105A就是内置网络变压器的RJ45座。RJ45座子上一般有两个灯，绿灯亮表示网络正常，黄色闪烁说明正在进行网络通信。PHY芯片会有两个引脚来控制这两个灯。</p><h4 id="参考链接">参考链接：</h4><p>https://www.jianshu.com/p/bb363a41afcf</p><p>https://xie.infoq.cn/article/29110ce061176979d5d61959b</p><p>https://mp.weixin.qq.com/s/Wys9IgAgimCgHmVvvywK3w</p><p>http://t.csdn.cn/qLH6F</p><p>http://t.csdn.cn/Ob4tg</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之USB</title>
    <link href="/2023/06/06/STM32CubeMX%E4%B9%8BUSB/"/>
    <url>/2023/06/06/STM32CubeMX%E4%B9%8BUSB/</url>
    
    <content type="html"><![CDATA[<h3 id="usb简介">USB简介</h3><p>USB（Universal Serial BUS）通用串行总线，是一个外部总线标准。USB 接口支持设备的即插即用和热插拔功能。</p><p>标准 USB 共四根线组成,除 VCC/GND 外,另外为 D+,D-，这两根数据线采用的是差分电压的方式进行数据传输的。在 USB 主机上，D-和 D+都是接了 15K 的电阻到低的，所以在没有设备接入的时候，D+、D-均是低电平。而在 USB 设备中，如果是高速设备，则会在 D+上接一个 1.5K 的电阻到 VCC，而如果是低速设备，则会在 D-上接一个 1.5K 的电阻到 VCC。这样当设备接入主机的时候，主机就可以判断是否有设备接入，并能判断设备是高速设备还是低速设备。</p><p>STM32F103 的 MCU 自带 USB 从控制器，符合 USB 规范的通信连接；PC 主机和微控制器之间的数据传输是通过共享一专用的数据缓冲区来完成的，该数据缓冲区能被 USB 外设直接访问。这块专用数据缓冲区的大小由所使用的端点数目和每个端点最大的数据分组大小所决定，每个端点最大可使用 512 字节缓冲区（专用的 512 字节，和 CAN 共用），最多可用于 16 个单向或 8 个双向端点。USB 模块同 PC 主机通信，根据 USB 规范实现令牌分组的检测，数据发送/接收的处理，和握手分组的处理。整个传输的格式由硬件完成，其中包括 CRC 的生成和校验。</p><p>USB功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606220817086.png" alt="image-20230606220817086" style="zoom:80%;" /></p><p>整个 USB 通信的详细过程是很复杂的，要正常使用 STM32F1 的 USB，就得编写 USB 驱动，好在ST 官方提供了一套完整的 USB 驱动库，通过这个库，我们可以很方便的实现USB功能，而不需要详细了解 USB 的整个驱动，大大缩短了我们的开发时间和精力。</p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606221327095.png" alt="image-20230606221327095" style="zoom:80%;" /></p><p>利用 STM32 自带的 USB 功能,连接电脑 USB,虚拟出一个 USB串口，实现电脑和开发板的数据通信。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>激活USB，参数默认即可。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606222512234.png" alt="image-20230606222512234" style="zoom:80%;" /></p><ul><li>RCC设置外接HSE，主时钟设置为72M，USB时钟设置为48M。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606222338962.png" alt="image-20230606222338962" style="zoom:80%;" /></p><ul><li>在中间件中选择 <code>USB_DEVICE</code> 设置，在 <code>Class For FS IP</code> 设备类别选择 <code>Communication Device Class（Virtual Port Com）</code> 虚拟串口，参数保持默认。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606222858420.png" alt="image-20230606222858420" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generate peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在usbd_cdc_if.c文件中找到发送和接收函数，其中，发生函数可以在外调用，接收函数则是自动触发，为了在串口助手中回送数据，需要在接收函数中添加发送函数。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  Data received over USB OUT endpoint are sent over CDC interface</span><span class="hljs-comment">  *         through this function.</span><span class="hljs-comment">  *</span><span class="hljs-comment">  *         @note</span><span class="hljs-comment">  *         This function will issue a NAK packet on any OUT packet received on</span><span class="hljs-comment">  *         USB endpoint until exiting this function. If you exit this function</span><span class="hljs-comment">  *         before transfer is complete on CDC interface (ie. using DMA controller)</span><span class="hljs-comment">  *         it will result in receiving more data while previous ones are still</span><span class="hljs-comment">  *         not sent.</span><span class="hljs-comment">  *</span><span class="hljs-comment">  * @param  Buf: Buffer of data to be received</span><span class="hljs-comment">  * @param  Len: Number of data received (in bytes)</span><span class="hljs-comment">  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">int8_t</span> <span class="hljs-title function_">CDC_Receive_FS</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* Buf, <span class="hljs-type">uint32_t</span> *Len)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 6 */</span>  USBD_CDC_SetRxBuffer(&amp;hUsbDeviceFS, &amp;Buf[<span class="hljs-number">0</span>]);  USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS);  CDC_Transmit_FS(Buf, *Len);<span class="hljs-comment">//添加回送函数</span>  <span class="hljs-keyword">return</span> (USBD_OK);  <span class="hljs-comment">/* USER CODE END 6 */</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  CDC_Transmit_FS</span><span class="hljs-comment">  *         Data to send over USB IN endpoint are sent over CDC interface</span><span class="hljs-comment">  *         through this function.</span><span class="hljs-comment">  *         @note</span><span class="hljs-comment">  *</span><span class="hljs-comment">  *</span><span class="hljs-comment">  * @param  Buf: Buffer of data to be sent</span><span class="hljs-comment">  * @param  Len: Number of data to be sent (in bytes)</span><span class="hljs-comment">  * @retval USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">CDC_Transmit_FS</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* Buf, <span class="hljs-type">uint16_t</span> Len)</span>&#123;  <span class="hljs-type">uint8_t</span> result = USBD_OK;  <span class="hljs-comment">/* USER CODE BEGIN 7 */</span>  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;  <span class="hljs-keyword">if</span> (hcdc-&gt;TxState != <span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">return</span> USBD_BUSY;  &#125;  USBD_CDC_SetTxBuffer(&amp;hUsbDeviceFS, Buf, Len);  result = USBD_CDC_TransmitPacket(&amp;hUsbDeviceFS);  <span class="hljs-comment">/* USER CODE END 7 */</span>  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><ul><li>在main.c函数中添加测试代码：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;usbd_cdc_if.h&quot;</span></span><span class="hljs-comment">/* USER CODE END Includes */</span><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint8_t</span> usb_send_buffer[] = <span class="hljs-string">&quot;This is USB Virtual Test.\r\n&quot;</span>;<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;CDC_Transmit_FS(usb_send_buffer, <span class="hljs-keyword">sizeof</span>(usb_send_buffer));HAL_Delay(<span class="hljs-number">1000</span>);<span class="hljs-comment">/* USER CODE END WHILE */</span><span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;</code></pre></div><ul><li>编译正常，下载到开发板，将USB连接线连接电脑和开发板的USB SLAVE口，打开串口助手，选择出现的虚拟端口号，串口不停的发送数据，当从串口助手发送数据时，也会回显到串口助手上。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606235349209.png" alt="image-20230606235349209" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606235715688.png" alt="image-20230606235715688" style="zoom:80%;" /></p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/usb.zip">usb</a></p><h4 id="参考链接">参考链接：</h4><p>http://t.csdn.cn/ZrHap</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之FatFs文件系统</title>
    <link href="/2023/05/31/STM32CubeMX%E4%B9%8BFatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/05/31/STM32CubeMX%E4%B9%8BFatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="fatfs-文件系统">FatFs 文件系统</h3><p>文件系统是为了存储和管理数据，而在存储介质中建立的一种组织结构，这些结构包括操作系统引导区、目录和文件。常见的 windows 下的文件系统格式包括 FAT32、NTFS、exFAT。在使用文件系统前，要先对存储介质进行格式化。</p><p>使用文件系统时，数据都以文件的形式存储。写入新文件时，先在目录中创建一个文件索引，它指示了文件存放的物理地址，再把数据存储到该地址中。当需要读取数据时，可以从目录中找到该文件的索引，进而在相应的地址中读取出数据。</p><p>FatFs 就是一个完全免费开源，面向小型嵌入式系统的一种通用的 FAT 文件系统。它完全是由 ANSI C 语言编写并且完全独立于底层的 I/O 介质。因此它可以很容易地不加修改地移植到其他的处理器当中，如 8051、PIC、AVR、SH、Z80、H8、ARM 等。FatFs 支持 FAT12、FAT16、FAT32 等格式。</p><p>FatFs 文件系统官网：http://elm-chan.org/fsw/ff/00index_e.html</p><p>FatFs 模块的层次结构如下图示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531201529949.png" alt="image-20230531201529949" style="zoom:80%;" /></p><p>一般只需要编写最底层驱动代码，它包括存储媒介读／写接口（disk I/O）和供给文件创建修改时间的实时时钟等。</p><p>FatFs 源码相关文件如下表示，移植时，一般只需要修改2个文件（即<strong>ffconf.h</strong>和<strong>diskio.c</strong>）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531202042461.png" alt="image-20230531202042461" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>使用FatFs 文件系统对SD卡进行相关操作，并使用串口1来打印调试信息。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531193736005.png" alt="image-20230531193736005" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活CRC；</li><li>激活SDIO，选择4线SD模式，使能硬件流控，分频因子设为4，其余默认设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531195623706.png" alt="image-20230531195623706" style="zoom:80%;" /></p><ul><li>打开FATFS文件系统，按下图配置，其余默认值</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531215923184.png" alt="image-20230531215923184" style="zoom:80%;" /></p><ul><li>增大堆空间</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531220058287.png" alt="image-20230531220058287" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generate peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在main.c中添加测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint32_t</span> wr_size;                <span class="hljs-comment">/* File write counts */</span><span class="hljs-type">uint32_t</span> rd_size;                 <span class="hljs-comment">/* File read counts */</span><span class="hljs-type">uint8_t</span> wr_buffer[] = <span class="hljs-string">&quot;This is STM32 working with FatFs.&quot;</span>; <span class="hljs-comment">/* File write buffer */</span><span class="hljs-type">uint8_t</span> rd_buffer[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;                   <span class="hljs-comment">/* File read buffers */</span><span class="hljs-type">char</span> *filename = <span class="hljs-string">&quot;STM32cubemx.txt&quot;</span>; <span class="hljs-comment">/* File will be open */</span><span class="hljs-type">char</span> *sensor_file = <span class="hljs-string">&quot;Sensor.txt&quot;</span>; <span class="hljs-comment">/* File will be create */</span><span class="hljs-type">char</span> sensor_buffer[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">/* 写入的数据缓存*/</span><span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fatfs_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">/* 1.挂载SD卡，进行格式化测试 */</span>retSD = f_mount(&amp;SDFatFS,SDPath,<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(retSD == FR_NO_FILESYSTEM)<span class="hljs-comment">/* SD卡没有文件系统 */</span>  &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡还没有文件系统，即将进行格式化...\r\n&quot;</span>);retSD = f_mkfs(SDPath, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">/* 格式化 */</span><span class="hljs-keyword">if</span>(retSD == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡格式化成功。\r\n&quot;</span>);retSD = f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 格式化后，先取消挂载 */</span>retSD = f_mount(&amp;SDFatFS, SDPath, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 重新挂载 */</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡格式化失败。\r\n&quot;</span>);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);&#125;  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(retSD != FR_OK) <span class="hljs-comment">/* SD卡挂载出现其它错误，打印错误码 */</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; SD卡挂载失败。%d \r\n&quot;</span>, retSD);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">/* SD卡挂载成功 */</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件系统挂载成功，可以进行读写测试!!!\r\n&quot;</span>);&#125;<span class="hljs-comment">/* 2.文件系统测试，写测试 */</span>  <span class="hljs-keyword">if</span>(f_open(&amp;SDFile, filename, FA_CREATE_ALWAYS | FA_WRITE) == FR_OK)  &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 打开文件成功，开始写入指定数据...\r\n&quot;</span>);retSD = f_write(&amp;SDFile, wr_buffer, <span class="hljs-keyword">sizeof</span>(wr_buffer), &amp;wr_size);<span class="hljs-comment">/* 将指定存储区内容写入到文件内 */</span><span class="hljs-keyword">if</span>(retSD == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 成功写入 %d 字节数据。\r\n&quot;</span>, wr_size);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 写入的数据 : %s\r\n&quot;</span>, wr_buffer);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件写入失败，错误码： %d\r\n&quot;</span>, retSD);&#125;f_close(&amp;SDFile);<span class="hljs-comment">/* 不再读写，关闭文件 */</span>  &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件打开失败。\r\n&quot;</span>);&#125;<span class="hljs-comment">/* 3.文件系统测试，读测试 */</span><span class="hljs-keyword">if</span>(f_open(&amp;SDFile, filename, FA_OPEN_EXISTING | FA_READ) == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 打开文件成功，开始读取数据...\r\n&quot;</span>);retSD = f_read(&amp;SDFile, rd_buffer, <span class="hljs-keyword">sizeof</span>(rd_buffer), &amp;rd_size);<span class="hljs-comment">/* 读取数据 */</span><span class="hljs-keyword">if</span>(retSD == FR_OK) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 成功读取 %d 字节数据。\r\n&quot;</span>, rd_size);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 读取的数据: %s\r\n&quot;</span>, rd_buffer);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 读取文件失败，错误码： %d\r\n&quot;</span>, retSD);&#125;f_close(&amp;SDFile);<span class="hljs-comment">/* 不再读写，关闭文件 */</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; 文件打开失败。\r\n&quot;</span>);&#125;<span class="hljs-comment">/* 4.文件系统测试，创建文件 */</span><span class="hljs-keyword">if</span>(f_open(&amp;SDFile,sensor_file,FA_CREATE_ALWAYS|FA_WRITE) == FR_OK)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt; %s 文件创建成功。\r\n&quot;</span>, sensor_file);<span class="hljs-comment">/* 首先写入项目栏参数 */</span><span class="hljs-built_in">sprintf</span>(sensor_buffer, <span class="hljs-string">&quot;Item\tTemp\tHumi\tLight\r\n&quot;</span>);f_write(&amp;SDFile, sensor_buffer, <span class="hljs-built_in">strlen</span>(sensor_buffer), &amp;wr_size);    <span class="hljs-comment">/* 然后写入具体数据 */</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<span class="hljs-built_in">sprintf</span>(sensor_buffer, <span class="hljs-string">&quot;%d\t%d\t%d\t%d\r\n&quot;</span>,i + <span class="hljs-number">1</span>, i + <span class="hljs-number">20</span>, i + <span class="hljs-number">30</span>, i + <span class="hljs-number">40</span>);f_write(&amp;SDFile,sensor_buffer, <span class="hljs-built_in">strlen</span>(sensor_buffer), &amp;wr_size);f_sync(&amp;SDFile);&#125;f_close(&amp;SDFile);  &#125;  f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 不再使用文件系统，取消挂载文件系统 */</span>&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</li><li>编译无误下载到开发板后，串口打印出如下信息：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230605205919074.png" alt="image-20230605205919074" style="zoom:80%;" /></p><p>将SD卡插入PC后，可以看到SD卡里建立了2个文件：Sensor.txt和STM32cubemx.txt，打开文件后可以看到写入的数据</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230605210046746.png" alt="image-20230605210046746" style="zoom: 67%;" /></p><p>工程代码Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/fatfs_sd.zip">fatfs</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之SDIO_SD卡</title>
    <link href="/2023/05/31/STM32CubeMX%E4%B9%8BSDIO_SD%E5%8D%A1/"/>
    <url>/2023/05/31/STM32CubeMX%E4%B9%8BSDIO_SD%E5%8D%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="sd卡介绍">SD卡介绍</h3><p>SD卡（Secure Digital Memory Card）即：安全数码卡。</p><p>根据容量大小，有下面几种分类：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531172428049.png" alt="image-20230531172428049" style="zoom:80%;" /></p><p>关于SD卡其他介绍，可参考 <a href="https://www.baidu.com/link?url=sXgupcfG8fflzEDeeUlhH7psACkhlMJWwL8aFDGca27sSn-LNEp_vK-jAyAPEjvk&amp;wd=&amp;eqid=c46ac4b50003b4c30000000664771096">SD卡通识篇</a></p><p>SD卡物理结构：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531182505470.png" alt="" /><figcaption>image-20230531182505470</figcaption></figure><table><thead><tr class="header"><th>SD卡寄存器</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>CID（Card identification number）</td><td>SD卡唯一识别码</td></tr><tr class="even"><td>RCA（Relative card address）</td><td>SD卡本地系统相对地址</td></tr><tr class="odd"><td>DSR（Driver Stage Register）</td><td>配置SD卡输出驱动</td></tr><tr class="even"><td>CSD（Card Specific Data）</td><td>SD卡操作状态特定信息</td></tr><tr class="odd"><td>SCR（SD Configuration Register）</td><td>SD卡特殊信息性能配置</td></tr><tr class="even"><td>OCR（Operation conditions Register）</td><td>SD卡操作状态信息</td></tr><tr class="odd"><td>SSR（SD Status）</td><td>SD卡属性信息</td></tr><tr class="even"><td>CSR（Card Status）</td><td>SD卡的状态</td></tr></tbody></table><p>SD卡初始化流程：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531190032444.png" alt="" /><figcaption>image-20230531190032444</figcaption></figure><h3 id="sdio-简介">SDIO 简介</h3><p>SDIO ，全称： Secure Digital Input and Output，即安全数字输入输出接口。STM32的SDIO控制器支持多媒体卡（MMC卡）、SD存储卡、SD I/O卡和CE-ATA设备。</p><p>SDIO框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531192743598.png" alt="image-20230531192743598" style="zoom:80%;" /></p><p>其中，SDIO 适配器</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531193038925.png" alt="image-20230531193038925" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>插上SD卡，开机的初始化 SD 卡，如果 SD 卡初始化完成，则串口1打印初始化成功，没初始化成功，则打印初始化失败。然后打印SD卡相关信息，最后写入和读取 SD 卡扇区 0 的数据，通过串口1发送到电脑。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531193736005.png" alt="image-20230531193736005" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活SDIO，选择4线SD模式，使能硬件流控，分频因子设为4，其余默认设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531195623706.png" alt="image-20230531195623706" style="zoom:80%;" /></p><ul><li>最好激活CRC功能，以避免后续读写SD卡报CRC校验错误</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531195739768.png" alt="image-20230531195739768" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generate peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击 GENERATE CODE，生成工程代码。</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在sdio.c文件下可以看到sdio初始化函数，同时在该文件下添加显示SD卡信息函数,并在sdio.h头文件中声明。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-comment">//显示SD卡信息函数</span><span class="hljs-type">void</span> <span class="hljs-title function_">Show_SDMMC_Info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;HAL_SD_CardCIDTypeDef SDCard_CID;HAL_SD_CardInfoTypeDef SDCard_INFO;<span class="hljs-type">uint64_t</span> CardCap;<span class="hljs-comment">//SD卡容量</span>HAL_SD_GetCardCID(&amp;hsd,&amp;SDCard_CID);<span class="hljs-comment">//获取CID</span>HAL_SD_GetCardInfo(&amp;hsd,&amp;SDCard_INFO);<span class="hljs-comment">//获取SD卡信息</span><span class="hljs-keyword">switch</span>(SDCard_INFO.CardType)<span class="hljs-comment">//SD卡类型</span>&#123;<span class="hljs-keyword">case</span> CARD_SDSC:<span class="hljs-keyword">if</span>(SDCard_INFO.CardVersion == CARD_V1_X)      &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Type: SDSC V1\r\n&quot;</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(SDCard_INFO.CardVersion == CARD_V2_X)      &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Type: SDSC V2\r\n&quot;</span>);&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> CARD_SDHC_SDXC:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Type: SDHC\r\n&quot;</span>);<span class="hljs-keyword">break</span>;&#125;CardCap = (<span class="hljs-type">uint64_t</span>)(SDCard_INFO.LogBlockNbr)*(<span class="hljs-type">uint64_t</span>)(SDCard_INFO.LogBlockSize)/<span class="hljs-number">1024</span>/<span class="hljs-number">1024</span>;<span class="hljs-comment">//计算SD卡容量(单位：MB)</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card ManufacturerID: %d\r\n&quot;</span>,SDCard_CID.ManufacturerID);<span class="hljs-comment">//制造商ID</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card RelativeAddress: %d\r\n&quot;</span>,SDCard_INFO.RelCardAdd);<span class="hljs-comment">//卡相对地址</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LogicBlockNumber: %d\r\n&quot;</span>,SDCard_INFO.LogBlockNbr);<span class="hljs-comment">//逻辑块数量</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LogBlockSize: %d\r\n&quot;</span>,SDCard_INFO.LogBlockSize);<span class="hljs-comment">//逻辑块大小</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card Capacity: %d MB\r\n&quot;</span>,(<span class="hljs-type">uint32_t</span>)CardCap);<span class="hljs-comment">//显示容量</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Card BlockSize: %d\r\n&quot;</span>,SDCard_INFO.BlockSize);<span class="hljs-comment">//块大小</span>&#125;<span class="hljs-comment">/* USER CODE END 1 */</span></code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</li><li>在main.c文件中编写SD卡读写测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-comment">/* USER CODE END Includes */</span><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> Buffer_Tx[<span class="hljs-number">256</span>],Buffer_Rx[<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-type">uint32_t</span> i;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span> Show_SDMMC_Info();<span class="hljs-comment">/* 准备好数据 */</span><span class="hljs-comment">//  memset(Buffer_Tx,0x15,sizeof(Buffer_Tx));</span><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)&#123;    Buffer_Tx[i] = i;&#125;<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">/* 擦除SD卡 */</span>    <span class="hljs-keyword">if</span>(HAL_SD_Erase(&amp;hsd,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) == HAL_OK)    &#123;        <span class="hljs-keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) != HAL_SD_CARD_TRANSFER);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nErase Block Success!\r\n&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nErase Block Failed!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">100</span>);    <span class="hljs-comment">/* 向SD卡写数据 */</span>        <span class="hljs-keyword">if</span>(HAL_SD_WriteBlocks(&amp;hsd,Buffer_Tx,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0xffffffff</span>) == HAL_OK)    &#123;        <span class="hljs-keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) != HAL_SD_CARD_TRANSFER);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Write Block Success!\r\n&quot;</span>);        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">sizeof</span>(Buffer_Tx); i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02x:%02d  &quot;</span>, i, Buffer_Tx[i]);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Write Block Failed!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">100</span>);    <span class="hljs-comment">/* 读取SD卡数据 */</span>    <span class="hljs-keyword">if</span>(HAL_SD_ReadBlocks(&amp;hsd,Buffer_Rx,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0xffffffff</span>) == HAL_OK)    &#123;        <span class="hljs-keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) != HAL_SD_CARD_TRANSFER);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nRead Block Success!\r\n&quot;</span>);        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">sizeof</span>(Buffer_Rx); i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02x:%02d  &quot;</span>, i, Buffer_Rx[i]);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nRead Block Failed!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">2000</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，插入SD卡，打开串口助手，显示SD卡信息及其他数据</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230602185047037.png" alt="" /><figcaption>image-20230602185047037</figcaption></figure><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/sdio.zip">sdio</a></p><h3 id="参考链接">参考链接：</h3><p>https://www.sdcard.org/downloads/pls/</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之内存管理</title>
    <link href="/2023/05/31/STM32CubeMX%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/31/STM32CubeMX%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>STM32F103ZET6内部有64KB的SRAM内存，加上外扩的128KB容量的SRAM后，可使用的内存还是比较多的。内存管理是指软件运行时对计算机内存资源的分配和使用的技术，其最主要的目的是如何高效、快速的分配，并且在适当的时候释放和回收内存资源。</p><p>这里介绍一种比较简单的内存管理方法：分块式内存管理，其实现原理如下图示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531163251884.png" alt="image-20230531163251884" style="zoom:80%;" /></p><p>内存管理表的项值代表的意义为：该项值代表该项对应的内存块已经被占用，其数值则代表被连续占用的内存块数。比如某项值为10，那么说明包括本项对应的内存块在内，总共分配了 10 个内存块给外部的某个指针。</p><p><strong>分配原理</strong>：当指针p调用malloc申请内存的时候，先判断p要分配的内存块数（m），然后从第n项开始，向下查找，直到找到m块连续的空内存块（即对应内存管理表项为0），然后将这m个内存管理表项的值都设置为m（标记被占用），最后把剩下空内存块的地址返回指针p，完成一次分配。注意，如果当内存不够的时候（找到最后也没找到连续的m块空闲内存），则返回NULL给 p，表示分配失败。</p><p><strong>释放原理</strong>：当p申请的内存用完，需要释放的时候，调用free函数实现。free函数先判断p指向的内存地址所对应的内存块，然后找到对应的内存管理表项目，得到p所占用的内存块数目m（内存管理表项目的值就是所分配内存块的数目），将这m个内存管理表项目的值都清零，标记释放，完成一次内存释放。</p><p><strong>注意</strong>：申请的内存在用完以后，一定要释放。</p><h3 id="硬件设计">硬件设计</h3><p>KEY0 用于申请内存，每次申请 2K 字节内存。KEY1 用于写数据到申请到的内存里面。KEY2 用于释放内存。UART1用来显示内存状态及内存使用率.</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PE2/PE3/PE4设置为GPIO输入模式、上拉；PA0设置为GPIO输入模式，下拉；</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generate peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>添加内存管理驱动文件malloc.c和malloc.h，可直接移植正点原子代码。</li><li>添加按键驱动文件key.c和key.h,可参照前面按键输入一章。</li><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</li><li>在main.c文件下添加相应的头文件，编写内存管理测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> key=<span class="hljs-number">0</span>, i=<span class="hljs-number">0</span>, *p=<span class="hljs-number">0</span>; <span class="hljs-type">uint8_t</span> paddr[<span class="hljs-number">8</span>];<span class="hljs-type">uint8_t</span> sramx=<span class="hljs-number">0</span>;<span class="hljs-comment">//默认为内部sram</span><span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-comment">/* 初始化内部内存池 */</span>my_mem_init(SRAMIN);<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    key = key_scan(<span class="hljs-number">0</span>);    <span class="hljs-keyword">switch</span>(key)    &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> KEY0_PRES:            &#123;                p = mymalloc(sramx, <span class="hljs-number">2048</span>); <span class="hljs-comment">//创建2k 字节空间并写入内容</span>                <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)                &#123;                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2K byte space create success!\r\n&quot;</span>);                    <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span>*)p, <span class="hljs-string">&quot;Memory Malloc Test%03d&quot;</span>,i); <span class="hljs-comment">//写入内容</span>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\r\n&quot;</span>, p);                &#125;                <span class="hljs-keyword">break</span>;            &#125;           <span class="hljs-keyword">case</span> KEY1_PRES:            &#123;                <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)                &#123;                    <span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span>*)paddr, <span class="hljs-string">&quot;Create space Addr:0X%08X&quot;</span>, (<span class="hljs-type">uint32_t</span>)p);<span class="hljs-comment">//显示p的地址</span>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\r\n&quot;</span>, paddr);                &#125;                <span class="hljs-keyword">break</span>;            &#125;        <span class="hljs-keyword">case</span> KEY2_PRES:            &#123;                myfree(sramx, p); <span class="hljs-comment">//释放内存</span>                p = <span class="hljs-number">0</span>;                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2K byte space is free now!\r\n&quot;</span>);                <span class="hljs-keyword">break</span>;            &#125;        <span class="hljs-keyword">case</span> WKUP_PRES:            &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Internal RAM usage：%d%%\r\n&quot;</span>,my_mem_perused(SRAMIN)); <span class="hljs-comment">//显示内部内存使用率</span>                i++;            &#125;    &#125;  &#125;</code></pre></div><ul><li>编译无误下载到开发板后，KEY0 用于申请内存，每次申请 2K 字节内存，并写入内容，KEY1 显示写入的内容，KEY2 用于释放内存，KEY_UP显示内部内存使用率。串口助手显示内存状态及内存使用率.</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230602235006078.png" alt="image-20230602235006078" style="zoom:80%;" /></p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/mem_management.zip">mem_management</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之外部SRAM</title>
    <link href="/2023/05/31/STM32CubeMX%E4%B9%8B%E5%A4%96%E9%83%A8SRAM/"/>
    <url>/2023/05/31/STM32CubeMX%E4%B9%8B%E5%A4%96%E9%83%A8SRAM/</url>
    
    <content type="html"><![CDATA[<h3 id="外部sramxm8a51216简介">外部SRAM(XM8A51216)简介</h3><p>STM32F103ZET6芯片自带 64K字节的SRAM，对一般应用已经足够了，但在一些对内存要求高的场合，就需要添加外部SRAM了，开发板上带有一颗 1M 字节（512K x 16bit）容量的 SRAM 芯片：IS62WV51216BLL；</p><p>其逻辑功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604164952473.png" alt="image-20230604164952473" style="zoom:80%;" /></p><p>芯片操作控制表：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531153007310.png" alt="image-20230531153007310" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531134019640.png" alt="image-20230531134019640" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531083826527.png" alt="image-20230531083826527" style="zoom:80%;" /></p><p>实验使用 FSMC BANK1 的第<strong>3</strong>区来控制IS62WV51216BLL，将外部 SRAM 容量大小显示在 LCD 上延时一段时间，显示预存在外部 SRAM 的数据。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活FSMC，选中Bank1，片选为NE3（即Bank1的第3区），存储器类型选为SRAM，数据宽度设为16位,勾选 Byte enable。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531161352775.png" alt="image-20230531161352775" style="zoom:80%;" /></p><ul><li>在FSMC配置菜单中，使能存储器写，根据SRAM驱动芯片的数据参数设置地址建立时间、数据保存时间、总线周转阶段持续时间（设置为0），模式A</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531162647366.png" alt="image-20230531162647366" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>添加IS62WV51216BLL芯片驱动文件sram.c和sram.h</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief在指定地址(WriteAddr+Bank1_SRAM3_ADDR)开始,连续写入n个字节.</span><span class="hljs-comment">  * @parampBuffer:字节指针</span><span class="hljs-comment">  * @param  WriteAddr:要写入的地址</span><span class="hljs-comment">  * @param  n:要写入的字节数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fsmc_sram_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pBuffer,<span class="hljs-type">uint32_t</span> WriteAddr,<span class="hljs-type">uint32_t</span> n)</span>&#123;<span class="hljs-keyword">while</span>(n--)&#123;*(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>*)(Bank1_SRAM3_ADDR+WriteAddr)=*pBuffer;WriteAddr++;pBuffer++;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief在指定地址((WriteAddr+Bank1_SRAM3_ADDR))开始,连续读出n个字节.</span><span class="hljs-comment">  * @parampBuffer:字节指针</span><span class="hljs-comment">  * @param  ReadAddr:要读出的起始地址</span><span class="hljs-comment">  * @param  n:要读出的字节数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fsmc_sram_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pBuffer,<span class="hljs-type">uint32_t</span> ReadAddr,<span class="hljs-type">uint32_t</span> n)</span>&#123;<span class="hljs-keyword">while</span>(n--)&#123;*pBuffer++=*(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>*)(Bank1_SRAM3_ADDR+ReadAddr);ReadAddr++;&#125;&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</li><li>在main.c文件下编写SRAM测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">fsmc_sram_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> writeData = <span class="hljs-number">0xf0</span>, readData;<span class="hljs-type">uint16_t</span> cap = <span class="hljs-number">0</span>;<span class="hljs-comment">//SRAM 容量大小</span><span class="hljs-type">uint32_t</span> addr;  <span class="hljs-comment">/* 以1024字节为单位计算，IS62WV51216的容量为1MB */</span><span class="hljs-keyword">for</span>(addr = <span class="hljs-number">1024</span>; addr &lt;= <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; addr += <span class="hljs-number">1024</span>)&#123;  fsmc_sram_write(&amp;writeData, addr, <span class="hljs-number">1</span>);  fsmc_sram_read(&amp;readData, addr, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(readData == writeData)&#123;cap++;<span class="hljs-comment">//如果相同表示写入/读出成功，容量加1KB</span>readData = <span class="hljs-number">0</span>; <span class="hljs-comment">//读出的值清零 </span>&#125;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;External SRAM Memory Size: %dKB\r\n&quot;</span>, cap);&#125;<span class="hljs-comment">/* USER CODE END 0 */</span><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> write_string[] = <span class="hljs-string">&quot;This is SRAM testing...&quot;</span>;<span class="hljs-type">uint8_t</span> textlen = <span class="hljs-keyword">sizeof</span>(write_string);<span class="hljs-type">uint8_t</span> read_buf[textlen];<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_Delay(<span class="hljs-number">100</span>);fsmc_sram_test();<span class="hljs-comment">//打印SRAM大小</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    fsmc_sram_write(write_string, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(write_string));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SRAM_Write:%s\r\n&quot;</span>, write_string);    HAL_Delay(<span class="hljs-number">1000</span>);    fsmc_sram_read(read_buf, <span class="hljs-number">0</span>, textlen);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SRAM_Read:%s\r\n&quot;</span>, read_buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，串口助手打印出外部SRAM大小：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604181111942.png" alt="image-20230604181111942" style="zoom:80%;" /></p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/sram.zip">sram</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之FSMC_TFTLCD</title>
    <link href="/2023/05/30/STM32CubeMX%E4%B9%8BFSMC-TFTLCD/"/>
    <url>/2023/05/30/STM32CubeMX%E4%B9%8BFSMC-TFTLCD/</url>
    
    <content type="html"><![CDATA[<h3 id="tftlcd简介">TFTLCD简介</h3><p>TFT-LCD（thin film transistor-liquid crystal display）即薄膜晶体管液晶显示器。液晶显示屏的每一个像素上都设置有一个薄膜晶体管（TFT），每个像素都可以通过点脉冲直接控制。</p><p>常用的通信模式有6800模式和8080模式，本例程使用8080并口模式（简称80并口），8080接口有5条基本的控制线和多条数据线（8/9/16/18位）：</p><ul><li><p>CS：TFTLCD 片选信号。</p></li><li><p>WR：向 TFTLCD 写入数据。</p></li><li><p>RD：从 TFTLCD 读取数据。</p></li><li><p>RST：硬复位 TFTLCD。</p></li><li><p>RS：命令/数据标志（0，读写命令；1，读写数据）。</p></li><li><p>D[15：0]：16 位双向数据线。</p></li></ul><p>实验中使用的LCD是正点原子TFTLCD，其内部控制芯片ILI9341，其功能框图如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531102629121.png" alt="image-20230531102629121"  /></p><p><strong>ILI9341 部分重要命令</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082242026.png" alt="image-20230606082242026" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082317721.png" alt="image-20230606082317721" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082349293.png" alt="image-20230606082349293" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230606082521224.png" alt="image-20230606082521224" style="zoom:80%;" /></p><p><strong>8080时序图：</strong></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531103103667.png" alt="" /><figcaption>image-20230531103103667</figcaption></figure><p>一般 TFTLCD 模块的使用流程：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531103242060.png" alt="image-20230531103242060" style="zoom:80%;" /></p><p>其中，其中硬复位和初始化序列，只需要执行一次。</p><p>例如点操作流程：</p><ul><li>画点：设置坐标 → 写 GRAM 指令 → 写入颜色数据 → LCD 上显示颜色；</li><li>读点：设置坐标 → 读 GRAM 指令 → 读取颜色数据 → 获取到对应点的颜色；</li></ul><p>设置TFT液晶显示通常需要以下几个步骤：</p><ul><li><p>设置STM32F1与TFTLCD模块连接的IO口，将与TFTLCD模块相连的IO口进行初始化，以便驱动LCD，ILI9341 的 8080 通讯接口时序可以由 STM32 普通 I/O 接口进行模拟，但这样效率太低，STM32 提供了一种特别的控制方法——使用 FSMC 接口实现 8080接口时序。</p></li><li><p>初始化TFTLCD模块，向LCD控制器写入一系列的设置值（比如RGB格式、LCD显示方向、伽马校准等），这部分代码一般LCD厂商会提供，初始化之后LCD才可以正常使用。</p></li><li><p>通过函数将字符和数字显示到TFTLCD模块上，点操作只是一个点的处理，因此需要设计一个函数来多次使用这个步骤以实现字符和数字的显示。</p></li></ul><h3 id="fsmc-简介">FSMC 简介</h3><p>FSMC（Flexible Static Memory Controller即灵活的静态存储控制器）是STM32系列采用的一种新型存储器扩展技术，能够连接同步、异步存储器和16位PC存储卡，STM32通过FSMC可以与SRAM、ROM、PSRAM、NOR Flash和NAND Flash等存储器的引脚直接相连。</p><h4 id="stm32f1的fsmc内部框图">STM32F1的FSMC内部框图</h4><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530152947731.png" alt="image-20230530152947731" style="zoom:80%;" /></p><p>从上图我们可以看出，STM32 的 FSMC 将外部设备分为 3 类：NOR/PSRAM 设备、NAND设备、PC卡设备。他们共用地址、数据总线等信号，具有不同的片选(NE[4:1])以区分不同的设备。</p><h4 id="fsmc-存储器划分">FSMC 存储器划分</h4><p>FSMC 将外部存储器划分固定大小为 256M 字节的四个存储块,如下所示：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530155325449.png" alt="image-20230530155325449" style="zoom:80%;" /></p><ul><li><strong>NOR/PSRAM块</strong>有四个区：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531083826527.png" alt="image-20230531083826527" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531084817727.png" alt="image-20230531084817727" style="zoom:80%;" /></p><ul><li><strong>NAND Flash块和PC Card块</strong>：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531091707020.png" alt="image-20230531091707020" style="zoom:80%;" /></p><p>​ 其中，NAND Flash有三个区：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531091542061.png" alt="image-20230531091542061" style="zoom:80%;" /></p><h4 id="传输时序模式">传输时序模式</h4><ul><li><p>NOR Flash/PSRAM 控制器 <strong>异步</strong> 传输时序模式：</p><ul><li><p><strong>Mode 1</strong> - SRAM/PSRAM (CRAM)</p></li><li><p><strong>Mode A</strong> - SRAM/PSRAM (CRAM) 输出使能触发</p></li><li><p><strong>Mode 2/B</strong> - NOR Flash</p></li><li><p><strong>Mode C</strong> - NOR Flash 输出使能触发</p></li><li><p><strong>Mode D</strong> - 扩展地址异步传输</p></li><li><p><strong>Muxed mode</strong> - NOR Flash复合异步传输</p></li></ul></li><li><p>NAND Flash和PC Card只有一种异步传输时序模式：</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531095320326.png" alt="image-20230531095320326" style="zoom:80%;" /></p><p>本实验中使用的TFTLCD采用Mode A模式连接到STM32 FSMC上，其Mode A读写时序如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531100226860.png" alt="image-20230531100226860" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531100246088.png" alt="image-20230531100246088" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531113726434.png" alt="image-20230531113726434" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530152024061.png" alt="image-20230530152024061" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>设置PB0为GPIO输出模式，上拉，高速，默认低电平。（背光控制信号）</li><li>选择FSMC，选中Bank1，片选为NE4（即Bank1的第4区），存储器类型选为LCD Interface，LCD寄存器选择（RS）设置为A10，数据宽度设为16位</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531114601180.png" alt="image-20230531114601180" style="zoom:80%;" /></p><ul><li>在FSMC配置菜单中，使能存储器写，根据LCD驱动芯片的数据参数设置地址建立时间、数据保存时间、总线周转阶段持续时间（设置为0），模式A</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531115913269.png" alt="image-20230531115913269" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>创建TFTLCD驱动文件tftlcd.c和tftlcd.h,部分代码如下，详细代码见工程。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* LCD重要参数集 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">uint16_t</span> width;     <span class="hljs-comment">/* LCD 宽度 */</span>    <span class="hljs-type">uint16_t</span> height;    <span class="hljs-comment">/* LCD 高度 */</span><span class="hljs-type">uint16_t</span> lcd_id;    <span class="hljs-comment">/* lcd id */</span>    <span class="hljs-type">uint8_t</span> dir;        <span class="hljs-comment">/* 横屏还是竖屏控制：0，竖屏；1，横屏。 */</span>&#125;<span class="hljs-type">lcd_dev_t</span>;<span class="hljs-comment">/* LCD背光控制 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_BL(x)   do&#123; x ? \</span><span class="hljs-meta">                      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET) : \</span><span class="hljs-meta">                      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET); \</span><span class="hljs-meta">                     &#125;while(0)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSMC_ADDR_CMD  ((uint32_t*)0x6C000000)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSMC_ADDR_DATA ((uint32_t*)0x6C000800) </span><span class="hljs-comment">/******************************************************************************************/</span><span class="hljs-comment">/* LCD 属性,根据使用的屏幕改变其属性 */</span><span class="hljs-comment">/** ---------------------------------</span><span class="hljs-comment"> * | LCD ID Type | Width or Height |</span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> * |    9343     |     240*320     | </span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> * | 5510/1963   |     480*800     |</span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> * |    5310     |     320*480     |</span><span class="hljs-comment"> * ---------------------------------</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_WIDTH       240</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_HEIGHT      320</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_VERTICAL    0  </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_HORIZONTAL  1</span><span class="hljs-comment">/* LCD device ID */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_9341    (0X9341)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_8552    (0X8552)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_5510    (0X5510)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_1963    (0X1963)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_5310    (0X5310)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_7789    (0x7789)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_5761    (0X5761)</span><span class="hljs-comment">/******************************************************************************************/</span><span class="hljs-comment">/* ILI9341、SSD1963、ST7789、NT35310 command */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD9341_READ_ID   0xd3     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD7789_READ_ID   0x04     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5310_READ_ID   0xd4     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1963_READ_ID   0xa1     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_SCAN_DIR       0x36     <span class="hljs-comment">//scanning direction of frame memory.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_DISPLAY_ON     0x29     <span class="hljs-comment">//Display on</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_DISPLAY_OFF    0x28     <span class="hljs-comment">//Display off</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_ADDR_COLUMN    0x2a     <span class="hljs-comment">//X坐标 Column Address Set</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_ADDR_PAGE      0x2b     <span class="hljs-comment">//Y坐标 Page Address Set </span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_WR_GRAM        0x2c     <span class="hljs-comment">//Memory Write</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_RD_GRAM        0x2e     <span class="hljs-comment">//Memory Read</span></span><span class="hljs-comment">/* NT5510 command */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_READ_IDH       0xC500     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_READ_IDL       0xC501     <span class="hljs-comment">//Read IC device code.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_SCAN_DIR       0x3600     <span class="hljs-comment">//scanning direction of frame memory.</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_DISPLAY_ON     0x2900     <span class="hljs-comment">//Display on</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_DISPLAY_OFF    0x2800     <span class="hljs-comment">//Display off</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_ADDR_COLUMN    0X2A00     <span class="hljs-comment">//X坐标 Column Address Set</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_ADDR_PAGE      0X2B00     <span class="hljs-comment">//Y坐标 Page Address Set </span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD5510_WR_GRAM        0X2C00     <span class="hljs-comment">//Memory Write</span></span><span class="hljs-comment">/* 屏幕扫描方向定义 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> L2R_U2D         0           <span class="hljs-comment">/* 从左到右,从上到下, 默认的扫描方向 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> L2R_D2U         1           <span class="hljs-comment">/* 从左到右,从下到上 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> R2L_U2D         2           <span class="hljs-comment">/* 从右到左,从上到下 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> R2L_D2U         3           <span class="hljs-comment">/* 从右到左,从下到上 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> U2D_L2R         4           <span class="hljs-comment">/* 从上到下,从左到右 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> U2D_R2L         5           <span class="hljs-comment">/* 从上到下,从右到左 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> D2U_L2R         6           <span class="hljs-comment">/* 从下到上,从左到右 */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> D2U_R2L         7           <span class="hljs-comment">/* 从下到上,从右到左 */</span></span><span class="hljs-comment">/******************************************************************************************/</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_data</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> value)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_cmd</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> cmd)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_write_reg</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> cmd, <span class="hljs-type">uint16_t</span> value)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;                        <span class="hljs-comment">/* 初始化LCD */</span> <span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_clear</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> color)</span>;     <span class="hljs-comment">/* LCD清屏 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_draw_line</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x1, <span class="hljs-type">uint16_t</span> y1, <span class="hljs-type">uint16_t</span> x2, <span class="hljs-type">uint16_t</span> y2, <span class="hljs-type">uint16_t</span> color)</span>;     <span class="hljs-comment">/* 画直线 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_draw_rectangle</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x1, <span class="hljs-type">uint16_t</span> y1, <span class="hljs-type">uint16_t</span> x2, <span class="hljs-type">uint16_t</span> y2, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-comment">/* 画矩形 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_char</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">char</span> chr, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">uint8_t</span> mode, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_num</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> len, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_xnum</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> len, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">uint8_t</span> mode, <span class="hljs-type">uint16_t</span> color)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd_show_string</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> x, <span class="hljs-type">uint16_t</span> y, <span class="hljs-type">uint16_t</span> width, <span class="hljs-type">uint16_t</span> height, <span class="hljs-type">uint8_t</span> size, <span class="hljs-type">char</span> *p, <span class="hljs-type">uint16_t</span> color)</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 定义一个LCD结构体变量 */</span><span class="hljs-type">lcd_dev_t</span> lcddev = &#123;.width = LCD_WIDTH,.height = LCD_HEIGHT,.dir = LCD_VERTICAL  <span class="hljs-comment">/* 默认为竖屏 */</span>&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD写数据</span><span class="hljs-comment"> * @param       data: 要写入的数据</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_data</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> value)</span>&#123;    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_DATA) = value;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD写指令</span><span class="hljs-comment"> * @param       cmd: lcd指令</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_wr_cmd</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> cmd)</span>&#123;    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_CMD) = cmd;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD读数据</span><span class="hljs-comment"> * @param       无</span><span class="hljs-comment"> * @retval      读取到的数据</span><span class="hljs-comment"> */</span><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">lcd_rd_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-keyword">return</span> (*( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_DATA));&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       LCD写寄存器</span><span class="hljs-comment"> * @param       cmd:指令</span><span class="hljs-comment"> * @param       data:要写入的数据</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_write_reg</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> cmd, <span class="hljs-type">uint16_t</span> value)</span>&#123;    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_CMD) = cmd;       <span class="hljs-comment">/* 写入要写的指令 */</span>    *( __IO <span class="hljs-type">uint16_t</span> * )(FSMC_ADDR_DATA) = value;    <span class="hljs-comment">/* 写入数据 */</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       初始化LCD</span><span class="hljs-comment"> * @note        该初始化函数可以初始化各种型号的LCD(详见本.c文件最前面的描述)</span><span class="hljs-comment"> * @param       无</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* 获取屏幕id */</span>  lcddev.lcd_id = lcd_read_id();  <span class="hljs-comment">/* 显示之前必须lcd芯片初始化 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_7789)    &#123;        lcd_ex_st7789_reginit();    <span class="hljs-comment">/* 执行ST7789初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_9341)    &#123;        lcd_ex_ili9341_reginit();   <span class="hljs-comment">/* 执行ILI9341初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5310)    &#123;        lcd_ex_nt35310_reginit();   <span class="hljs-comment">/* 执行NT35310初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5510)    &#123;        lcd_ex_nt35510_reginit();   <span class="hljs-comment">/* 执行NT35510初始化 */</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_1963)    &#123;        lcd_ex_ssd1963_reginit();   <span class="hljs-comment">/* 执行SSD1963初始化 */</span>        lcd_ssd_set_backlight(<span class="hljs-number">100</span>); <span class="hljs-comment">/* 背光设置为最亮 */</span>    &#125;    <span class="hljs-comment">/* 设置屏幕大小、方向及扫描方向 */</span>  lcd_set_scan_dir(L2R_U2D);    <span class="hljs-comment">/* 开背光 */</span>    LCD_BL(<span class="hljs-number">1</span>);       <span class="hljs-comment">/* 清屏 */</span>    lcd_clear(WHITE);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       读取屏幕id</span><span class="hljs-comment"> * @param       None</span><span class="hljs-comment"> * @retval      屏幕id</span><span class="hljs-comment"> */</span><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">lcd_read_id</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* 尝试9341 ID的读取 */</span>    lcd_wr_cmd(LCD9341_READ_ID);    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* dummy read */</span>    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读到0X00 */</span>    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读取93 */</span>    lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;    lcddev.lcd_id |= lcd_rd_data(); <span class="hljs-comment">/* 读取41 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_9341)    <span class="hljs-comment">/* 不是 9341 , 尝试看看是不是 ST7789 */</span>    &#123;        lcd_wr_cmd(LCD7789_READ_ID);        lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* dummy read */</span>        lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* 读到0X85 */</span>        lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* 读取0X85 */</span>        lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;        lcddev.lcd_id |= lcd_rd_data();     <span class="hljs-comment">/* 读取0X52 */</span>                <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_8552)        <span class="hljs-comment">/* 将8552的ID转换成7789 */</span>        &#123;            lcddev.lcd_id = LCD_7789;        &#125;        <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_7789)        <span class="hljs-comment">/* 也不是ST7789, 尝试是不是 NT35310 */</span>        &#123;            lcd_wr_cmd(LCD5310_READ_ID);            lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* dummy read */</span>            lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读回0X01 */</span>            lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读回0X53 */</span>            lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;            lcddev.lcd_id |= lcd_rd_data(); <span class="hljs-comment">/* 这里读回0X10 */</span>            <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_5310)    <span class="hljs-comment">/* 也不是NT35310,尝试看看是不是NT35510 */</span>            &#123;                <span class="hljs-comment">/* 发送秘钥（厂家提供,照搬即可） */</span>                lcd_write_reg(<span class="hljs-number">0xF000</span>, <span class="hljs-number">0x0055</span>);                lcd_write_reg(<span class="hljs-number">0xF001</span>, <span class="hljs-number">0x00AA</span>);                lcd_write_reg(<span class="hljs-number">0xF002</span>, <span class="hljs-number">0x0052</span>);                lcd_write_reg(<span class="hljs-number">0xF003</span>, <span class="hljs-number">0x0008</span>);                lcd_write_reg(<span class="hljs-number">0xF004</span>, <span class="hljs-number">0x0001</span>);                                lcd_wr_cmd(LCD5510_READ_IDH);           <span class="hljs-comment">/* 读取ID高8位 */</span>                lcddev.lcd_id = lcd_rd_data();      <span class="hljs-comment">/* 读回0X55 */</span>                lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;                lcd_wr_cmd(LCD5510_READ_IDL);           <span class="hljs-comment">/* 读取ID低8位 */</span>                lcddev.lcd_id |= lcd_rd_data();     <span class="hljs-comment">/* 读回0X10 */</span>                HAL_Delay(<span class="hljs-number">5</span>);                                <span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_5510)        <span class="hljs-comment">/* 也不是NT5510,尝试看看是不是SSD1963 */</span>                &#123;                    lcd_wr_cmd(LCD1963_READ_ID);                    lcddev.lcd_id = lcd_rd_data();                    lcddev.lcd_id = lcd_rd_data();  <span class="hljs-comment">/* 读回0X57 */</span>                    lcddev.lcd_id &lt;&lt;= <span class="hljs-number">8</span>;                    lcddev.lcd_id |= lcd_rd_data(); <span class="hljs-comment">/* 读回0X61 */</span>                    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5761)lcddev.lcd_id = LCD_1963; <span class="hljs-comment">/* SSD1963读回的ID是5761H,为方便区分,我们强制设置为1963 */</span>                &#125;            &#125;        &#125;    &#125;<span class="hljs-keyword">return</span> lcddev.lcd_id;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       设置LCD的自动扫描方向(对RGB屏无效)</span><span class="hljs-comment"> * @note</span><span class="hljs-comment"> *              9341/5310/5510/1963/7789等IC已经实际测试</span><span class="hljs-comment"> *              注意:其他函数可能会受到此函数设置的影响(尤其是9341),</span><span class="hljs-comment"> *              所以,一般设置为L2R_U2D即可,如果设置为其他扫描方式,可能导致显示不正常.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param       dir:0~7,代表8个方向</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_set_scan_dir</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> dir)</span>&#123;    <span class="hljs-type">uint16_t</span> regval = <span class="hljs-number">0</span>;    <span class="hljs-type">uint16_t</span> dirreg = <span class="hljs-number">0</span>;    <span class="hljs-type">uint16_t</span> temp;    <span class="hljs-comment">/* 横屏时，对1963不改变扫描方向！其他IC改变扫描方向！竖屏时1963改变方向，其他IC不改变扫描方向 */</span>    <span class="hljs-keyword">if</span> ((lcddev.dir == LCD_HORIZONTAL &amp;&amp; lcddev.lcd_id != LCD_1963) || (lcddev.dir == LCD_VERTICAL &amp;&amp; lcddev.lcd_id == LCD_1963))    &#123;        <span class="hljs-keyword">switch</span> (dir)   <span class="hljs-comment">/* 方向转换 */</span>        &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: dir = <span class="hljs-number">6</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: dir = <span class="hljs-number">7</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: dir = <span class="hljs-number">4</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: dir = <span class="hljs-number">5</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: dir = <span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: dir = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: dir = <span class="hljs-number">3</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: dir = <span class="hljs-number">2</span>; <span class="hljs-keyword">break</span>;        &#125;    &#125;<span class="hljs-comment">/* 根据扫描方式 设置 0X36/0X3600 寄存器 bit 5,6,7 位的值 */</span><span class="hljs-keyword">switch</span> (dir)&#123;<span class="hljs-keyword">case</span> L2R_U2D:<span class="hljs-comment">/* 从左到右,从上到下 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> L2R_D2U:<span class="hljs-comment">/* 从左到右,从下到上 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> R2L_U2D:<span class="hljs-comment">/* 从右到左,从上到下 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> R2L_D2U:<span class="hljs-comment">/* 从右到左,从下到上 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> U2D_L2R:<span class="hljs-comment">/* 从上到下,从左到右 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> U2D_R2L:<span class="hljs-comment">/* 从上到下,从右到左 */</span>regval |= (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> D2U_L2R:<span class="hljs-comment">/* 从下到上,从左到右 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> D2U_R2L:<span class="hljs-comment">/* 从下到上,从右到左 */</span>regval |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<span class="hljs-keyword">break</span>;&#125;dirreg = LCD_SCAN_DIR;  <span class="hljs-comment">/* 对绝大部分驱动IC, 由0X36寄存器控制 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5510)    &#123;        dirreg = LCD5510_SCAN_DIR;    <span class="hljs-comment">/* 对于5510, 和其他驱动ic的寄存器有差异 */</span>    &#125;     <span class="hljs-comment">/* 9341 &amp; 7789 要设置BGR位 */</span>    <span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_9341 || lcddev.lcd_id == LCD_7789)    &#123;        regval |= <span class="hljs-number">0X08</span>;    &#125;lcd_write_reg(dirreg, regval);<span class="hljs-keyword">if</span> (lcddev.lcd_id != LCD_1963)   <span class="hljs-comment">/* 1963不做坐标处理 */</span>&#123;<span class="hljs-keyword">if</span> (regval &amp; <span class="hljs-number">0X20</span>)&#123;<span class="hljs-keyword">if</span> (lcddev.width &lt; lcddev.height)   <span class="hljs-comment">/* 交换X,Y */</span>&#123;temp = lcddev.width;lcddev.width = lcddev.height;lcddev.height = temp;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (lcddev.width &gt; lcddev.height)   <span class="hljs-comment">/* 交换X,Y */</span>&#123;temp = lcddev.width;lcddev.width = lcddev.height;lcddev.height = temp;&#125;&#125;&#125;<span class="hljs-comment">/* 设置显示区域(开窗)大小 */</span><span class="hljs-keyword">if</span> (lcddev.lcd_id == LCD_5510)&#123;lcd_wr_cmd(LCD5510_ADDR_COLUMN);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_COLUMN + <span class="hljs-number">1</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_COLUMN + <span class="hljs-number">2</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_cmd(LCD5510_ADDR_COLUMN + <span class="hljs-number">3</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE + <span class="hljs-number">1</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE + <span class="hljs-number">2</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_cmd(LCD5510_ADDR_PAGE + <span class="hljs-number">3</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);&#125;<span class="hljs-keyword">else</span>&#123;lcd_wr_cmd(LCD_ADDR_COLUMN);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_data((lcddev.width - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);lcd_wr_cmd(LCD_ADDR_PAGE);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data(<span class="hljs-number">0</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>);lcd_wr_data((lcddev.height - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0XFF</span>);&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief       清屏函数</span><span class="hljs-comment"> * @param       color: 要清屏的颜色</span><span class="hljs-comment"> * @retval      无</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd_clear</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> color)</span>&#123;    <span class="hljs-type">uint32_t</span> index = <span class="hljs-number">0</span>;    <span class="hljs-type">uint32_t</span> totalpoint = lcddev.width;    totalpoint *= lcddev.height;    <span class="hljs-comment">/* 得到总点数 */</span>    lcd_set_cursor(<span class="hljs-number">0x00</span>, <span class="hljs-number">0x0000</span>);   <span class="hljs-comment">/* 设置光标位置 */</span>  <span class="hljs-keyword">if</span>(lcddev.lcd_id == LCD_5510)&#123;  lcd_wr_cmd(LCD5510_WR_GRAM);        <span class="hljs-comment">/* 开始写入GRAM */</span>&#125;<span class="hljs-keyword">else</span>&#123;  lcd_wr_cmd(LCD_WR_GRAM);        <span class="hljs-comment">/* 开始写入GRAM */</span>&#125;    <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; totalpoint; index++)    &#123;  lcd_wr_data(color);    &#125;&#125;</code></pre></div><ul><li>在main.c文件下编写TFTLCD测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./Lcd/tftlcd.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">/* USER CODE END Includes */</span><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> x = <span class="hljs-number">0</span>;<span class="hljs-type">uint8_t</span> dev_id[<span class="hljs-number">12</span>];<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>lcd_init();                                         <span class="hljs-comment">/* 初始化LCD */</span><span class="hljs-built_in">sprintf</span>((<span class="hljs-type">char</span> *)dev_id, <span class="hljs-string">&quot;LCD ID:%04X&quot;</span>, lcddev.lcd_id);  <span class="hljs-comment">/* 将LCD ID打印到lcd_id数组 */</span><span class="hljs-comment">//printf(&quot;LCD ID:%x\r\n&quot;, lcddev.lcd_id); /* 打印LCD ID 此处没有初始化串口，无法打印 */</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">switch</span> (x)    &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: lcd_clear(WHITE);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: lcd_clear(BLACK);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: lcd_clear(BLUE);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: lcd_clear(RED);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: lcd_clear(MAGENTA);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: lcd_clear(GREEN);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: lcd_clear(CYAN);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: lcd_clear(YELLOW);  <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: lcd_clear(BRRED);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: lcd_clear(GRAY);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: lcd_clear(LGRAY);<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: lcd_clear(BROWN);<span class="hljs-keyword">break</span>;    &#125;    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">240</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&quot;STM32&quot;</span>, RED);    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">80</span>, <span class="hljs-number">240</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&quot;TFTLCD TEST&quot;</span>, GREEN);    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">110</span>, <span class="hljs-number">240</span>, <span class="hljs-number">16</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;KayoungZhang&quot;</span>, GREEN);    lcd_show_string(<span class="hljs-number">10</span>, <span class="hljs-number">130</span>, <span class="hljs-number">240</span>, <span class="hljs-number">16</span>, <span class="hljs-number">16</span>, (<span class="hljs-type">char</span> *)dev_id, RED); <span class="hljs-comment">/* 显示LCD ID */</span>    <span class="hljs-keyword">if</span> (x++ == <span class="hljs-number">12</span>)        x = <span class="hljs-number">0</span>;    HAL_Delay(<span class="hljs-number">1000</span>); <span class="hljs-comment">//1s轮换一次画面</span>&#125;</code></pre></div><ul><li>编译无误下载到开发板后，LCD屏循环显示相应的文字</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604142633939.png" alt="image-20230604142633939" style="zoom: 50%;" /> <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230604142703634.png" alt="image-20230604142703634" style="zoom: 50%;" /></p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/tftlcd.zip">tftlcd</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之SPI_Flash</title>
    <link href="/2023/05/30/STM32CubeMX%E4%B9%8BSPI-Flash/"/>
    <url>/2023/05/30/STM32CubeMX%E4%B9%8BSPI-Flash/</url>
    
    <content type="html"><![CDATA[<h3 id="spi-简介">SPI 简介</h3><p>SPI全称Serial Peripheral Interface，即串行外围设备接口。它是Motorola首先在其MC68HCXX系列处理器上定义的。SPI是一种高速的、全双工、同步通讯总线。</p><p>标准的SPI需要四根信号线：</p><p><strong>SS（Slave Select）</strong>：从设备选择，也称片选，master通过拉低slave的片选信号选择slave <strong>SCK（Serial Clock）</strong>：传输时钟的信号线，时钟信号由master产生，类似于I2C的SCL <strong>MOSI（Master Out Slave In）</strong>：master输出，slave输入，由master向slave发送数据的通道 <strong>MISO（Master In Slave Out）</strong>：master输入，slave输出，由slave向master发送数据的通道</p><p>通常一个master主设备可以连接多个slave从设备，同一时刻只有一个slave可以与master通信，通过片选信号来进行区别，还有一种类似菊花链的连接方式，可自行了解。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2294744-20220112223510175-1577265499.jpg" alt="" /><figcaption>SPI多从机示意图</figcaption></figure><p>SPI的工作基于移位寄存器，工作过程就像一个环形传送带，由master逐位将数据放在传送带上，并驱动传送带将数据传送到slave，同时slave也会同步地逐位将数据传送给master。简单的理解:可以认为是数据交换，外设的写操作和读操作时同步完成的，如果只进行写操作，主设备只需要忽略接收到的字节，如果主设备要进行读操作，就必须发送一个空字节来引发从设备的传输。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2294744-20220112223510132-1684027745.jpg" alt="" /><figcaption>SPI移位原理</figcaption></figure><p>SPI总线根据时钟极性（CPOL）和时钟相位（CPHA）的配置不同，可以有四种工作方式：</p><ul><li><strong>mode 0：CPOL = 0，CPHA = 0；</strong></li></ul><p>时钟空闲时为低电平，第一个上升沿采样，第一个下降沿传输数据</p><ul><li><strong>mode 1：CPOL = 0，CPHA = 1；</strong></li></ul><p>时钟空闲时为低电平，第一个上升沿传输数据，第一个下降沿采样</p><ul><li><strong>mode 2：CPOL = 1，CPHA = 0；</strong></li></ul><p>时钟空闲时为高电平，第一个下降沿采样，第一个上升沿传输数据</p><ul><li><strong>mode 3：CPOL = 1，CPHA = 1；</strong></li></ul><p>时钟空闲时为高电平，第一个下降沿传输数据，第一个上升沿采样</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530135814179.png" alt="image-20230530135814179" style="zoom:80%;" /></p><p>STM32内部集成有 SPI 控制器，其内部框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530132423592.png" alt="image-20230530132423592" style="zoom:80%;" /></p><h3 id="w25qxx芯片简介">W25QXX芯片简介</h3><p>外部flash使用比较多的是华邦公司推出的W25QXX系列spi flash芯片，开发板上使用的flash是W25Q128。</p><p>它的容量为128M-bit（16M字节），它分为256个块(Block)（块大小为64KB），每个块又分为16个扇区(Sector)（扇区大小为4KB），最小擦除单位为一个扇区即4KB，因此在选择芯片的时候必须要有4K以上的SRAM（可以开辟4K的缓冲区）。</p><p>W25Q128 flash框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530141712311.png" alt="image-20230530141712311"  /></p><p>其常用指令如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530141512789.png" alt="image-20230530141512789"  /></p><h3 id="硬件设计">硬件设计</h3><p>我们将使用 STM32 的 SPI2 来读取外部 SPI FLASH 芯片（W25Q128），向flash写入数据，然后读出来，并使用串口打印出来。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530142337023.png" alt="image-20230530142337023" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>PB12设置为GPIO推挽输出模式、默认高电平输出、上拉、高速（片选引脚）</li><li>激活SPI2，不开启NSS，数据长度8位，MSB先输出，分频因子256，CPOL为HIGH，CPHA为第二个边沿，不开启CRC检验，NSS为软件控制</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530145350108.png" alt="image-20230530145350108" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generate peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li><p>在spi.c文件下可以看到SPI2的初始化函数，片选管脚的初始化在gpio.c中。</p></li><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</p></li><li><p>在工程中创建w25qxx文件夹，并编写flash驱动文件：w25qxx.c和w25qxx.h,注意添加头文件及路径，部分重要的函数如下：</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  使用SPI2发送一个字节的数据并返回读取的一字节数据</span><span class="hljs-comment"> * @param  byte：要发送的数据</span><span class="hljs-comment"> * @retval 返回接收到的数据</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">spi2_rd_wr_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> TxData)</span>&#123;<span class="hljs-type">uint8_t</span> Rxdata;HAL_SPI_TransmitReceive(&amp;hspi2,&amp;TxData,&amp;Rxdata,<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>);        <span class="hljs-keyword">return</span> Rxdata;              <span class="hljs-comment">//返回收到的数据</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  读取flash id</span><span class="hljs-comment"> * @param  None.</span><span class="hljs-comment"> * @retval Temp: 返回的ID值</span><span class="hljs-comment"> */</span><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">w25qxx_readID</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint16_t</span> Temp = <span class="hljs-number">0</span>;W25QXX_CS_LOW();  <span class="hljs-comment">/* Send &quot;RDID &quot; instruction */</span>spi2_rd_wr_byte(W25X_ManufactDeviceID);<span class="hljs-comment">//发送读取ID命令    </span>spi2_rd_wr_byte(Dummy_Byte);     spi2_rd_wr_byte(Dummy_Byte);     spi2_rd_wr_byte(Dummy_Byte);  Temp|=spi2_rd_wr_byte(Dummy_Byte)&lt;&lt;<span class="hljs-number">8</span>;  Temp|=spi2_rd_wr_byte(Dummy_Byte); W25QXX_CS_HIGH();    <span class="hljs-keyword">return</span> Temp;&#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  擦除FLASH扇区</span><span class="hljs-comment">  * @param  SectorAddr：要擦除的扇区地址</span><span class="hljs-comment">  * @retval 无</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_erase_sector</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> SectorAddr)</span>   &#123;  w25qxx_write_enable();                  <span class="hljs-comment">//SET WEL  </span>w25qxx_wait_busy();   W25QXX_CS_LOW();                            <span class="hljs-comment">//使能器件   </span>spi2_rd_wr_byte(W25X_SectorErase);   <span class="hljs-comment">//发送扇区擦除指令 </span><span class="hljs-keyword">if</span>(W25QXX_TYPE==W25Q256)                <span class="hljs-comment">//如果是W25Q256的话地址为4字节的，要发送最高8位</span>&#123;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((SectorAddr)&gt;&gt;<span class="hljs-number">24</span>)); &#125;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((SectorAddr)&gt;&gt;<span class="hljs-number">16</span>));  <span class="hljs-comment">//发送24bit地址    </span>spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((SectorAddr)&gt;&gt;<span class="hljs-number">8</span>));   spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)SectorAddr);  W25QXX_CS_HIGH();                            <span class="hljs-comment">//取消片选           </span>w25qxx_wait_busy();       <span class="hljs-comment">//等待擦除完成</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  对FLASH写入数据，调用本函数写入数据前需要先擦除扇区</span><span class="hljs-comment">  * @param pBuffer，要写入数据的指针</span><span class="hljs-comment">  * @param  WriteAddr，写入地址</span><span class="hljs-comment">  * @param  NumByteToWrite，写入数据长度</span><span class="hljs-comment">  * @retval 无</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer, <span class="hljs-type">uint32_t</span> WriteAddr, <span class="hljs-type">uint16_t</span> NumByteToWrite)</span>&#123;<span class="hljs-type">uint8_t</span> NumOfPage = <span class="hljs-number">0</span>, NumOfSingle = <span class="hljs-number">0</span>, Addr = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>, temp = <span class="hljs-number">0</span>;Addr = WriteAddr % W25X_PageSize;   <span class="hljs-comment">//mod运算求余，若writeAddr是W25X_PageSize整数倍，运算结果Addr值为0</span>count = W25X_PageSize - Addr;<span class="hljs-comment">//差count个数据值，刚好可以对齐到页地址</span>NumOfPage =  NumByteToWrite / W25X_PageSize; <span class="hljs-comment">//计算出要写多少整数页</span>NumOfSingle = NumByteToWrite % W25X_PageSize; <span class="hljs-comment">//mod运算求余，计算出剩余不满一页的字节数</span><span class="hljs-comment">/* Addr=0,则WriteAddr 刚好按页对齐 aligned  */</span><span class="hljs-keyword">if</span> (Addr == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (NumOfPage == <span class="hljs-number">0</span>) <span class="hljs-comment">// NumByteToWrite &lt; W25X_PageSize</span>&#123;   w25qxx_page_write(pBuffer, WriteAddr, NumByteToWrite);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">while</span> (NumOfPage--)<span class="hljs-comment">//先把整数页都写了</span>&#123;w25qxx_page_write(pBuffer, WriteAddr, W25X_PageSize);WriteAddr +=  W25X_PageSize;pBuffer += W25X_PageSize;&#125;w25qxx_page_write(pBuffer, WriteAddr, NumOfSingle);<span class="hljs-comment">//若有多余的不满一页的数据，把它写完</span>&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">/* WriteAddr 不能按页对齐 */</span>&#123;<span class="hljs-keyword">if</span> (NumOfPage == <span class="hljs-number">0</span>) <span class="hljs-comment">//NumByteToWrite &lt; W25X_PageSize</span>&#123;<span class="hljs-keyword">if</span> (NumOfSingle &gt; count) <span class="hljs-comment">//当前页剩余的count个位置比NumOfSingle小，写不完</span>&#123;temp = NumOfSingle - count;w25qxx_page_write(pBuffer, WriteAddr, count);<span class="hljs-comment">//先写满当前页</span>WriteAddr +=  count;pBuffer += count;w25qxx_page_write(pBuffer, WriteAddr, temp);<span class="hljs-comment">//再写剩余的数据</span>&#125;<span class="hljs-keyword">else</span> &#123;w25qxx_page_write(pBuffer, WriteAddr, NumByteToWrite);&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/*地址不对齐多出的count分开处理，不加入这个运算*/</span>NumByteToWrite -= count;NumOfPage =  NumByteToWrite / W25X_PageSize;NumOfSingle = NumByteToWrite % W25X_PageSize;w25qxx_page_write(pBuffer, WriteAddr, count);WriteAddr +=  count;pBuffer += count;<span class="hljs-keyword">while</span> (NumOfPage--)<span class="hljs-comment">//把整数页都写了</span>&#123;w25qxx_page_write(pBuffer, WriteAddr, W25X_PageSize);WriteAddr +=  W25X_PageSize;pBuffer += W25X_PageSize;&#125;<span class="hljs-keyword">if</span> (NumOfSingle != <span class="hljs-number">0</span>)<span class="hljs-comment">//若有多余的不满一页的数据，把它写完</span>&#123;w25qxx_page_write(pBuffer, WriteAddr, NumOfSingle);&#125;&#125;&#125;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief   读取FLASH数据</span><span class="hljs-comment">  * @param   pBuffer，存储读出数据的指针</span><span class="hljs-comment">  * @param   ReadAddr，读取地址</span><span class="hljs-comment">  * @param   NumByteToRead，读取数据长度</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer,<span class="hljs-type">uint32_t</span> ReadAddr,<span class="hljs-type">uint16_t</span> NumByteToRead)</span>   &#123;     W25QXX_CS_LOW();                            <span class="hljs-comment">//使能器件   </span>spi2_rd_wr_byte(W25X_ReadData);      <span class="hljs-comment">//发送读取命令  </span><span class="hljs-keyword">if</span>(W25QXX_TYPE==W25Q256)                <span class="hljs-comment">//如果是W25Q256的话地址为4字节的，要发送最高8位</span>&#123;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((ReadAddr)&gt;&gt;<span class="hljs-number">24</span>));    &#125;spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((ReadAddr)&gt;&gt;<span class="hljs-number">16</span>));   <span class="hljs-comment">//发送24bit地址    </span>spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)((ReadAddr)&gt;&gt;<span class="hljs-number">8</span>));   spi2_rd_wr_byte((<span class="hljs-type">uint8_t</span>)ReadAddr);<span class="hljs-comment">/* 读取数据 */</span><span class="hljs-keyword">while</span> (NumByteToRead--)&#123;*pBuffer = spi2_rd_wr_byte(Dummy_Byte);<span class="hljs-comment">/* 指向下一个字节缓冲区 */</span>pBuffer++;&#125;W25QXX_CS_HIGH();            &#125;</code></pre></div><ul><li>在main.c文件下编写SPI测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> wData[<span class="hljs-number">255</span>];<span class="hljs-type">uint8_t</span> rData[<span class="hljs-number">255</span>];<span class="hljs-type">uint32_t</span> i;<span class="hljs-type">uint16_t</span> flash_id = <span class="hljs-number">0</span>;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>flash_id = w25qxx_readID();<span class="hljs-keyword">if</span>(flash_id == W25Q128)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash type is W25Q128. ID: %#X \r\n&quot;</span>, flash_id);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash type is unknown. ID: %#X \r\n&quot;</span>, flash_id);&#125;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)&#123;    wData[i] = i;    rData[i] = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 写入数据，写入之前必须擦除 */</span>w25qxx_erase_sector(<span class="hljs-number">0</span>);w25qxx_write(wData, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">/* 读取数据 */</span>    w25qxx_read(rData, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);     <span class="hljs-comment">/* 打印数据 */</span>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02X &quot;</span>, rData[i]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">2000</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，串口助手每隔1秒打印读取的数据信息。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230602214324217.png" alt="image-20230602214324217" style="zoom:80%;" /></p><p>工程文件Gitee： <a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/spi_flash.zip">spi_flash</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之I2C_EEPROM</title>
    <link href="/2023/05/30/STM32CubeMX%E4%B9%8BI2C-EEPROM/"/>
    <url>/2023/05/30/STM32CubeMX%E4%B9%8BI2C-EEPROM/</url>
    
    <content type="html"><![CDATA[<h3 id="i2c-简介">I2C 简介</h3><p>I2C（Inter-Integrated Circuit）总线是由PHILIPS公司开发的由数据线SDA和时钟线SCL构成的两线式串行总线，用于连接微控制器及其外围I2C设备。</p><p>在物理层结构框图上：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/9f8e02deafc832aa7db61065c5a469b8f2d0f1d4.png@831w_276h_progressive.webp" alt="" /><figcaption>img</figcaption></figure><p>它有如下特点：</p><ul><li><p>在一个 I2C 通讯总线中，可连接多个 I2C 设备，支持多个通讯主机及多个通讯从机。每个连接到总线的设备都有一个独立的地址，主机利用这个地址进行不同设备之间的访问；</p></li><li><p>总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。</p></li><li><p>多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p></li><li><p>有三种传输模式，标准模式（100kbit/s）、快速模式（400kbit/s）、高速模式（3.4Mbit/s 多数I2C设备不支持）</p></li><li><p>连接到相同总线的 I2C 设备数量受到总线的最大电容 400pF 限制。</p></li></ul><p>在I2C协议层上：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/1487d890ccbbd39731bc795c2c18b007b6f09e6f.png@831w_236h_progressive.webp" alt="" /><figcaption>img</figcaption></figure><p>I2C总线在传送数据的过程中共有三种类型信号：</p><ul><li>开始信号:SCL为高电平时，SDA由高电平向低电平跳变，开始传送数据</li><li>结束信号:SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据</li><li>应答信号:接收数据的IC在接收到8位数据后，向发送数据的IC发出特定的低电平脉冲，表示已经收到数据。</li></ul><p>I2C总线寻址按照从机地址可分为7位和10位（寻址字节）寻址两种，D7~D1位组成从机的地址，D0位是数据传送方向（0表示主机向从机写数据/1表示主机由从机读数据）</p><h3 id="eeprom简介">EEPROM简介</h3><p>EEPROM 芯片具有掉电后存储内容不丢失的功能，所以一般用来存储参数数据，比较常用的AT24C02芯片，内部含有256个字节，具有I2C通讯接口。</p><p>AT24C02芯片的器件地址为7位，高4位固定为1010，低3位有上表中的A0/A1/A2引脚的电平决定，还有一位（最低位R/W）用来选择读写方向。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530124753089.png" alt="" /><figcaption>image-20230530124753089</figcaption></figure><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530122039619.png" alt="image-20230530122039619" style="zoom:80%;" /></p><p>通过向AT24C02写入特定的数据，然后断电从其中读取数据，通过串口1打印出来。</p><h3 id="软件设计">软件设计</h3><p>I2C程序可以通过gpio模拟的方式编写，但STM32集成有I2C控制器，所以可以直接通过其I2C控制器进行程序的控制。</p><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活I2C1，选择标准传输模式，选择7位寻址地址，其余默认设置</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601204436710.png" alt="image-20230601204436710" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generate peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li><p>在i2c.c文件下可以看到I2C1初始化函数;</p></li><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</p></li><li><p>添加AT24C02驱动文件24cxx.c和24cxx.h,并添加头文件和头文件路径，主要代码如下：</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief   从EEPROM里面读取一块数据   </span><span class="hljs-comment">  *@param     pBuffer:存放从EEPROM读取的数据的缓冲区指针</span><span class="hljs-comment">  *@param     WriteAddr:接收数据的EEPROM的地址</span><span class="hljs-comment">  * @param     NumByteToWrite:要从EEPROM读取的字节数</span><span class="hljs-comment">  * @retval  无</span><span class="hljs-comment">  */</span><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">at24cxx_BufferRead</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer, <span class="hljs-type">uint8_t</span> ReadAddr, <span class="hljs-type">uint16_t</span> NumByteToRead)</span>&#123;HAL_StatusTypeDef status = HAL_OK;status=HAL_I2C_Mem_Read(&amp;hi2c1,EEPROM_ADDRESS,ReadAddr, I2C_MEMADD_SIZE_8BIT, (<span class="hljs-type">uint8_t</span> *)pBuffer, NumByteToRead,<span class="hljs-number">1000</span>);<span class="hljs-keyword">return</span> status;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief     将缓冲区中的数据写到I2C EEPROM中  </span><span class="hljs-comment">  *@param     pBuffer:缓冲区指针</span><span class="hljs-comment">  *@param     WriteAddr:写地址</span><span class="hljs-comment">  * @param     NumByteToWrite:写的字节数</span><span class="hljs-comment">  * @retval    无</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">at24cxx_BufferWrite</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pBuffer, <span class="hljs-type">uint8_t</span> WriteAddr, <span class="hljs-type">uint16_t</span> NumByteToWrite)</span>&#123;  <span class="hljs-type">uint8_t</span> NumOfPage = <span class="hljs-number">0</span>, NumOfSingle = <span class="hljs-number">0</span>, Addr = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;  Addr = WriteAddr % EEPROM_PAGESIZE;  count = EEPROM_PAGESIZE - Addr;  NumOfPage =  NumByteToWrite / EEPROM_PAGESIZE;  NumOfSingle = NumByteToWrite % EEPROM_PAGESIZE;   <span class="hljs-comment">/* If WriteAddr is I2C_PageSize aligned  */</span>  <span class="hljs-keyword">if</span>(Addr == <span class="hljs-number">0</span>)   &#123;    <span class="hljs-comment">/* If NumByteToWrite &lt; I2C_PageSize */</span>    <span class="hljs-keyword">if</span>(NumOfPage == <span class="hljs-number">0</span>)     &#123;      at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);    &#125;    <span class="hljs-comment">/* If NumByteToWrite &gt; I2C_PageSize */</span>    <span class="hljs-keyword">else</span>      &#123;      <span class="hljs-keyword">while</span>(NumOfPage--)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, EEPROM_PAGESIZE);         WriteAddr +=  EEPROM_PAGESIZE;        pBuffer += EEPROM_PAGESIZE;      &#125;      <span class="hljs-keyword">if</span>(NumOfSingle!=<span class="hljs-number">0</span>)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);      &#125;    &#125;  &#125;  <span class="hljs-comment">/* If WriteAddr is not I2C_PageSize aligned  */</span>  <span class="hljs-keyword">else</span>   &#123;    <span class="hljs-comment">/* If NumByteToWrite &lt; I2C_PageSize */</span>    <span class="hljs-keyword">if</span>(NumOfPage== <span class="hljs-number">0</span>)     &#123;      at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);    &#125;    <span class="hljs-comment">/* If NumByteToWrite &gt; I2C_PageSize */</span>    <span class="hljs-keyword">else</span>    &#123;      NumByteToWrite -= count;      NumOfPage =  NumByteToWrite / EEPROM_PAGESIZE;      NumOfSingle = NumByteToWrite % EEPROM_PAGESIZE;            <span class="hljs-keyword">if</span>(count != <span class="hljs-number">0</span>)      &#123;          at24cxx_PageWrite(pBuffer, WriteAddr, count);        WriteAddr += count;        pBuffer += count;      &#125;             <span class="hljs-keyword">while</span>(NumOfPage--)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, EEPROM_PAGESIZE);        WriteAddr +=  EEPROM_PAGESIZE;        pBuffer += EEPROM_PAGESIZE;        &#125;      <span class="hljs-keyword">if</span>(NumOfSingle != <span class="hljs-number">0</span>)      &#123;        at24cxx_PageWrite(pBuffer, WriteAddr, NumOfSingle);       &#125;    &#125;  &#125;  &#125;</code></pre></div><ul><li>在main.c中添加测试代码：</li></ul><p>AT24C02的2Kbit分为32页，每页8个字节。而EEPROM也可以按页写入，本例使用了按页写入的方式，分32次写入。注意每次写入完毕需要延时5ms，是AT24C02芯片的要求；读取数据没有页的限制，可以一次全部读取256个字节</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> WriteBuf[<span class="hljs-number">256</span>];<span class="hljs-type">uint8_t</span> ReadBuf[<span class="hljs-number">256</span>];<span class="hljs-type">uint16_t</span> i;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">256</span>; i++)&#123; <span class="hljs-comment">//初始化写数据缓冲区</span>    WriteBuf[i] = i;&#125;<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    at24cxx_BufferWrite(WriteBuf, <span class="hljs-number">0x00</span>, <span class="hljs-number">256</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EEPROM 24C02 write Test OK!\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">3000</span>); <span class="hljs-comment">//延时3s</span>    <span class="hljs-comment">/* EEPROM读取没有页限制，可以一次读取256个字节 */</span>    at24cxx_BufferRead(ReadBuf, <span class="hljs-number">0x00</span>, (<span class="hljs-type">uint16_t</span>)<span class="hljs-number">256</span>);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>;i++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%02X &quot;</span>,ReadBuf[i]);    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">memcmp</span>(WriteBuf,ReadBuf,<span class="hljs-number">256</span>) == <span class="hljs-number">0</span>)    &#123;<span class="hljs-comment">//通过内存比较，判断读取和写入的数据是否相同</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nEEPROM 24C02 Read Test OK!\r\n&quot;</span>);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nEEPROM 24C02 Read Test False!\r\n&quot;</span>);    &#125;    HAL_Delay(<span class="hljs-number">500</span>);&#125;</code></pre></div><ul><li>编译无误下载到开发板后，同时串口助手打印出相应信息</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601220435162.png" alt="image-20230601220435162" style="zoom:80%;" /></p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/i2c_eeprom.zip">i2c_eeprom</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之MCU内部温度传感器</title>
    <link href="/2023/05/29/STM32CubeMX%E4%B9%8BMCU%E5%86%85%E9%83%A8%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    <url>/2023/05/29/STM32CubeMX%E4%B9%8BMCU%E5%86%85%E9%83%A8%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>STM32F103 有一个内部的温度传感器，可以用来测量 CPU 及周围的温度(TA)。该温度传感器在内部和 ADCx_IN16 输入通道相连接，此通道把传感器输出的电压转换成数字值,这也属于ADC。此温度传感器官方推荐采样时间是 17.1 µs。</p><p>其内部框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530101309912.png" alt="image-20230530101309912" style="zoom:80%;" /></p><p><strong>温度公式： = (V25 - VSENSE) / Avg_Slope + 25 °C</strong></p><p>其中：</p><ul><li>V25 为 25°C时VSENSE的电压值（典型值：1.43V）</li><li>Avg_Slope 为温度与Vsense曲线的平均斜率（典型值为4.3 mV/°C）</li></ul><p>在datasheet电气特性章节中看到：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210530101608931.png" alt="" /><figcaption>image-20210530101608931</figcaption></figure><h3 id="硬件设计">硬件设计</h3><p>本实验通过ADC1通道16采集内部温度，将采样的AD值和转换后的温度值通过USART1串口打印出来</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活ADC1温度传感器通道，设置右对齐，关闭扫描、连续及间断模式，使能regular conversion，设置软件触发、设置采样时间239.5个周期（239.5/12MHz =19.96us）</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210530103255512.png" alt="" /><figcaption>image-20210530103255512</figcaption></figure><ul><li>RCC设置外接HSE，时钟设置为72M，ADC预分频因子设置为6，ADC_CLK为12MHz</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210530090558085.png" alt="" /><figcaption>image-20210530090558085</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generate peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在主函数while循环中添加如下测试程序</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint16_t</span> ad_value = <span class="hljs-number">0</span>;<span class="hljs-type">float</span> voltage = <span class="hljs-number">0.0f</span>, temperature = <span class="hljs-number">0.0f</span>;<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;HAL_ADC_Start(&amp;hadc1);<span class="hljs-comment">//启动ADC转换</span>HAL_ADC_PollForConversion(&amp;hadc1,<span class="hljs-number">10</span>);<span class="hljs-comment">//等待转换完成，10ms表示超时时间</span>ad_value = HAL_ADC_GetValue(&amp;hadc1);<span class="hljs-comment">//读取ADC转换数据（12位数据）</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN16 ADC value: %d\r\n&quot;</span>, ad_value);voltage = ad_value*(<span class="hljs-number">3.3</span>/<span class="hljs-number">4096</span>);<span class="hljs-comment">//AD值乘以分辨率即为电压值</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN16 VOL value: %.2fV\r\n&quot;</span>, voltage);temperature = (<span class="hljs-number">1.43</span> - voltage)/<span class="hljs-number">0.0043</span> + <span class="hljs-number">25</span>;<span class="hljs-comment">//根据公式算出温度值</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MCU Internal Temperature: %.2f ℃\r\n&quot;</span>, temperature);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);HAL_Delay(<span class="hljs-number">1000</span>);&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</li><li>编译无误后下载到开发板，串口助手每隔1秒打印读取的温度数据</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601084339509.png" alt="image-20230601084339509" style="zoom:80%;" /></p><p>工程文件Gitee： <a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/adc_inter_temp.zip">adc_inter_temp</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之DAC</title>
    <link href="/2023/05/29/STM32CubeMX%E4%B9%8BDAC/"/>
    <url>/2023/05/29/STM32CubeMX%E4%B9%8BDAC/</url>
    
    <content type="html"><![CDATA[<p>DAC（digital to analog converter）即数模转换器，它可以将数字信号转换为模拟信号.在常见的数字信号系统中，大部分传感器信号被转化成电压信号，而ADC把电压模拟信号转换成易于计算机存储、处理的数字编码，由计算机处理完成后，再由DAC输出电压模拟信号来驱动某些执行器件，使人类易于感知。如音频信号的采集和还原就是这样的一个过程。</p><p>STM32F1的DAC模块是12位电压输出型DAC。可以配置为8位或12位模式，在12位模式下，数据可以设置为左对齐或右对齐。它有2个输出通道，2个通道可以独立地进行转换。</p><p>DAC通道框图如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530105255132.png" alt="image-20230530105255132" style="zoom:80%;" /></p><p><strong>DAC的转换公式</strong>：<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530105432369.png" alt="image-20230530105432369" style="zoom:80%;" /></p><p>DOR：DAC数据输出寄存器值；</p><h3 id="硬件设计">硬件设计</h3><p>本实验通过 DAC 通道1 输出模拟电压，用KEY1用来增加DAC输入值，WK_UP用来减少DAC输入值，然后使用USART1将输出的电压值打印出来</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530111127269.png" alt="image-20230530111127269" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PE3设置为GPIO输入模式、上拉；PA0设置为GPIO输入模式，下拉；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601203040597.png" alt="image-20230601203040597" style="zoom:80%;" /></p><ul><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活DAC_OUT1，关闭输出缓冲，不使用触发功能</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601132917195.png" alt="image-20230601132917195" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generate peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>因为使用到按键功能，所以移植之前用到的按键输入工程中Key文件,记得添加头文件和路径（#include "key.h"）。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601175003752.png" alt="image-20230601175003752" style="zoom:80%;" /></p><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</li><li>在main.c文件下编写DAC测试代码</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint16_t</span> dac_val;<span class="hljs-comment">//读取的DAC值</span><span class="hljs-type">float</span> dac_vol;<span class="hljs-comment">//转换后的电压值</span><span class="hljs-type">uint16_t</span> dac_setval = <span class="hljs-number">0</span>;<span class="hljs-comment">//DAC设置值</span><span class="hljs-type">uint8_t</span> key = <span class="hljs-number">0</span>;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_DAC_Start(&amp;hdac,DAC_CHANNEL_1);<span class="hljs-comment">//开启DAC通道1</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    key = key_scan(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(key == KEY1_PRES)    &#123;        <span class="hljs-keyword">if</span>(dac_setval &gt; <span class="hljs-number">4000</span>)            dac_setval = <span class="hljs-number">0</span>;        dac_setval += <span class="hljs-number">200</span>;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key == WKUP_PRES)    &#123;        <span class="hljs-keyword">if</span>(dac_setval &lt; <span class="hljs-number">200</span>)            dac_setval = <span class="hljs-number">4000</span>;        dac_setval -= <span class="hljs-number">200</span>;    &#125;    HAL_DAC_SetValue(&amp;hdac,DAC_CHANNEL_1,DAC_ALIGN_12B_R,dac_setval);    <span class="hljs-keyword">if</span>(key == KEY1_PRES || key == WKUP_PRES)    &#123;        dac_val = HAL_DAC_GetValue(&amp;hdac,DAC_CHANNEL_1);<span class="hljs-comment">//其值=dac_setval</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DAC_OUT1 DAC value: %d\r\n&quot;</span>,dac_val);        dac_vol = (<span class="hljs-type">float</span>)dac_val * (<span class="hljs-number">3.3</span>/<span class="hljs-number">4096</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DAC_OUT1 VOL value: %.2fV\r\n&quot;</span>,dac_vol);    &#125;    HAL_Delay(<span class="hljs-number">10</span>);&#125;</code></pre></div><ul><li>编译无误后下载到开发板，打印出DAC通道1的DAC值和电压值，按下按键，DAC值和电压值发生变化。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230601202614101.png" alt="image-20230601202614101" style="zoom:80%;" /></p><p>工程文件Gitee： <a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/dac.zip">dac</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之ADC</title>
    <link href="/2023/05/29/STM32CubeMX%E4%B9%8BADC/"/>
    <url>/2023/05/29/STM32CubeMX%E4%B9%8BADC/</url>
    
    <content type="html"><![CDATA[<h3 id="adc简介">ADC简介</h3><p>ADC（analog to digital converter）即模数转换器，它可以将模拟量信号转换为数字信号，按照转换原理主要分为逐次逼近型、双积分型、电压频率转换型三种。</p><p>STM32 的 ADC 是 12 位逐次逼近型的模拟数字转换器。它有 18 个通道，可测量 16 个外部和 2 个内部信号源。各通道的 A/D 转换模式有单次、连续、扫描或间断模式。ADC 的转换结果可以以左对齐或右对齐方式存储在 16 位数据寄存器中。ADC时钟挂载在APB2上，最大14MHz。</p><p>单个ADC功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530083701000.png" alt="image-20230530083701000" style="zoom:80%;" /></p><p>STM32 将 ADC 的转换分为 2 个通道组：规则通道组和注入通道组。STM32 其 ADC 的规则通道组最多包含 16 个转换，而注入通道组最多包含 4 个通道。</p><p>ADC 的转换时间可以由以下公式计算：Time = 采样时间 + 12.5个周期；</p><p>ADC能3种产生相应中断：规则转换与注入转换结束、模拟看门狗事件、DMA请求；</p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530084243966.png" alt="image-20230530084243966" style="zoom:80%;" /></p><p>通过ADC1通道1（PA1）采样外部电压值，将采样的AD值和转换后的电压值通过USART1串口打印出来。如上图，可以将不同的电压（0~3.3V）连接到连接座上。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>激活ADC1通道1，设置右对齐，关闭扫描、连续及间断模式，使能regular conversion，设置软件触发、设置采样时间1.5个周期</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530090516872.png" alt="image-20230530090516872" style="zoom:80%;" /></p><ul><li>RCC设置外接HSE，时钟设置为72M，ADC预分频因子设置为6，ADC_CLK为12MHz</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530090558085.png" alt="" /><figcaption>image-20230530090558085</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ files per periapheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在主函数while循环中添加如下测试程序，ADC1是12位转换精度，因此电压分辨率为：3.3/(2^12) = 3.3/4096</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint16_t</span> ad_value = <span class="hljs-number">0</span>;<span class="hljs-type">float</span> voltage = <span class="hljs-number">0.0f</span>;<span class="hljs-comment">/* USER CODE END 1 */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    HAL_ADC_Start(&amp;hadc1);<span class="hljs-comment">//启动ADC转换</span>    HAL_ADC_PollForConversion(&amp;hadc1,<span class="hljs-number">10</span>);<span class="hljs-comment">//等待转换完成，10ms表示超时时间</span>    ad_value = HAL_ADC_GetValue(&amp;hadc1);<span class="hljs-comment">//读取ADC转换数据（12位数据）</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN1 ADC value: %d\r\n&quot;</span>,ad_value);    voltage = ad_value*(<span class="hljs-number">3.3</span>/<span class="hljs-number">4096</span>);<span class="hljs-comment">//AD值乘以分辨率即为电压值</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADC1_IN1 VOL value: %.2fV\r\n&quot;</span>,voltage);    HAL_Delay(<span class="hljs-number">1000</span>);&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</li><li>编译无误后下载到开发板，通过接口接入不同的电压（0~3.3），获取的AD转换值和电压值将变化，并通过串口打印出来</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531225347273.png" alt="image-20230531225347273" style="zoom:80%;" /></p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/adc.zip">adc</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之RTC</title>
    <link href="/2023/05/29/STM32CubeMX%E4%B9%8BRTC/"/>
    <url>/2023/05/29/STM32CubeMX%E4%B9%8BRTC/</url>
    
    <content type="html"><![CDATA[<p>STM32的实时时钟RTC是一个独立的定时器,RTC模块和时钟配置系统（RCC_BDCR寄存器）是在后背区域，即在系统复位或从待机模式唤醒后RTC的设置和事件维持不变。但是在系统复位后，会自动禁止访问后备寄存器和RTC，以防止对后备区域（BKP）的意外操作。所以在要设置时间之前，要先取消备份区域写保护。</p><p>RTC的功能框图如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529212612816.png" alt="image-20230529212612816" style="zoom:80%;" /></p><p>RTC由两个主要部分组成：第一部分（APB1接口）用来和APB1总线相连；另一部分（RTC核心）由一组可编程计数器组成，分为两个主要模块，第一个模块是RTC的预分频模块，可编程产生1秒的RTC时间基准TR_CLK，第二个模块是一个32位的可编程计数器（RTC_CNT），可被初始化为当前的系统时间。</p><h3 id="硬件设计">硬件设计</h3><p>RTC 属于 STM32F1 内部资源，本实验通过RTC的秒中断来持续输出时间通过串口1打印出来，并通过设置闹钟中断实现一个闹钟提醒。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li><p>RCC设置中开启外部高速晶振（HSE）以及外部低速晶振（LSE）；</p></li><li><p>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</p></li><li><p>激活时钟源，激活日历，选择RTC Output，设置初始日期和时间，在NVIC中使能RTC全局中断。</p></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529222921310.png" alt="" /><figcaption>image-20230529222921310</figcaption></figure><ul><li>时钟树设置HCLK为72MHz，RTC时钟为32.768KHz</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529223151558.png" alt="image-20230529223151558" style="zoom:80%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在rtc.c文件中编写秒中断处理回调函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-comment">/* 定义日期和时间结构体 */</span>RTC_DateTypeDef GetDate;RTC_TimeTypeDef GetTime;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_RTCEx_RTCEventCallback</span><span class="hljs-params">(RTC_HandleTypeDef *hrtc)</span>&#123;HAL_RTC_GetTime(hrtc,&amp;GetTime,RTC_FORMAT_BIN);HAL_RTC_GetDate(hrtc,&amp;GetDate,RTC_FORMAT_BIN);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Date:%02d-%02d-%02d\r\n&quot;</span>,<span class="hljs-number">2000</span>+GetDate.Year,GetDate.Month,GetDate.Date);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Time:%02d:%02d:%02d\r\n&quot;</span>,GetTime.Hours,GetTime.Minutes,GetTime.Seconds);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);&#125;<span class="hljs-comment">/* USER CODE END 1 */</span></code></pre></div><ul><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</p></li><li><p>在main.c文件中编写闹钟设置相关代码并开启相关中断</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>__HAL_RTC_SECOND_ENABLE_IT(&amp;hrtc,RTC_IT_SEC); <span class="hljs-comment">//开启秒中断</span><span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div><ul><li>编译无误后下载到开发板，串口助手每1s会打印出相应的日期和时间。</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230531223357869.png" alt="" /><figcaption>image-20230531223357869</figcaption></figure><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/rtc.zip">rtc</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之低功耗</title>
    <link href="/2023/05/29/STM32CubeMX%E4%B9%8B%E4%BD%8E%E5%8A%9F%E8%80%97/"/>
    <url>/2023/05/29/STM32CubeMX%E4%B9%8B%E4%BD%8E%E5%8A%9F%E8%80%97/</url>
    
    <content type="html"><![CDATA[<p>STM32F10xxx有三种低功耗模式:</p><ul><li><strong>睡眠模式(Sleep mode)</strong>（CM3 内核停止，外设包括核心外设如NVIC，SysTick等仍然运行，功耗最高）</li><li><strong>停止模式(Stop mode)</strong>（所有时钟都停止，功耗中等）</li><li><strong>待机模式(Standby mode)</strong>（1.8V 内核电源关闭，功耗最低）</li></ul><p>此外，在运行模式下，为了降低功耗，可以通过降低系统时钟和关闭APB和AHB总线上未使用外设的时钟。</p><p>三种低功耗模式的区别如下：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529164036755.png" alt="image-20230529164036755" style="zoom:80%;" /></p><p>这一章实验主要针对待机模式进行介绍，该模式实在CM3深睡眠模式时关闭电压调节器，整个1.8V供电区域被断电，HSI/HSE振荡器也被断电，SRAM和寄存器内容丢失，仅备份的寄存器和待机电路维持供电。</p><h3 id="硬件设计">硬件设计</h3><p>使用了 KEY_UP 按键用于唤醒和进入待机模式，然后通过 LED0来指示程序是否在运行。灯闪烁表示系统正常运行，灯熄灭表示进入待机模式。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528162340882.png" alt="image-20230528162340882" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528102557291.png" alt="image-20230528102557291" style="zoom: 67%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PB5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平</li><li>PA0设置为GPIO输入模式，下拉</li><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在main.c文件中添加进入待机模式函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  进入待机模式</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">enter_standby_mode</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    __HAL_RCC_APB2_FORCE_RESET();       <span class="hljs-comment">//复位所有IO口 </span>   __HAL_RCC_PWR_CLK_ENABLE();         <span class="hljs-comment">//使能PWR时钟</span>      __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);      <span class="hljs-comment">//清除Wake_UP标志</span>    HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN1);    <span class="hljs-comment">//设置WKUP用于唤醒</span>    HAL_PWR_EnterSTANDBYMode();                  <span class="hljs-comment">//进入待机模式     </span>&#125;<span class="hljs-comment">/* USER CODE END 0 */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">/* 闪烁3s后进入待机模式 */</span>    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);    HAL_Delay(<span class="hljs-number">500</span>);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);    HAL_Delay(<span class="hljs-number">500</span>);    enter_standby_mode();    <span class="hljs-comment">/* USER CODE END WHILE */</span>&#125;</code></pre></div><ul><li>编译无误后下载到开发板，可以看到系统运行时LED0会闪烁三次，然后进入待机模式，此时LED0熄灭。当按下KEY_UP按键或复位按键时，待机模式被唤醒，系统重新运行.</li></ul><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/low_power.zip">low_power</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之输入捕获</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8B%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8B%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="输入捕获简介">输入捕获简介</h3><p>输入捕获一般应用在两个方面，一是信号脉宽/频率的测量，二是 PWM 的输入测量。</p><ul><li>脉宽/频率测量:</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529124032810.png" alt="image-20230529124032810" style="zoom:80%;" /></p><p>可以看到只需要一个捕获通道就可以根据捕获值的差值计算脉宽和频率。</p><p>捕获过程中，两次边沿捕获之间会产生N次定时器溢出，所以:</p><p>脉宽 = (N*ARR + (value2-value1))*CNT计数周期;</p><p>频率 = CNT计数周期/(N*ARR + (value3-value1));</p><ul><li>PWM输入模式时序：</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529111153732.png" alt="image-20230529111153732" style="zoom: 80%;" /></p><p>如图PWM输入测量需要两个捕获通道。</p><h3 id="硬件设计">硬件设计</h3><p>通过 <strong>WK_UP</strong> 按键将PA0输入高电平，然后捕获TIM5_CH1（PA0）上的高电平脉宽，并从串口打印高电平脉宽。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/30915046b8743181980a17e715c3a8b7.png" alt="" /><figcaption>img</figcaption></figure><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li><li>选择TIM5，设置定时器时钟源为内部时钟源、设置通道1为输入捕获模式（PA0自动被选中），NVIC设置中激活定时器中断，预分频系数设置为72-1，向上计数，自动重装载值设为0xFFFF，则计时器时钟频率为1MHz，计时器周期为1us，定时器溢出周期为 65535 * 1 = 65535us</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529134108484.png" alt="" /><figcaption>image-20230529134108484</figcaption></figure><ul><li>在GPIO设置里将PA0下拉保证没有信号输入的时候电平稳定.</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529133718902.png" alt="" /><figcaption>image-20230529133718902</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ files per peripheral；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>因为可能存在定时溢出的情况，所以在tim.c文件中同时编写定时器更新中断处理回调函数和输入捕获中断处理回调函数。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span><span class="hljs-type">uint8_t</span> pulse_edge = <span class="hljs-number">0</span>;<span class="hljs-comment">//状态变化计数值</span><span class="hljs-type">uint8_t</span> overflow_cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//定时器溢出的次数</span><span class="hljs-type">uint32_t</span> capture_value = <span class="hljs-number">0</span>;<span class="hljs-comment">//储存计数器的记录值</span><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_PeriodElapsedCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>&#123;<span class="hljs-keyword">if</span>(htim-&gt;Instance == TIM5)&#123;<span class="hljs-comment">/* 已经捕获一次上升沿，还没捕获过下降沿期间出现定时器溢出 */</span><span class="hljs-keyword">if</span>(pulse_edge == <span class="hljs-number">1</span>)&#123;overflow_cnt++;&#125;&#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_IC_CaptureCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>&#123;<span class="hljs-keyword">if</span>(htim-&gt;Instance == TIM5)&#123;<span class="hljs-comment">/* 捕获到一个上升沿，清除标志位，清空CNT，准备捕获下降沿 */</span><span class="hljs-keyword">if</span>(pulse_edge == <span class="hljs-number">0</span>)&#123;pulse_edge++;capture_value = <span class="hljs-number">0</span>;overflow_cnt = <span class="hljs-number">0</span>;__HAL_TIM_SET_COUNTER(&amp;htim5, <span class="hljs-number">0</span>);__HAL_TIM_SET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING);<span class="hljs-comment">//设置下降沿捕获</span>&#125;<span class="hljs-keyword">else</span>&#123;HAL_TIM_IC_Stop_IT(&amp;htim5,TIM_CHANNEL_1); <span class="hljs-comment">//关闭定时器5</span>pulse_edge++; <span class="hljs-comment">//进入到主函数</span>capture_value = HAL_TIM_ReadCapturedValue(&amp;htim5, TIM_CHANNEL_1); <span class="hljs-comment">//读取捕获通道的值</span>__HAL_TIM_SET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);HAL_TIM_IC_Start_IT(&amp;htim5,TIM_CHANNEL_1);  <span class="hljs-comment">//打开输入捕获</span>&#125;&#125;    &#125;<span class="hljs-comment">/* USER CODE END 1 */</span></code></pre></div><ul><li><p>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</p></li><li><p>在main.c文件中编写高电平持续时间处理代码</p></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>    <span class="hljs-type">uint32_t</span> pulse_width;<span class="hljs-comment">//高电平持续时间</span>    <span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> pulse_edge;<span class="hljs-comment">//状态变化时，计数值</span>    <span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> overflow_cnt;<span class="hljs-comment">//定时器溢出的次数</span>    <span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> capture_value;<span class="hljs-comment">//两个边沿之间的计数值</span>    <span class="hljs-comment">/* USER CODE END 1 */</span>    <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>    <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>    HAL_Init();    <span class="hljs-comment">/* USER CODE BEGIN Init */</span>    <span class="hljs-comment">/* USER CODE END Init */</span>    <span class="hljs-comment">/* Configure the system clock */</span>    SystemClock_Config();    <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>    <span class="hljs-comment">/* USER CODE END SysInit */</span>    <span class="hljs-comment">/* Initialize all configured peripherals */</span>    MX_GPIO_Init();    MX_USART1_UART_Init();    MX_TIM5_Init();    <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>    HAL_TIM_Base_Start_IT(&amp;htim5);<span class="hljs-comment">//打开定时器中断</span>    HAL_TIM_IC_Start_IT(&amp;htim5,TIM_CHANNEL_1);<span class="hljs-comment">//一定要开启TIM5通道1的捕获中断</span>    <span class="hljs-comment">/* USER CODE END 2 */</span>    <span class="hljs-comment">/* Infinite loop */</span>    <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">if</span>(pulse_edge == <span class="hljs-number">2</span>)        &#123;            pulse_edge = <span class="hljs-number">0</span>;            pulse_width = <span class="hljs-number">65536</span>*overflow_cnt + capture_value;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;高电平持续时间:%d ms\r\n&quot;</span>, pulse_width/<span class="hljs-number">1000</span>);        &#125;        <span class="hljs-comment">/* USER CODE END WHILE */</span>        <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>    &#125;    <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><ul><li>编译无误后下载到开发板，按下KEY_UP后，串口会打印出相应的高电平持续时间</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530233211951.png" alt="" /><figcaption>image-20230530233211951</figcaption></figure><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/input_capture.zip">input_capture</a></p><p>参考链接：http://t.csdn.cn/nf7yk</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之PWM输出</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8BPWM%E8%BE%93%E5%87%BA/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8BPWM%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="pwm-简介">PWM 简介</h3><p>脉冲宽度调制（PWM,Pulse Width Modulation）简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。PWM 输出就是对外输出脉宽（即占空比）可调的方波信号，信号频率由自动重装寄存器 ARR 的值决定，占空比由比较寄存器 CCR 的值决定。</p><p>PWM 模式分为两种：mode1 和 mode2，它们的区别如下：</p><table><thead><tr class="header"><th>PWM模式</th><th>计数器CNT计数方式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><strong>mode 1</strong></td><td>upcounting</td><td>CNT&lt;CCRx，通道channel有效(OCxREF=1)，否则无效(OCxREF=0)</td></tr><tr class="even"><td></td><td>downcounting</td><td>CNT&gt;CCRx，通道channel无效(OCxREF=0)，否则有效(OCxREF=1)</td></tr><tr class="odd"><td><strong>mode 2</strong></td><td>upcounting</td><td>CNT&lt;CCRx，通道channel无效(OCxREF=0)，否则有效(OCxREF=1)</td></tr><tr class="even"><td></td><td>downcounting</td><td>CNT&gt;CCRx，通道channel有效(OCxREF=1)，否则无效(OCxREF=0)</td></tr></tbody></table><p>以PWM mode 1递增计数方式为例：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230529112644749.png" alt="image-20230529112644749" style="zoom:80%;" /></p><ul><li>当计数器 CNT &lt; 比较捕获寄存器 CCRx，PWM 参考信号 OCxREF 输出高电平。</li><li>当计数器 CNT &gt;= 比较捕获寄存器 CCRx， PWM 参考信号 OCxREF 输出低电平。</li><li>当比较捕获寄存器 CCRx &gt; 自动重载寄存器 ARR，OCxREF 保持为 1。</li><li>当比较捕获寄存器 CCRx = 0，则 OCxRef 保持为 0。</li></ul><h3 id="硬件设计">硬件设计</h3><p>LED灯的呼吸灯效果可以很好的查看PWM的调节情况，查看定时器复用功能重映射，刚好TIM3第二通道可以重映射到LED0上。所以，可以通过TIM3的通道2输出PWM信号，控制LED0的亮度。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528211500355.png" alt="image-20230528211500355" style="zoom:67%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72MHz；</li><li>TIM3的时钟挂载在APB1上，因为APB1 Prescacler设置为2，所以 TIM3时钟为36x2=72MHz；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528200120931.png" alt="image-20230528200120931" style="zoom:67%;" /></p><ul><li><p>激活TIM3定时器，**Timeout = (Prescaler-1)*(Period-1)/72MHz**</p><p>时钟源选择为内部时钟，设置通道2为PWM模式，选中PB5的TIM3_CH2完成重映射，预分频系数设置为72-1，向上计数，自动重装载值设为500-1，则计时器时钟频率为1MHz，计时器周期为1us，PWM周期为 500 * 1 = 500us，PWM频率为1/500us = 2KHz，PWM模式选择PWM1，Pulse默认为0，PWM极性设置为低电平（由于LED低电平点亮）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528213741747.png" alt="image-20230528213741747" style="zoom:80%;" /></p></li><li><p>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ files per peripheral ；点击GENERATE CODE，生成工程代码</p></li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在tim.c文件中可以看到TIM3的初始化相关函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_TIM3_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  TIM_ClockConfigTypeDef sClockSourceConfig = &#123;<span class="hljs-number">0</span>&#125;;  TIM_MasterConfigTypeDef sMasterConfig = &#123;<span class="hljs-number">0</span>&#125;;  TIM_OC_InitTypeDef sConfigOC = &#123;<span class="hljs-number">0</span>&#125;;  htim3.Instance = TIM3;  htim3.Init.Prescaler = <span class="hljs-number">71</span>;  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;  htim3.Init.Period = <span class="hljs-number">499</span>;  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIM_Base_Init(&amp;htim3) != HAL_OK)  &#123;    Error_Handler();  &#125;  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;  <span class="hljs-keyword">if</span> (HAL_TIM_ConfigClockSource(&amp;htim3, &amp;sClockSourceConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;  <span class="hljs-keyword">if</span> (HAL_TIM_PWM_Init(&amp;htim3) != HAL_OK)  &#123;    Error_Handler();  &#125;  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIMEx_MasterConfigSynchronization(&amp;htim3, &amp;sMasterConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;  sConfigOC.OCMode = TIM_OCMODE_PWM1;  sConfigOC.Pulse = <span class="hljs-number">0</span>;  sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIM_PWM_ConfigChannel(&amp;htim3, &amp;sConfigOC, TIM_CHANNEL_2) != HAL_OK)  &#123;    Error_Handler();  &#125;  HAL_TIM_MspPostInit(&amp;htim3);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_Base_MspInit</span><span class="hljs-params">(TIM_HandleTypeDef* tim_baseHandle)</span>&#123;  <span class="hljs-keyword">if</span>(tim_baseHandle-&gt;Instance==TIM3)  &#123;    __HAL_RCC_TIM3_CLK_ENABLE();  &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_MspPostInit</span><span class="hljs-params">(TIM_HandleTypeDef* timHandle)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-keyword">if</span>(timHandle-&gt;Instance==TIM3)  &#123;    __HAL_RCC_GPIOB_CLK_ENABLE();    <span class="hljs-comment">/**TIM3 GPIO Configuration</span><span class="hljs-comment">    PB5     ------&gt; TIM3_CH2</span><span class="hljs-comment">    */</span>    GPIO_InitStruct.Pin = GPIO_PIN_5;    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;    HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);    __HAL_AFIO_REMAP_TIM3_PARTIAL();  &#125;&#125;</code></pre></div><ul><li>在main函数中编写代码，周期性的改变CCR1的值来改变PWM占空比</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>  <span class="hljs-type">uint8_t</span> dir = <span class="hljs-number">1</span>;<span class="hljs-comment">//计数方向</span>  <span class="hljs-type">uint16_t</span> ledpwmval = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数值</span>  <span class="hljs-comment">/* USER CODE END 1 */</span>  <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>  <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>  HAL_Init();  <span class="hljs-comment">/* USER CODE BEGIN Init */</span>  <span class="hljs-comment">/* USER CODE END Init */</span>  <span class="hljs-comment">/* Configure the system clock */</span>  SystemClock_Config();  <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>  <span class="hljs-comment">/* USER CODE END SysInit */</span>  <span class="hljs-comment">/* Initialize all configured peripherals */</span>  MX_GPIO_Init();  MX_TIM3_Init();  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);<span class="hljs-comment">//开启定时器PWM输出</span>  <span class="hljs-comment">/* USER CODE END 2 */</span>  <span class="hljs-comment">/* Infinite loop */</span>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;HAL_Delay(<span class="hljs-number">10</span>);<span class="hljs-keyword">if</span>(dir)ledpwmval++;<span class="hljs-keyword">else</span>ledpwmval--;<span class="hljs-keyword">if</span>(ledpwmval &gt; <span class="hljs-number">300</span>)dir = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(ledpwmval == <span class="hljs-number">0</span>)dir = <span class="hljs-number">1</span>;TIM3-&gt;CCR2 = ledpwmval;<span class="hljs-comment">//更改CCR2的值来改变PWM的占空比</span>    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>  &#125;  <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><ul><li>编译后下载到开发板，可以看到LED0由暗变亮，再由亮变暗，呈现呼吸灯的效果。</li></ul><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/pwm_out.zip">pwm_output</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之窗口看门狗</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97/</url>
    
    <content type="html"><![CDATA[<h3 id="窗口看门狗简介">窗口看门狗简介</h3><p>窗口看门狗（WWDG）通常被用来监测由外部干扰或不可预见的逻辑条件造成的应用程序背离正常的运行序列而产生的软件故障。递减计数器需要在一个有限的时间窗口中被刷新才不会产生MCU复位，否则就会产生RESET。WWDG</p><p>窗口看门狗时序图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528174707824.png" alt="image-20230528174707824" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528174924225.png" alt="image-20230528174924225" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>我们将通过USART1来打印调试信息，然后通过 LED1 提示复位状态。(LED1常亮则系统正常，LED1闪烁则系统一直复位)</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M；</li><li>IWDG的时钟默认为LSI时钟；</li><li>PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528170246253.png" alt="image-20230528170246253" style="zoom:67%;" /></p><ul><li><p>激活WWDG，Timeout = 4096 x Prescaler x (上窗口值 - 下窗口值 )/36MHz</p><p>WWDG挂载在APB1上，时钟为36MHz，计数器预分频值设为8，窗口寄存器设为W[6:0] = 0x5A，递减计数器刷新值设置为T[6:0] = 0x7F；根据公式算出超时时间为 （4096 * 8）*（0x7F-0x3F）/ 36MHz = 58.3ms；使能EWI中断，在NVIC设置中开启窗口看门狗中断</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528175822680.png" alt="image-20230528175822680" style="zoom:67%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ files per peripheral ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在wwdg.c文件中可以看到独立看门狗的初始化函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_WWDG_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  hwwdg.Instance = WWDG;  hwwdg.Init.Prescaler = WWDG_PRESCALER_8;  hwwdg.Init.Window = <span class="hljs-number">0x5a</span>;  hwwdg.Init.Counter = <span class="hljs-number">0x7f</span>;  hwwdg.Init.EWIMode = WWDG_EWI_ENABLE;  <span class="hljs-keyword">if</span> (HAL_WWDG_Init(&amp;hwwdg) != HAL_OK)  &#123;    Error_Handler();  &#125;&#125;</code></pre></div><ul><li>在<strong>stm32f1xx_hal_wwdg.c</strong>文件中找到弱符号早期唤醒中断函数原型，并在wwdg.c中自定义该回调函数 <code>__weak void HAL_WWDG_EarlyWakeupCallback(WWDG_HandleTypeDef *hwwdg)</code></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_WWDG_EarlyWakeupCallback</span><span class="hljs-params">(WWDG_HandleTypeDef *hwwdg)</span>&#123;HAL_WWDG_Refresh(hwwdg);<span class="hljs-comment">//在早期唤醒中断函数中喂狗</span>&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</li><li>在main函数中编写代码：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nWWDG Test!!!\r\n&quot;</span>);HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);<span class="hljs-comment">//熄灭LED0</span>HAL_Delay(<span class="hljs-number">500</span>);HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);<span class="hljs-comment">//点亮LED0</span>MX_WWDG_Init();<span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-comment">/* Infinite loop */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nHello, WWDG...!\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">1000</span>);    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;<span class="hljs-comment">/* USER CODE END 3 */</span></code></pre></div><ul><li>实验现象：</li></ul><p>LED1常亮，且串口助手显示一直在喂狗：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528191522516.png" alt="image-20230528191522516" style="zoom:67%;" /></p><p>如果注释掉早期唤醒中断函数中的喂狗函数，则LED1闪烁且串口输出，需要<strong>注意</strong>的是，<code>MX_WWDG_Init()</code>函数需要放到LED闪烁函数之后，否则程序一直在复位，根本执行不到后面的部分：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528192419226.png" alt="image-20230528192419226" style="zoom:67%;" /></p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/wwdg.zip">wwdg</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之独立看门狗</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8B%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8B%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97/</url>
    
    <content type="html"><![CDATA[<h3 id="独立看门狗简介">独立看门狗简介</h3><p>STM32F1内部自带了 2 个看门狗：独立看门狗（IWDG）和窗口看门狗（WWDG)。这一章主要来看看独立看门狗，从功能上说它在程序发生意外（程序进入死循环或跑飞）的时候，能重新回复到系统刚上电状态。</p><p>独立看门狗由内部专门的 40Khz 低速RC 时钟驱动，即使主时钟发生故障，它也仍然有效。但它是在 30~60Khz 之间的一个可变化的时钟，只是我们在估算的时候，以 40Khz 的频率来计算，时钟有些偏差，都是可以接受的。</p><p>实际上独立看门口狗是一个递减计数器，当计时器的值减到0时，IWDG会产生一个复位信号，系统复位重新启动。为避免产生看门狗复位，则需在计数器减到0之前重载计数器,即“喂狗”。</p><p>独立看门狗功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528161307256.png" alt="image-20230528161307256" style="zoom:80%;" /></p><p>独立看门狗超时时间（40KHz的输入时钟LSI）：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528161857687.png" alt="image-20230528161857687" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p>我们将通过USART1来打印调试信息，然后通过 LED0 提示复位状态。(LED0常亮则系统正常，LED0闪烁则系统一直复位)</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M；</li><li>IWDG的时钟默认为LSI时钟；</li><li>PB5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528170246253.png" alt="image-20230528170246253" style="zoom:67%;" /></p><ul><li><p>激活IWDG，Timeout = (Prescaler*ReloadValue/40)ms;</p><p>IWDG的时钟为40kHz,此时设置计数器时钟为32分频，则分频后的时钟频率为1.25KHz（时钟周期为1s/1250 = 0.8ms），递减基础器重载值（down-counter reload value）配置为1000，即800ms不刷新IWDG，则系统复位。</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528164949027.png" alt="image-20230528164949027" style="zoom: 67%;" /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ files per peripheral ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在iwdg.c文件中可以看到独立看门狗的初始化函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_IWDG_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  hiwdg.Instance = IWDG;  hiwdg.Init.Prescaler = IWDG_PRESCALER_32;  hiwdg.Init.Reload = <span class="hljs-number">1000</span>;  <span class="hljs-keyword">if</span> (HAL_IWDG_Init(&amp;hiwdg) != HAL_OK)  &#123;    Error_Handler();  &#125;&#125;</code></pre></div><ul><li>在uart.c文件中添加fputc重定义函数，并添加头文件<code>&lt;stdio.h&gt;</code>，勾选keil软件<strong>Use MicroLIB</strong>选项。</li><li>在main函数中编写代码:</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nIWDG Test!!!\r\n&quot;</span>);HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);<span class="hljs-comment">//熄灭LED0</span>HAL_Delay(<span class="hljs-number">300</span>);HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_RESET);<span class="hljs-comment">//点亮LED0</span><span class="hljs-comment">/* USER CODE END 2 */</span><span class="hljs-comment">/* Infinite loop */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//HAL_IWDG_Refresh(&amp;hiwdg);</span>    <span class="hljs-comment">//printf(&quot;\r\nRefreshes the IWDG...!\r\n&quot;);</span>    HAL_Delay(<span class="hljs-number">500</span>); <span class="hljs-comment">//每500ms喂狗一次 &lt; 800ms</span>    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;<span class="hljs-comment">/* USER CODE END 3 */</span></code></pre></div><ul><li>实验现象：</li></ul><p>LED0常亮，且串口助手显示一直在喂狗：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528171626961.png" alt="image-20230528171626961" style="zoom:67%;" /></p><p>如果注释掉while循环里的喂狗动作，则LED0闪烁且串口输出：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528173055722.png" alt="image-20230528173055722" style="zoom:67%;" /></p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/iwdg.zip">iwdg</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之定时器中断</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="定时器中断简介">定时器中断简介</h3><p>STM32 的定时器功能十分强大，有 TIME1 和 TIME8 等高级定时器，也有 TIME2~TIME5 等通用定时器，还有 TIME6 和TIME7 等基本定时器。这一章主要介绍通用定时器，是一个通过可编程预分频器（PSC）驱动的 16 位自动装载计数器（CNT）构成。STM32 的通用定时器可以被用于：测量输入信号的脉冲长度(输入捕获)或者产生输出波形(输出比较和 PWM)等。</p><p>通用定时器功能框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528194943205.png" alt="image-20230528194943205" style="zoom:67%;" /></p><h3 id="硬件设计">硬件设计</h3><p>通过 TIM3 的中断来控制 LED1 的亮灭。TIM3 属于MCU内部资源，只需要软件设置即可正常工作。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72MHz；</li><li>TIM3的时钟挂载在APB1上，因为APB1 Prescacler设置为2，所以 TIM3时钟为36x2=72MHz；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528200120931.png" alt="image-20230528200120931" style="zoom:67%;" /></p><ul><li><p>PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</p></li><li><p>激活TIM3定时器，**Timeout = (Prescaler-1)*(Period-1)/72MHz**</p><p>时钟源选择为内部时钟，PSC预分频设置为7200-1，向上计数，自动重装载值(ARR)设置为10000-1，在NVIC设置中激活TIM3定时器中断；根据公式可算出：计数器时钟CK_CNT = 72M/7200 = 10000Hz，计时器中断时间为 ARR/10000 = 1s</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528200912377.png" alt="image-20230528200912377" style="zoom: 67%;" /></p></li><li><p>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated peripheral initialization as a pair of ‘.c/.h’ files per peripheral ；点击GENERATE CODE，生成工程代码</p></li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在 tim.c 文件中可以看到定时器3的初始化函数</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_TIM3_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  TIM_ClockConfigTypeDef sClockSourceConfig = &#123;<span class="hljs-number">0</span>&#125;;  TIM_MasterConfigTypeDef sMasterConfig = &#123;<span class="hljs-number">0</span>&#125;;  htim3.Instance = TIM3;  htim3.Init.Prescaler = <span class="hljs-number">7199</span>;  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;  htim3.Init.Period = <span class="hljs-number">9999</span>;  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;  <span class="hljs-keyword">if</span> (HAL_TIM_Base_Init(&amp;htim3) != HAL_OK)  &#123;    Error_Handler();  &#125;  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;  <span class="hljs-keyword">if</span> (HAL_TIM_ConfigClockSource(&amp;htim3, &amp;sClockSourceConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;  <span class="hljs-keyword">if</span> (HAL_TIMEx_MasterConfigSynchronization(&amp;htim3, &amp;sMasterConfig) != HAL_OK)  &#123;    Error_Handler();  &#125;&#125;</code></pre></div><ul><li>找到弱符号周期运行回调函数原型，并在tim.c中自定义该回调函数 <code>__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</code></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_TIM_PeriodElapsedCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>&#123;    <span class="hljs-keyword">if</span>(htim == &amp;htim3)    &#123;        HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);<span class="hljs-comment">//LED1状态每1s翻转一次</span>    &#125;&#125;</code></pre></div><ul><li>在main.c中启动TIM3：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_TIM_Base_Start_IT(&amp;htim3); <span class="hljs-comment">//启动TIM3</span><span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div><p>编译下载到开发板，可以看到LED1每1s状态翻转一次，达到预期效果。</p><p>工程文件Gitee: <a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/tim3.zip">tim3</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之UART</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8BUART/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8BUART/</url>
    
    <content type="html"><![CDATA[<h3 id="串口简介">串口简介</h3><p>STM32F103ZET6 最多可提供 5 路串口，有分数波特率发生器、支持同步单线通信和半双工单线通讯、支持 LIN、支持调制解调器操作、智能卡协议和 IrDA SIR ENDEC 规范、具有 DMA等。</p><p>我们通常使用的是异步通信，异步通信规定传输的数据格式由起始位（start bit）、数据位（data bit）、奇偶校验位（parity bit）和停止位（stop bit）组成。在进行传输之前，双方一定要使用相同的波特率，波特率就是每秒钟传输的数据位数。串口通讯有HAL 库轮询，中断，DMA 三种通信模式：</p><ul><li><strong>轮询方式</strong>：CPU不断查询IO设备，如设备有请求则加以处理。例如CPU不断查询串口是否传输完成，如传输超过则返回超时错误。轮询方式会占用CPU处理时间，效率较低。</li><li><strong>中断控制方式</strong>：当I/O操作完成时，输入输出设备控制器通过中断请求线向处理器发出中断信号，处理器收到中断信号之后，转到中断处理程序，对数据传送工作进行相应的处理。</li><li><strong>直接内存存取技术（DMA）方式</strong>：所谓直接传送，即在内存与IO设备间传送一个数据块的过程中，不需要CPU的任何中间干涉，只需要CPU在过程开始时向设备发出“传送块数据”的命令，然后通过中断来得知过程是否结束和下次操作是否准备就绪。</li></ul><h3 id="硬件设计">硬件设计</h3><p>战舰开发板板载了 1 个 USB和 2 个 RS232 串口。通过CH340芯片把串口1与PC的USB口进行连接，实现串口传输。我们将利用串口 1 不停的打印信息到电脑上，同时接收从串口发过来的数据，把发送过来的数据直接送回给电脑。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528133425092.png" alt="image-20230528133425092" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>USART1选择为异步通讯方式，波特率设置为115200Bits/s，传输数据长度为8Bit，无奇偶校验，1位停止位</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528134337560.png" alt="" /><figcaption>image-20230528134337560</figcaption></figure><ul><li>若使用中断方式，还需要开启串口中断</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528134456998.png" alt="" /><figcaption>image-20230528134456998</figcaption></figure><ul><li>若使用直接内存存取（DMA）方式，除以上步骤外（串口中断要开启，否则程序只能发送一次数据，且不能判断DMA传输是否完成，USART一直处于busy状态）还需要设置DMA传输方向、通道、优先级、数据长度以及指针递增与否</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528134749373.png" alt="" /><figcaption>image-20230528134749373</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated periphera initialization as a pair of ‘.c/.h’ files per IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm软件编程">MDK-ARM软件编程</h4><p>在生成的usart.c文件中，软件已经帮我们实现了UART1和GPIO的初始化操作，以下只看轮询方式初始化函数。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_USART1_UART_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN USART1_Init 0 */</span>  <span class="hljs-comment">/* USER CODE END USART1_Init 0 */</span>  <span class="hljs-comment">/* USER CODE BEGIN USART1_Init 1 */</span>  <span class="hljs-comment">/* USER CODE END USART1_Init 1 */</span>  huart1.Instance = USART1;  huart1.Init.BaudRate = <span class="hljs-number">115200</span>;  huart1.Init.WordLength = UART_WORDLENGTH_8B;  huart1.Init.StopBits = UART_STOPBITS_1;  huart1.Init.Parity = UART_PARITY_NONE;  huart1.Init.Mode = UART_MODE_TX_RX;  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;  huart1.Init.OverSampling = UART_OVERSAMPLING_16;  <span class="hljs-keyword">if</span> (HAL_UART_Init(&amp;huart1) != HAL_OK)  &#123;    Error_Handler();  &#125;  <span class="hljs-comment">/* USER CODE BEGIN USART1_Init 2 */</span>  <span class="hljs-comment">/* USER CODE END USART1_Init 2 */</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_MspInit</span><span class="hljs-params">(UART_HandleTypeDef* uartHandle)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-keyword">if</span>(uartHandle-&gt;Instance==USART1)  &#123;  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspInit 0 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspInit 0 */</span>    <span class="hljs-comment">/* USART1 clock enable */</span>    __HAL_RCC_USART1_CLK_ENABLE();    __HAL_RCC_GPIOA_CLK_ENABLE();    <span class="hljs-comment">/**USART1 GPIO Configuration</span><span class="hljs-comment">    PA9     ------&gt; USART1_TX</span><span class="hljs-comment">    PA10     ------&gt; USART1_RX</span><span class="hljs-comment">    */</span>    GPIO_InitStruct.Pin = GPIO_PIN_9;    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);    GPIO_InitStruct.Pin = GPIO_PIN_10;    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;    GPIO_InitStruct.Pull = GPIO_NOPULL;    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspInit 1 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspInit 1 */</span>  &#125;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_MspDeInit</span><span class="hljs-params">(UART_HandleTypeDef* uartHandle)</span>&#123;  <span class="hljs-keyword">if</span>(uartHandle-&gt;Instance==USART1)  &#123;  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspDeInit 0 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspDeInit 0 */</span>    <span class="hljs-comment">/* Peripheral clock disable */</span>    __HAL_RCC_USART1_CLK_DISABLE();    <span class="hljs-comment">/**USART1 GPIO Configuration</span><span class="hljs-comment">    PA9     ------&gt; USART1_TX</span><span class="hljs-comment">    PA10     ------&gt; USART1_RX</span><span class="hljs-comment">    */</span>    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_9|GPIO_PIN_10);  <span class="hljs-comment">/* USER CODE BEGIN USART1_MspDeInit 1 */</span>  <span class="hljs-comment">/* USER CODE END USART1_MspDeInit 1 */</span>  &#125;&#125;</code></pre></div><p>打印输出会使用到printf函数，若要printf输出到串口，需要将fputc函数里面的输出指向串口(重定向)，在<code>usart.c</code>文件中重定向<code>fputc</code>函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span>&#123;HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span>*)&amp;ch, <span class="hljs-number">1</span>, <span class="hljs-number">0xffff</span>);<span class="hljs-keyword">return</span> ch;&#125;</code></pre></div><p>同时需要勾选 <strong>Use MicroLIB</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528140811005.png" alt="image-20230528140811005" style="zoom:80%;" /></p><p>下面在main函数中针对UART1三种操作方式进行编写程序：</p><ul><li>轮询方式</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    HAL_UART_Transmit(&amp;huart1, <span class="hljs-string">&quot;HAL_UART_Transmit Test...&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-number">0xffff</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n uart test...\r\n&quot;</span>);    HAL_Delay(<span class="hljs-number">500</span>);    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;</code></pre></div><p>实验现象：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528141728742.png" alt="image-20230528141728742" style="zoom:80%;" /></p><ul><li>中断方式</li></ul><p>在 <strong>stm32f1xx_hal_uart.c</strong>文件中找到弱符号中断接收完成回调函数原型，并在usart.c中自定义该回调函数 <code>__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</code></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> RxMsg[<span class="hljs-number">20</span>];<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_UART_RxCpltCallback</span><span class="hljs-params">(UART_HandleTypeDef *huart)</span>&#123;<span class="hljs-keyword">if</span>(huart-&gt;Instance == USART1)&#123;HAL_UART_Transmit(&amp;huart1,RxMsg,<span class="hljs-number">10</span>,<span class="hljs-number">0xffff</span>);<span class="hljs-comment">//将接收的数据通过串口1发送回去</span>HAL_UART_Receive_IT(&amp;huart1,RxMsg,<span class="hljs-number">10</span>);<span class="hljs-comment">//再次开启接收中断</span>&#125;&#125;</code></pre></div><p>在<strong>main.c</strong>中添加以下代码： <div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint8_t</span> TxMsg[] = <span class="hljs-string">&quot;\r\n*****USART communication based on IT*****\r\n&quot;</span>;<span class="hljs-type">uint8_t</span> RxMsg[<span class="hljs-number">20</span>];<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-comment">/* USER CODE BEGIN 2 */</span>HAL_UART_Transmit_IT(&amp;huart1,TxMsg,<span class="hljs-keyword">sizeof</span>(TxMsg)); <span class="hljs-comment">//开启发送数据中断</span>HAL_UART_Receive_IT(&amp;huart1,RxMsg,<span class="hljs-number">10</span>); <span class="hljs-comment">//开启接收数据中断</span><span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div></p><p>使用串口助手发送10个字符，串口助手回显发送的数据；串口要发够10个字符才会触发中断；超过10个字符，串口只会发送10个字符（<strong>注意</strong>不要勾选‘发送新行’）</p><p>实验现象：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528144050587.png" alt="image-20230528144050587" style="zoom:80%;" /></p><ul><li>DMA方式</li></ul><p>在 main.c中添加如下代码：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><span class="hljs-type">uint8_t</span> TxMsg[] = <span class="hljs-string">&quot;\r\n*****USART communication based on DMA*****\r\n&quot;</span>;<span class="hljs-comment">/* USER CODE END PV */</span><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;    HAL_UART_Transmit_DMA(&amp;huart1,TxMsg,<span class="hljs-keyword">sizeof</span>(TxMsg));    HAL_Delay(<span class="hljs-number">500</span>);    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>&#125;<span class="hljs-comment">/* USER CODE END 3 */</span></code></pre></div><p>另外需要<strong>注意</strong>, 软件会将DMA初始化函数放到uart初始化函数后面，这样无法实现DMA寄存器设置，无法实现功能。必须将MX_DMA_Init函数放在UART DMA配置之前调用。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Initialize all configured peripherals */</span>MX_DMA_Init();MX_GPIO_Init();MX_USART1_UART_Init();<span class="hljs-comment">/* USER CODE BEGIN 2 */</span></code></pre></div><p>实验现象：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528150421728.png" alt="image-20230528150421728" style="zoom:80%;" /></p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/uart.zip">uart</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之EXTI</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8BEXTI/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8BEXTI/</url>
    
    <content type="html"><![CDATA[<h3 id="exti介绍">EXTI介绍</h3><p>STM32F103 的外部中断/事件控制器支持 19个外部中断/事件请求（互联网型产品支持20个）。每个中断设有状态位，每个中断/事件都有独立的触发和屏蔽设置。</p><p>STM32F103的19个外部中断为：</p><ul><li>EXTI线0~15：对应外部IO口的输入中断</li><li>EXTI线16：连接到PVD输出</li><li>EXTI线17：连接到RTC闹钟事件</li><li>EXTI线18：连接到USB唤醒事件</li><li>EXTI线19：连接到以太网唤醒事件（互联网型产品）</li></ul><p>其中112个GPIO通过以下方式映射到16个外部中断/事件线上：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528115852770.png" alt="image-20230528115852770" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528102842722.png" alt="" /><figcaption>image-20230528102842722</figcaption></figure><p>这一章主要是通过外部中断的方式，用开发板上的4 个按钮（KEY_UP、KEY0、KEY1 和 KEY2）来控制板上的 2 个 LED（DS0 和 DS1）和蜂鸣器。</p><ul><li>KEY_UP 控制蜂鸣器，按一次叫，再按一次停；</li><li>KEY2 控制 DS0，按一次亮，再按一次灭；</li><li>KEY1 控制 DS1，效果同 KEY2；</li><li>KEY0 则同时控制 DS0 和 DS1，按一次，他们的状态就翻转一次。</li></ul><p><strong>注意</strong>：KEY0、KEY1 和 KEY2 外部没有上下拉电阻，所以需要在MCU内部设置上下拉。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx配置">STM32CubeMx配置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PA0设置为<strong>GPIO外部中断上升沿触发模式</strong>、下拉；</li><li>PE2/PE3/PE4设置为<strong>GPIO外部中断下降沿触发模式</strong>、上拉；</li><li>PB8设置为GPIO推挽输出模式、上拉、高速、默认输出电平为低电平；</li><li>PB5和PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528122534347.png" alt="image-20230528122534347"  /></p><ul><li>在NVIC(嵌套向量中断控制器)中，勾选EXIT Line0/2/3/4 interrupt，使能PA0和PE2/3/4中断。右边两个选项设置抢占优先级和响应优先级</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528123030801.png" alt="" /><figcaption>image-20230528123030801</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated periphera initialization as a pair of ‘.c/.h’ files per IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm编程">MDK-ARM编程</h4><ul><li>在gpio.c文件中可以看到gpio初始化函数。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_GPIO_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">/* GPIO Ports Clock Enable */</span>  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(BEEP_GPIO_Port, BEEP_Pin, GPIO_PIN_RESET);  <span class="hljs-comment">/*Configure GPIO pins : PE2 PE3 PE4 */</span>  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4;  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;  GPIO_InitStruct.Pull = GPIO_PULLUP;  HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED1_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(LED1_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PA0 */</span>  GPIO_InitStruct.Pin = GPIO_PIN_0;  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;  GPIO_InitStruct.Pull = GPIO_PULLDOWN;  HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pins : PBPin PBPin */</span>  GPIO_InitStruct.Pin = LED0_Pin|BEEP_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);  <span class="hljs-comment">/* EXTI interrupt init*/</span>  HAL_NVIC_SetPriority(EXTI0_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);  HAL_NVIC_EnableIRQ(EXTI0_IRQn);  HAL_NVIC_SetPriority(EXTI2_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);  HAL_NVIC_EnableIRQ(EXTI2_IRQn);  HAL_NVIC_SetPriority(EXTI3_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);  HAL_NVIC_EnableIRQ(EXTI3_IRQn);  HAL_NVIC_SetPriority(EXTI4_IRQn, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  HAL_NVIC_EnableIRQ(EXTI4_IRQn);&#125;</code></pre></div><p>在<strong>stm32f1xx_hal_gpio.c</strong>文件中找到GPIO EXTI弱符号中断回调函数原型，并在gpio.c中自定义该回调函数 <code>__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)</code></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 2 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span>&#123;HAL_Delay(<span class="hljs-number">10</span>);<span class="hljs-comment">/* PA0 -&gt; EXTI0 */</span><span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_0)&#123;HAL_GPIO_TogglePin(BEEP_GPIO_Port, BEEP_Pin);&#125;<span class="hljs-comment">/* PE2 -&gt; EXTI2 */</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_2)&#123;HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);&#125;<span class="hljs-comment">/* PE3 -&gt; EXTI3 */</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_3)&#123;HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);&#125;<span class="hljs-comment">/* PE4 -&gt; EXTI4 */</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(GPIO_Pin == GPIO_PIN_4)&#123;HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);&#125;&#125;<span class="hljs-comment">/* USER CODE END 2 */</span></code></pre></div><p>main.c函数不需要添加任何代码，编译下载，跟按键输入一章同样的现象，获得预期目标。</p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/exti.zip">exti</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之按键输入</title>
    <link href="/2023/05/28/STM32CubeMX%E4%B9%8B%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5/"/>
    <url>/2023/05/28/STM32CubeMX%E4%B9%8B%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>上一节介绍了GPIO的输出使用，这一节介绍一下GPIO的输入，GPIO口作为输入使用的时候，是通过读取GPIOx_IDR寄存器内容来获得IO口的状态。</p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528101819341.png" alt="image-20230528101819341" style="zoom:80%;" /></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528102842722.png" alt="" /><figcaption>image-20230528102842722</figcaption></figure><p>通过开发板上的4 个按钮（KEY_UP、KEY0、KEY1 和 KEY2）来控制板上的 2 个 LED（DS0 和 DS1）和蜂鸣器。</p><ul><li>KEY_UP 控制蜂鸣器，按一次叫，再按一次停；</li><li>KEY2 控制 DS0，按一次亮，再按一次灭；</li><li>KEY1 控制 DS1，效果同 KEY2；</li><li>KEY0 则同时控制 DS0 和 DS1，按一次，他们的状态就翻转一次。</li></ul><p><strong>注意</strong>：KEY0、KEY1 和 KEY2 外部没有上下拉电阻，所以需要在MCU内部设置上下拉。必须初始化WK_UP键（PA0），否则其它按键不能正常使用，属于开发板的bug吧，这个问题折腾好久。</p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PA0设置为GPIO输入模式、下拉；</li><li>PE2/PE3/PE4设置为GPIO输入模式、上拉；</li><li>PB8设置为GPIO推挽输出模式、上拉、高速、默认输出电平为低电平；</li><li>PB5和PE5设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平；</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528104919285.png" alt="" /><figcaption>image-20230528104919285</figcaption></figure><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated periphera initialization as a pair of ‘.c/.h’ files per IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="mdk-arm软件编程">MDK-ARM软件编程</h4><ol type="1"><li>在gpio.c文件中可以看到各GPIO管脚的初始化函数</li></ol><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_GPIO_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">/* GPIO Ports Clock Enable */</span>  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(BEEP_GPIO_Port, BEEP_Pin, GPIO_PIN_RESET);  <span class="hljs-comment">/*Configure GPIO pins : PEPin PEPin PEPin */</span>  GPIO_InitStruct.Pin = KEY2_Pin|KEY1_Pin|KEY0_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;  GPIO_InitStruct.Pull = GPIO_PULLUP;  HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED1_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(LED1_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = WK_UP_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;  GPIO_InitStruct.Pull = GPIO_PULLDOWN;  HAL_GPIO_Init(WK_UP_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pins : PBPin PBPin */</span>  GPIO_InitStruct.Pin = LED0_Pin|BEEP_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;  HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);&#125;</code></pre></div><ol start="2" type="1"><li>在工程的应用文件目录下创建key文件夹，并在文件夹中创建key.c和key.h文件，然后编写按键相关函数</li></ol><ul><li>key.h文件：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _KEY_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> _KEY_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f1xx.h&quot;</span></span><span class="hljs-comment">//下面的方式是通过直接操作HAL库函数方式读取IO</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0        HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_4)  <span class="hljs-comment">//KEY0按键PE4</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1        HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_3)  <span class="hljs-comment">//KEY1按键PE3</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY2        HAL_GPIO_ReadPin(GPIOE,GPIO_PIN_2) <span class="hljs-comment">//KEY2按键PE2</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WK_UP       HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0)  <span class="hljs-comment">//WKUP按键PA0</span></span><span class="hljs-comment">//定义按键按下时的键值</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_PRES 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_PRES2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY2_PRES3</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_PRES   4</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">key_scan</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> mode)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><ul><li>key.c文件：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;key.h&quot;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief按键处理函数,返回按键值(注意此函数有响应优先级,KEY0&gt;KEY1&gt;KEY2&gt;WK_UP!!)</span><span class="hljs-comment">  * @parammode:0 不支持连续按；1 支持连续按</span><span class="hljs-comment">  * @retval按键值</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">key_scan</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> mode)</span>&#123;    <span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> key_up=<span class="hljs-number">1</span>;     <span class="hljs-comment">//按键松开标志</span>    <span class="hljs-keyword">if</span>(mode==<span class="hljs-number">1</span>)key_up=<span class="hljs-number">1</span>;    <span class="hljs-comment">//支持连按</span>    <span class="hljs-keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="hljs-number">0</span>||KEY1==<span class="hljs-number">0</span>||KEY2==<span class="hljs-number">0</span>||WK_UP==<span class="hljs-number">1</span>))    &#123;        HAL_Delay(<span class="hljs-number">10</span>);<span class="hljs-comment">//按键消抖</span>        key_up=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(KEY0==<span class="hljs-number">0</span>)       <span class="hljs-keyword">return</span> KEY0_PRES;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY1==<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> KEY1_PRES;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY2==<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> KEY2_PRES;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(WK_UP==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> WKUP_PRES;              &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY0==<span class="hljs-number">1</span>&amp;&amp;KEY1==<span class="hljs-number">1</span>&amp;&amp;KEY2==<span class="hljs-number">1</span>&amp;&amp;WK_UP==<span class="hljs-number">0</span>)key_up=<span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//无按键按下</span>&#125;</code></pre></div><ul><li>在main.c函数中编写相关程序</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span>  <span class="hljs-type">uint8_t</span> key;  <span class="hljs-comment">/* USER CODE END 1 */</span>  <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span>  <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>  HAL_Init();  <span class="hljs-comment">/* USER CODE BEGIN Init */</span>  <span class="hljs-comment">/* USER CODE END Init */</span>  <span class="hljs-comment">/* Configure the system clock */</span>  SystemClock_Config();  <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span>  <span class="hljs-comment">/* USER CODE END SysInit */</span>  <span class="hljs-comment">/* Initialize all configured peripherals */</span>  MX_GPIO_Init();  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span>  <span class="hljs-comment">/* USER CODE END 2 */</span>  <span class="hljs-comment">/* Infinite loop */</span>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;    <span class="hljs-comment">/* USER CODE END WHILE */</span>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span>key = key_scan(<span class="hljs-number">0</span>);<span class="hljs-keyword">switch</span>(key)    &#123;<span class="hljs-keyword">case</span> WKUP_PRES:&#123;<span class="hljs-comment">/* 控制蜂鸣器 */</span>HAL_GPIO_TogglePin(BEEP_GPIO_Port, BEEP_Pin);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> KEY2_PRES:&#123;<span class="hljs-comment">/* LED0 */</span>HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> KEY1_PRES:&#123;<span class="hljs-comment">/* LED1 */</span>HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> KEY0_PRES:&#123;<span class="hljs-comment">/* LED0 &amp; LED1 */</span>HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);<span class="hljs-keyword">break</span>;&#125;    &#125;HAL_Delay(<span class="hljs-number">10</span>);  &#125;  <span class="hljs-comment">/* USER CODE END 3 */</span>&#125;</code></pre></div><ol start="3" type="1"><li>程序验证</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230528114108663.png" alt="image-20230528114108663" style="zoom:80%;" /></p><p>注意添加头文件，设置下载器选项，编译下载程序，分别按下按键，现象和预期一致，达到了实验目的。</p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/key.zip">key</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之LED闪烁</title>
    <link href="/2023/05/27/STM32CubeMX%E4%B9%8BLED%E9%97%AA%E7%83%81/"/>
    <url>/2023/05/27/STM32CubeMX%E4%B9%8BLED%E9%97%AA%E7%83%81/</url>
    
    <content type="html"><![CDATA[<p>下面结合正点原子战舰开发板，对多个外设介绍，并编程实验。</p><p>开发板使用的MCU是STM32F103ZET6，进入ST官网，下载其相关资料。<a href="https://www.st.com/en/microcontrollers-microprocessors/stm32f103ze.html#documentation">STM32F103ZE</a></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527225335619.png" alt="" /><figcaption>image-20230527225335619</figcaption></figure><h3 id="gpio口简介">GPIO口简介</h3><p>每个GPIO端口有两个32位配置寄存器（GPIOx_CRL和GPIOx_CRH），两个32位数据寄存器（GPIOx_IDR和GPIOx_ODR），一个32位置位/复位寄存器（GPIOx_BSRR），一个16位复位寄存器（GPIOx_BRR）和一个32位锁定寄存器（GPIOx_LCKR）。 在HAL库中，GPIO端口的每个位可以由软件分别配置成多种模式：</p><ul><li>浮空输入模式</li><li>开漏输出模式</li><li>复用推挽模式</li><li>复用输入模式</li><li>模拟模式</li><li>上升沿触发中断模式</li><li>下降沿触发中断模式</li><li>上升沿/下降沿触发中断模式</li><li>上升沿触发事件模式</li><li>下降沿触发事件模式</li><li>上升沿/下降沿触发事件模式</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527225635350.png" alt="image-20230527225635350" style="zoom:80%;" /></p><h3 id="硬件设计">硬件设计</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527231125164.png" alt="image-20230527231125164" style="zoom:80%;" /></p><h3 id="软件设计">软件设计</h3><h4 id="stm32cubemx设置">1. STM32CubeMX设置</h4><ul><li>RCC设置外接HSE，时钟设置为72M</li><li>PB5和PE5设置为GPIO推挽输出模式、上拉、低速、默认输出电平为高电平</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527232409961.png" alt="image-20230527232409961"  /></p><ul><li>输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated periphera initialization as a pair of ‘.c/.h’ files per IP ；点击GENERATE CODE，生成工程代码</li></ul><h4 id="keil工程代码的编写">2.keil工程代码的编写</h4><ul><li>CubeMX已经帮我们完成gpio初始化的过程。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_GPIO_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">/* GPIO Ports Clock Enable */</span>  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin Output Level */</span>  HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED1_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  HAL_GPIO_Init(LED1_GPIO_Port, &amp;GPIO_InitStruct);  <span class="hljs-comment">/*Configure GPIO pin : PtPin */</span>  GPIO_InitStruct.Pin = LED0_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_PULLUP;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  HAL_GPIO_Init(LED0_GPIO_Port, &amp;GPIO_InitStruct);&#125;</code></pre></div><ul><li>我们只需要在main.c函数中编写LED闪烁程序即可（<strong>注意编写的程序应该在相应的USER CODE范围内，否则再次使用CubeMX修改配置时，USER CODE范围之外的程序会被清除</strong>）</li></ul><p>在<strong>stm32f1xx_hal_gpio.h</strong>库文件中, 找到可以改变引脚电平的API函数</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_WritePin</span><span class="hljs-params">(GPIO_TypeDef *GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin, GPIO_PinState PinState)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_TogglePin</span><span class="hljs-params">(GPIO_TypeDef *GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span>;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527234410653.png" alt="image-20230527234410653" style="zoom:80%;" /></p><ul><li>下载程序</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527235236622.png" alt="image-20230527235236622" style="zoom:80%;" /></p><p>可以看到两个LED不停的闪烁。</p><p>工程文件Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/stm32/led.zip">LED</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX之开发环境的搭建</title>
    <link href="/2023/05/27/STM32CubeMX%E4%B9%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/05/27/STM32CubeMX%E4%B9%8B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>在ST公司推出HAL库之前，开发SMT32一般使用的是标准库，但后来为了便于移植程序，官方不再更新STM32标准库，而大力推崇HAL库，伴随HAL库的兴起，ST推出了STM32CubeMX开发工具，它是STM32芯片图形化配置工具， 允许用户使用图形化向导生成C 初始化代码，极大限度内减少了工程师的工作量，转而把工作重点放在项目逻辑层、应用层的实现。另外，ST也同时推出一整套IDE软件STM32CubeIDE ，本章不做过多介绍。</p><p>HAL 的全称是：<strong>Hardware Abstraction Layer (硬件抽象层)</strong>，HAL 位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化。它是一个由 ST公司基于硬件抽象层而设计的软件函数包，由程序、数据结构、宏等组成，包括了微控制器所有外设的性能特征。此外HAL函数库包括每一个外设的驱动描述和应用实例，为开发者访问底层硬件提供了一个中间 API，所以说通过使用 HAL 库，工程师不需要花过多精力去深入掌握底层硬件细节，就可以应用STM32的每个外设，实现快速二次开发的目的。</p><h3 id="smt32开发环境的搭建">SMT32开发环境的搭建</h3><p><strong>友情提醒：全程下载安装过程中尽量不要使用中文目录，防止个别异常情况发生。</strong></p><h4 id="一keil-mdk-arm软件的安装">一、Keil MDK-ARM软件的安装</h4><ol type="1"><li>获取Keil MDK-ARM软件：<a href="https://developer.arm.com/Tools%20and%20Software/Keil%20MDK">官网</a></li></ol><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527210314137.png" alt="" /><figcaption>image-20230527210314137</figcaption></figure><p>可以安装社区版，免费正版使用一年，需要进行注册才能下载，为了学习可以在网上查找其他方式进行安装。</p><ol start="2" type="1"><li>获取STM32芯片设备安装包：<a href="https://www.keil.arm.com/devices/?q=&amp;vendor=stmicroelectronics&amp;core=Cortex-M3&amp;sort_by=">官网</a></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527210938403.png" alt="image-20230527210938403"  /></p><p>选择对应的厂商和内核版本，进行相应下载即可。</p><ol start="3" type="1"><li>安装keil软件和STM32设备安装包</li></ol><h4 id="二stm32cubemx软件的安装">二、STM32CubeMX软件的安装</h4><p>安装STM32CubeMX必须具备的条件：</p><ul><li>JRE（Java Runtime Environment）：JAVA运行环境。</li><li>STM32CubeMX软件：生成初始化代码的地方。</li><li>HAL库 PACK包：F0、F1、F3、H7等Cortex内核，都需要对应的PACK包安装。</li></ul><ol type="1"><li>安装JRE：JRE官网下载链接： https://www.java.com/en/download/manual.jsp</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527212452472.png" alt="image-20230527212452472" style="zoom:80%;" /></p><ol start="2" type="1"><li>获取STM32CubeMX：<a href="https://www.st.com/en/development-tools/stm32cubemx.html">官网</a></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527211706175.png" alt="image-20230527211706175"  /></p><ol start="3" type="1"><li>获取HAL库 PACK包，由两种方式：</li></ol><ul><li>通过STM32CubeMX软件进行安装</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527213020674.png" alt="image-20230527213020674" style="zoom: 67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527213741351.png" alt="image-20230527213741351" style="zoom: 80%;" /></p><ul><li>下载离线PACK包，然后通过STM32CubeMX软件进行安装：<a href="https://www.st.com/en/development-tools/stm32cubemx.html#tools-software">官网</a></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527214001528.png" alt="image-20230527214001528" style="zoom: 67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527213852127.png" alt="image-20230527213852127" style="zoom:80%;" /></p><h4 id="三stm32cubemx使用">三、STM32CubeMX使用</h4><ul><li>新建工程，选择对应开发MCU</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527214446420.png" alt="image-20230527214446420"  /></p><ul><li>RCC设置，选择HSE（外部高速时钟）为Crystal/Ceramic Resonator（晶振/陶瓷谐振器）</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527214726370.png" alt="image-20230527214726370"  /></p><ul><li>时钟配置，STM32F103最高时钟为72M</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527215030571.png" alt="image-20230527215030571"  /></p><ul><li>功能外设配置，以PA0/PA1为例，设置GPIO引脚相关参数</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527215605956.png" alt="image-20230527215605956"  /></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527215826116.png" alt="" /><figcaption>image-20230527215826116</figcaption></figure><ul><li>工程设置并生成Keil工程</li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527220345421.png" alt="" /><figcaption>image-20230527220345421</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230530093411899.png" alt="" /><figcaption>image-20230530093411899</figcaption></figure><ul><li>点击Open Project，打开keil工程，至此就配置好了工程外设初始化；在gpio.c文件中可以看到PA0/PA1管脚的初始化函数；至此用户可以根据自已的需求编写应用程序</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527221407553.png" alt="image-20230527221407553" style="zoom: 80%;" /></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527222104592.png" alt="" /><figcaption>image-20230527222104592</figcaption></figure><h4 id="参考链接">参考链接：</h4><p><a href="http://t.csdn.cn/dnLul">STM32CubeMX系列</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典运放电路的分析与计算</title>
    <link href="/2023/05/27/%E7%BB%8F%E5%85%B8%E8%BF%90%E6%94%BE%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/05/27/%E7%BB%8F%E5%85%B8%E8%BF%90%E6%94%BE%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>基本运放电路是模拟电路的学习重点，复杂的模拟电路很多都是由基本运放电路组成的。在运放电路中，一般运用运放的“虚短”和“虚断”来进行分析，然后应用欧姆定律等电流电压关系，即可得输入输出的关系。</p><p><strong>“虚短”</strong>是指在分析运算放大器处于线性状态时，可把两输入端视为等电位（<strong>V+ = V-</strong> ），这一特性称为虚假短路，简称虚短。显然不能将两输入端真正短路。</p><p><strong>“虚断”</strong>是指在分析运放处于线性状态时，可以把两输入端视为等效开路（<strong>ib- = ib+ = 0</strong>），这一特性称为虚假开路，简称虚断。显然不能将两输入端真正断路。（差模输入电阻无穷大）</p><p>以下详细看看基本运放电路：</p><ul><li><strong>反向运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527131553159.png" alt="image-20230527131553159" style="zoom:80%;" /></p><ul><li><strong>同向运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527133057553.png" alt="image-20230527133057553" style="zoom:80%;" /></p><ul><li><strong>反相求和运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527134531510.png" alt="image-20230527134531510" style="zoom:80%;" /></p><ul><li><strong>同相求和运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527140528733.png" alt="image-20230527140528733" style="zoom:80%;" /></p><ul><li><strong>减法运算电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527141757901.png" alt="image-20230527141757901" style="zoom:80%;" /></p><ul><li><strong>积分电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527143345994.png" alt="image-20230527143345994" style="zoom:80%;" /></p><ul><li><strong>微分电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527144506543.png" alt="image-20230527144506543" style="zoom:80%;" /></p><ul><li><strong>差分运算电路</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527155455519.png" alt="" /><figcaption>image-20230527155455519</figcaption></figure><ul><li><strong>电流检测电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527163159557.png" alt="image-20230527163159557" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527163453552.png" alt="image-20230527163453552" style="zoom:80%;" /></p><ul><li><strong>电压检测电路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230527175438392.png" alt="image-20230527175438392" style="zoom:80%;" /></p><p>以上是基本的运放电路及分析，掌握了基本的运放电路分析方法，对于复杂的运放电路，可以进行拆解分析，在实际应用中要做到举一反三。</p><p><strong>参考链接：</strong></p><p>http://t.csdn.cn/xbhB9</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几种常用的电平转换方法</title>
    <link href="/2023/05/26/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%B5%E5%B9%B3%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/"/>
    <url>/2023/05/26/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%B5%E5%B9%B3%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在电路设计时，有时会遇到电压域不匹配的问题，如外部接口芯片为1.8V供电，而MCU为3.3V供电。这时候就需要进行电平转换才能通讯。下面总结几种常用的电平转换电路。</p><h3 id="二极管电平转换电路">二极管电平转换电路</h3><p>一些通讯模块（4G、NB模块等）的串口是1.8V电平，与常用MCU的3.3V，这时就需要电平转换。需要注意转换的方向，高电压端和低电压端不可调换。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526230229375.png" alt="image-20230526230229375" style="zoom:80%;" /></p><p>当TX为低电平时，D1导通，RX被拉低；</p><p>当TX为高电平3.3V时，D1截止，RX被拉高到1.8V高电平;</p><h3 id="三极管电平转换电路">三极管电平转换电路</h3><ul><li>IC为1.8V电平，MCU为3.3V电平。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526232323959.png" alt="image-20230526232323959" style="zoom:80%;" /></p><p>当TXD为低电平时，Q1导通，RXD被拉低；</p><p>当TXD为高电平1.8V时，Q1截止，RXD被拉到高电平。</p><ul><li>将外接的信号转化为稳定的高低电平。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526232932554.png" alt="image-20230526232932554" style="zoom:80%;" /></p><p>当输入 S_IN 为低电平时，三极管 Q1关断，三极管 Q2 基极为高电平，导致 Q2 导通，输出端 S_OUT被拉低，实现两端都为低电平。</p><p>当输入 S_IN 为高电平 (VDD_EXT) 时，三极管 Q1 导通，三极管Q2关断，输出端 S_OUT 被 R4 拉高到 VDD_MCU，实现两端都为高电平。</p><p>❤️ 三极管电平转换电路，便宜实用，但是只能单向转化。而且不适用于波特率过高的应用（大概大于 400Kbps 就不建议用了）。</p><h3 id="mos管电平转换电路">MOS管电平转换电路</h3><p>在使用I2C、SPI等接口做不同电压域通讯时，就需要用到双向的电平转换电路。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526233821002.png" alt="image-20230526233821002" style="zoom:80%;" /></p><p>取SDA数据线进行分析：</p><p>当SDA1输出高电平时：MOS管Q1的Vgs = 0，MOS管关闭，SDA2被电阻R3上拉到5V。</p><p>当SDA1输出低电平时：MOS管Q1的Vgs = 3.3V，大于导通电压，MOS管导通，SDA2通过MOS管被拉到低电平。</p><p>当SDA2输出高电平时：MOS管Q1的Vgs不变，MOS维持关闭状态，SDA1被电阻R2上拉到3.3V。</p><p>当SDA2输出低电平时：MOS管不导通，但是它有体二极管，MOS管里的体二极管把SDA1拉低到低电平，此时Vgs约等于3.3V，MOS管导通，进一步拉低了SDA1的电压。</p><h3 id="电平转换芯片">电平转换芯片</h3><p>在一些高速通讯的场合，就需要用到专用的电平转换芯片。芯片有很多种，单向电平转换、带方向控制的双向电平转换、自动双向电平转换等。如SN74LVC4245A、TXS0108EPWR。</p><p>❤️ 成本相对前面较高，但是速度快，双向并且能够自动检测方向，高速低速场合都适用。</p><p>如果对成本不敏感，电平转换芯片是最稳定可靠的方式。</p><h3 id="参考链接">参考链接</h3><p>http://t.csdn.cn/9Tvhd</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PT100测温电路总结分析</title>
    <link href="/2023/05/25/PT100%E6%B5%8B%E6%B8%A9%E7%94%B5%E8%B7%AF%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/"/>
    <url>/2023/05/25/PT100%E6%B5%8B%E6%B8%A9%E7%94%B5%E8%B7%AF%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>PT100 温度传感器是一种以铂(Pt)作成的电阻式温度传感器，属于正电阻系数,其电阻和温度变化的关系为：<strong>R=R0(1+αT) 其中α=0.003851,Ro 为 100Ω(在 0℃的电阻值),T 为摄氏温度</strong>。</p><p>PT100测温采样电路主要有电桥法、恒流源法、集成芯片法等，分别介绍如下：</p><h3 id="一惠斯通电桥法">一、惠斯通电桥法</h3><p>惠斯通电桥（<strong>Wheatstone bridge</strong>）又称为惠斯登电桥，是一种测量工具，用来精确测量电阻器的电阻值。它的拓扑图如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230526091948810.png" alt="" /><figcaption>image-20230526091948810</figcaption></figure><p>在实际使用中，一般会将电阻的变化量转化为电压的变化，我们通常将其中三个电阻值固定， 而将另外一个电阻换成热敏电阻、压敏电阻、PT100等，这时候就可以用电桥来测物理量了。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-22233.png" alt="" /><figcaption>image-22233</figcaption></figure><p>如果将PT100接入电桥，PT100的阻值发生变化导致ΔV发生变化，通过差分运放放大后送入AD转换芯片或直接进入单片机的AD采样部分，再对照PT100的电阻-温度对应表就可以知道当前温度了。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230114357429.png" alt="" /><figcaption>image-20230114357429</figcaption></figure><p><strong>恒压源：</strong></p><p>这里采用TL431通过分压产生+4.096V恒压源，也可通过REF3140作为基准源。</p><p><strong>电桥部分：</strong></p><p>因为PT100厚膜铂电阻温度传感器允许通过的工作<em>电流</em>为:<em>≦5mA</em>，所以电桥部分电阻阻值需要注意。RP2电位器主要作用是调节温度的下限，设计中可以设置为固定值。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-202305150017095.png" alt="" /><figcaption>image-202305150017095</figcaption></figure><p><strong>RF部分：</strong></p><p>参考AD623芯片手册进行滤波干扰处理。</p><p><strong>放大电路：</strong></p><p>RG阻值可改变放大倍数G，RG = 100 kΩ/(G − 1) ，它们的关系如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-202306142609555.png" alt="" /><figcaption>image-202306142609555</figcaption></figure><p>运算放大器还可以用AD620、AD627、OP07、MCP355X等芯片。</p><p><strong>应用</strong></p><p>比如VCC电压为 <strong>+5V</strong>，设置运放增益为 <strong>100</strong>，则最大输入电压为 <strong>50mV (5V/100)</strong>.</p><p>运算放大器反向端电压：V- = 4.096*RP2/(2500+RP2)</p><p>运算放大器同向端电压：V+ = V- + 50mV;</p><p>则通过分压原理，PT100最大阻值：R = (2500*V+) / (4.096-V+);</p><p>譬如设置最低温度下限为 <strong>-50℃</strong>，则对应PT100阻值: <strong>80.31Ω</strong>，为了电桥平衡，设置RP2为<strong>80.31Ω</strong>，由以上公式PT100最大阻值R= <strong>113.23Ω</strong>， 对应的温度：<strong>30.4℃</strong>。则温度测试的范围（-50~30.4℃），可通过调小运放增益来扩宽温度的范围。（电阻的取值要根据市面上相近的阻值来确定，计算的阻值不见得有）</p><h3 id="二恒流源法">二、恒流源法</h3><p>参考<a href="https://blog.csdn.net/z3y3m3/article/details/86225594">PT100恒流源测温电路</a></p><h3 id="三芯片集成法">三、芯片集成法</h3><p>集成芯片测PT100，市面有很多，如ADS1120、MAX31865、HX712、HX717、CS1237、TM7711等，查看其芯片手册，一般都会有典型应用线路。</p><h3 id="参考链接">参考链接</h3><p><a href="PT100/PT1000温度采集电路方案">PT100/PT1000温度采集电路方案</a></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pcb layout 审核表</title>
    <link href="/2023/05/25/pcb-layout-%E5%AE%A1%E6%A0%B8%E8%A1%A8/"/>
    <url>/2023/05/25/pcb-layout-%E5%AE%A1%E6%A0%B8%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>PCB设计完成需要进行综合检查，除了设计软件设定的规则外，还需要手动确认一些其它重要的信息。</p><h3 id="结构">结构</h3><ul><li><p>PCB中的定位孔位置大小是否和结构的要求一致，旁边是否有挨得太近的器件（保留间距大于1mm）；</p></li><li><p>接插件的型号，方向，顺序是否和要求一致，位置是否合理；</p></li><li><p>母板，子板的连接座的方向，顺序是否一致，位置是否合理；</p></li><li><p>新器件的封装，脚位定义，电气连接都需校对；</p></li></ul><h3 id="原理图和pcb">原理图和PCB</h3><ul><li>确保从原理图导入的网表无误（务必在审核PCB时实际导入，核对）；</li><li>核对PCB的板层设置是否合理；</li></ul><h3 id="电源">电源</h3><ul><li>电源线路要求尽量短，粗，考虑温升；</li><li>关掉敷铜层和走线，点亮地网络，检查地过孔是否足够；</li><li>IC的散热焊盘上是否有多过孔接地；</li></ul><h3 id="usb">USB</h3><ul><li>USB的脚位排序是否正确（VBUS/DM/DP/GND）；</li><li>USB DM,DP走线是否满足差分要求，不要有节点；</li><li>请注意DM，DP走线是否和其它数据线平行（临层平行）</li><li>HOST端口的电源走线宽度是否满足要求；</li></ul><h3 id="wifi">WIFI</h3><ul><li>WIFI天线是否进行包地处理；</li><li>WIFI的接地检查；模块是否可靠接地，模块的散热焊盘不能全敷铜接地；</li><li>晶体Layout检查；晶体电路下方必须铺地，且下面的其它层尽量只走控制线，最好铺地；</li></ul><h3 id="audio">Audio</h3><ul><li>电源的滤波电容是否靠近IC电源管脚，电源线是否有数据线干扰；</li><li>音频IC的下方不能走数据线；</li><li>音频的输入，输出走线（包括MIC）是否包地，是否有高频干扰信号，临层是否有电源层和数字信号；</li><li>如音频线的走线比较长（100mil以上)，建议左右声道中间隔地；</li><li>I2S走线是否分组，在同一区域布线，各数据线是否等长；</li></ul><h3 id="sd">SD</h3><ul><li>SDIO走线是否为一组，在同一区域布线，各数据和CLK等长，CLK尽量包地；</li><li>SD卡座电源管脚位置放置10uF的电容；</li><li>检查SD卡脚位的正确性；</li></ul><h3 id="sdram">SDRAM</h3><ul><li>DDR的走线分四组：数据线（DQ，DM，DQS），地址线，命令线，CLK线。</li></ul><ol start="2" type="1"><li>DQS走线位置应在组内的DQ中间；</li><li>DQS与时钟不要相邻；</li><li>地址/命令/控制信号采用T型拓扑方式，分叉点到DDR芯片两端的长度须尽量等长（若不等长，可走蛇形线使两端等长）；</li><li>蛇形线的中心间距至少3倍线宽；</li></ol><ul><li>尽量拉大数据线与数据线的距离；相邻层的数据线避免正对并行；</li><li>DDR的数据线尽量走PCB的表层，方便阻抗匹配；</li><li>CLK差分对之间是否有端接电阻；</li></ul><h3 id="camera">Camera</h3><ul><li>电源的滤波电容是否靠近相应的IC电源管脚，电源走线是否受到数据线干扰；</li><li>数据线分组，Layout在同一区域，需要控制数据线的等长，误差在500mil之内；</li><li>CLKin/out信号串电阻并电容，复位信号高低电平；</li><li>CLKin和CLKout应包地处理，不要其它数据线相互平行（注意临层平行）；</li></ul><h3 id="lcd">LCD</h3><ul><li>核对LCD座的封装，脚位顺序，屏的插入方式；</li><li>LCD的走线分组，Layout在同一区域，需要控制数据线和CLK的线的等长，误差在500mil之内，特别是有HDMI和RK1000S时；</li><li>LCD的clk最好能包地，串磁珠，并电容；CLK的参考层最好不要换；</li><li>TMDS信号是否按差分线要求Layout；</li><li>LCD的数据线最好的方式是走中间层，尽量少走外层；</li><li>LCD部分的走线和器件需要屏蔽（包括LVDS IC，HDMI IC）</li><li>LCD的FPC位置下面的表层PCB上要留有接地的漏铜区，便于FPC包屏蔽材料接地(如需过EMI测试，LCD一定会要可靠接地）；</li></ul><h3 id="hdmi">HDMI</h3><ul><li>数据线是否分组，同一区域布线，是否等长（误差不超过500mil），CLK上需要串串磁珠并电容到地；</li><li>电源的滤波电容是否靠近IC电源管脚，电源走线是否避开数据线；</li><li>TMDS信号是否按差分线要求Layout；</li><li>HDMI走线和器件需严控屏蔽；</li></ul><h3 id="g">3G</h3><ul><li>电源的走线宽度是否足够宽；滤波电容是否靠近相应的电源管脚；</li><li>3G整机需要有严格的屏蔽（RF电路和数字电路分开屏蔽）；</li><li>3G通话要注意结构上喇叭和MIC位置的处理，喇叭和MIC要有各自的腔体；</li><li>天线的Layout检查；</li></ul><h3 id="gps">GPS</h3><ul><li>电源和滤波电容的位置；</li><li>是否有有严格的屏蔽（RF电路和数字电路分开屏蔽）,所有的具有数字信号的器件都有要求，如Code,LCD,LVDS,HDMI，并且LCD的FPC，摄像头的FPC，喇叭连接线附近都要预留漏铜区便于相关连接线屏蔽接地；</li><li>GPS的天线位置是否合理，和金属部件的距离是否有6mm以上的距离；</li></ul><h3 id="compass">Compass</h3><ul><li>尽量不要放在屏蔽壳内(如有必要，需采用)；</li><li>周围是否大电流的数据线；</li><li>是否和磁感器件，软铁材料保持需要的距离（喇叭，SD卡座）</li></ul><h3 id="测试点检查">测试点检查</h3><ul><li>是否放置如下测试点：开机键；USB口；触摸屏；电池座，耳机座，DC座;外响焊点；</li><li>测试点直径需要0.8mm，测试点与测试点的距离不能小于1.25mm，测试点与器件的距离不能小于0.2mm；</li></ul><h3 id="发热器件">发热器件</h3><ul><li>发热器件应该放置在利于散热的位置上,且注意不要放置在对温度敏感的器件旁边；</li><li>不同发热器件的距离最好能拉开距离，尽量保持在20mm以上；</li></ul><h3 id="其它">其它</h3><ul><li>WIFI天线不能放在手能握住的地方，避免客户使用机器的时候信号不好；</li><li>调试口是否接出；</li><li>PCB的版本和日期是否标识清晰；</li><li>如果有其它器件，请参考它们的Layout规格；</li></ul><p>以上部分摘录自PCB联盟网，PCB设计完成后，对照审核表进行详细检查，可以避免PCB设计的错误，另外，“<a href="https://dfm.elecfans.com/viewer/?tid=DFM-dh">华秋DFM</a>”软件可检查PCB的可制造性，它可自动分析PCB的设计缺陷。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230525180738659.png" alt="image-20230525180738659" style="zoom:80%;" /></p><p><a href="https://gitee.com/kayoungzhang/my_codehub.git">PCB layout checklist</a></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PCB layout rules</title>
    <link href="/2023/05/24/PCB-layout-rules/"/>
    <url>/2023/05/24/PCB-layout-rules/</url>
    
    <content type="html"><![CDATA[<p>PCB设计过程中，器件的整体布局和关键信号的layout至关重要，布局得当，信号线layout顺畅，就会在后续设计开发过程中，减少不必要的麻烦，相反，布局不当，layout失误，一是影响PCB整体的美观程度，二是在测试应用中带来诸多麻烦。为了减少不必要的设计麻烦，下面介绍一些常用的PCB设计的布局和layout规则：</p><h3 id="pcb布局">PCB布局</h3><ul><li>首先对结构有限高或位置要求的器件进行摆放。布局要美观，器件间尽量对齐。</li><li>PCB整体布局要考虑散热，电源，模拟、数字电路和高速、中速、低速电路等要分开布局。强电流、高电压、强辐射元件要远离弱电流、低电压、敏感器件。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524194603654.png" alt="image-20230524194603654" style="zoom:80%;" /></p><ul><li><p>以每个功能电路的核心组件为中心，围绕它进行布局，尽量减少和缩短各零件间的引线和连接。</p></li><li><p>高压元器件和低压元器件之间最好要有较宽的电气隔离带。</p></li><li><p>布局要考虑布线通道和空间，预估电源通道，不要来回绕。</p></li><li><p>接口保护器件尽量靠近接口摆放，采用一字型布局。信号转换芯片靠近插接口放置。</p></li><li><p>插拔器件或板边连接器周围3mm范围内尽量不布置SMD，以防止连接器插拔时产生的应力损伤器件。</p></li><li><p>器件摆放要外围留有足够的焊接空间，考虑后期可手动焊接。</p></li><li><p>有极性或方向性的插件器件在布局上方向一致，排列整齐。</p></li><li><p>对于会产生磁场的元件，如变压器、扬声器、电感等，布局时应注意减少磁力线对印制导线的切割，相邻元件磁场方向应相互垂直，减少彼此之间的耦合。</p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524222945408.png" /></p><ul><li><p>晶振不要放置到PCB板边，滤波电容与晶体采用π型滤波方式摆放。</p></li><li><p>元器件的编号应该紧靠元器件的边框布置，大小统一，方向整齐，不与元器件、过孔和焊盘重叠。</p></li><li><p>滤波电容尽量靠近芯片管脚，容值越小，越靠近管脚且先经过电容再进入芯片。</p></li></ul><h3 id="pcb-layout">PCB layout</h3><ul><li>首先对重要的信号或要求比较严格的信号进行走线，信号线的过孔尽量少，信号线与其回路构成的环面积要尽可能小，环面积越小，对外的辐射越少，接收外界的干扰也越小。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524202049996.png" alt="image-20230524202049996" style="zoom:80%;" /></p><ul><li>输入/输出端导线尽量避免相邻平行，最好加地线隔离，以免发生耦合。</li><li>电源部分尽量采用铺铜方式，保证载流得当。</li><li>CHIP器件走线和焊盘连接要避免不对称走线。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524214904856.png" alt="image-20230524214904856" style="zoom:80%;" /></p><ul><li>贴片焊盘上不要有过孔，走线避免出现直角或锐角。</li><li>对于密间距的IC，走线从焊盘出线时，宽度不能比焊盘宽。</li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230524214930539.png" alt="image-20230524214930539" style="zoom:80%;" /></p><p>以上是设计中常用的规则，应该还有其它常用的规则，后续遇到了再进行添加。</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pcb设计之重要信号线layout注意事项</title>
    <link href="/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%87%8D%E8%A6%81%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%87%8D%E8%A6%81%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>这一篇主要看看pcb设计中重要信号线的layout注意事项：</p><ul><li><strong>差分信号线尽量在一起同一层走线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521104356728.png" alt="image-20230521104356728" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521104659980.png" alt="image-20230521104659980" style="zoom:80%;" /></p><ul><li><strong>差分间距无法满足20mil，最好进行包地</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521104926751%20-%20%E5%89%AF%E6%9C%AC.png" alt="" /><figcaption>image-20230521104926751 - 副本</figcaption></figure><ul><li><strong>usb按90欧姆差分阻抗进行走线，等长处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520105039307.png" alt="image-20230520105039307" style="zoom:80%;" /></p><ul><li><strong>usb打孔换层应在旁边放置地过孔回流</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105612441%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105612441 - 副本" style="zoom:80%;" /></p><ul><li><strong>网口按100欧姆差分阻抗走线，等长处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105139287%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105139287 - 副本" style="zoom:80%;" /></p><ul><li><strong>LVDS差分信号包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105447526%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105447526 - 副本" style="zoom:80%;" /></p><ul><li><strong>差分线等长处理不易幅度过大</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521105746352%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521105746352 - 副本" style="zoom:80%;" /></p><ul><li><strong>DDR所有的走线都应该在ddr的电源分割区域内，且分割区域不能有其他信号线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps1%20-%20%E5%89%AF%E6%9C%AC.jpg" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps2%20-%20%E5%89%AF%E6%9C%AC.jpg" /></p><ul><li><strong>DDR走线要保证同组同层，不要表层一部分，内层一部分</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521110154465%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20230521110154465 - 副本" style="zoom:80%;" /></p><ul><li><strong>DDR布线要满足3W原则</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521110323383%20-%20%E5%89%AF%E6%9C%AC.png" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pcb设计之普通信号线layout注意事项</title>
    <link href="/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%99%AE%E9%80%9A%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%99%AE%E9%80%9A%E4%BF%A1%E5%8F%B7%E7%BA%BFlayout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>这一篇主要看普通信号线的layout注意事项：</p><ul><li><strong>走线不要出现直角锐角</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215258665.png" alt="image-20230520215258665" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215440544.png" alt="image-20230520215440544" style="zoom:80%;" /></p><ul><li><strong>走线不要超过焊盘宽度，应以焊盘同宽出线，可出完焊盘后立即加粗</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215531104.png" alt="image-20230520215531104" style="zoom:80%;" /></p><ul><li><strong>尽量减少环路</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215751818.png" alt="image-20230520215751818" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215820652.png" alt="image-20230520215820652" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520222742879.png" alt="image-20230520222742879" style="zoom:80%;" /></p><ul><li><strong>7个地焊盘只有两个地孔，最多最多三个焊盘一个过孔</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520102020202.jpg" alt="img" style="zoom:80%;" /></p><ul><li><strong>所有层中间间距拉开一点，加到15mil~20mil</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520215958770.png" alt="image-20230520215958770" style="zoom:80%;" /></p><ul><li><strong>走线不要压到电源内缩层</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/20230520102020203.jpg" alt="" /><figcaption>20230520102020203</figcaption></figure><ul><li><strong>走线优化，拉直。</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520102541420.jpg" alt="img" style="zoom:80%;" /></p><ul><li><strong>不要从IC狭窄处走线，影响焊接</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520220316490.png" alt="image-20230520220316490" style="zoom:80%;" /></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520220340784.png" alt="" /><figcaption>image-20230520220340784</figcaption></figure><ul><li><strong>电源处有多少过孔，地焊盘周边也打同样数量过孔，便于回流</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520220556496.png" alt="image-20230520220556496" style="zoom:80%;" /></p><ul><li><strong>走线间距太小容易串扰，需满足3W原则</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20220520220712824.png" alt="image-20230520220712824" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20220520221701707.png" alt="image-20230520221701707" style="zoom:80%;" /></p><ul><li><strong>预留地回流的通道</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20220520220803115.png" alt="image-20230520220803115" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520231118917.png" alt="image-20210520231118917" style="zoom:80%;" /></p><ul><li><strong>可以一同走的线，避免单独绕环线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221029160.png" alt="image-20210520221029160" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221053269.png" alt="image-20210520221053269" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223724436.png" alt="image-20210520223724436" style="zoom:80%;" /></p><ul><li><strong>铺铜的地方就不要再走细线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221230603.png" alt="image-20210520221230603" style="zoom:80%;" /></p><ul><li><strong>焊盘之间的窄小铜皮使用cutout进行去除，避免手动焊接短路风险</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221545131.png" alt="image-20210520221545131" style="zoom:80%;" /></p><ul><li><strong>相邻层走线不要重叠</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520221806754.png" alt="image-20210520221806754" style="zoom:80%;" /></p><ul><li><strong>不要横向连接多个焊盘，容易造成不良焊接，可以先焊盘各自拉线出来，再两两相连</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222136579.png" alt="image-20210520222136579" style="zoom:80%;" /></p><ul><li><strong>走线能短则短</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222412740.png" alt="image-20210520222412740" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223011614.png" alt="image-20210520223011614" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225850852.png" alt="image-20210520225850852" style="zoom:80%;" /></p><ul><li><strong>走线不要太靠板边</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222521807.png" alt="image-20210520222521807" style="zoom:80%;" /></p><ul><li><strong>高压跟低压部分的间距最少保持5mm的间距</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520222521890.jpg" alt="image-20210520222521890" style="zoom:80%;" /></p><ul><li><strong>合理布局</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223236635.png" alt="image-20210520223236635" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520223544644.png" alt="image-20210520223544644" style="zoom:80%;" /></p><ul><li><strong>管脚之间阻焊层相连，需要修改Rule规则阻焊外扩距离</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225318763.png" alt="image-20210520225318763" style="zoom:80%;" /></p><ul><li><strong>走线不要太绕</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225618301.png" alt="image-20210520225618301" style="zoom:80%;" /></p><ul><li><p><strong>晶振采用Π型滤波模式，且对信号线进行包地处理，晶振下面不要走线</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233516091.png" alt="image-20210520233516091" style="zoom:80%;" /></p></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520225725174.png" alt="image-20210520225725174" style="zoom:80%;" /></p><ul><li><strong>电感中间不要有铜皮，且不要走线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230103302.png" alt="image-20210520230103302" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230711630.png" alt="image-20210520230711630" style="zoom:80%;" /></p><ul><li><strong>光耦所有层中间要挖空隔开，不要走线</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230201233.png" alt="image-20210520230201233" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102742621.png" alt="image-20210521102742621" style="zoom:80%;" /></p><ul><li><strong>GPRS模块下面需要打回流地过孔，一方面为了散热，一方面利于信号</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230429986.png" alt="image-20210520230429986" style="zoom:80%;" /></p><ul><li><strong>尽量减少打孔换层</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520230555960.png" alt="image-20210520230555960" style="zoom:80%;" /></p><ul><li><strong>多排走线不要并排打孔，容易造成地平面隔离，影响完整性</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520231520271.png" alt="image-20210520231520271" style="zoom:80%;" /></p><ul><li><strong>相同模块尽量保持一致，比较美观</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520231649818.png" alt="image-20210520231649818" style="zoom:80%;" /></p><ul><li><strong>过孔需要盖油</strong></li></ul><p><strong>低版本：</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520232756374.png" alt="image-20210520232756374" style="zoom:80%;" /></p><p><strong>高版本：</strong></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520232709864.png" alt="image-20210520232709864" style="zoom:80%;" /></p><ul><li><strong>不可将过孔打在焊盘上</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520232908468.png" alt="image-20210520232908468" style="zoom:80%;" /></p><ul><li><strong>过孔焊盘直径应为孔径2倍(+/- 2mil)</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233133110.png" alt="image-20210520233133110" style="zoom:80%;" /></p><ul><li><strong>丝印文字常用字宽与字高比例：4/25mil 5/30mil 6/45mil ,丝印不要放到阻焊层上</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233730194.png" alt="image-20210520233730194"  /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210520233755149.png" alt="image-20210520233755149" style="zoom:80%;" /></p><ul><li><strong>继电器下面不要走线，且部分走线要加粗</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521101637502.png" alt="image-20210521101637502" style="zoom:80%;" /></p><ul><li><strong>FM天线部分下面不要走线，且要包地处理</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521101821828.png" alt="" /><figcaption>image-20210521101821828</figcaption></figure><ul><li><strong>WIFI模块下面要挖空处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102020202.png" alt="image-20210521102020202" style="zoom:80%;" /></p><ul><li><strong>喇叭走线需要包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102222760.png" alt="image-20210521102222760" style="zoom:80%;" /></p><ul><li><strong>天线模块下面要挖空，天线走线要控制50欧姆阻抗</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102541420.png" alt="image-20210521102541420" style="zoom:80%;" /></p><ul><li><strong>网口部分要挖空处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521102851161.png" alt="image-20210521102851161" style="zoom:80%;" /></p><ul><li><strong>射频部分严格按照阻抗要求走线，转弯部分用圆弧走线，包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/Imge-16846362511801.jpg" alt="Imge-16846362511801" style="zoom:80%;" /></p><ul><li><strong>时钟信号不要离干扰源太近，距离普通信号线要大于20mil，最好做包地处理</strong></li></ul><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-16846364276462.jpg" alt="" /><figcaption>image-16846364276462</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-16846364395533.jpg" alt="" /><figcaption>image-16846364395533</figcaption></figure><ul><li><strong>MIC属于模拟信号，要类差分走线，包地处理</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521103714413.png" alt="image-20210521103714413" style="zoom:80%;" /></p><ul><li><strong>模拟信号加粗处理，部分进行包地</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521103853551.png" alt="image-20210521103853551" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20210521103923788.png" alt="image-20210521103923788" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pcb设计之电源layout注意事项</title>
    <link href="/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%94%B5%E6%BA%90layout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/05/20/pcb%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%94%B5%E6%BA%90layout%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>pcb设计中，在layout时需要遵循一定规范，才会避免设计出不合格的pcb板，下面几篇文章主要总结一下layout过程中常见的问题，本篇是关于电源layout，内容主要来源自pcb联盟网论坛。</p><ul><li><strong>电源滤波电容尽量靠近IC管脚放置。</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205025967.png" alt="image-20230520205025967" style="zoom:80%;" /></p><ul><li><strong>电源走线载流过小，加大铺铜宽度，保证载流量</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205236535.png" alt="image-20230520205236535" style="zoom:80%;" /></p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205310933.png" alt="" /><figcaption>image-20230520205310933</figcaption></figure><ul><li><strong>电源分割线20mil以上，分割的区域尽量宽</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520205632526.png" alt="image-20230520205632526" style="zoom:80%;" /></p><ul><li><strong>芯片电源输出口先经过去耦电容再给其他元件供电</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520210452461.png" alt="image-20230520210452461" style="zoom:80%;" /></p><ul><li><strong>对于输入和输出，滤波电容遵循先大电容，后小电容放置</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520210844679.png" alt="image-20230520210844679" style="zoom:80%;" /></p><ul><li><strong>电源的反馈信号要接到最后一个滤波电容之后</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211057631.png" alt="image-20230520211057631" style="zoom:80%;" /></p><ul><li><strong>多个滤波电容应该放置到一起，且先大后小摆放</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211345243.png" alt="image-20230520211345243" style="zoom:80%;" /></p><ul><li><strong>电源路径不能过细，需要满足过载量，一般20mil线宽通1A电流</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211653288.png" alt="image-20230520211653288" style="zoom:80%;" /></p><ul><li><strong>电源输入和输出尽量L型或一字型布局</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520211931150.png" alt="image-20230520211931150" style="zoom:80%;" /></p><ul><li><strong>电源线不要绕成圈</strong></li></ul><p><img src= "https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520212159692.png" alt="image-20230520212159692" style="zoom:80%;" /></p><ul><li><strong>高压部分走线要加粗，且不能从变压器中间穿</strong></li></ul><p><img src= "https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520212345079.png" alt="image-20230520212345079" style="zoom:80%;" /></p><ul><li><strong>电源层铺铜尽量保证完整性</strong></li></ul><p><img src= "https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230520234104774.png" alt="image-20230520234104774" style="zoom:80%;" /></p><ul><li><strong>电源分割</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123010522.png" alt="image-20230521123010522" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123053217.png" alt="image-20230521123053217" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123123868.png" alt="image-20230521123123868" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123147836.png" alt="image-20230521123147836" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230521123209186.png" alt="image-20230521123209186" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Altium Designer软件应用常见问题</title>
    <link href="/2023/05/19/Altium-Designer%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/19/Altium-Designer%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>使用Altium Designer时，有时候会碰到一些不常见的问题，以下总结几个，后续发现了问题，再增加。</p><ul><li><strong>高版本AD无法寻找系统设置项</strong></li></ul><p>解决方法：</p><p>高版本在软件右上角有个设置图标即是设置项或 Tools -&gt; Preferences.</p><ul><li><strong>在低版本AD，PCB中拖动元件，元件不显示。</strong></li></ul><p>解决方法：</p><ol type="1"><li>Preferences -&gt; PCB Editor -&gt; Display -&gt; 去掉Use Alpha Blending对勾。</li><li>Preferences -&gt; PCB Editor -&gt; Display -&gt; 选中Use DirectX if possible。</li></ol><ul><li><strong>在PCB中元器件随时绿色报错，影响视觉。</strong></li></ul><p>解决方法：</p><ol type="1"><li>Tools -&gt; Design Rule Check -&gt; 除了Electrical，其他项对勾都去掉。</li><li>Design-&gt;Rules -&gt; Electrical Clearance -&gt; 设置Minimum clearance 5mil.</li><li>快捷键T -&gt; M，复位报错。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519231617128.png" alt="image-20230519231617128" style="zoom:80%;" /></p><ul><li><strong>原理图导入PCB中，总是有元件无法导入，可能是footprint的unique ID相同。</strong></li></ul><p>解决方法：复位零件ID。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519230324234.png" alt="" /><figcaption>image-20230519230324234</figcaption></figure><ul><li><strong>低版本AD中，原理图导出pdf文件，中文字体不显示/乱码</strong></li></ul><p>解决方法：</p><p>打开Preference界面，System-&gt;General，将系统字体改为中文；如果还不显示，可能原理图之前的文字没有修正过来，需要手动修改。</p><ul><li><strong>PCB编辑界面左上角悬浮框怎么取消</strong></li></ul><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519231723071.png" alt="image-20230519231723071" style="zoom: 80%;" /></p><p>解决方法：</p><p>按快捷键Shift+H，可以选择打开或者关闭抬头显示；</p><p>按快捷键Shift+G，抬头跟随鼠标移动，再次按下Shift+G即可固定。</p><ul><li><strong>原理图库引脚上面一横怎么添加的（表示低电平有效）</strong></li></ul><p>解决方法：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519232255161.png" alt="image-20230519232255161" style="zoom:80%;" /></p><ul><li><strong>pcb设计中某个零件需要铺铜，铺完后发现不理想，不想重新铺铜，怎么操作。</strong></li></ul><p>解决方法：</p><ol type="1"><li>低版本，使用快捷键 M + G进行修铜即可。</li><li>高版本，直接通过鼠标选择边框进行修改，然后重新铺铜。</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230519234223510.png" alt="image-20230519234223510" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Altium Designer Gerber Files 生成步骤</title>
    <link href="/2023/05/18/Altium-Designer-Gerber-Files-%E7%94%9F%E6%88%90%E6%AD%A5%E9%AA%A4/"/>
    <url>/2023/05/18/Altium-Designer-Gerber-Files-%E7%94%9F%E6%88%90%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<p>pcb layout完成后，然后就可以发送到PCB板厂进行生产制造了，一般为了保密性质，发送给厂商的是GerberFiles文件，所以，就需要生成GerberFiles。以下说一下Altium Designer生成GerberFiles的具体的操作步骤：</p><p>生成Gerber文件前，需要设置PCB原点，工艺边，定位孔，钻孔描述(drill层放置 '.legend')，尺寸标注(一般为mechanic1、2层)。但是对于普通PCB设计者来说，这些不是必须要设置的。</p><ol type="1"><li><p>打开Gerber Setup，Files -&gt; Fabrication Outputs -&gt; Gerber Files</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps1.jpg" alt="img"  /></p></li><li><p>勾选要生成Gerber文件层面，在右侧Mechanical列表中选择要加载到各个Gerber层的机械尺寸信息。勾选左侧的Mechanical 1，则在光绘文件GM1单层显示，勾选右侧的Mechanical 1则每层都会加入机械层信息，“Include unconnected mid-layer pads”项仅限于包含了中间层的PCB 文件输出Gerber 时使能。</p></li></ol><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps2.jpg" alt="" /><figcaption>img</figcaption></figure><ol start="3" type="1"><li>勾选Drill层</li></ol><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps3.jpg" alt="" /><figcaption>img</figcaption></figure><ol start="4" type="1"><li>勾选光圈</li></ol><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps4.jpg" alt="" /><figcaption>img</figcaption></figure><ol start="5" type="1"><li>设置影像大小</li></ol><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps5.jpg" alt="" /><figcaption>img</figcaption></figure><ol start="6" type="1"><li>生成钻孔文件，Files -&gt; Fabrication Outputs -&gt; NC Drill files</li></ol><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps6.jpg" alt="" /><figcaption>img</figcaption></figure><ol start="7" type="1"><li>生成测试网表，Files -&gt; Fabrication Outputs -&gt; Test Point Report</li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps7.jpg" /></p><ol start="8" type="1"><li>生成SMT贴片零件位置表，Files -&gt; Assembly Outputs -&gt; Generates pick and place files</li></ol><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps8.jpg" alt="" /><figcaption>img</figcaption></figure><ol start="9" type="1"><li>生成SMT贴片零件PCB组装图，Files -&gt; Smart PDF</li></ol><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps9.jpg" alt="" /><figcaption>img</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps10.jpg" alt="" /><figcaption>img</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/wps11.jpg" alt="" /><figcaption>img</figcaption></figure><p>将前面7个步骤生成的文件打包发送给pcb板厂就可以制造PCB了，如果还需要贴片，就需要第8步和第9步生成的组装文件了。</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Altium Designer 快捷键汇总</title>
    <link href="/2023/05/17/Altium-Designer-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/"/>
    <url>/2023/05/17/Altium-Designer-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>最近新项目需要设计电路和PCB，刚好结合之前整理的Altium Designer快捷键汇总一下：</p><ul><li><h4 id="对齐">对齐</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>A</td><td>弹出对齐对话框</td></tr><tr class="even"><td>A+L</td><td>向左对齐</td></tr><tr class="odd"><td>A+R</td><td>向右对齐</td></tr><tr class="even"><td>A+D</td><td>横向等间距</td></tr><tr class="odd"><td>A+T</td><td>向上对齐</td></tr><tr class="even"><td>A+B</td><td>向下对齐</td></tr><tr class="odd"><td>A+S</td><td>纵向等间距</td></tr></tbody></table><ul><li><h4 id="元件调整">元件调整</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>M</td><td>元件调整</td></tr><tr class="even"><td>N</td><td>飞线的显示与隐藏</td></tr><tr class="odd"><td>M+S</td><td>器件任意位置移动</td></tr><tr class="even"><td>A+P</td><td>调整位号位置</td></tr><tr class="odd"><td>F11</td><td>选中器件，按下F11</td></tr><tr class="even"><td>E+A</td><td>特殊粘贴</td></tr></tbody></table><ul><li><h4 id="选择">选择</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>S+I</td><td>框选</td></tr><tr class="even"><td>S+O</td><td>反选</td></tr><tr class="odd"><td>S+L</td><td>线选</td></tr><tr class="even"><td>S+N</td><td>选择网络</td></tr><tr class="odd"><td>S+C</td><td>选中直接相连的网络</td></tr><tr class="even"><td>J+C</td><td>查询与搜索器件</td></tr><tr class="odd"><td>J+N</td><td>查询与搜索网络</td></tr><tr class="even"><td>S+T</td><td>切换选择</td></tr></tbody></table><ul><li><h4 id="设置">设置</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>D+C</td><td>进入Class设置</td></tr><tr class="even"><td>D+R</td><td>PCB 规则设置</td></tr><tr class="odd"><td>T+D</td><td>DRC检查</td></tr><tr class="even"><td>T+M</td><td>复位DRC检查</td></tr><tr class="odd"><td>O+B</td><td>PCB板选项设置</td></tr><tr class="even"><td>G</td><td>设置栅格属性</td></tr><tr class="odd"><td>T+N</td><td>器件位号重新编排</td></tr><tr class="even"><td>T+P</td><td>进行系统设置</td></tr></tbody></table><ul><li><h4 id="显示">显示</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>shift+E</td><td>可捕获至中点</td></tr><tr class="even"><td>shift+H</td><td>坐标信息的隐藏与显示</td></tr><tr class="odd"><td>shift+D</td><td>切换悬浮的坐标显示风格</td></tr><tr class="even"><td>shift+S</td><td>单层切换显示</td></tr><tr class="odd"><td>shift+M</td><td>PCB的洞察力镜头</td></tr><tr class="even"><td>shift+空格</td><td>切换走线模式</td></tr><tr class="odd"><td>Ctrl+L</td><td>图层控制</td></tr><tr class="even"><td>Ctrl+D</td><td>Object的隐藏与显示</td></tr><tr class="odd"><td>Ctrl+G</td><td>栅格设置</td></tr><tr class="even"><td>*</td><td>层切换</td></tr><tr class="odd"><td>V+B</td><td>板子翻转</td></tr><tr class="even"><td>L</td><td>器件正反面放置</td></tr><tr class="odd"><td>O+G</td><td>背景和格点设置(PCB与原理图通用)</td></tr></tbody></table><ul><li><h4 id="走线">走线</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>shift+R</td><td>切换走线模式</td></tr><tr class="even"><td>shift+G</td><td>显示走线长度</td></tr><tr class="odd"><td>shift+E</td><td>切换捕获栅格模式</td></tr><tr class="even"><td>E+K</td><td>截断走线</td></tr><tr class="odd"><td>*或-或+</td><td>走线时切换到其他层(自动加过孔)</td></tr><tr class="even"><td>[</td><td>走线时可单独显示要连接的地方高亮</td></tr><tr class="odd"><td>E+D</td><td>连续删线</td></tr><tr class="even"><td>Shift+W</td><td>走线时，设置走线的线宽</td></tr><tr class="odd"><td>Shift+V</td><td>走线时，设置焊盘大小</td></tr><tr class="even"><td>U+M</td><td>AD17 多根相同间距走线，先选中，再U+M走线</td></tr><tr class="odd"><td>T+T+M</td><td>选中多根线，然后同时走线</td></tr><tr class="even"><td>Ctrl+点击焊盘</td><td>同一网络快速走线</td></tr><tr class="odd"><td>Ctrl+H</td><td>高显</td></tr><tr class="even"><td>Ctrl+W</td><td>可视化间距显示(AD16版本以上才有此功能)</td></tr></tbody></table><ul><li><h4 id="功能">功能</h4></li></ul><table><thead><tr class="header"><th>快捷键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>Alt+点击GND</td><td>全部与GND相连的线高亮（单个网络高亮）</td></tr><tr class="even"><td>T+E</td><td>泪滴增加与移除</td></tr><tr class="odd"><td>P+Y</td><td>分离铜皮（按Tab可以设置线宽）</td></tr><tr class="even"><td>D+S+D</td><td>快速定义板框</td></tr><tr class="odd"><td>Ctrl+M</td><td>测量尺寸</td></tr><tr class="even"><td>Ctrl+Q或Q</td><td>改变单位（mm/mil）</td></tr></tbody></table><p>另外，以前学习凡亿教育课程，因为在设计时常用的操作就那几个，所以可以将常用快捷键设置为单个按键，这样在设计时就可快速方便的进行操作，提高了效率，方法是： <strong>按住Ctrl键不放，点击软件各功能选择图标，然后就可设置惯用的快捷键</strong>，主要有以下几个：</p><table><thead><tr class="header"><th>快捷键</th><th>功能设置</th><th>快捷键</th><th>功能设置</th></tr></thead><tbody><tr class="odd"><td>F2</td><td><strong>电气走线</strong></td><td>Alt+F2</td><td>差分走线</td></tr><tr class="even"><td>F3</td><td><strong>放置过孔</strong></td><td>Alt+F3</td><td>放置fill</td></tr><tr class="odd"><td>F4</td><td><strong>敷铜</strong></td><td>Alt+F4</td><td><strong>重新敷铜</strong></td></tr><tr class="even"><td>F5</td><td>颜色开关</td><td></td><td></td></tr><tr class="odd"><td>F6</td><td><strong>矩形框放置器件</strong></td><td></td><td></td></tr><tr class="even"><td>F7</td><td>原理图与layout交互映射</td><td></td><td></td></tr></tbody></table><table><thead><tr class="header"><th>快捷键</th><th>功能设置</th><th>快捷键</th><th>功能设置</th></tr></thead><tbody><tr class="odd"><td>`</td><td><strong>删除</strong></td><td>Alt+`</td><td><strong>删除物理连接</strong></td></tr><tr class="even"><td>1</td><td>选择物理连接</td><td>Alt+1</td><td>显示长度</td></tr><tr class="odd"><td>2</td><td><strong>线选</strong></td><td>Alt+2</td><td>测量中心距</td></tr><tr class="even"><td>3</td><td><strong>框选</strong></td><td>Alt+3</td><td>移动选择</td></tr><tr class="odd"><td>4</td><td>单线等长(蛇形线)</td><td>Alt+4</td><td>差分等长</td></tr><tr class="even"><td>5</td><td><strong>保持原间距走线</strong></td><td>Alt+5</td><td>等间距走线</td></tr><tr class="odd"><td>6</td><td>坐标移动</td><td></td><td></td></tr><tr class="even"><td>7</td><td><strong>修铜</strong></td><td>Alt+7</td><td>M+G</td></tr></tbody></table><table><thead><tr class="header"><th>小键盘数字键</th><th>功能设置</th></tr></thead><tbody><tr class="odd"><td><strong>1</strong></td><td><strong>左对齐</strong></td></tr><tr class="even"><td><strong>2</strong></td><td><strong>下对齐</strong></td></tr><tr class="odd"><td><strong>3</strong></td><td><strong>右对齐</strong></td></tr><tr class="even"><td><strong>4</strong></td><td><strong>水平等间距</strong></td></tr><tr class="odd"><td><strong>5</strong></td><td><strong>上对齐</strong></td></tr><tr class="even"><td><strong>6</strong></td><td><strong>垂直等间距</strong></td></tr><tr class="odd"><td><strong>7</strong></td><td><strong>器件位号排列</strong></td></tr></tbody></table><p>以上加粗部分是常用功能，可根据自己的需要灵活更改。</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pcb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>crc校验及其实现</title>
    <link href="/2023/05/15/crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/05/15/crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>在通信领域传输数据时，为了避免接收到错误的数据，一般会对源数据和接收到的数据进行特定的校验处理，如果一致，则说明传输正确，否则传输发生了错误。常用的校验算法有奇偶校验、校验和、CRC等，这里主要看看CRC校验。</p><h3 id="crc简介">CRC简介</h3><p>循环冗余校验（Cyclic Redundancy Check， CRC），它是利用除法及余数的原理来作错误侦测的，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。具体原理参考：</p><p><a href="https://www.cnblogs.com/liushui-sky/p/9962123.html">CRC码计算及校验原理的最通俗诠释</a></p><h3 id="crc参数模型">CRC参数模型</h3><p>一个完整的CRC参数模型应该包含以下信息：WIDTH，POLY，INIT，REFIN，REFOUT，XOROUT。</p><ul><li>NAME：参数模型名称。</li><li>WIDTH：宽度，即生成的CRC数据位宽，如CRC-8，生成的CRC为8位</li><li>POLY：十六进制多项式，省略最高位1，如 x8 + x2 + x + 1，二进制为1 0000 0111，省略最高位1，转换为十六进制为0x07。</li><li>INIT：CRC初始值，和WIDTH位宽一致。</li><li>REFIN：true或false，在进行计算之前，原始数据是否翻转，如原始数据：0x34 = 0011 0100，如果REFIN为true，进行翻转之后为0010 1100 = 0x2c</li><li>REFOUT：true或false，运算完成之后，得到的CRC值是否进行翻转，如计算得到的CRC值：0x97 = 1001 0111，如果REFOUT为true，进行翻转之后为11101001 = 0xE9。</li><li>XOROUT：计算结果与此参数进行异或运算后得到最终的CRC值，和WIDTH位宽一致。</li></ul><p>通常如果只给了一个多项式，其他的没有说明则：INIT=0x00，REFIN=false，REFOUT=false，XOROUT=0x00。</p><p>常用的21个标准CRC参数模型：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230515215944403.png" alt="image-20230515215944403" style="zoom:80%;" /></p><p>CRC校验在电子通信领域非常常用，可以说有通信存在的地方，就有CRC校验：</p><ul><li>美信(MAXIM)的芯片DS2401/DS18B20，都是使用的CRC-8/MAXIM模型</li><li>SD卡或MMC使用的是CRC-7/MMC模型</li><li>Modbus通信使用的是CRC-16/MODBUS参数模型</li><li>USB协议中使用的CRC-5/USB和CRC-16/USB模型</li><li>STM32自带的硬件CRC计算模块使用的是CRC-32模型</li></ul><h3 id="crc计算的程序实现">CRC计算的程序实现</h3><p>CRC的程序实现，网上有很多比较完备的开源CRC计算库，可以直接使用，没有必要重复造轮子。</p><ul><li>https://github.com/whik/crc-lib-c</li><li><a href="https://www.libcrc.org/">LibCRC – Open Source CRC Library in C</a></li></ul><h3 id="crc计算工具">CRC计算工具</h3><ul><li><a href="http://www.geshe.com/zh-cn/products/gtoolbox">格西CRC计算器</a></li><li>http://www.ip33.com/crc.html</li><li>https://www.lammertbies.nl/comm/info/crc-calculation</li></ul><h3 id="参考链接">参考链接</h3><p><a href="http://www.wangchaochao.top/2020/09/20/Principle-and-implementation-of-CRC/">CRC校验原理及其实现</a></p>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>crc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssd3as压力传感器的开发设计</title>
    <link href="/2023/05/14/ssd3as%E5%8E%8B%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/14/ssd3as%E5%8E%8B%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>spi通讯在开发过程中会经常用到，譬如下面介绍的数字压力传感器SSD系列，在传输压力值时就可以通过spi协议进行通讯。</p><h3 id="产品特点">产品特点</h3><ul><li>中压量程： 7Kpa ~ 1Mpa</li><li>供电：3.3V / 5V可选</li><li>输出：SPI / I2C，压力14位，温度，11位</li><li>温度补偿：-10 ~ 50℃</li></ul><h3 id="引脚定义">引脚定义</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514211435154.png" alt="image-20230514211435154" style="zoom:80%;" /></p><h3 id="压力类型">压力类型</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514211828407.png" alt="image-20230514211828407" style="zoom:80%;" /></p><h3 id="压力公式">压力公式</h3><p>此传感器可模拟输出和数字输出，这里只对数字输出进行处理。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514211610619.png" alt="image-20230514211610619" style="zoom:80%;" /></p><h3 id="输出百分比">输出百分比</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514212122812.png" alt="image-20230514212122812" style="zoom:80%;" /></p><h3 id="spi协议">SPI协议</h3><p>此传感器可以SPI传输，也可I2C传输，这里主要使用gpio 模拟SPI进行传输。</p><p>网上关于SPI的讲解有很多，搜集了网上的资料，可参考<a href="http://t.csdn.cn/Fv29I">SPI协议详解</a> 和 <a href="http://t.csdn.cn/gF3lX">spi时序图怎么分析，怎么看懂spi时序图</a>，这两篇博客写的特别清楚，详细介绍了spi协议的具体内容。</p><ol type="1"><li>spi通过时钟极性（CPOL）和时钟相位（CPHA）控制两个spi设备进行数据传输，所以共有四种模式。</li><li>spi协议适用一主多从的工作场景，通过片选引脚可控制不同的从设备。</li><li>spi传输的实质是主从设备交换数据，也就是你发一个数据必然会收到一个数据，你要收一个数据也要发一个数据（一般是0x00）。</li><li>spi进行数据传输时是从最高位MSB到最低位LSB。</li></ol><h3 id="spi模式与时序">SPI模式与时序</h3><p>CPOL=0 表示SCLK在空闲时为低电平。</p><p>CPOL=1 表示SCLK在空闲时为高电平。</p><p>CPHA=0 数据是在第一个跳变沿的时候就会被采集。</p><p>CPHA=1 数据是在第二个跳变沿的时候才会被采集。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514215453741.png" alt="image-20230514215453741" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514215552736.png" alt="image-20230514215552736" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514215213595.png" alt="image-20230514215213595" style="zoom:80%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230514215320573.png" alt="image-20230514215320573" style="zoom:80%;" /></p><h3 id="程序实现">程序实现</h3><p>spi模块：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SPI_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">uint16_t</span>;<span class="hljs-comment">/* spi pin definition */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_SS      P10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_CLK     P12</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_MISO    P11</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_MOSI    P13</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">spi_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode0</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode1</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode2</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode3</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">* @file     spi.c</span><span class="hljs-comment">* @author   Kayoung</span><span class="hljs-comment">* @version  V1.1</span><span class="hljs-comment">* @date     20221015</span><span class="hljs-comment">* @brief    gpio模拟spi四种驱动函数.</span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">* @attention spi原理：http://t.csdn.cn/gF3lX</span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">*/</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * =================================================</span><span class="hljs-comment">  * |    模式   | CPOL(时钟极性)  |CPHA（时钟相位）|</span><span class="hljs-comment">  * =================================================</span><span class="hljs-comment">  * |MODE0(常用) |       0   |        0       |</span><span class="hljs-comment">  * -------------------------------------------------</span><span class="hljs-comment">  * |MODE1  |       0    |        1       |</span><span class="hljs-comment">  *-------------------------------------------------</span><span class="hljs-comment">  * |MODE2  |       1    |        0       | </span><span class="hljs-comment">  *-------------------------------------------------</span><span class="hljs-comment">  * |MODE3(常用) |   1   |        1       |</span><span class="hljs-comment">  *=================================================</span><span class="hljs-comment">  * MODE0：SCK空闲时为低电平，数据在SCK上升沿被采样，下降沿输出</span><span class="hljs-comment">　* MODE1：SCK空闲时为低电平，数据在SCK下降沿被采样，上升沿输出</span><span class="hljs-comment">　* MODE2：SCK空闲时为高电平，数据在SCK下降沿被采样，上升沿输出</span><span class="hljs-comment">　* MODE3：SCK空闲时为高电平，数据在SCK上升沿被采样，下降沿输出</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spi.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;intrins.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">Delay1us</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;_nop_();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefspi初始化</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">spi_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;SPI_CLK = <span class="hljs-number">0</span>;SPI_SS = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  gpio 模拟spi,SPI模式0,CPOL=0，CPHA=0, MSB first，上升沿采样</span><span class="hljs-comment">  * @param  send_byte: 发送的一字节数据</span><span class="hljs-comment">  * @retvalread_dat:读取的一字节数据</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode0</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span>&#123;<span class="hljs-type">uint8_t</span> i, read_dat = <span class="hljs-number">0</span>;SPI_SS = <span class="hljs-number">0</span>; <span class="hljs-comment">//选择从设备</span>SPI_CLK = <span class="hljs-number">0</span>; <span class="hljs-comment">//空闲SCLK为0</span>Delay1us();<span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++ )&#123;<span class="hljs-comment">/* 接收数据 */</span>SPI_CLK = <span class="hljs-number">1</span>;   <span class="hljs-comment">//拉高时钟，上升沿采样</span>read_dat &lt;&lt;= <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span>(SPI_MISO) read_dat++; <span class="hljs-comment">//若从从机接收到高电平，数据自加一</span>Delay1us();<span class="hljs-comment">/* 发送数据 */</span>SPI_CLK = <span class="hljs-number">0</span>; <span class="hljs-keyword">if</span>(send_byte &amp; <span class="hljs-number">0x80</span>) <span class="hljs-comment">//下降沿输出数据</span>SPI_MOSI = <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span>                    SPI_MOSI = <span class="hljs-number">0</span>;  send_byte &lt;&lt;= <span class="hljs-number">1</span>;Delay1us();&#125;SPI_SS = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放从设备</span><span class="hljs-keyword">return</span> read_dat;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  gpio 模拟spi,SPI模式1,CPOL=0，CPHA=1, MSB first，下降沿采样</span><span class="hljs-comment">  * @param  send_byte: 发送的一字节数据</span><span class="hljs-comment">  * @retvalread_dat:读取的一字节数据</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode1</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span> &#123;<span class="hljs-type">uint8_t</span> i, read_dat = <span class="hljs-number">0</span>;SPI_SS = <span class="hljs-number">0</span>; <span class="hljs-comment">//选择从设备</span>    SPI_CLK = <span class="hljs-number">0</span>; <span class="hljs-comment">//空闲状态SCLK为0</span>Delay1us();<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)   &#123;<span class="hljs-comment">/* 发送数据 */</span>SPI_CLK = <span class="hljs-number">1</span>;     <span class="hljs-comment">//上升沿输出数据</span><span class="hljs-keyword">if</span>(send_byte &amp; <span class="hljs-number">0x80</span>)SPI_MOSI = <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span>      SPI_MOSI = <span class="hljs-number">0</span>;   send_byte &lt;&lt;= <span class="hljs-number">1</span>;    Delay1us();<span class="hljs-comment">/* 接收数据 */</span>SPI_CLK = <span class="hljs-number">0</span>;     <span class="hljs-comment">//拉低时钟，下降沿采样</span>read_dat &lt;&lt;= <span class="hljs-number">1</span>;     <span class="hljs-keyword">if</span>(SPI_MISO)read_dat++;     <span class="hljs-comment">//若从从机接收到高电平，数据自加一</span>Delay1us();&#125;SPI_SS = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放从设备</span><span class="hljs-keyword">return</span> (read_dat);     &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  gpio 模拟spi,SPI模式2,CPOL=1，CPHA=0, MSB first，下降沿采样</span><span class="hljs-comment">  * @param  send_byte: 发送的一字节数据</span><span class="hljs-comment">  * @retvalread_dat:读取的一字节数据</span><span class="hljs-comment">  */</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode2</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span> &#123;    <span class="hljs-type">uint8_t</span> i, read_dat = <span class="hljs-number">0</span>;SPI_SS = <span class="hljs-number">0</span>; <span class="hljs-comment">//选择从设备 </span>SPI_CLK = <span class="hljs-number">1</span>; <span class="hljs-comment">//空闲状态SCLK为1</span>Delay1us();<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)     &#123;<span class="hljs-comment">/* 接收数据 */</span>SPI_CLK = <span class="hljs-number">0</span>;     <span class="hljs-comment">//拉低时钟采样</span>read_dat &lt;&lt;= <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(SPI_MISO)read_dat++;     <span class="hljs-comment">//若从从机接收到高电平，数据自加一</span>Delay1us();<span class="hljs-comment">/* 发送数据 */</span>SPI_CLK = <span class="hljs-number">1</span>;     <span class="hljs-comment">//拉高时钟</span><span class="hljs-keyword">if</span>(send_byte &amp; <span class="hljs-number">0x80</span>) <span class="hljs-comment">//上升沿输出数据</span>SPI_MOSI = <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span>      SPI_MOSI = <span class="hljs-number">0</span>;   send_byte &lt;&lt;= <span class="hljs-number">1</span>;     Delay1us();&#125;SPI_SS = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放从设备</span><span class="hljs-keyword">return</span> (read_dat);     &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  gpio 模拟spi,SPI模式3,CPOL=1，CPHA=1, MSB first，上升沿采样</span><span class="hljs-comment">  * @param  send_byte: 发送的一字节数据</span><span class="hljs-comment">  * @retvalread_dat:读取的一字节数据</span><span class="hljs-comment">  */</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode3</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> send_byte)</span> &#123;<span class="hljs-type">uint8_t</span> i, read_dat = <span class="hljs-number">0</span>;SPI_SS = <span class="hljs-number">0</span>; <span class="hljs-comment">//选择从设备</span>SPI_CLK = <span class="hljs-number">1</span>;<span class="hljs-comment">//空闲状态SCLK为1</span>Delay1us();<span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++ )&#123;<span class="hljs-comment">/* 发送数据 */</span>SPI_CLK = <span class="hljs-number">0</span>;    <span class="hljs-comment">//下降沿输出数据</span><span class="hljs-keyword">if</span>(send_byte &amp; <span class="hljs-number">0x80</span>)SPI_MOSI = <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span>                    SPI_MOSI = <span class="hljs-number">0</span>;  send_byte &lt;&lt;= <span class="hljs-number">1</span>;Delay1us();<span class="hljs-comment">/* 接收数据 */</span>SPI_CLK = <span class="hljs-number">1</span>;   <span class="hljs-comment">//拉高时钟采样</span>read_dat &lt;&lt;= <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span>(SPI_MISO) read_dat++; <span class="hljs-comment">//若从从机接收到高电平，数据自加一</span>Delay1us();&#125;SPI_SS = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放从设备</span><span class="hljs-keyword">return</span> read_dat;&#125;</code></pre></div><p>传感器模块:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SSD3AS_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SSD3AS_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spi.h&quot;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><span class="hljs-class">&#123;</span>SENSOR_AP = <span class="hljs-number">0</span>,   <span class="hljs-comment">//绝压</span>SENSOR_GP,       <span class="hljs-comment">//表压</span>SENSOR_DP        <span class="hljs-comment">//差压</span>&#125;sensor_type_e;<span class="hljs-comment">/*******BASE值默认情况下改为0，根据上电初始状态显示数值确定具体值*********/</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_DP_BASE  35</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_GP_BASE  2.42</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_AP_BASE  0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_DP_MAX2500</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_DP_MIN-2500</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_GP_MAX1000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_GP_MIN0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_AP_MAX120000UL</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRESSURE_AP_MIN0</span> <span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ssd_get_value</span><span class="hljs-params">(<span class="hljs-type">float</span>* pressure, <span class="hljs-type">float</span>* temperature, sensor_type_e sensor_type)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">/************************* End of File ***************************/</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">* @file     ssd3as.c</span><span class="hljs-comment">* @author   Kayoung</span><span class="hljs-comment">* @version  V1.0</span><span class="hljs-comment">* @date     20201015</span><span class="hljs-comment">* @brief    压力传感器SPI通讯函数.</span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">* @attention </span><span class="hljs-comment">******************************************************************************</span><span class="hljs-comment">*/</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ssd3as.h&quot;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment">* @brief  读取传感器压力值和温度值。</span><span class="hljs-comment">* @param  pressure: 读取的压力值。</span><span class="hljs-comment">* @param  temperature: 读取的温度值。</span><span class="hljs-comment">* @param  sensor_type: 压力传感器类型</span><span class="hljs-comment">* @retval None</span><span class="hljs-comment">* @attention 传感器的温度读出来有问题，应该跟传感器有关。</span><span class="hljs-comment">*/</span><span class="hljs-type">void</span> <span class="hljs-title function_">ssd_get_value</span><span class="hljs-params">(<span class="hljs-type">float</span>* pressure, <span class="hljs-type">float</span>* temperature, sensor_type_e sensor_type)</span>&#123;<span class="hljs-type">uint16_t</span> buf[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;   <span class="hljs-comment">//用于存放压力AD值和温度AD值</span><span class="hljs-type">uint16_t</span> pressure_data = <span class="hljs-number">0</span>, temprature_data = <span class="hljs-number">0</span>;<span class="hljs-type">uint8_t</span> i;  <span class="hljs-comment">/* readout value from sensor by spi */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)  &#123;buf[i] = soft_spi_rw_mode0(<span class="hljs-number">0x00</span>);&#125;pressure_data = (buf[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-number">8</span> | buf[<span class="hljs-number">1</span>]) &amp; <span class="hljs-number">0x3fff</span>; <span class="hljs-comment">//14位压力值</span>temprature_data = (buf[<span class="hljs-number">2</span>]&lt;&lt;<span class="hljs-number">8</span> | buf[<span class="hljs-number">3</span>]) &amp; <span class="hljs-number">0x7ff</span>; <span class="hljs-comment">//11位温度值</span><span class="hljs-comment">/* 计算压力值 */</span><span class="hljs-comment">/* 1.A-type输出10%~90%    2.B-type输出5%~95%*/</span><span class="hljs-keyword">if</span>(pressure_data &gt; <span class="hljs-number">16383</span>*<span class="hljs-number">0.1</span> &amp;&amp; pressure_data &lt; <span class="hljs-number">16383</span>*<span class="hljs-number">0.9</span>) &#123;<span class="hljs-keyword">switch</span>(sensor_type)&#123;<span class="hljs-keyword">case</span>(SENSOR_AP):&#123;*pressure = (pressure_data - <span class="hljs-number">1638.3</span>) * (PRESSURE_AP_MAX - PRESSURE_AP_MIN) / <span class="hljs-number">13106.4</span> \+ PRESSURE_AP_MIN - PRESSURE_AP_BASE; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span>(SENSOR_GP):&#123;*pressure = (pressure_data - <span class="hljs-number">1638.3</span>) * (PRESSURE_GP_MAX - PRESSURE_GP_MIN) / <span class="hljs-number">13106.4</span> \+ PRESSURE_GP_MIN - PRESSURE_GP_BASE; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span>(SENSOR_DP):&#123;*pressure = (pressure_data - <span class="hljs-number">1638.3</span>) * (PRESSURE_DP_MAX - PRESSURE_DP_MIN) / <span class="hljs-number">13106.4</span> \+ PRESSURE_DP_MIN - PRESSURE_DP_BASE; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>;&#125;&#125;  <span class="hljs-comment">/* 计算温度值 */</span>*temperature = temprature_data * <span class="hljs-number">200.0</span> / <span class="hljs-number">2047.0</span> - <span class="hljs-number">50.0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ssd3as.h&quot;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">Delay500ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">22</span>;j = <span class="hljs-number">3</span>;k = <span class="hljs-number">227</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-type">float</span> preesure = <span class="hljs-number">0.0f</span>, temperature = <span class="hljs-number">0.0f</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;uart1_init();spi_init();<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//ssd_get_value(&amp;preesure, &amp;temperature, SENSOR_AP);</span><span class="hljs-comment">//printf(&quot;pressure: %.2fkPa \r\n&quot;, preesure/1000.0);</span>ssd_get_value(&amp;preesure, &amp;temperature, SENSOR_GP);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pressure: %.2fPa \r\n&quot;</span>, preesure);Delay500ms();&#125;&#125;</code></pre></div><p>连接大气压传感器效果如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2023-05-14_184805.png" alt="" /><figcaption>2023-05-14_184805</figcaption></figure><p>连接表压传感器，改变压力，效果如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/2023-05-14_185549.png" alt="" /><figcaption>2023-05-14_185549</figcaption></figure><p>工程文件：<a href="https://gitee.com/kayoungzhang/my_codehub/raw/master/pressure/pressureTest.zip">pressure</a></p><h3 id="参考链接">参考链接</h3><p><a href="http://www.sensedz.com/product/html/?141.html">SSD系列数字压力传感器</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sensor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ads1120温度传感器的开发设计</title>
    <link href="/2023/05/09/ads1120%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/09/ads1120%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>前面介绍了ds18b20单总线测量温度，一般应用在环境温度的测量，但开发过程中，针对高低温，宽范围的温度测量，此时用到最多的传感器一般是热电阻(RTDs)和热电偶，如PT100系列热电阻，K-type热电偶。在电路上通过放大器将测量的小信号放大输出，就可以得到测量的温度数据，当然比较简单的做法是使用集成芯片进行处理，像MAX6675，ADS1120，ADS1220等等，之前项目我选用的是ads1120芯片，下面详细介绍一下它的具体情况。</p><h3 id="芯片特性">芯片特性</h3><ul><li>电压： 2.3 V ~ 5.5 V</li><li>SPI接口 (<strong>Mode 1： CPOL=0，CPHA=1</strong>）</li><li>PGA: 1 V/V ~ 128 V/V</li><li>采样率: 最大 2kSPS</li><li>输入：4个单端输入口或两个差分输入口</li><li>16 位无噪声分辨率（20SPS 时）</li><li>内部基准电压： 2.048-V，漂移：5 ppm/°C</li><li>功耗：1.4mW</li><li>采用单周期稳定数字滤波器，在 20SPS 时实现 50Hz 和 60Hz 谐波抑制</li><li>双匹配可编程电流源：50μA 至 1.5mA</li></ul><h3 id="功能框图">功能框图</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511191841945.png" alt="image-20230511191841945"  /></p><h3 id="pga共模电压要求">PGA共模电压要求</h3><p>为了始终处于 PGA 的线性工作范围内，输入信号必须满足以下要求。可参考datasheet具体实例。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511202038516.png" alt="" /><figcaption>image-20230511202038516</figcaption></figure><h3 id="电压基准">电压基准</h3><p>该器件集成了 <strong>2.048V</strong> 低漂移电压基准。提供两对差分基准输入（REFP0/REFN0 和 REFP1/REFN1）。 基准源通过配置寄存器的两位 (VREF[1:0]) 进行选择。默认选择内部基准。上电后、退出掉电模式或由外部基准源切换至内部基准后，内部基准电压在 25µs 内即可完全稳定。</p><p>差分基准输入支持自由选择共模基准电压。REFP0 和 REFN0 为专用基准输入，而 REFP1 和 REFN1 分别与输入 AIN0 和 AIN3 共享。所有基准输入均在内部进行缓冲，以提高输入阻抗。因此，使用外部基准时，通常无需额外使用基准缓冲器。</p><p>在多数情况下，转换结果与基准源稳定性成正比。转换结果将反映电压基准的所有噪声和漂移。</p><h3 id="激励电流源">激励电流源</h3><p>该器件为 RTD 应用提供两个匹配的可编程激励电流源 (IDAC)。使用配置寄存器的相应位 (IDAC[2:0]) 可通过编程方式将电流源输出电流设定为 10μA、50μA、100μA、250μA、500μA、1000μA 或 1500μA。每个电流源均可与所有模拟输入 (AINx) 及所有专用基准输入（REFP0 和 REFN0）相连。两电流源还可与同一引脚相连。IDAC 的路由通过配置寄存器的位（I1MUX[2:0]，I2MUX[2:0]）进行配置。</p><h3 id="电路设计">电路设计</h3><p>参考芯片datasheet的应用电路，我采用如下兼容设计，可自由切换外接热电偶和3线制PT100。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511194947821.png" alt="" /><figcaption>image-20230511194947821</figcaption></figure><h3 id="pcb设计">PCB设计</h3><p>主要是模拟和数字地的隔离，电源引脚必须通过低 ESR 陶瓷电容旁路至接地。旁路电容的最佳位置应尽可能靠近电源引脚。采用差分连接的模拟输入之间必须放置差分电容。适用于差分测量的最佳输入组合包括：AIN0、AIN1 和 AIN2、AIN3，必须选择高品质差分电容。C0G (NPO) 电容属性稳定且具备低噪声特性，这是最适用的陶瓷贴片电容。对热电偶输入连接周围的覆铜区域进行热隔离，以构建热性能稳定的冷端。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511203153776.png" alt="image-20230511203153776" style="zoom: 80%;" /></p><h3 id="温度传感器">温度传感器</h3><p>ADS1120 集成了一个精密温度传感器。通过将配置寄存器的 TS 位置 1 可使能温度传感器模式。。温度数据以 <strong>14</strong> 位结果呈现，与 24 位转换结果左对齐。负数以二进制补码形式表示。数字代码转换温度公式：如果 MSB 为 0，将十进制代码乘以 0.03125°C 即可获得结果。如果 MSB = 1，则将结果减 1 后对所有位取补码。之后将结果乘以 –0.03125°C。</p><p>示例：器件回读 0960h: 0960h 的 MSB = 0。</p><p>0960h · 0.03125°C = 2400 · 0.03125°C = 75°C</p><p>示例：器件回读 3CE0h: 3CE0h 的 MSB = 1。</p><p>减 1 后对结果取补码：3CE0h → 0320h （C320h &amp; 3FFFh）</p><p>0320h · (–0.03125°C) = 800 · (–0.03125°C) = –25°C</p><h3 id="数据格式">数据格式</h3><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511203020170.png" alt="" /><figcaption>image-20230511203020170</figcaption></figure><h3 id="指令">指令</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511192136721.png" alt="image-20230511192136721"  /></p><h3 id="寄存器">寄存器</h3><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511192406483.png" alt="" /><figcaption>image-20230511192406483</figcaption></figure><h3 id="程序实现">程序实现</h3><p>程序中只实现了基本的温度测量功能，可根据需求添加其他功能，另外，芯片的配置函数根据电路的不同也需要进行相应修改。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ADS1120_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-comment">/* spi 引脚定义 */</span>sbit ADS1120_RDY = P1^<span class="hljs-number">1</span>;sbit ADS1120_CS  = P1^<span class="hljs-number">4</span>;sbit ADS1120_SDI = P1^<span class="hljs-number">5</span>;sbit ADS1120_SDO = P1^<span class="hljs-number">6</span>;sbit ADS1120_CLK = P1^<span class="hljs-number">7</span>;<span class="hljs-comment">/* 传感器类型 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><span class="hljs-class">&#123;</span>PT100 = <span class="hljs-number">0</span>, <span class="hljs-comment">//pt100</span>K_TYPE,   <span class="hljs-comment">//k-type</span>INTER     <span class="hljs-comment">//internal temperature sensor</span>&#125;sensor_e;<span class="hljs-comment">/********************ADS1120 Definitions**********************/</span><span class="hljs-comment">/* ADS1120 Command Definitions */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_RESET         0x06</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_START         0x08</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_POWERDOWN     0x02</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_RDATA         0x10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_RREG          0x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_WREG          0x40</span><span class="hljs-comment">/* ADS1120 Register Definitions */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_0_REGISTER    0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_1_REGISTER    0x01</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_2_REGISTER    0x02</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_3_REGISTER    0x03</span><span class="hljs-comment">/* ADS1120 Register 0 Definition */</span><span class="hljs-comment">/** ---------------------------------------------------------------</span><span class="hljs-comment">  * | Bit7 | Bit6 | Bit5 | Bit4 | Bit3 | Bit2 | Bit1 |    Bit0    |</span><span class="hljs-comment">  * ---------------------------------------------------------------</span><span class="hljs-comment">  * |         MUX[3:0]          |      GAIN[2:0]     | PGA_BYPASS |</span><span class="hljs-comment">  * ---------------------------------------------------------------</span><span class="hljs-comment">  */</span><span class="hljs-comment">/* Define MUX */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_MUX_0_1   0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_MUX_3_2   0x70</span><span class="hljs-comment">/* Define GAIN */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_1      0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_2      0x02</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_4      0x04</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_8      0x06</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_16     0x08</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_32     0x0a</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_64     0x0c</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_GAIN_128    0x0e</span><span class="hljs-comment">/* Define PGA_BYPASS */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_PGA_ENABLE  0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_PGA_DISABLE 0x01</span><span class="hljs-comment">/* ADS1120 Register 1 Definition */</span><span class="hljs-comment">/** ---------------------------------------------------------</span><span class="hljs-comment">  * | Bit7 | Bit6 | Bit5 | Bit4 | Bit3 | Bit2 | Bit1 | Bit0 |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  * |       DR[2:0]      |  MODE[1:0]  |  CM  |  TS  |  BCS |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  */</span><span class="hljs-comment">/* Define DR (data rate) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_20       0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_45       0x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_90       0x40</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_175      0x60</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_330      0x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_600      0xa0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DR_1000     0xc0</span><span class="hljs-comment">/* Define MODE of Operation */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_MODE_NORMAL 0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_MODE_DUTY   0x08</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_MODE_TURBO  0x10</span><span class="hljs-comment">/* Define CM (conversion mode) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_SS          0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_CC          0x04</span><span class="hljs-comment">/* Define TS (internal temperature sensor) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_TEMP_SENSOR 0x02</span><span class="hljs-comment">/* Define BCS (burnout current source) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_BCS         0x01</span><span class="hljs-comment">/* ADS1120 Register 2 Definition */</span><span class="hljs-comment">/** ---------------------------------------------------------</span><span class="hljs-comment">  * | Bit7 | Bit6 | Bit5 | Bit4 | Bit3 | Bit2 | Bit1 | Bit0 |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  * |  VREF[1:0]  |  50/60[1:0] | PSW  |      IDAC[2:0]     |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  */</span><span class="hljs-comment">/* Define VREF */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_VREF_INT0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_VREF_00x40</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_VREF_10x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_VREF_SUPPLY0xc0</span><span class="hljs-comment">/* Define 50/60 (filter response) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_REJECT_OFF0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_REJECT_BOTH0x10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_REJECT_500x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_REJECT_600x30</span><span class="hljs-comment">/* Define PSW (low side power switch) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_PSW_AUTO0x08</span><span class="hljs-comment">/* Define IDAC (IDAC current) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_OFF       0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_50        0x02</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_100       0x03</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_250       0x04</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_500       0x05</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_1000      0x06</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC_1500      0x07</span><span class="hljs-comment">/* ADS1120 Register 3 Definition */</span><span class="hljs-comment">/** ---------------------------------------------------------</span><span class="hljs-comment">  * | Bit7 | Bit6 | Bit5 | Bit4 | Bit3 | Bit2 | Bit1  | Bit0 |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  * |      I1MUX[2:0]    |      I2MUX[2:0]    | DRDYM |  0   |</span><span class="hljs-comment">  * ---------------------------------------------------------</span><span class="hljs-comment">  */</span><span class="hljs-comment">/* Define I1MUX (IDAC1 routing configuration) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_OFF     0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_AIN0    0x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_AIN1    0x40</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_AIN2    0x60</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_AIN3    0x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_REFP0   0xa0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC1_REFN0   0xc0</span><span class="hljs-comment">/* Define I2MUX (IDAC2 routing configuration) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_OFF     0x00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_AIN0    0x04</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_AIN1    0x08</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_AIN2    0x0c</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_AIN3    0x10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_REFP0   0x14</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_IDAC2_REFN0   0x18</span><span class="hljs-comment">/* define DRDYM (DRDY mode) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADS1120_DRDY_MODE     0x02</span><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> cold_compensation;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">spi_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_confiuration</span><span class="hljs-params">(sensor_e sensor_type)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_get_average_temp</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, sensor_e sensor_type)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_thermocouple_compensation</span><span class="hljs-params">(<span class="hljs-type">int</span>* voltage)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  * @file    ads1120.c </span><span class="hljs-comment">  * @version V1.0.0</span><span class="hljs-comment">  * @date    2023.03.08</span><span class="hljs-comment">  * @author  Kayoung</span><span class="hljs-comment">  * @brief   PT100或K型热电偶SPI传输温度</span><span class="hljs-comment">  * @details  </span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  * @attention </span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ads1120.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;intrins.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-type">int</span> cold_compensation = <span class="hljs-number">0</span>;<span class="hljs-comment">//热电偶冷端补偿值</span><span class="hljs-comment">/* 函数申明 */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode1</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byte)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_wr_reg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, <span class="hljs-type">uint8_t</span> num, <span class="hljs-type">uint8_t</span>* p_data)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">Delay1us</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;_nop_();&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Delay100ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">5</span>;j = <span class="hljs-number">52</span>;k = <span class="hljs-number">195</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  MCU SPI initial</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">spi_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;ADS1120_RDY = <span class="hljs-number">1</span>;ADS1120_CS  = <span class="hljs-number">1</span>;ADS1120_SDI = <span class="hljs-number">0</span>;ADS1120_SDO = <span class="hljs-number">0</span>;ADS1120_CLK = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120 initial config</span><span class="hljs-comment">  * @param  sensor_type: 传感器类型</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_confiuration</span><span class="hljs-params">(sensor_e sensor_type)</span>&#123;<span class="hljs-comment">/* ads1120 register configuration */</span><span class="hljs-type">uint8_t</span> config[<span class="hljs-number">4</span>] =&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">switch</span> (sensor_type)&#123;<span class="hljs-keyword">case</span> PT100:&#123;<span class="hljs-comment">/* PT100 configuration */</span>config[<span class="hljs-number">0</span>] = ADS1120_MUX_0_1 | ADS1120_GAIN_8; <span class="hljs-comment">/* register 0 configuration */</span>config[<span class="hljs-number">1</span>] = ADS1120_DR_20 | ADS1120_CC; <span class="hljs-comment">/* register 1 configuration */</span>config[<span class="hljs-number">2</span>] = ADS1120_VREF_0 | ADS1120_REJECT_BOTH | ADS1120_IDAC_500; <span class="hljs-comment">/* register 2 configuration */</span>config[<span class="hljs-number">3</span>] = ADS1120_IDAC1_AIN2 | ADS1120_IDAC2_AIN3; <span class="hljs-comment">/* register 3 configuration */</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> K_TYPE:&#123;<span class="hljs-comment">/* K-type Thermocouple configuration */</span>config[<span class="hljs-number">0</span>] = ADS1120_MUX_0_1 | ADS1120_GAIN_32; <span class="hljs-comment">/* register 0 configuration */</span>config[<span class="hljs-number">1</span>] = ADS1120_DR_20 | ADS1120_CC; <span class="hljs-comment">/* register 1 configuration */</span>config[<span class="hljs-number">2</span>] = ADS1120_VREF_INT | ADS1120_REJECT_BOTH | ADS1120_IDAC_OFF; <span class="hljs-comment">/* register 2 configuration */</span>config[<span class="hljs-number">3</span>] = ADS1120_IDAC1_OFF | ADS1120_IDAC2_OFF; <span class="hljs-comment">/* register 3 configuration */</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> INTER:&#123;<span class="hljs-comment">/* ads1120 internal temperature sensor configuration */</span>config[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 0 configuration */</span>config[<span class="hljs-number">1</span>] = ADS1120_CC | ADS1120_TEMP_SENSOR; <span class="hljs-comment">/* register 1 configuration */</span>config[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 2 configuration */</span>config[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 3 configuration */</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>;&#125;ADS1120_CS = <span class="hljs-number">0</span>;soft_spi_rw_mode1(ADS1120_RESET); <span class="hljs-comment">// reset ads1120</span>Delay100ms();ads1120_wr_reg(ADS1120_0_REGISTER, <span class="hljs-number">0x04</span>, config); <span class="hljs-comment">//config ads1120 register</span>Delay100ms();soft_spi_rw_mode1(ADS1120_START); <span class="hljs-comment">//start conversation</span>ADS1120_CS = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  gpio 模拟spi，只支持SPI模式1,CPOL=0，CPHA=1, MSB first下降沿采样</span><span class="hljs-comment">  * @param  byte: 发送的一字节数据</span><span class="hljs-comment">  * @paramread_dat:读取的一字节数据</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">soft_spi_rw_mode1</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byte)</span> &#123;<span class="hljs-type">uint8_t</span> i,read_dat=<span class="hljs-number">0</span>; <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)     <span class="hljs-comment">// 循环8次</span>&#123;<span class="hljs-comment">/* 发送数据 */</span>ADS1120_CLK = <span class="hljs-number">1</span>;     <span class="hljs-comment">//拉高时钟</span><span class="hljs-keyword">if</span>(byte &amp; <span class="hljs-number">0x80</span>)ADS1120_SDI = <span class="hljs-number">1</span>;  <span class="hljs-comment">//若最到位为高，则输出高</span><span class="hljs-keyword">else</span>      ADS1120_SDI = <span class="hljs-number">0</span>;   <span class="hljs-comment">//若最到位为低，则输出低</span>byte &lt;&lt;= <span class="hljs-number">1</span>;     <span class="hljs-comment">// 低一位移位到最高位</span>Delay1us();<span class="hljs-comment">/* 接收数据 */</span>ADS1120_CLK = <span class="hljs-number">0</span>;     <span class="hljs-comment">//拉低时钟</span>read_dat &lt;&lt;= <span class="hljs-number">1</span>;     <span class="hljs-comment">//数据左移</span><span class="hljs-keyword">if</span>(ADS1120_SDO)read_dat++;     <span class="hljs-comment">//若从从机接收到高电平，数据自加一</span>Delay1us();&#125;<span class="hljs-keyword">return</span> (read_dat);     <span class="hljs-comment">//返回数据</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120读寄存器</span><span class="hljs-comment">  * @param  addr：寄存器开始地址</span><span class="hljs-comment">  *@paramnum：读取的字节数</span><span class="hljs-comment">  *@paramp_data：读取的数据指针</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_rd_reg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, <span class="hljs-type">uint8_t</span> num, <span class="hljs-type">uint8_t</span>* p_data)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">/* send the command byte */</span>soft_spi_rw_mode1(ADS1120_RREG | (((addr &lt;&lt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x0c</span>) |((num - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x03</span>)));  <span class="hljs-comment">/* get the register content */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;*p_data++ = soft_spi_rw_mode1(<span class="hljs-number">0x00</span>);&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120写寄存器</span><span class="hljs-comment">  * @param  addr：寄存器开始地址</span><span class="hljs-comment">  *@paramnum：写入的字节数</span><span class="hljs-comment">  *@paramp_data：写入数据的指针</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_wr_reg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> addr, <span class="hljs-type">uint8_t</span> num, <span class="hljs-type">uint8_t</span>* p_data)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">/* send the command byte */</span>soft_spi_rw_mode1(ADS1120_WREG | (((addr &lt;&lt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x0c</span>) |((num - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x03</span>)));  <span class="hljs-comment">/* send the register content */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;soft_spi_rw_mode1(*p_data++);&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120读取转换数据</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval result：读取到的两字节数据</span><span class="hljs-comment">  */</span><span class="hljs-type">long</span> <span class="hljs-title function_">ads1120_rd_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;  <span class="hljs-comment">/* assert CS to start transfer */</span>ADS1120_CS = <span class="hljs-number">0</span>;Delay1us();  <span class="hljs-comment">/* send the command byte */</span>  soft_spi_rw_mode1(ADS1120_RDATA);<span class="hljs-comment">//read conversation data</span><span class="hljs-comment">//while(ADS1120_RDY); //等待数据到来</span>result = soft_spi_rw_mode1(<span class="hljs-number">0x00</span>);result = (result &lt;&lt; <span class="hljs-number">8</span>) | soft_spi_rw_mode1(<span class="hljs-number">0x00</span>);<span class="hljs-comment">/* sign extend data */</span>  <span class="hljs-keyword">if</span> (result &amp; <span class="hljs-number">0x8000</span>)result |= <span class="hljs-number">0xffff0000</span>;<span class="hljs-comment">//result = (~result) &amp; 0x7fff;</span><span class="hljs-comment">//uart1_send_byte(result &gt;&gt; 8);</span><span class="hljs-comment">//uart1_send_byte(result);</span>Delay1us();ADS1120_CS = <span class="hljs-number">1</span>;  <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120获取温度</span><span class="hljs-comment">  * @param  temperature：获取的温度值</span><span class="hljs-comment">  * @param  sensor_type: 传感器类型</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_get_temperature</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, sensor_e sensor_type)</span>&#123;<span class="hljs-type">long</span> value = <span class="hljs-number">0</span>;<span class="hljs-type">float</span> voltage = <span class="hljs-number">0.0f</span>;value = ads1120_rd_data();<span class="hljs-keyword">switch</span> (sensor_type)&#123;<span class="hljs-keyword">case</span> PT100:&#123;<span class="hljs-comment">/* PT100 */</span>voltage = (<span class="hljs-type">float</span>)(value * <span class="hljs-number">1.65f</span> / <span class="hljs-number">8</span> / <span class="hljs-number">32768</span>);*temperature = (voltage * <span class="hljs-number">2000</span> - <span class="hljs-number">100</span>)/<span class="hljs-number">0.385f</span>;<span class="hljs-comment">//IDAC_500uA, PT100每升高1℃，阻值增加0.385 ohm</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> K_TYPE:&#123;<span class="hljs-comment">/* K-type thermocouple */</span><span class="hljs-comment">//uart1_send_byte(calibration_value &gt;&gt; 8);</span><span class="hljs-comment">//uart1_send_byte(calibration_value);</span>voltage = (<span class="hljs-type">float</span>)(value * <span class="hljs-number">62.5</span> / <span class="hljs-number">32</span>  + cold_compensation); <span class="hljs-comment">//voltage=value*2.048f/32/32768*1000000;转换为uV</span>*temperature = (<span class="hljs-type">float</span>)(voltage / <span class="hljs-number">41.0</span>);<span class="hljs-comment">//K-type赛贝克系数：41℃/uV</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> INTER:&#123;<span class="hljs-comment">/* ads1120 internal temperature sensor 14bit left-data */</span>value = (value &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x3fff</span>;<span class="hljs-keyword">if</span>(value &amp; <span class="hljs-number">0x2000</span>) <span class="hljs-comment">//negative temp</span>&#123;value = (~(value - <span class="hljs-number">1</span>))&amp;<span class="hljs-number">0x1fff</span>;*temperature =(<span class="hljs-type">float</span>)(value * (<span class="hljs-number">-0.03125f</span>));&#125;<span class="hljs-keyword">else</span>&#123;*temperature =(<span class="hljs-type">float</span>)(value * <span class="hljs-number">0.03125f</span>);<span class="hljs-comment">//postive temp</span>&#125;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">default</span>: <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120平均温度</span><span class="hljs-comment">  * @param  temperature：温度平均值</span><span class="hljs-comment">  * @param  sensor_type: 传感器类型</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_get_average_temp</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, sensor_e sensor_type)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-type">float</span> sum = <span class="hljs-number">0.0</span>; <span class="hljs-comment">//温度和</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)&#123;ads1120_get_temperature(temperature, sensor_type);sum += *temperature;&#125;*temperature = (<span class="hljs-type">float</span>)(sum / <span class="hljs-number">8.0</span>);sum = <span class="hljs-number">0.0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  ads1120 K型热电偶冷端补偿</span><span class="hljs-comment">  * @param  voltage：获取冷端电压值的指针（单位：uV）</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ads1120_thermocouple_compensation</span><span class="hljs-params">(<span class="hljs-type">int</span>* voltage)</span>&#123;<span class="hljs-comment">/* ads1120 register configuration */</span><span class="hljs-type">uint8_t</span> config[<span class="hljs-number">4</span>] =&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<span class="hljs-type">float</span> temp = <span class="hljs-number">0</span>;<span class="hljs-comment">/* ads1120 internal temperature sensor configuration */</span>config[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 0 configuration */</span>config[<span class="hljs-number">1</span>] = ADS1120_TEMP_SENSOR; <span class="hljs-comment">/* register 1 configuration */</span>config[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 2 configuration */</span>config[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* register 3 configuration */</span>ADS1120_CS = <span class="hljs-number">0</span>;soft_spi_rw_mode1(ADS1120_RESET); <span class="hljs-comment">// reset ads1120</span>Delay100ms();ads1120_wr_reg(ADS1120_0_REGISTER, <span class="hljs-number">0x04</span>, config); <span class="hljs-comment">//config ads1120 register</span>Delay100ms();soft_spi_rw_mode1(ADS1120_START); <span class="hljs-comment">//start conversation</span><span class="hljs-comment">//  soft_spi_rw_mode1(ADS1120_RDATA);//read conversation data</span><span class="hljs-keyword">while</span>(ADS1120_RDY); <span class="hljs-comment">//等待数据到来</span>result = soft_spi_rw_mode1(<span class="hljs-number">0x00</span>);result = (result &lt;&lt; <span class="hljs-number">8</span>) | soft_spi_rw_mode1(<span class="hljs-number">0x00</span>);ADS1120_CS = <span class="hljs-number">1</span>;result = (result &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x3fff</span>; <span class="hljs-comment">//14bit postive temp</span><span class="hljs-keyword">if</span>(result &amp; <span class="hljs-number">0x2000</span>) <span class="hljs-comment">//negative temp</span>&#123;result = (~(result - <span class="hljs-number">1</span>))&amp;<span class="hljs-number">0x1fff</span>;temp =(<span class="hljs-type">float</span>)(result * (<span class="hljs-number">-0.03125f</span>));&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">//postive temp</span>&#123;temp =(<span class="hljs-type">float</span>)(result * <span class="hljs-number">0.03125f</span>);&#125;<span class="hljs-comment">/* 根据表格数据得出电压与温度关系式：https://srdata.nist.gov/its90/main/its90_main_page.html */</span>*voltage = (<span class="hljs-type">int</span>)(<span class="hljs-number">40.309</span> * temp - <span class="hljs-number">5.3031</span>); <span class="hljs-comment">//NIST- its90 温度与电压关系式（单位：uV）</span><span class="hljs-keyword">return</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ads1120.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-type">float</span> temperature = <span class="hljs-number">0.0f</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">gpio_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-comment">//M1  M0</span><span class="hljs-comment">//0   0     准双向口</span><span class="hljs-comment">//0   1     推挽输出</span><span class="hljs-comment">//1   0     高阻输入</span><span class="hljs-comment">//1   1     开漏</span><span class="hljs-comment">/* SPI引脚设置 */</span>P1M1 = <span class="hljs-number">0x42</span>;<span class="hljs-comment">//M1 0100 0010</span>P1M0 = <span class="hljs-number">0xb0</span>;<span class="hljs-comment">//M0 1011 0000</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">Delay1000ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">43</span>;j = <span class="hljs-number">6</span>;k = <span class="hljs-number">203</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;uart1_init();gpio_init();    spi_init();<span class="hljs-comment">//ads1120_confiuration(INTER); //芯片内部温度</span>ads1120_confiuration(PT100); <span class="hljs-comment">//PT100</span><span class="hljs-comment">//ads1120_confiuration(K_TYPE); //K-type热电偶</span><span class="hljs-comment">//ads1120_thermocouple_compensation(&amp;cold_compensation);//热电偶冷端补偿</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//ads1120_get_average_temp(&amp;temperature, INTER);</span>ads1120_get_average_temp(&amp;temperature, PT100);<span class="hljs-comment">//ads1120_get_average_temp(&amp;temperature, K_TYPE);</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;temperature is %.3f℃\r\n&quot;</span>, temperature);Delay1000ms();&#125;&#125;</code></pre></div><p>效果：</p><p>内部温度传感器测量效果：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511200919371.png" alt="" /><figcaption>image-20230511200919371</figcaption></figure><p>外接PT100传感器测量的温度效果：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230511201148501.png" alt="" /><figcaption>image-20230511201148501</figcaption></figure><p>工程代码：https://gitee.com/kayoungzhang/my_codehub/raw/master/ads1120/ads1120.zip</p><h3 id="参考链接">参考链接</h3><p><a href="https://www.ti.com/product/ADS1120?keyMatch=ADS1120&amp;tisearch=search-everything&amp;usecase=GPN#hardware-development">ads1120 datasheet</a></p><p>https://www.ti.com/lit/zip/sbac227</p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RTD</tag>
      
      <tag>热电偶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ds1302实时时钟芯片的开发</title>
    <link href="/2023/05/05/ds1302%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E8%8A%AF%E7%89%87%E7%9A%84%E5%BC%80%E5%8F%91/"/>
    <url>/2023/05/05/ds1302%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E8%8A%AF%E7%89%87%E7%9A%84%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>DS1302芯片作为实时时钟使用，在开发过程中，使用比较频繁，时钟芯片PCF8563也有使用，这里主要写写DS1302这款芯片的开发设计。</p><h3 id="特点">特点</h3><ul><li>电压：2.0V ~ 5.5V</li><li>提供年、月、日、时、分、秒、星期等信息</li><li>31 字节数据静态RAM</li><li>通过简单的串行口与单片机进行通信</li></ul><h3 id="应用电路">应用电路</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230505182519782.png" alt="image-20230505182519782" style="zoom:67%;" /></p><table><thead><tr class="header"><th>引脚</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>Vcc2</td><td>主电源</td></tr><tr class="even"><td>Vcc1</td><td>备用电源，如纽扣电池CR2032</td></tr><tr class="odd"><td>X1、X2</td><td>外接32.768khz晶振</td></tr><tr class="even"><td>CE</td><td>控制信号</td></tr><tr class="odd"><td>I/O</td><td>串行接口数据线</td></tr><tr class="even"><td>SCLK</td><td>串行接口时钟线</td></tr></tbody></table><h3 id="指令寄存器">指令寄存器</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230505184339517.png" alt="image-20230505184339517" style="zoom: 67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230505185956240.png" alt="image-20230505185956240" style="zoom:67%;" /></p><h2 id="bcd码">BCD码</h2><p>BCD码（Binary Coded Decimal‎），用4位二进制数来表示1位十进制数，所以4位二进制表示的数字最大到 <strong>9</strong> 。例：0001 0011表示13，1000 0101表示85，0001 1010不合法。在十六进制中的体现：0x13表示13，0x85表示85，0x1A不合法</p><p><code>BCD码转十进制：DEC=BCD/16*10+BCD%16; （2位BCD）</code></p><p><code>十进制转BCD码：BCD=DEC/10*16+DEC%10; （2位BCD）</code></p><p>DS1302写数据时需要将十进制数据转为BCD码的形式，读数据时需要将BCD码转为十进制数据形式。</p><h2 id="通信时序">通信时序</h2><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230505194024970.png" alt="image-20230505194024970" style="zoom:67%;" /></p><p><strong>注意：</strong> 读时序时，发送完命令字的MSB位后，马上就读出数据，所以每个脉冲提前半拍。</p><h3 id="程序实现">程序实现</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DS1302_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DS1302_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-comment">/* pin definition */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DS1302_IO  P34</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DS1302_SCLKP36</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DS1302_CE  P35</span><span class="hljs-comment">/* register of rtc read address command */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_SECOND_READ   0x81</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_MINUTE_READ   0x83</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_HOUR_READ     0x85</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_DATE_READ     0x87</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_MONTH_READ    0x89</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_DAY_READ      0x8b  <span class="hljs-comment">//week</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_YEAR_READ     0x8d</span><span class="hljs-comment">/* register of rtc write address command */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_SECOND_WRITE   0x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_MINUTE_WRITE   0x82</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_HOUR_WRITE     0x84</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_DATE_WRITE     0x86</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_MONTH_WRITE    0x88</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_DAY_WRITE      0x8a</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_YEAR_WRITE     0x8c</span><span class="hljs-comment">/* write protect */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_WR_PROTECT_READ    0x8f</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REG_WR_PROTECT_WRITE   0x8e</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITE_PROTECT_ENABLE   0x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> WRITE_PROTECT_DISABLE  0x00</span><span class="hljs-comment">/* 年 月 日 时 分 秒 周 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> year; <span class="hljs-comment">//0~99</span><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> month;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> date;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hour;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> minute;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> second;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> day;&#125;<span class="hljs-type">tm_t</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_read_time</span><span class="hljs-params">(<span class="hljs-type">tm_t</span>* p_tm)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_write_time</span><span class="hljs-params">(<span class="hljs-type">tm_t</span>* p_tm)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ************************************************</span><span class="hljs-comment">  * @file     ds1302.c</span><span class="hljs-comment">  * @author  Kayoung</span><span class="hljs-comment">  * @version  V1.0</span><span class="hljs-comment">  * @date     20220327</span><span class="hljs-comment">  * @brief    ds1302时钟driver</span><span class="hljs-comment">  **********************************************</span><span class="hljs-comment">  */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ds1302.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-comment">/* BCD转十进制DEC： DEC = BCD/16*10 + BCD%16;(2位BCD)</span><span class="hljs-comment">   十进制DEC转BCD： BCD = DEC/10*16 + DEC%10;(2位BCD)</span><span class="hljs-comment">*/</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief   ds1302初始化</span><span class="hljs-comment">  * @param   None</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;DS1302_SCLK = <span class="hljs-number">0</span>;DS1302_CE = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief 向ds1302写入一个字节</span><span class="hljs-comment">  * @param command: 命令字</span><span class="hljs-comment">  * @param   wr_data: 待写入的字节</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_wrbyte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> command, <span class="hljs-type">uint8_t</span> wr_data)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//循环变量</span>DS1302_CE = <span class="hljs-number">1</span>;<span class="hljs-comment">/* 先写入command */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<span class="hljs-comment">//LSB to MSB</span>&#123;DS1302_IO = command &amp; (<span class="hljs-number">0x01</span>&lt;&lt;i);DS1302_SCLK = <span class="hljs-number">1</span>; <span class="hljs-comment">//51单片机速率慢，此处不需要延时，上升沿写入命令</span>DS1302_SCLK = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 再写入data */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<span class="hljs-comment">//LSB to MSB</span>&#123;DS1302_IO = wr_data &amp; (<span class="hljs-number">0x01</span>&lt;&lt;i);DS1302_SCLK = <span class="hljs-number">1</span>; <span class="hljs-comment">//51单片机速率慢，此处不需要延时,上升沿写入数据</span>DS1302_SCLK = <span class="hljs-number">0</span>;&#125;DS1302_CE = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief ds1302读出一个字节</span><span class="hljs-comment">  * @param command: 命令字</span><span class="hljs-comment">  * @retval  recv_byte: 接收的字节</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ds1302_rdbyte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> command)</span>&#123;<span class="hljs-type">uint8_t</span> recv_byte = <span class="hljs-number">0</span>;<span class="hljs-type">uint8_t</span> i;<span class="hljs-comment">//循环变量</span>DS1302_CE = <span class="hljs-number">1</span>;<span class="hljs-comment">/* 先发送命令 */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<span class="hljs-comment">//LSB to MSB</span>&#123;DS1302_IO = command &amp; (<span class="hljs-number">0x01</span> &lt;&lt; i);DS1302_SCLK = <span class="hljs-number">0</span>;DS1302_SCLK = <span class="hljs-number">1</span>;<span class="hljs-comment">//上升沿写入命令</span>&#125;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++)<span class="hljs-comment">//LSB to MSB</span>&#123;DS1302_SCLK = <span class="hljs-number">1</span>;<span class="hljs-comment">//下降沿读出数据</span>DS1302_SCLK = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(DS1302_IO)&#123;recv_byte |= (<span class="hljs-number">0x01</span> &lt;&lt; i);&#125;&#125;DS1302_CE = <span class="hljs-number">0</span>;DS1302_IO = <span class="hljs-number">0</span>;  <span class="hljs-comment">//解决读取时间是ff的问题</span><span class="hljs-keyword">return</span> recv_byte;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief ds1302设置时间</span><span class="hljs-comment">  * @param p_tm: 时间结构体指针</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_write_time</span><span class="hljs-params">(<span class="hljs-type">tm_t</span>* p_tm)</span>&#123;ds1302_wrbyte(REG_WR_PROTECT_WRITE, WRITE_PROTECT_DISABLE);<span class="hljs-comment">//关闭写保护</span><span class="hljs-comment">/* 十进制转BCD码 */</span>ds1302_wrbyte(REG_YEAR_WRITE, (p_tm-&gt;year / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;year % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_MONTH_WRITE, (p_tm-&gt;month / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;month % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_DATE_WRITE, (p_tm-&gt;date / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;date % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_HOUR_WRITE, (p_tm-&gt;hour / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;hour % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_MINUTE_WRITE, (p_tm-&gt;minute / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;minute % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_SECOND_WRITE, (p_tm-&gt;second / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;second % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_DAY_WRITE, (p_tm-&gt;day / <span class="hljs-number">10</span> * <span class="hljs-number">16</span> + p_tm-&gt;day % <span class="hljs-number">10</span>));ds1302_wrbyte(REG_WR_PROTECT_WRITE, WRITE_PROTECT_ENABLE);<span class="hljs-comment">//打开写保护</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief ds1302读取时间</span><span class="hljs-comment">  * @param p_tm: 时间结构体指针</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ds1302_read_time</span><span class="hljs-params">(<span class="hljs-type">tm_t</span>* p_tm)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> temp;<span class="hljs-comment">/* BCD码转十进制 */</span>temp = ds1302_rdbyte(REG_YEAR_READ);p_tm-&gt;year = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_MONTH_READ);p_tm-&gt;month = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_DATE_READ);p_tm-&gt;date = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_HOUR_READ);p_tm-&gt;hour = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_MINUTE_READ);p_tm-&gt;minute = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_SECOND_READ);p_tm-&gt;second = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;temp = ds1302_rdbyte(REG_DAY_READ);p_tm-&gt;day = temp / <span class="hljs-number">16</span> * <span class="hljs-number">10</span> + temp % <span class="hljs-number">16</span>;<span class="hljs-comment">//printf(&quot;%#x&quot;, temp);</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ds1302.h&quot;</span></span><span class="hljs-comment">/* 初始化时间：2022年03月27日17时20分50秒周七，存储格式是用BCD码 */</span><span class="hljs-type">tm_t</span> default_time = &#123;<span class="hljs-number">22</span>,<span class="hljs-number">3</span>,<span class="hljs-number">27</span>,<span class="hljs-number">17</span>,<span class="hljs-number">20</span>,<span class="hljs-number">50</span>,<span class="hljs-number">7</span>&#125;;<span class="hljs-type">tm_t</span> tm; <span class="hljs-comment">//存储读取的时间</span><span class="hljs-type">void</span> <span class="hljs-title function_">Delay1000ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">43</span>;j = <span class="hljs-number">6</span>;k = <span class="hljs-number">203</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;uart1_init();ds1302_init();<span class="hljs-comment">/* 设置时间 */</span>ds1302_write_time(&amp;default_time);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">/* 读取时间 */</span>ds1302_read_time(&amp;tm);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-%d-%d &quot;</span>, (tm.year + <span class="hljs-number">2000</span>), tm.month, tm.date);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:%d:%d 周%d&quot;</span>,tm.hour, tm.minute, tm.second, tm.day);<span class="hljs-comment">//不能放到同一个printf中，否则周期乱码</span>Delay1000ms();&#125;&#125;</code></pre></div><p>效果图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230508203331455.png" alt="image-20230508203331455" style="zoom:80%;" /></p><p>工程代码：<a href="https://gitee.com/kayoungzhang/my_codehub.git">ds1302</a></p><h3 id="参考链接">参考链接</h3><p>https://wendy.blog.csdn.net/article/details/124249444</p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ds1302</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sht3x温湿度传感器的开发设计</title>
    <link href="/2023/04/30/sht3x%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/04/30/sht3x%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>国内市场碰到的温湿度传感器一般都采用的是瑞士公司Sensirion 生产的，像SHT2x 和 SHT3x和 SHTCx和 SHT4x等系列温湿度传感器。下面介绍一下其经典的数字温湿度传感器<a href="https://sensirion.com/cn/products/product-catalog/SHT31-DIS-B">SHT31-DIS-B</a>。</p><h3 id="特点">特点</h3><ul><li><p>电源电压：2.4 - 5.5V</p></li><li><p>相对湿度范围：0 - 100%RH 相对湿度精度：2%RH</p></li><li><p>工作温度范围：-40 - 125°C 温度精度：0.2°C</p></li><li><p>接口：I²C</p></li><li><p>尺寸 (长x宽x高)：2.5 x 2.5 x 0.9 mm³</p></li></ul><h3 id="引脚定义及其典型线路应用">引脚定义及其典型线路应用</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230429191808155.png" alt="image-20230429191808155" style="zoom: 67%;" /><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230430092336215.png" alt="image-20230430092336215" style="zoom:67%;" /></p><h3 id="获取芯片序列号">获取芯片序列号</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230429195521345.png" alt="image-20230429195521345" style="zoom: 67%;" /></p><h3 id="单次采集模式时序">单次采集模式时序</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230429194522708.png" alt="image-20230429194522708" style="zoom: 80%;" /></p><h3 id="周期性采集模式时序">周期性采集模式时序</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230430185828051.png" alt="image-20230430185828051" style="zoom:67%;" /></p><p><strong>注意</strong>：灰色块是传感器发送。</p><h3 id="计算公式">计算公式</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230429235908382.png" alt="image-20230429235908382" style="zoom:67%;" /></p><h3 id="代码实现">代码实现</h3><ul><li>I2C代码部分：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __BSP_I2C_H__</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __BSP_I2C_H__</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">uint16_t</span>;<span class="hljs-comment">/* 引脚定义 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_SCLP23</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_SDAP24</span><span class="hljs-comment">/* I2C acknowledge status */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span>  ACK  = <span class="hljs-number">0</span>,  NACK = <span class="hljs-number">1</span>,&#125;ack_e;<span class="hljs-comment">/* 函数声明 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2c_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2c_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2c_stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2c_delay</span> <span class="hljs-params">(<span class="hljs-type">uint8_t</span> t)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2c_rd_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* recv_byte, ack_e ack_status)</span>;<span class="hljs-keyword">extern</span> ack_e <span class="hljs-title function_">i2c_wr_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> write_byte)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">crc8_calc</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *crcdata, <span class="hljs-type">uint8_t</span> size)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/*END OF FILE*/</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> ******************************************************************************</span><span class="hljs-comment"> * @file    bsp_i2c.c</span><span class="hljs-comment"> * @author  Kayoung</span><span class="hljs-comment"> * @version V1.1</span><span class="hljs-comment"> * @date    20201106</span><span class="hljs-comment"> * @brief   gpio软件模拟i2c</span><span class="hljs-comment"> ******************************************************************************</span><span class="hljs-comment"> * @attention </span><span class="hljs-comment"> ******************************************************************************</span><span class="hljs-comment"> */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_i2c.h&quot;</span></span><span class="hljs-comment">/* Generator polynomial for CRC8 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLYNOMIAL  0x31 <span class="hljs-comment">// P(x) = x^8 + x^5 + x^4 + 1 = 00110001 ，省略了最高位1</span></span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefcrc8计算</span><span class="hljs-comment">  * @paramcrcdata：数据指针</span><span class="hljs-comment">  * @param  size：数据长度</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">crc8_calc</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *crcdata, <span class="hljs-type">uint8_t</span> size)</span>&#123;<span class="hljs-type">uint8_t</span> Bit;        <span class="hljs-comment">// bit mask</span><span class="hljs-type">uint8_t</span> crc = <span class="hljs-number">0xFF</span>; <span class="hljs-comment">// calculated checksum</span><span class="hljs-type">uint8_t</span> byteCtr;    <span class="hljs-comment">// byte counter</span>    <span class="hljs-comment">// calculates 8-Bit checksum with given polynomial </span>  <span class="hljs-keyword">for</span>(byteCtr = <span class="hljs-number">0</span>; byteCtr &lt; size; byteCtr++)  &#123;    crc ^= (crcdata[byteCtr]);    <span class="hljs-keyword">for</span>(Bit = <span class="hljs-number">8</span>; Bit &gt; <span class="hljs-number">0</span>; --Bit)    &#123;      <span class="hljs-keyword">if</span>(crc &amp; <span class="hljs-number">0x80</span>) crc = (crc &lt;&lt; <span class="hljs-number">1</span>) ^ POLYNOMIAL;      <span class="hljs-keyword">else</span>           crc = (crc &lt;&lt; <span class="hljs-number">1</span>);    &#125;  &#125;<span class="hljs-keyword">return</span> crc;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">i2c_delay</span> <span class="hljs-params">(<span class="hljs-type">uint8_t</span> t)</span>&#123;<span class="hljs-keyword">while</span>(t--);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  i2c start.</span><span class="hljs-comment"> * @param  None.</span><span class="hljs-comment"> * @retval None.</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;I2C_SDA = <span class="hljs-number">1</span>; I2C_SCL = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  i2c start. I2C_SCL、I2C_SDA同为高，I2C_SDA跳变成低之后，I2C_SCL跳变成低</span><span class="hljs-comment"> * @param  None.</span><span class="hljs-comment"> * @retval None.</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  I2C_SDA = <span class="hljs-number">1</span>;  I2C_SCL = <span class="hljs-number">1</span>;  i2c_delay(<span class="hljs-number">10</span>);  I2C_SDA = <span class="hljs-number">0</span>;  i2c_delay(<span class="hljs-number">10</span>);  I2C_SCL = <span class="hljs-number">0</span>;  i2c_delay(<span class="hljs-number">10</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  i2c stop.I2C_SCL、I2C_SDA同为低，I2C_SCL跳变成高之后，I2C_SDA跳变成高</span><span class="hljs-comment"> * @param  None.</span><span class="hljs-comment"> * @retval None.</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  I2C_SDA = <span class="hljs-number">0</span>;  I2C_SCL = <span class="hljs-number">0</span>;i2c_delay(<span class="hljs-number">10</span>);  I2C_SCL = <span class="hljs-number">1</span>;  i2c_delay(<span class="hljs-number">10</span>);  I2C_SDA = <span class="hljs-number">1</span>;  i2c_delay(<span class="hljs-number">10</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  CPU从I2C总线设备发送8bit数据</span><span class="hljs-comment"> * @param  write_byte: 待写入的1字节数据</span><span class="hljs-comment"> * @retval res：(获取从机ack)ACK: 0, NACK：1.</span><span class="hljs-comment"> */</span>ack_e <span class="hljs-title function_">i2c_wr_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> write_byte)</span>&#123;<span class="hljs-type">uint8_t</span> i;ack_e ack_status;I2C_SCL = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)&#123;<span class="hljs-comment">//要发送8位，从最高位开始</span><span class="hljs-keyword">if</span> (write_byte &amp; <span class="hljs-number">0x80</span>) <span class="hljs-comment">// I2C_SDA = (write_byte &amp; 0x80) &gt;&gt; 7;</span>&#123;I2C_SDA = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;I2C_SDA = <span class="hljs-number">0</span>;&#125;i2c_delay(<span class="hljs-number">10</span>);I2C_SCL = <span class="hljs-number">1</span>;<span class="hljs-comment">//输出I2C_SDA稳定后，拉高I2C_SCL给出上升沿，从机检测到后进行数据采样</span>i2c_delay(<span class="hljs-number">50</span>);I2C_SCL = <span class="hljs-number">0</span>;i2c_delay(<span class="hljs-number">10</span>);write_byte &lt;&lt;= <span class="hljs-number">1</span>;&#125;I2C_SDA = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放总线</span>I2C_SCL = <span class="hljs-number">1</span>;i2c_delay(<span class="hljs-number">50</span>);ack_status = I2C_SDA;I2C_SCL=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> ack_status;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * @brief  CPU从I2C总线设备读取8bit数据</span><span class="hljs-comment"> * @param  recv_byte : 读取的1字节数据指针.</span><span class="hljs-comment"> * @param  ack_status：主机发送ack（ACK: 0, NACK：1.）</span><span class="hljs-comment"> * @retval None.</span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">i2c_rd_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* recv_byte, ack_e ack_status)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) <span class="hljs-comment">//from MSB to LSB</span>&#123;*recv_byte &lt;&lt;= <span class="hljs-number">1</span>;I2C_SCL = <span class="hljs-number">1</span>;i2c_delay(<span class="hljs-number">30</span>);<span class="hljs-comment">//延时等待信号稳定</span><span class="hljs-keyword">if</span>(I2C_SDA == <span class="hljs-number">1</span>)(*recv_byte)++;I2C_SCL = <span class="hljs-number">0</span>; <span class="hljs-comment">//fall edge for next value</span>i2c_delay(<span class="hljs-number">10</span>);&#125;I2C_SDA = ack_status; i2c_delay(<span class="hljs-number">10</span>);I2C_SCL = <span class="hljs-number">1</span>;<span class="hljs-comment">//产生一个时钟</span>i2c_delay(<span class="hljs-number">50</span>);I2C_SCL = <span class="hljs-number">0</span>;i2c_delay(<span class="hljs-number">10</span>);I2C_SDA = <span class="hljs-number">1</span>;<span class="hljs-comment">//释放总线</span>&#125;</code></pre></div><ul><li>SHT31代码部分：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __SHT3X_H_</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SHT3X_H_</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_i2c.h&quot;</span></span><span class="hljs-comment">/* only the 7 MSBs of the I2C Read/Write header constitute the I2C Address. */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHT3XADDR 0x44    <span class="hljs-comment">//default address             </span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHT3XWriteHeader SHT3XADDR&lt;&lt;1   <span class="hljs-comment">//7 MSBs + write bit 0</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHT3XReadHeader  SHT3XWriteHeader|0x01   <span class="hljs-comment">//7 MSBs + read bit 1</span></span><span class="hljs-comment">/* Error codes */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span>  NO_ERROR       = <span class="hljs-number">0x00</span>, <span class="hljs-comment">// no error</span>  ACK_ERROR      = <span class="hljs-number">0x01</span>, <span class="hljs-comment">// no acknowledgment error</span>  CHECKSUM_ERROR = <span class="hljs-number">0x02</span>, <span class="hljs-comment">// checksum mismatch error</span>  TIMEOUT_ERROR  = <span class="hljs-number">0x04</span>, <span class="hljs-comment">// timeout error</span>  PARM_ERROR     = <span class="hljs-number">0x80</span>, <span class="hljs-comment">// parameter out of range error</span>&#125;etError;<span class="hljs-comment">/* Sensor Commands */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span>  CMD_READ_SERIALNBR  = <span class="hljs-number">0x3780</span>, <span class="hljs-comment">// read serial number</span>  CMD_READ_STATUS     = <span class="hljs-number">0xF32D</span>, <span class="hljs-comment">// read status register</span>  CMD_CLEAR_STATUS    = <span class="hljs-number">0x3041</span>, <span class="hljs-comment">// clear status register</span>  CMD_HEATER_ENABLE   = <span class="hljs-number">0x306D</span>, <span class="hljs-comment">// enabled heater</span>  CMD_HEATER_DISABLE  = <span class="hljs-number">0x3066</span>, <span class="hljs-comment">// disable heater</span>  CMD_SOFT_RESET      = <span class="hljs-number">0x30A2</span>, <span class="hljs-comment">// soft reset</span>  CMD_MEAS_CLOCKSTR_H = <span class="hljs-number">0x2C06</span>, <span class="hljs-comment">// measurement: clock stretching, high repeatability</span>  CMD_MEAS_CLOCKSTR_M = <span class="hljs-number">0x2C0D</span>, <span class="hljs-comment">// measurement: clock stretching, medium repeatability</span>  CMD_MEAS_CLOCKSTR_L = <span class="hljs-number">0x2C10</span>, <span class="hljs-comment">// measurement: clock stretching, low repeatability</span>  CMD_MEAS_POLLING_H  = <span class="hljs-number">0x2400</span>, <span class="hljs-comment">// measurement: polling, high repeatability</span>  CMD_MEAS_POLLING_M  = <span class="hljs-number">0x240B</span>, <span class="hljs-comment">// measurement: polling, medium repeatability</span>  CMD_MEAS_POLLING_L  = <span class="hljs-number">0x2416</span>, <span class="hljs-comment">// measurement: polling, low repeatability</span>  CMD_MEAS_PERI_05_H  = <span class="hljs-number">0x2032</span>, <span class="hljs-comment">// measurement: periodic 0.5 mps, high repeatability</span><span class="hljs-comment">//  CMD_MEAS_PERI_05_M  = 0x2024, // measurement: periodic 0.5 mps, medium repeatability</span>  CMD_MEAS_PERI_05_L  = <span class="hljs-number">0x202F</span>, <span class="hljs-comment">// measurement: periodic 0.5 mps, low repeatability</span>  CMD_MEAS_PERI_1_H   = <span class="hljs-number">0x2130</span>, <span class="hljs-comment">// measurement: periodic 1 mps, high repeatability</span><span class="hljs-comment">//  CMD_MEAS_PERI_1_M   = 0x2126, // measurement: periodic 1 mps, medium repeatability</span>  CMD_MEAS_PERI_1_L   = <span class="hljs-number">0x212D</span>, <span class="hljs-comment">// measurement: periodic 1 mps, low repeatability</span>  CMD_MEAS_PERI_2_H   = <span class="hljs-number">0x2236</span>, <span class="hljs-comment">// measurement: periodic 2 mps, high repeatability</span><span class="hljs-comment">//  CMD_MEAS_PERI_2_M   = 0x2220, // measurement: periodic 2 mps, medium repeatability</span>  CMD_MEAS_PERI_2_L   = <span class="hljs-number">0x222B</span>, <span class="hljs-comment">// measurement: periodic 2 mps, low repeatability</span>  CMD_MEAS_PERI_4_H   = <span class="hljs-number">0x2334</span>, <span class="hljs-comment">// measurement: periodic 4 mps, high repeatability</span><span class="hljs-comment">//  CMD_MEAS_PERI_4_M   = 0x2322, // measurement: periodic 4 mps, medium repeatability</span>  CMD_MEAS_PERI_4_L   = <span class="hljs-number">0x2329</span>, <span class="hljs-comment">// measurement: periodic 4 mps, low repeatability</span>  CMD_MEAS_PERI_10_H  = <span class="hljs-number">0x2737</span>, <span class="hljs-comment">// measurement: periodic 10 mps, high repeatability</span><span class="hljs-comment">//  CMD_MEAS_PERI_10_M  = 0x2721, // measurement: periodic 10 mps, medium repeatability</span>  CMD_MEAS_PERI_10_L  = <span class="hljs-number">0x272A</span>, <span class="hljs-comment">// measurement: periodic 10 mps, low repeatability</span>  CMD_FETCH_DATA      = <span class="hljs-number">0xE000</span>, <span class="hljs-comment">// readout measurements for periodic mode</span>  CMD_R_AL_LIM_LS     = <span class="hljs-number">0xE102</span>, <span class="hljs-comment">// read alert limits, low set</span>  CMD_R_AL_LIM_LC     = <span class="hljs-number">0xE109</span>, <span class="hljs-comment">// read alert limits, low clear</span>  CMD_R_AL_LIM_HS     = <span class="hljs-number">0xE11F</span>, <span class="hljs-comment">// read alert limits, high set</span>  CMD_R_AL_LIM_HC     = <span class="hljs-number">0xE114</span>, <span class="hljs-comment">// read alert limits, high clear</span>  CMD_W_AL_LIM_HS     = <span class="hljs-number">0x611D</span>, <span class="hljs-comment">// write alert limits, high set</span>  CMD_W_AL_LIM_HC     = <span class="hljs-number">0x6116</span>, <span class="hljs-comment">// write alert limits, high clear</span>  CMD_W_AL_LIM_LC     = <span class="hljs-number">0x610B</span>, <span class="hljs-comment">// write alert limits, low clear</span>  CMD_W_AL_LIM_LS     = <span class="hljs-number">0x6100</span>, <span class="hljs-comment">// write alert limits, low set</span>  CMD_NO_SLEEP        = <span class="hljs-number">0x303E</span>,&#125;etCommands;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sht3x_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> etError <span class="hljs-title function_">sht3x_rd_serial_num</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>* serialNumber)</span>; <span class="hljs-keyword">extern</span> etError <span class="hljs-title function_">sht3x_single_polling</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd, <span class="hljs-type">uint8_t</span> timeout)</span>;<span class="hljs-keyword">extern</span> etError <span class="hljs-title function_">sht3x_single_clkStretch</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd, <span class="hljs-type">uint8_t</span> timeout)</span>;<span class="hljs-keyword">extern</span> etError <span class="hljs-title function_">sht3x_periodic_mode</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ************************************************</span><span class="hljs-comment">  * @filesht31.c</span><span class="hljs-comment">  * @authorKayoung</span><span class="hljs-comment">  * @versionV1.0.0</span><span class="hljs-comment">  * @date2023.04.30</span><span class="hljs-comment">  * @briefsht3x温湿度传感器驱动函数</span><span class="hljs-comment">  ************************************************</span><span class="hljs-comment">  */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sht31.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;intrins.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">Delay1ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j;_nop_();i = <span class="hljs-number">11</span>;j = <span class="hljs-number">190</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief向sht3x传感器写指令</span><span class="hljs-comment">  * @paramcommand：指令</span><span class="hljs-comment">  * @retvalerror（ack：0 or nack：1）</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> ack_e <span class="hljs-title function_">sht3x_wr_cmd</span><span class="hljs-params">(etCommands command)</span>&#123;  ack_e error; <span class="hljs-comment">// ack or nack</span>  error  = i2c_wr_byte(command &gt;&gt; <span class="hljs-number">8</span>); <span class="hljs-comment">//upper 8 bits</span>  error |= i2c_wr_byte(command &amp; <span class="hljs-number">0xFF</span>); <span class="hljs-comment">//lower 8 bits</span>  <span class="hljs-keyword">return</span> error;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefsht3x初始化</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">sht3x_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;i2c_init();<span class="hljs-comment">//I2C初始化</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief读取sht3x序列号</span><span class="hljs-comment">  * @paramserialNumber: sht3x序列号指针</span><span class="hljs-comment">  * @retvalerror</span><span class="hljs-comment">  */</span>etError <span class="hljs-title function_">sht3x_rd_serial_num</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>* serialNumber)</span>&#123;etError error = NO_ERROR;           <span class="hljs-comment">// error code</span><span class="hljs-type">uint8_t</span> serialNumWords[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;      <span class="hljs-comment">//serial number raw value and checksum value</span>  <span class="hljs-type">uint8_t</span> i;i2c_start();  error = i2c_wr_byte(SHT3XWriteHeader);<span class="hljs-keyword">if</span>(error == NO_ERROR)  error = sht3x_wr_cmd(CMD_READ_SERIALNBR); <span class="hljs-comment">// write &quot;read serial number&quot; command</span>Delay1ms();<span class="hljs-keyword">if</span>(error == NO_ERROR)&#123;i2c_start();error = i2c_wr_byte(SHT3XReadHeader);&#125;<span class="hljs-comment">/* read temperature and humidity raw values */</span>  <span class="hljs-keyword">if</span>(error == NO_ERROR)  &#123;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123; i2c_rd_byte(&amp;serialNumWords[i], ACK);&#125;    i2c_rd_byte(&amp;serialNumWords[i], NACK);<span class="hljs-comment">//i = 5</span><span class="hljs-comment">//serialNumWords[6] = &#x27;\0&#x27;;</span>i2c_stop();<span class="hljs-keyword">if</span>(serialNumWords[<span class="hljs-number">2</span>] != crc8_calc(serialNumWords,<span class="hljs-number">2</span>))     error = CHECKSUM_ERROR;  <span class="hljs-keyword">if</span>(serialNumWords[<span class="hljs-number">5</span>] != crc8_calc(&amp;serialNumWords[<span class="hljs-number">3</span>],<span class="hljs-number">2</span>)) error = CHECKSUM_ERROR;  &#125;  <span class="hljs-comment">/* calc serial number as 32-bit integer */</span>  <span class="hljs-keyword">if</span>(error == NO_ERROR)  &#123;<span class="hljs-comment">/* print serialNumber */</span><span class="hljs-comment">//printf(&quot;serialNumber: 0x%02x%02x\r\n&quot;, serialNumWords[0], serialNumWords[1], serialNumWords[3], serialNumWords[4]);</span>*serialNumber = serialNumWords[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span> | serialNumWords[<span class="hljs-number">1</span>];*serialNumber &lt;&lt;= <span class="hljs-number">16</span>;*serialNumber |= serialNumWords[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span> | serialNumWords[<span class="hljs-number">4</span>];&#125;  <span class="hljs-keyword">return</span> error;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefsht3x单次轮询模式获取温湿度数据</span><span class="hljs-comment">  * @paramtemperature : 温度指针</span><span class="hljs-comment">  * @paramhumidity: 湿度指针</span><span class="hljs-comment">  * @param  cmd：指令</span><span class="hljs-comment">  * @param  timeout：超时（ms）</span><span class="hljs-comment">  * @retvalerror（ack：0 or nack：1）</span><span class="hljs-comment">  */</span>etError <span class="hljs-title function_">sht3x_single_polling</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd, <span class="hljs-type">uint8_t</span> timeout)</span>&#123;    etError error = NO_ERROR;           <span class="hljs-comment">// error code</span>    <span class="hljs-type">uint16_t</span> rawValueTemp, rawValueHumi;    <span class="hljs-comment">// temperature and humidity raw value from sensor</span>    <span class="hljs-type">uint8_t</span> Rdata[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;      <span class="hljs-comment">//temperature and humidity raw value and checksum value</span>    <span class="hljs-type">uint8_t</span> i;    <span class="hljs-comment">/* Start Measurement*/</span>    i2c_start();    error = i2c_wr_byte(SHT3XWriteHeader);    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        error = sht3x_wr_cmd(cmd);    &#125;    i2c_stop();    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        i2c_start();        error = i2c_wr_byte(SHT3XReadHeader);    &#125;    <span class="hljs-keyword">while</span>(timeout--)    &#123;        i2c_stop();        i2c_start();        error = i2c_wr_byte(SHT3XReadHeader);<span class="hljs-comment">// check if the measurement has finished</span>        <span class="hljs-keyword">if</span>(error == NO_ERROR) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// if measurement has finished -&gt; exit loop</span>        Delay1ms();    &#125;    <span class="hljs-keyword">if</span>(timeout == <span class="hljs-number">0</span>) error = TIMEOUT_ERROR;    <span class="hljs-comment">// check for timeout error</span>    <span class="hljs-comment">/* read temperature and humidity raw values */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)        &#123;            i2c_rd_byte(&amp;Rdata[i], ACK);        &#125;        i2c_rd_byte(&amp;Rdata[i], NACK);        i2c_stop();        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">2</span>] != crc8_calc(Rdata,<span class="hljs-number">2</span>))     error = CHECKSUM_ERROR;        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">5</span>] != crc8_calc(&amp;Rdata[<span class="hljs-number">3</span>],<span class="hljs-number">2</span>)) error = CHECKSUM_ERROR;    &#125;    <span class="hljs-comment">/* calculate temperature in  and humidity in %RH */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        rawValueTemp = (Rdata[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">1</span>];        rawValueHumi = (Rdata[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">4</span>];        *temperature = <span class="hljs-number">175.0f</span> * (<span class="hljs-type">float</span>)rawValueTemp / <span class="hljs-number">65535.0f</span> - <span class="hljs-number">45.0f</span>;        *humidity = <span class="hljs-number">100.0f</span> * (<span class="hljs-type">float</span>)rawValueHumi / <span class="hljs-number">65535.0f</span>;    &#125;    <span class="hljs-keyword">return</span> error;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefsht3x单次时钟扩展模式获取温湿度数据</span><span class="hljs-comment">  * @paramtemperature : 温度指针</span><span class="hljs-comment">  * @paramhumidity: 湿度指针</span><span class="hljs-comment">  * @param  cmd：指令</span><span class="hljs-comment">  * @param  timeout：超时（ms）</span><span class="hljs-comment">  * @retvalerror（ack：0 or nack：1）</span><span class="hljs-comment">  */</span>etError <span class="hljs-title function_">sht3x_single_clkStretch</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd, <span class="hljs-type">uint8_t</span> timeout)</span>&#123;    etError error = NO_ERROR;           <span class="hljs-comment">// error code</span>    <span class="hljs-type">uint16_t</span> rawValueTemp, rawValueHumi;    <span class="hljs-comment">// temperature and humidity raw value from sensor</span>    <span class="hljs-type">uint8_t</span> Rdata[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;      <span class="hljs-comment">//temperature and humidity raw value and checksum value</span>    <span class="hljs-type">uint8_t</span> i;    <span class="hljs-comment">/* Start Measurement*/</span>    i2c_start();    error = i2c_wr_byte(SHT3XWriteHeader);    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        error = sht3x_wr_cmd(cmd);    &#125;    i2c_stop();    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        i2c_start();        error = i2c_wr_byte(SHT3XReadHeader);    &#125;    <span class="hljs-keyword">while</span>(timeout--)    &#123;        Delay1ms();    &#125;    <span class="hljs-keyword">if</span>(timeout == <span class="hljs-number">0</span>) error = TIMEOUT_ERROR;    <span class="hljs-comment">// check for timeout error</span>    <span class="hljs-comment">/* read temperature and humidity raw values */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)        &#123;            i2c_rd_byte(&amp;Rdata[i], ACK);        &#125;        i2c_rd_byte(&amp;Rdata[i], NACK);        i2c_stop();        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">2</span>] != crc8_calc(Rdata,<span class="hljs-number">2</span>))     error = CHECKSUM_ERROR;        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">5</span>] != crc8_calc(&amp;Rdata[<span class="hljs-number">3</span>],<span class="hljs-number">2</span>)) error = CHECKSUM_ERROR;    &#125;    <span class="hljs-comment">/* calculate temperature in  and humidity in %RH */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        rawValueTemp = (Rdata[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">1</span>];        rawValueHumi = (Rdata[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">4</span>];        *temperature = <span class="hljs-number">175.0f</span> * (<span class="hljs-type">float</span>)rawValueTemp / <span class="hljs-number">65535.0f</span> - <span class="hljs-number">45.0f</span>;        *humidity = <span class="hljs-number">100.0f</span> * (<span class="hljs-type">float</span>)rawValueHumi / <span class="hljs-number">65535.0f</span>;    &#125;    <span class="hljs-keyword">return</span> error;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefsht3x 周期性获取温湿度数据</span><span class="hljs-comment">  * @paramtemperature : 温度指针</span><span class="hljs-comment">  * @paramhumidity: 湿度指针</span><span class="hljs-comment">  * @param  cmd：指令</span><span class="hljs-comment">  * @retvalerror（ack：0 or nack：1）</span><span class="hljs-comment">  */</span>etError <span class="hljs-title function_">sht3x_periodic_mode</span><span class="hljs-params">(<span class="hljs-type">float</span>* temperature, <span class="hljs-type">float</span>* humidity, etCommands cmd)</span>&#123;    etError error = NO_ERROR;           <span class="hljs-comment">// error code</span>    <span class="hljs-type">uint16_t</span> rawValueTemp, rawValueHumi;    <span class="hljs-comment">// temperature and humidity raw value from sensor</span>    <span class="hljs-type">uint8_t</span> Rdata[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;      <span class="hljs-comment">//temperature and humidity raw value and checksum value</span>    <span class="hljs-type">uint8_t</span> i;    <span class="hljs-comment">/* start measurement */</span>    i2c_start();    error  = i2c_wr_byte(SHT3XWriteHeader);    <span class="hljs-keyword">if</span>(error == NO_ERROR) error = sht3x_wr_cmd(cmd);    <span class="hljs-comment">/* Readout of Measurement Results */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        i2c_start();        error  = i2c_wr_byte(SHT3XWriteHeader);    &#125;    <span class="hljs-keyword">if</span>(error == NO_ERROR) error = sht3x_wr_cmd(CMD_FETCH_DATA);    <span class="hljs-keyword">if</span>(error == NO_ERROR)     &#123;        i2c_start();        error = i2c_wr_byte(SHT3XReadHeader);    &#125;    <span class="hljs-comment">/* read temperature and humidity raw values */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)        &#123;            i2c_rd_byte(&amp;Rdata[i], ACK);        &#125;        i2c_rd_byte(&amp;Rdata[i], NACK);        i2c_stop();        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">2</span>] != crc8_calc(Rdata,<span class="hljs-number">2</span>))     error = CHECKSUM_ERROR;        <span class="hljs-keyword">if</span>(Rdata[<span class="hljs-number">5</span>] != crc8_calc(&amp;Rdata[<span class="hljs-number">3</span>],<span class="hljs-number">2</span>)) error = CHECKSUM_ERROR;    &#125;    <span class="hljs-comment">/* calculate temperature in  and humidity in %RH */</span>    <span class="hljs-keyword">if</span>(error == NO_ERROR)    &#123;        rawValueTemp = (Rdata[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">1</span>];        rawValueHumi = (Rdata[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>) | Rdata[<span class="hljs-number">4</span>];        *temperature = <span class="hljs-number">175.0f</span> * (<span class="hljs-type">float</span>)rawValueTemp / <span class="hljs-number">65535.0f</span> - <span class="hljs-number">45.0f</span>;        *humidity = <span class="hljs-number">100.0f</span> * (<span class="hljs-type">float</span>)rawValueHumi / <span class="hljs-number">65535.0f</span>;    &#125;    <span class="hljs-keyword">return</span> error;&#125;</code></pre></div><p>main.c</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC12C5A60S2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_uart.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sht31.h&quot;</span></span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> serialNumber;<span class="hljs-type">float</span> temperature = <span class="hljs-number">0.0f</span>, humidity = <span class="hljs-number">0.0f</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">Delay500ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">22</span>;j = <span class="hljs-number">3</span>;k = <span class="hljs-number">227</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;uart1_init();sht3x_init();<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">/* get the serial number */</span>sht3x_rd_serial_num(&amp;serialNumber); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;serial number: %#lx\r\n&quot;</span>, serialNumber);sht3x_periodic_mode(&amp;temperature, &amp;humidity, CMD_MEAS_PERI_1_H); <span class="hljs-comment">//周期性获取温湿度</span><span class="hljs-comment">//sht3x_single_polling(&amp;temperature, &amp;humidity, CMD_MEAS_POLLING_L, 50); //单次轮询模式获取温湿度</span><span class="hljs-comment">//sht3x_single_clkStretch(&amp;temperature, &amp;humidity, CMD_MEAS_CLOCKSTR_H, 50);//单次时钟扩展模式获取温湿度</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;temperature = %.3f℃ humidity = %.3f%%\r\n&quot;</span>, temperature, humidity);Delay500ms();&#125;&#125;</code></pre></div><p>串口输出：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230507195015130.png" alt="image-20230507195015130" style="zoom: 80%;" /></p><p>工程代码Gitee ：<a href="https://gitee.com/kayoungzhang/my_codehub.git">sht3x</a></p><h3 id="参考链接">参考链接</h3><p><a href="https://sensirion.com/media/documents/213E6A3B/63A5A569/Datasheet_SHT3x_DIS.pdf">Datasheet SHT3x-DIS</a></p><p>https://sensirion.com/resource/software/code/sht3x</p><p><a href="https://blog.csdn.net/weixin_45607920/article/details/109526396">SHT3X 温湿度模块 C51驱动 ——简单调用获取温湿度信息</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>温湿度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>温度传感器DS18B20的应用</title>
    <link href="/2023/04/28/%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8DS18B20%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/28/%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8DS18B20%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>DS18B20温度传感器在日常应用中，使用比较广泛，以下简单介绍一下：</p><h3 id="特点">特点：</h3><ul><li>单总线传输（1-Wire interface）</li><li>供电范围： 3.0V ~ 5.5V</li><li>测量温度范围：-55°C ~ +125°C</li><li>精度：-10°C ~ +85°C（±0.5°C）</li><li>分辨率： 9 ~ 12 bits</li><li>每一个 DS1820 有唯一的系列号，因此多个 DS1820 可以存在于同一条单线总线上。</li></ul><h3 id="存储器图">存储器图</h3><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230428152810011.png" alt="" /><figcaption>image-20230428152810011</figcaption></figure><h3 id="单总线接口访问ds1820的协议">单总线接口访问DS1820的协议</h3><p>1.初始化 2.进行ROM功能操作 3.进行RAM功能操作 4.传输数据</p><h3 id="rom功能指令">ROM功能指令</h3><table><thead><tr class="header"><th>ROM指令</th><th>功能</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>Read ROM [33h]</td><td>读取DS18B20内部信息</td><td>总线存在多个DS18B20无法使用此命令</td></tr><tr class="even"><td>Match ROM [55h]</td><td>根据64位ROM信息匹配对应的DS18B20</td><td></td></tr><tr class="odd"><td>Skip ROM [CCh]</td><td>跳过DS18B20</td><td>总线上只有一个DS18B20</td></tr><tr class="even"><td>Search ROM [F0h]</td><td>搜索DS18B20</td><td></td></tr><tr class="odd"><td>Alarm Search [ECh]</td><td>搜索DS18B20</td><td>上一次碰到警报才搜索DS18B20</td></tr></tbody></table><h3 id="ram功能指令">RAM功能指令</h3><table><thead><tr class="header"><th>RAM命令</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>Write Scratchpad [4Eh]</td><td>向暂存存储器写内容</td></tr><tr class="even"><td>Read Scratchpad [BEh]</td><td>读暂存存储器的内容</td></tr><tr class="odd"><td>Copy Scratchpad [48h]</td><td>复制暂存存储器内容到非易失存储器 <strong>E2 RAM</strong></td></tr><tr class="even"><td>Convert T [44h]</td><td>转换温度</td></tr><tr class="odd"><td>Recall E2 [B8h]</td><td>重新调出 <strong>E2 RAM</strong> 存储到暂存存储器</td></tr><tr class="even"><td>Read Power Supply [B4h]</td><td>读供电方式</td></tr></tbody></table><h3 id="初始化时序">初始化时序</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230428144010335.png" alt="image-20230428144010335" style="zoom: 67%;" /></p><h3 id="写时序">写时序</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230428144206875.png" alt="image-20230428144206875" style="zoom: 67%;" /></p><h3 id="读时序">读时序</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230428144418569.png" alt="image-20230428144418569" style="zoom:67%;" /></p><h3 id="程序实现">程序实现</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DEV_DS18B20_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DS18B20_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stc15.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> DQ P37   <span class="hljs-comment">//ds18b20接口定义</span></span><span class="hljs-comment">/******* ROM function command ****************/</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>READ_ROM(0x33)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>MATCH_ROM(0x55)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>SKIP_ROM(0xCC)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>SEARCH_ROM(0xF0)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>ALARM_SEARCH(0XEC)</span><span class="hljs-comment">/******* RAM function command ****************/</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>WRITE_SCRATCHPAD(0x4E)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>READ_SCRATCHPAD(0xBE)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>COPY_SCRATCHPAD(0x48) <span class="hljs-comment">//把暂存器RAM中的数据复制到EEPROM中</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span>CONVERT_T(0x44)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>RECALL_EE(0xB8) <span class="hljs-comment">//把EEPROM中的数据恢复到RAM中</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span>READ_POWER(0xB4)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TH_LIMIT(0x78)<span class="hljs-comment">//120℃</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TL_LIMIT(0x05)<span class="hljs-comment">//5℃</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> RESOLUTION_9(0x1F)<span class="hljs-comment">//Thermometer Resolution Configuration</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> RESOLUTION_10(0x3F)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> RESOLUTION_11(0x5F)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> RESOLUTION_12(0x7F)</span><span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ds18b20_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds18b20_convert_temp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">float</span> <span class="hljs-title function_">ds18b20_get_temp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ************************************************</span><span class="hljs-comment">  * @filedev_ds18b20.c</span><span class="hljs-comment">  * @authorKayoung</span><span class="hljs-comment">  * @versionV1.0</span><span class="hljs-comment">  * @date20220324</span><span class="hljs-comment">  * @briefds18b20测温度</span><span class="hljs-comment">  **********************************************</span><span class="hljs-comment">  */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dev_ds18b20.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;intrins.h&gt;</span></span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief检测温度传感器是否正常</span><span class="hljs-comment">  * @paramNone </span><span class="hljs-comment">  * @retval1:失败 0：成功</span><span class="hljs-comment">*/</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ds18b20_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//延时循环变量</span><span class="hljs-type">uint8_t</span> ack;<span class="hljs-comment">//存储检测设备是否成功标志</span>DQ = <span class="hljs-number">1</span>;DQ = <span class="hljs-number">0</span>;i = <span class="hljs-number">227</span>;<span class="hljs-comment">//将总线拉低480us~960us，这里延时500us</span><span class="hljs-keyword">while</span> (--i);DQ = <span class="hljs-number">1</span>;<span class="hljs-comment">//然后拉高总线，延时70us</span>i = <span class="hljs-number">29</span>;<span class="hljs-keyword">while</span> (--i);ack = DQ; <span class="hljs-comment">//读取总线电平</span>i = <span class="hljs-number">227</span>;<span class="hljs-comment">//延时500us</span><span class="hljs-keyword">while</span>(i--);<span class="hljs-keyword">return</span> ack;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefds18b20发送一个位</span><span class="hljs-comment">  * @paramsendbit：待发送的位</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ds18b20_sendbit</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> sendbit)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//延时时间循环变量</span>DQ = <span class="hljs-number">0</span>; <span class="hljs-comment">//主机拉低延时10us</span>i = <span class="hljs-number">2</span>;<span class="hljs-keyword">while</span> (--i); DQ = sendbit; <span class="hljs-comment">//发送位，延时50us</span>i = <span class="hljs-number">20</span>;<span class="hljs-keyword">while</span> (--i); DQ = <span class="hljs-number">1</span>; <span class="hljs-comment">//释放总线</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @briefds18b20接收到一位</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalBit: 从总线上接收到的一位</span><span class="hljs-comment">  */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ds18b20_recvbit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-type">uint8_t</span> Bit; <span class="hljs-comment">//存储接收到的一位</span>DQ = <span class="hljs-number">0</span>; <span class="hljs-comment">//主机拉低，延时8us</span>i = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (--i);DQ = <span class="hljs-number">1</span>; <span class="hljs-comment">//主机释放总线，延时8us</span>i = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (--i);Bit = DQ; <span class="hljs-comment">//读取总线数据，延时50us</span>i = <span class="hljs-number">20</span>;<span class="hljs-keyword">while</span> (--i);<span class="hljs-keyword">return</span> Bit;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief向温度传感器写一个字节</span><span class="hljs-comment">  * @paramwr_data：待写入的数据</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">*/</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ds18b20_wr_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> wr_data)</span>&#123;<span class="hljs-type">uint8_t</span> j;<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)   <span class="hljs-comment">//From LSB to MSB</span>&#123;ds18b20_sendbit(wr_data &amp; (<span class="hljs-number">0x01</span> &lt;&lt; j));&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief读取温度传感器一个字节</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalrecv_byte：读取的一个字节</span><span class="hljs-comment">*/</span><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ds18b20_rd_byte</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> recv_byte = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储接收到的数据</span><span class="hljs-type">uint8_t</span> j;<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<span class="hljs-comment">//from LSB to MSB</span>&#123;<span class="hljs-keyword">if</span>(ds18b20_recvbit())&#123;recv_byte |= (<span class="hljs-number">0x01</span> &lt;&lt; j);&#125;&#125;<span class="hljs-keyword">return</span> recv_byte;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief转换温度</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">ds18b20_convert_temp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;ds18b20_init();ds18b20_wr_byte(SKIP_ROM);  <span class="hljs-comment">//跳过ROM</span>ds18b20_wr_byte(CONVERT_T); <span class="hljs-comment">//转换命令</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief获取正负温度</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalftemp：温度值</span><span class="hljs-comment">  */</span><span class="hljs-type">float</span> <span class="hljs-title function_">ds18b20_get_temp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> TLSB, TMSB;<span class="hljs-comment">//存储温度的两个字节</span><span class="hljs-type">int</span> temp; <span class="hljs-comment">//存储温度的整形</span><span class="hljs-type">float</span> ftemp; <span class="hljs-comment">//温度</span>ds18b20_init();ds18b20_wr_byte(SKIP_ROM);ds18b20_wr_byte(READ_SCRATCHPAD);TLSB = ds18b20_rd_byte();TMSB = ds18b20_rd_byte();temp = (TMSB &lt;&lt; <span class="hljs-number">8</span>) | TLSB; ftemp = temp * <span class="hljs-number">0.0625</span>; <span class="hljs-comment">//分辨率是0.0625</span><span class="hljs-keyword">return</span> ftemp;<span class="hljs-comment">//负数是以其补码形式存储的，所以此函数可以表示负温度</span>&#125;</code></pre></div><p>注意事项：</p><p>单总线传输过程中，有严格的延时时序要求，对于不同的MCU，延时时间会跟此程序不一致，需要根据其时序图进行相应的调整。此程序已上传Gitee：<a href="https://gitee.com/kayoungzhang/my_codehub.git">ds18b20</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>温度传感器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传感器的三种常用算法处理</title>
    <link href="/2023/04/27/%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%84%E7%90%86/"/>
    <url>/2023/04/27/%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<ul><li>加权平滑：平滑和均衡传感器数据，减小偶然数据突变的影响。</li><li>抽取突变：去除静态和缓慢变化的数据背景，强调瞬间变化。</li><li>简单移动平均线：保留数据流最近的K个数据，取平均值。</li></ul><hr /><p><strong>加权平滑</strong>，使用算法如下：</p><p>新值 = 旧值<em>(1 - a) + X </em> a；其中a为设置的权值，X为最新数据，程序实现如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> filter_coe 0.00001  <span class="hljs-comment">//滤波系数 小于1</span></span><span class="hljs-type">static</span> <span class="hljs-type">long</span> AD_Res_Last=<span class="hljs-number">0</span>;<span class="hljs-comment">//上一轮的ADC数值保存</span><span class="hljs-type">long</span> <span class="hljs-title function_">Read_18Bit_AD</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">float</span> out,c;out = AD_Res_Last;c = Read_CS1237();<span class="hljs-keyword">if</span>(c!=<span class="hljs-number">0</span>) <span class="hljs-comment">// 读到正确数据</span>&#123;out = out*filter_coe + c*(<span class="hljs-number">1</span>-filter_coe);AD_Res_Last = out;<span class="hljs-comment">//把这次的计算结果放到全局变量里面保护</span>&#125;<span class="hljs-keyword">return</span> AD_Res_Last;&#125;</code></pre></div><p><strong>抽取突变</strong>采用上面加权平滑的逆算法<strong>，</strong>实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">onSensorChanged</span><span class="hljs-params">(SensorEvent event)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-type">float</span> ALPHA = <span class="hljs-number">0.8</span>;    gravity[<span class="hljs-number">0</span>] = ALPHA * gravity[<span class="hljs-number">0</span>] + (<span class="hljs-number">1</span>-ALPHA) * event.values[<span class="hljs-number">0</span>];    gravity[<span class="hljs-number">1</span>] = ALPHA * gravity[<span class="hljs-number">1</span>] + (<span class="hljs-number">1</span>-ALPHA) * event.values[<span class="hljs-number">1</span>];    gravity[<span class="hljs-number">2</span>] = ALPHA * gravity[<span class="hljs-number">2</span>] + (<span class="hljs-number">1</span>-ALPHA) * event.values[<span class="hljs-number">2</span>];    filteredValues[<span class="hljs-number">0</span>] = event.values[<span class="hljs-number">0</span>] - gravity[<span class="hljs-number">0</span>];    filteredValues[<span class="hljs-number">1</span>] = event.values[<span class="hljs-number">1</span>] - gravity[<span class="hljs-number">1</span>];    filteredValues[<span class="hljs-number">2</span>] = event.values[<span class="hljs-number">2</span>] - gravity[<span class="hljs-number">2</span>];&#125;</code></pre></div><p><strong>简单移动平均线，</strong>保留传感器数据流中最近的K个数据，返回它们的平均值。k表示平均“窗口”的大小，实现代码如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 12</span><span class="hljs-type">char</span> <span class="hljs-title function_">filter</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> count;    <span class="hljs-keyword">for</span>(count = <span class="hljs-number">0</span>; count &lt; N; count++)    &#123;        sum += get_ad();        delay();&#125;<span class="hljs-keyword">return</span> (<span class="hljs-type">char</span>)(sum/N);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sensor</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STC芯片内部EEPROM的程序设计</title>
    <link href="/2023/04/27/STC%E8%8A%AF%E7%89%87%E5%86%85%E9%83%A8EEPROM%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/04/27/STC%E8%8A%AF%E7%89%87%E5%86%85%E9%83%A8EEPROM%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>STC单片机内部集成了的EEPROM是与程序空间是分开的，利用ISP/IAP技术可将内部Data Flash当EEPROM，擦写次数在10万次以上。以下根据datasheet简单介绍一下单片机内部EEPROM的编程方式。</p><h3 id="iap及eeprom特殊功能寄存器介绍">IAP及EEPROM特殊功能寄存器介绍</h3><ul><li>ISP/IAP数据寄存器IAP_DATA</li><li>ISP/IAP地址寄存器IAP_ADDRH和IAP_ADDRL</li><li>ISP/IAP命令寄存器IAP_CMD</li><li>ISP/IAP命令触发寄存器IAP_TRIG</li><li>ISP/IAP控制寄存器IAP_CONTR</li></ul><h3 id="注意事项">注意事项</h3><p>1.<strong>写数据</strong>：如果该字节不是0xFF，则须先将整个扇区擦除，因为只有扇区擦除才可以将 <strong>0</strong> 变为 <strong>1</strong> 。</p><p>2.<strong>扇区擦除</strong>：将扇区内各字节变为 <strong>0xFF</strong> 。</p><p>3.同一次修改的数据放在同一扇区中，不是同一次修改的数据放在另外的扇区。</p><p>4.IAP指令完成后，地址不会自动增减，需要手动处理。</p><h3 id="eeprom程序实现">EEPROM程序实现</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span>IAP_EEPROM__H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stc15.h&quot;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">uint16_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">uint32_t</span>;<span class="hljs-meta">#<span class="hljs-keyword">define</span> TOTAL_ITEM (20) <span class="hljs-comment">//存储数据的数量</span></span><span class="hljs-comment">/** STC12C5A60S2</span><span class="hljs-comment">  *eeprom 扇区地址</span><span class="hljs-comment">  * 0x0000 ~ 0x3fff</span><span class="hljs-comment">  */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_ADDR_SECTOR_00x0000  <span class="hljs-comment">//第一扇区基地址</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_ADDR_SECTOR_10x0200  <span class="hljs-comment">//第二扇区基地址</span></span><span class="hljs-comment">/* IAP_CMD register */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_CMD_STANDBY0x00  <span class="hljs-comment">//待机模式</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_CMD_BYTE_RD0x01  <span class="hljs-comment">//字节读</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_CMD_BYTE_WR0x02  <span class="hljs-comment">//字节写</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_CMD_SECTOR_ERASE0x03  <span class="hljs-comment">//扇区擦除</span></span><span class="hljs-comment">/* IAP_TRIG register */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TRIG_FIRST0x5a</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TRIG_SECOND0xa5</span><span class="hljs-comment">/* IAP_CONTR register */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_EN0x80<span class="hljs-comment">//IAP使能</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_ISP0x60<span class="hljs-comment">//复位后从系统ISP监控程序区启动</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_1M0x07<span class="hljs-comment">//设置系统时钟小于或等于1MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_2M0x06<span class="hljs-comment">//设置系统时钟小于或等于2MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_3M0x05<span class="hljs-comment">//设置系统时钟小于或等于3MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_6M0x04<span class="hljs-comment">//设置系统时钟小于或等于6MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_12M0x03<span class="hljs-comment">//设置系统时钟小于或等于12MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_20M0x02<span class="hljs-comment">//设置系统时钟小于或等于20MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_24M0x01<span class="hljs-comment">//设置系统时钟小于或等于24MHZ</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> IAP_TIMEOUT_30M0x00<span class="hljs-comment">//设置系统时钟小于或等于30MHZ</span></span><span class="hljs-keyword">extern</span> <span class="hljs-type">uint16_t</span> eeprom_save[TOTAL_ITEM];<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iap_erase</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iap_rd_byte</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* dat)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iap_wr_byte</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr,<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* dat)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iap_rd_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">iap_wr_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  * @file    eeprom.c </span><span class="hljs-comment">  * @version V1.0.0</span><span class="hljs-comment">  * @date    2023.03.16</span><span class="hljs-comment">  * @author  Kayoung</span><span class="hljs-comment">  * @brief   IAP EEPROM 相关功能</span><span class="hljs-comment">  * @details  </span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  * @attention </span><span class="hljs-comment">  ******************************************************************************</span><span class="hljs-comment">  */</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;eeprom.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;intrins.h&quot;</span></span><span class="hljs-comment">/* 定义一个存储数据数组 */</span><span class="hljs-type">uint16_t</span> eeprom_save[TOTAL_ITEM] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//注意：每个数据两字节</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  关闭IAP功能</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;IAP_CONTR = <span class="hljs-number">0</span>;IAP_CMD = <span class="hljs-number">0</span>;IAP_TRIG = <span class="hljs-number">0</span>;IAP_ADDRH = <span class="hljs-number">0xff</span>;IAP_ADDRL = <span class="hljs-number">0xff</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  擦除某地址所在的扇区</span><span class="hljs-comment">  * @param  addr：待擦除扇区地址</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_erase</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span>&#123;IAP_CONTR = IAP_EN | IAP_TIMEOUT_12M;<span class="hljs-comment">//允许IAP操作，设置IAP操作速度         </span>IAP_CMD = IAP_CMD_SECTOR_ERASE;<span class="hljs-comment">//扇区擦除命令            </span>IAP_ADDRL = addr;              IAP_ADDRH = addr &gt;&gt; <span class="hljs-number">8</span>;<span class="hljs-comment">//地址赋值          </span>IAP_TRIG = IAP_TRIG_FIRST;                IAP_TRIG = IAP_TRIG_SECOND;<span class="hljs-comment">//触发命令               </span>_nop_();_nop_();         iap_disable();<span class="hljs-comment">//清空IAP操作寄存器等</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  在某地址写入一个字节</span><span class="hljs-comment">  * @param  addr: 地址</span><span class="hljs-comment">  * @paramdat： 待写入的一字节数据指针</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_wr_byte</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr,<span class="hljs-type">uint8_t</span>* dat)</span>&#123;IAP_CONTR = IAP_EN | IAP_TIMEOUT_12M;<span class="hljs-comment">//允许IAP操作，设置IAP操作速度   </span>IAP_CMD = IAP_CMD_BYTE_WR;<span class="hljs-comment">//IAP写命令</span>IAP_ADDRL = addr;IAP_ADDRH = addr &gt;&gt; <span class="hljs-number">8</span>;<span class="hljs-comment">//地址赋值</span>IAP_DATA = *dat;<span class="hljs-comment">//更新写寄存器</span>IAP_TRIG = IAP_TRIG_FIRST;IAP_TRIG = IAP_TRIG_SECOND;<span class="hljs-comment">//触发</span>_nop_();iap_disable();<span class="hljs-comment">//清空IAP操作寄存器等</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  读取某地址一个字节</span><span class="hljs-comment">  * @param  addr: 地址</span><span class="hljs-comment">  * @param  dat： 待读取的一字节数据指针</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_rd_byte</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint8_t</span>* dat)</span>&#123;IAP_CONTR = IAP_EN | IAP_TIMEOUT_12M;<span class="hljs-comment">//允许IAP</span>IAP_CMD = IAP_CMD_BYTE_RD;<span class="hljs-comment">//IAP读命令</span>IAP_ADDRL = addr;IAP_ADDRH = addr &gt;&gt; <span class="hljs-number">8</span>;<span class="hljs-comment">//地址赋值</span>IAP_TRIG = IAP_TRIG_FIRST;IAP_TRIG = IAP_TRIG_SECOND;<span class="hljs-comment">//触发</span>_nop_();_nop_();*dat = IAP_DATA;iap_disable();<span class="hljs-comment">//清空IAP操作寄存器等</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  读取eeprom存储的参数</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_rd_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> tmp_h = <span class="hljs-number">0</span>, tmp_l = <span class="hljs-number">0</span>; <span class="hljs-comment">//临时变量</span><span class="hljs-type">uint8_t</span> i;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; TOTAL_ITEM; i++)&#123;iap_rd_byte(IAP_ADDR_SECTOR_0 + <span class="hljs-number">2</span>*i, &amp;tmp_l);iap_rd_byte(IAP_ADDR_SECTOR_0 + <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>, &amp;tmp_h);eeprom_save[i] = tmp_h &lt;&lt; <span class="hljs-number">8</span> | tmp_l; <span class="hljs-comment">//EEPROM中每两个字节组成一个数据</span>&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  存储数据到eeprom</span><span class="hljs-comment">  * @param  void</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">iap_wr_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> tmp_h = <span class="hljs-number">0</span>, tmp_l = <span class="hljs-number">0</span>; <span class="hljs-comment">//临时变量</span><span class="hljs-type">uint8_t</span> i;<span class="hljs-comment">/* 保存之前，擦除当前需要保存数据的扇区 */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; TOTAL_ITEM; i++)&#123;<span class="hljs-keyword">if</span>(eeprom_save[i] != <span class="hljs-number">0xffff</span>)&#123;iap_erase(IAP_ADDR_SECTOR_0);<span class="hljs-comment">//擦除eeprom 1st sector</span><span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">/* 存储数据到eeprom */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; TOTAL_ITEM; i++)&#123;        <span class="hljs-comment">/* 擦除完EEPROM，每个字节数据都是0xff*/</span><span class="hljs-keyword">if</span>(eeprom_save[i] == <span class="hljs-number">0xffff</span>)eeprom_save[i] = <span class="hljs-number">0</span>;tmp_h = eeprom_save[i] / <span class="hljs-number">256</span>;tmp_l = eeprom_save[i] % <span class="hljs-number">256</span>;iap_wr_byte(IAP_ADDR_SECTOR_0 + <span class="hljs-number">2</span>*i, &amp;tmp_l);iap_wr_byte(IAP_ADDR_SECTOR_0 + <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>, &amp;tmp_h);&#125;&#125;</code></pre></div><p>程序附件 <a href="https://gitee.com/kayoungzhang/my_codehub.git">iap_eeprom</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于LCD1602的程序开发</title>
    <link href="/2023/04/26/%E5%85%B3%E4%BA%8ELCD1602%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <url>/2023/04/26/%E5%85%B3%E4%BA%8ELCD1602%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>LCD1602字符型显示屏在单片机程序开发中作为显示输出的器件，因为简单，成本低，被大量应用。在我们平时开发调试过程中，除了串口printf可以输出信息外，其实，LCD1602一样可以作为调试工具，用来输出一些重要信息。下面详细介绍一下它的程序设计。</p><h3 id="lcd1602引脚信号">1. LCD1602引脚信号</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426170209080.png" alt="image-20230426170209080" style="zoom: 67%;" /></p><h3 id="基本操作时序">2. 基本操作时序</h3><ul><li>读状态：RS = L，RW = H， E = H</li><li>写指令：RS = L，RW = L， D0~D7 = 指令码， E = 下降沿</li><li>读数据：RS = H，RW = H， E = H</li><li>写数据：RS = H，RW = L， D0~D7 = 数据， E = 下降沿</li></ul><p>（H：高电平，L：低电平）</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426172246464.png" alt="image-20230426172246464" style="zoom: 67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426172326018.png" alt="image-20230426172326018" style="zoom:67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426172355403.png" alt="image-20230426172355403" style="zoom:67%;" /></p><h3 id="内部地址ram映射表">3. 内部地址RAM映射表</h3><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426171931946.png" alt="image-20230426171931946"  /></p><h3 id="lcd1602指令码">4. LCD1602指令码</h3><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230426184139175.png" alt="" /><figcaption>image-20230426184139175</figcaption></figure><h3 id="程序实现">5.程序实现</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LCD1602_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1602_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC15.H&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>  <span class="hljs-type">uint32_t</span>;<span class="hljs-comment">/* 引脚定义 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1602_RSP26</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1602_ENP27</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1602_WRP25</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD1602_DATAP0</span><span class="hljs-comment">/* LCD1602指令码 */</span><span class="hljs-comment">/* 1. Clear Display */</span>  <span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_CLEAR0x01</span><span class="hljs-comment">/* 2. Return Home */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  CURSOR_RETURN0x02</span><span class="hljs-comment">/* 3. Entry Mode Set */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  AC_INCREMENT0x06</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  AC_DECREMENT       0x04</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_SHIFT_ON    0x05</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_SHIFT_OFF    0x04</span><span class="hljs-comment">/* 4. Display On/Off Control */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_ON0x0c</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  CURSOR_ON    0x0a</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  CURSOR_BLINK0x09</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISP_OFF0x08</span><span class="hljs-comment">/* 5. Cursor or Display Shift */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  CURSOR_SHIFT_LEFT   0x10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  CURSOR_SHIFT_RIGHT 0x14</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_SHIFT_LEFT 0x18</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_SHIFT_RIGHT 0x1c</span><span class="hljs-comment">/* 6. Function Set */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DATA_LENGTH_4   0x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DATA_LENGTH_8   0x30</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_ONE_LINE 0x20  </span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DISP_TWO_LINE 0x28</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DOT_FONT_5X8    0x20</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DOT_FONT_5X10   0x24</span><span class="hljs-comment">/* 数据地址AC */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA_ADDR_ROW_ONE  0x80</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATA_ADDR_ROW_TWO  0xc0</span><span class="hljs-comment">/* 函数声明 */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showchar</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint8_t</span> wr_char)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showstring</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint8_t</span>* p_wr_string)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_shownum</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_show_signednum</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">int</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showhex</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showbin</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_dip_shift</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_clear</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ************************************************</span><span class="hljs-comment">  * @file    lcd1602.c</span><span class="hljs-comment">  * @authorKayoung</span><span class="hljs-comment">  * @versionV1.0</span><span class="hljs-comment">  * @date20220326</span><span class="hljs-comment">  * @briefLCD1602显示驱动</span><span class="hljs-comment">  **********************************************</span><span class="hljs-comment">  */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lcd1602.h&quot;</span></span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">delay1ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j;i = <span class="hljs-number">2</span>;j = <span class="hljs-number">199</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">delay300ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;i = <span class="hljs-number">13</span>;j = <span class="hljs-number">156</span>;k = <span class="hljs-number">83</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">while</span> (--k);&#125; <span class="hljs-keyword">while</span> (--j);&#125; <span class="hljs-keyword">while</span> (--i);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brieflcd1602写命令</span><span class="hljs-comment">  * @paramcommand：命令</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_wr_com</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> command)</span>&#123;LCD1602_RS = <span class="hljs-number">0</span>;LCD1602_WR = <span class="hljs-number">0</span>;LCD1602_DATA = command;LCD1602_EN = <span class="hljs-number">1</span>;delay1ms();<span class="hljs-comment">//根据timing，延时1ms，确保命令写到命令端口上</span>LCD1602_EN = <span class="hljs-number">0</span>;delay1ms();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brieflcd1602写数据</span><span class="hljs-comment">  * @paramwr_data: 待写入的数据</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_wr_data</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> wr_data)</span>&#123;LCD1602_RS = <span class="hljs-number">1</span>;LCD1602_WR = <span class="hljs-number">0</span>;LCD1602_DATA = wr_data;LCD1602_EN = <span class="hljs-number">1</span>;delay1ms();LCD1602_EN = <span class="hljs-number">0</span>;delay1ms();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brieflcd1602初始化</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;lcd1602_wr_com(DATA_LENGTH_8 | DISP_TWO_LINE); <span class="hljs-comment">//16x2显示模式，5x7点阵，8位数据接口</span>lcd1602_wr_com(DISP_ON); <span class="hljs-comment">//开显示，不显示光标</span>lcd1602_wr_com(AC_INCREMENT); <span class="hljs-comment">//写一个字符后，AC加1</span>lcd1602_wr_com(DISP_CLEAR); <span class="hljs-comment">//显示清零</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief确定光标位置</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_set_cursor</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column)</span>&#123;<span class="hljs-comment">/* 确定位置 */</span><span class="hljs-keyword">if</span>(row == <span class="hljs-number">1</span>)&#123;lcd1602_wr_com(DATA_ADDR_ROW_ONE | (column - <span class="hljs-number">1</span>)); &#125;<span class="hljs-keyword">else</span>&#123;lcd1602_wr_com(DATA_ADDR_ROW_TWO | (column - <span class="hljs-number">1</span>));&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示一个字符</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  wr_char：待写入的字符</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showchar</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint8_t</span> wr_char)</span>&#123;lcd1602_set_cursor(row, column);<span class="hljs-comment">/* 写入数据 */</span>lcd1602_wr_data(wr_char);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示字符串</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  p_wr_string：待写入的字符串指针</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showstring</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint8_t</span>* p_wr_string)</span>&#123;lcd1602_set_cursor(row, column);<span class="hljs-keyword">while</span>((*p_wr_string) != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;lcd1602_wr_data(*p_wr_string++);&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief指数函数</span><span class="hljs-comment">  * @parambase: 底数</span><span class="hljs-comment">  * @paramindex：幂指数</span><span class="hljs-comment">  * @retvalresult：结果</span><span class="hljs-comment">  */</span><span class="hljs-type">int</span> <span class="hljs-title function_">lcd_pow</span><span class="hljs-params">(base, index)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-comment">//循环变量</span><span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; index; i++)&#123;result *= base;&#125;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示一个数字</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  num：待写入的数(0~65535)</span><span class="hljs-comment">  * @param  num_length: 数的位数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_shownum</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//循环变量</span>lcd1602_set_cursor(row, column);<span class="hljs-comment">/* 显示各位数字字符 */</span><span class="hljs-keyword">for</span>(i = num_length; i &gt; <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-comment">/* 根据规律，每次循环，得出其中的一位 */</span>lcd1602_wr_data((num / lcd_pow(<span class="hljs-number">10</span>, (i<span class="hljs-number">-1</span>)) % <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//转换成数字字符</span>&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示一个带符号数字</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  num：待写入的数</span><span class="hljs-comment">  * @param  num_length: 数的位数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_show_signednum</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">int</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//循环变量</span><span class="hljs-type">uint32_t</span> num_temp;<span class="hljs-comment">//无符号临时变量，存储有符号数字</span>lcd1602_set_cursor(row, column);<span class="hljs-comment">/* 判断是否是带符号数字 */</span><span class="hljs-keyword">if</span>(num &gt;= <span class="hljs-number">0</span>)&#123;lcd1602_wr_data(<span class="hljs-string">&#x27;+&#x27;</span>);num_temp = num;&#125;<span class="hljs-keyword">else</span>&#123;lcd1602_wr_data(<span class="hljs-string">&#x27;-&#x27;</span>);num_temp = -num;&#125;<span class="hljs-comment">/* 显示各位数字字符 */</span><span class="hljs-keyword">for</span>(i = num_length; i &gt; <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-comment">/* 根据规律，每次循环，得出其中的一位 */</span>lcd1602_wr_data((num_temp / lcd_pow(<span class="hljs-number">10</span>, (i<span class="hljs-number">-1</span>)) % <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//转换成数字字符</span>&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示十六进制数</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  num：待写入的数</span><span class="hljs-comment">  * @param  num_length: 数的位数</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showhex</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-comment">//循环变量</span><span class="hljs-type">uint8_t</span> single_num; <span class="hljs-comment">//存储单个位数</span>lcd1602_set_cursor(row, column);<span class="hljs-comment">/* 显示各位数字字符 */</span><span class="hljs-keyword">for</span>(i = num_length; i &gt; <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-comment">/* 根据规律，每次循环，得出其中的一位 */</span>single_num = num / lcd_pow(<span class="hljs-number">16</span>, (i<span class="hljs-number">-1</span>)) % <span class="hljs-number">16</span>;<span class="hljs-keyword">if</span>(single_num &lt; <span class="hljs-number">10</span>)<span class="hljs-comment">//0~9</span>&#123;lcd1602_wr_data(single_num + <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//转换成数字字符</span>&#125;<span class="hljs-keyword">else</span>  <span class="hljs-comment">//A~F</span>&#123;lcd1602_wr_data(single_num + <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">10</span>); <span class="hljs-comment">//转换成数字字符</span>&#125;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief显示一个数的二进制</span><span class="hljs-comment">  * @paramrow: 行（1~2）</span><span class="hljs-comment">  * @param  column：列（1~16）</span><span class="hljs-comment">  * @param  num：待写入的数(0~65535)</span><span class="hljs-comment">  * @param  num_length: 数的位数（8或16）</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_showbin</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> row, <span class="hljs-type">uint8_t</span> column, <span class="hljs-type">uint32_t</span> num, <span class="hljs-type">uint8_t</span> num_length)</span>&#123;<span class="hljs-type">uint8_t</span> i; <span class="hljs-comment">//循环变量</span>lcd1602_set_cursor(row, column);<span class="hljs-comment">/* 显示各位数字字符 */</span><span class="hljs-keyword">for</span>(i = num_length; i &gt; <span class="hljs-number">0</span>; i--)&#123;<span class="hljs-comment">/* 根据规律，每次循环，得出其中的一位 */</span>lcd1602_wr_data((num / lcd_pow(<span class="hljs-number">2</span>, (i<span class="hljs-number">-1</span>)) % <span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//转换成数字字符</span>&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief lcd1602屏幕移动</span><span class="hljs-comment">  * @param None</span><span class="hljs-comment">  * @retval  None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_dip_shift</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;lcd1602_wr_com(DISP_SHIFT_LEFT);delay300ms();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brieflcd1602清屏</span><span class="hljs-comment">  * @paramNone</span><span class="hljs-comment">  * @retvalNone</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">lcd1602_clear</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;lcd1602_wr_com(DISP_CLEAR);&#125;</code></pre></div><p>在 main函数中，根据需要调用这些接口函数，即可完成相应的功能。</p><p>代码已上传码云： <a href="https://gitee.com/kayoungzhang/my_codehub.git">lcd1602</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora数学公式格式编辑汇总</title>
    <link href="/2023/04/24/Typora%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%A0%BC%E5%BC%8F%E7%BC%96%E8%BE%91%E6%B1%87%E6%80%BB/"/>
    <url>/2023/04/24/Typora%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%A0%BC%E5%BC%8F%E7%BC%96%E8%BE%91%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>在Typora编辑中，会经常使用到数学公式，以下总结常用的公式编辑语法。</p><h4 id="常用符号">常用符号</h4><table><thead><tr class="header"><th>类型及语法</th><th>显示</th><th>类型及语法</th><th>显示</th></tr></thead><tbody><tr class="odd"><td>上标 a^2</td><td><span class="math inline">\(a^2\)</span></td><td>下标 A_2</td><td><span class="math inline">\(A_2\)</span></td></tr><tr class="even"><td>正负号 2 \pm 3</td><td><span class="math inline">\(2 \pm 3\)</span></td><td>分式 \frac{1}{2}</td><td><span class="math inline">\(\frac{1}{2}\)</span></td></tr><tr class="odd"><td>根号 \sqrt[6]{2}</td><td><span class="math inline">\(\sqrt[6]{2}\)</span></td><td>水平线 \overline{a+b}=\underline{b+c}</td><td><span class="math inline">\(\overline{a+b}=\underline{b+c}\)</span></td></tr><tr class="even"><td>对数 \log_28</td><td><span class="math inline">\(log_28\)</span></td><td>矢量 \vec{a}</td><td><span class="math inline">\(\vec{a}\)</span></td></tr><tr class="odd"><td>上方箭头 \overleftarrow{x}</td><td><span class="math inline">\(\overleftarrow{x}\)</span></td><td>三角函数 \sin{\theta}</td><td><span class="math inline">\(\sin{\theta}\)</span></td></tr><tr class="even"><td>并集 A \bigcup B</td><td><span class="math inline">\(A \bigcup B\)</span></td><td>交集 A \bigcap B</td><td><span class="math inline">\(A \bigcap B\)</span></td></tr><tr class="odd"><td>属于 A \in B</td><td><span class="math inline">\(A \in B\)</span></td><td>异或 A \oplus B</td><td><span class="math inline">\(A \oplus B\)</span></td></tr><tr class="even"><td>同或 A \odot B</td><td><span class="math inline">\(A \odot B\)</span></td><td>存在 \exists</td><td><span class="math inline">\(\exists\)</span></td></tr><tr class="odd"><td>任意 \forall</td><td><span class="math inline">\(\forall\)</span></td><td>分隔符 \vert-2 \vert</td><td><span class="math inline">\(\vert-2 \vert\)</span></td></tr><tr class="even"><td>单空格 A \ B</td><td><span class="math inline">\(A \ B\)</span></td><td>Tab空格 A \quad B</td><td><span class="math inline">\(A \quad B\)</span></td></tr><tr class="odd"><td>多空格 A \qquad B</td><td><span class="math inline">\(A \qquad B\)</span></td><td>换行 A <code>\\</code> B</td><td>A<br />B</td></tr><tr class="even"><td>不定积分 \int{x}dx</td><td><span class="math inline">\(\int{x}dx\)</span></td><td>不等号 2 \neq 3</td><td><span class="math inline">\(2 \neq 3\)</span></td></tr><tr class="odd"><td>小于或等于 3 \leq 6</td><td><span class="math inline">\(3 \leq 6\)</span></td><td>大于或等于 8 \geq 3</td><td><span class="math inline">\(8 \geq 3\)</span></td></tr><tr class="even"><td>约等于 2.1 \approx 2</td><td><span class="math inline">\(2.1 \approx 2\)</span></td><td>水平双向箭头 \Longleftrightarrow</td><td><span class="math inline">\(\Longleftrightarrow\)</span></td></tr><tr class="odd"><td>水平单箭头 \longrightarrow</td><td><span class="math inline">\(\longrightarrow\)</span></td><td>水平双箭头 \Longleftarrow</td><td><span class="math inline">\(\Longleftarrow\)</span></td></tr><tr class="even"><td>箭头带字 A \xrightarrow{加热} B</td><td><span class="math inline">\(A \xrightarrow{加热} B\)</span></td><td>大号的括号 \left( \right)</td><td>$( ) $</td></tr><tr class="odd"><td>角度 \angle</td><td><span class="math inline">\(\angle\)</span></td><td>因为符 \because</td><td><span class="math inline">\(\because\)</span></td></tr><tr class="even"><td>所以符 \therefore</td><td><span class="math inline">\(\therefore\)</span></td><td>垂直符 \bot</td><td><span class="math inline">\(\bot\)</span></td></tr><tr class="odd"><td>字体大小\large A \small A</td><td><span class="math inline">\(\large A \small A\)</span></td><td>转义符 \ \</td><td>\</td></tr></tbody></table><p><strong>注意：如果上下标级联，需要{}括起来</strong></p><h4 id="希腊字母">希腊字母</h4><table><thead><tr class="header"><th>大写</th><th>Typora语法</th><th>小写</th><th>Typora语法</th><th>大写</th><th>Typora语法</th><th>小写</th><th>Typora语法</th></tr></thead><tbody><tr class="odd"><td>A</td><td>A</td><td>α</td><td>\alpha</td><td>Ω</td><td>\Omega</td><td>ω</td><td>\omega</td></tr><tr class="even"><td>B</td><td>B</td><td>β</td><td>\beta</td><td>Ψ</td><td>\Psi</td><td>ψ</td><td>\psi</td></tr><tr class="odd"><td>Γ</td><td>\Gamma</td><td>γ</td><td>\gamma</td><td>X</td><td>X</td><td>χ</td><td>\chi</td></tr><tr class="even"><td>Δ</td><td>\Delta</td><td>δ</td><td>\delta</td><td>φ</td><td>\varphi</td><td></td><td></td></tr><tr class="odd"><td>E</td><td>E</td><td>ϵ</td><td>\epsilon</td><td>Φ</td><td>\Phi</td><td>ϕ</td><td>\phi</td></tr><tr class="even"><td>ε</td><td>\varepsilon</td><td></td><td></td><td>Υ</td><td>\Upsilon</td><td>υ</td><td>\upsilon</td></tr><tr class="odd"><td>Z</td><td>Z</td><td>ζ</td><td>\zeta</td><td>T</td><td>T</td><td>τ</td><td>\tau</td></tr><tr class="even"><td>H</td><td>H</td><td>η</td><td>\eta</td><td>Σ</td><td>\Sigma</td><td>σ</td><td>\sigma</td></tr><tr class="odd"><td>Θ</td><td>\Theta</td><td>θ</td><td>\theta</td><td>P</td><td>P</td><td>ρ</td><td>\rho</td></tr><tr class="even"><td>I</td><td>I</td><td>ι</td><td>\iota</td><td>Π</td><td>\Pi</td><td>π</td><td>\pi</td></tr><tr class="odd"><td>K</td><td>K</td><td>κ</td><td>\kappa</td><td>O</td><td>O</td><td>ο</td><td>\omicron</td></tr><tr class="even"><td>Λ</td><td>\Lambda</td><td>λ</td><td>\lambda</td><td>Ξ</td><td>\Xi</td><td>ξ</td><td>\xi</td></tr><tr class="odd"><td>M</td><td>M</td><td>μ</td><td>\mu</td><td>N</td><td>N</td><td>ν</td><td>\nu</td></tr></tbody></table><h4 id="复杂表达式">复杂表达式</h4><p><strong>求和</strong> \sum_{n=1}^{100} {a_n}<br /><span class="math display">\[\sum_{n=1}^{100} {a_n}\]</span> <strong>累乘</strong> \prod_{n=1}^{199} {x_n} <span class="math display">\[\prod_{n=1}^{199} {x_n}\]</span> <strong>定积分</strong> \int_{1}^{2}xdx<br /><span class="math display">\[\int_{1}^{2}xdx\]</span> <strong>极限</strong> \lim_{n\rightarrow + \infty} {(a+b)}<br /><span class="math display">\[\lim_{n\rightarrow + \infty}{(a+b)}\]</span></p><p><strong>矩阵</strong></p><div class="code-wrapper"><pre><code class="hljs livescript">a = <span class="hljs-string">\left[\matrix&#123;\alpha_1</span> &amp; test1<span class="hljs-string">\\</span> <span class="hljs-string">\alpha_2</span> &amp; test2<span class="hljs-string">\\</span> <span class="hljs-string">\alpha_3</span> &amp; test3 &#125;<span class="hljs-string">\right]</span></code></pre></div><p><span class="math display">\[a = \left[\matrix{\alpha_1 &amp; test1\\ \alpha_2 &amp; test2\\ \alpha_3 &amp; test3 }\right]\]</span> <strong>行列式</strong></p><div class="code-wrapper"><pre><code class="hljs livescript">X=<span class="hljs-string">\left|</span><span class="hljs-string">\begin&#123;matrix&#125;</span>x_&#123;<span class="hljs-number">11</span>&#125; &amp; x_&#123;<span class="hljs-number">12</span>&#125; &amp; <span class="hljs-string">\cdots</span> &amp; x_&#123;<span class="hljs-number">1d</span>&#125;<span class="hljs-string">\\</span>x_&#123;<span class="hljs-number">21</span>&#125; &amp; x_&#123;<span class="hljs-number">22</span>&#125; &amp; <span class="hljs-string">\cdots</span> &amp; x_&#123;<span class="hljs-number">2d</span>&#125;<span class="hljs-string">\\</span><span class="hljs-string">\vdots</span> &amp; <span class="hljs-string">\vdots</span> &amp; <span class="hljs-string">\ddots</span> &amp; <span class="hljs-string">\vdots</span> <span class="hljs-string">\\</span>x_&#123;<span class="hljs-number">11</span>&#125; &amp; x_&#123;<span class="hljs-number">12</span>&#125; &amp; <span class="hljs-string">\cdots</span> &amp; x_&#123;<span class="hljs-number">1d</span>&#125;<span class="hljs-string">\\</span><span class="hljs-string">\end&#123;matrix&#125;</span><span class="hljs-string">\right|</span> <span class="hljs-string">\tag&#123;2-3&#125;</span></code></pre></div><p><span class="math display">\[X=\left|    \begin{matrix}        x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\\        x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d}\\        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\        x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\\    \end{matrix}\right| \tag{2-3}\]</span> <strong>分段函数</strong></p><div class="code-wrapper"><pre><code class="hljs excel">f(<span class="hljs-built_in">n</span>)=\begin&#123;cases&#125;<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>, &amp; \text&#123;<span class="hljs-built_in">if</span> $<span class="hljs-built_in">n</span>$ is <span class="hljs-built_in">even</span>&#125;\\<span class="hljs-number">3</span><span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>,&amp; \text&#123;<span class="hljs-built_in">if</span> $<span class="hljs-built_in">n</span>$ is <span class="hljs-built_in">odd</span>&#125;\end&#123;cases&#125;</code></pre></div><p><span class="math display">\[f(n)=    \begin{cases}        n/2, &amp; \text{if $n$ is even}\\        3n+1,&amp; \text{if $n$ is odd}    \end{cases}\]</span> <strong>方程组</strong></p><div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-string">\left\&#123;</span><span class="hljs-string">\begin&#123;array&#125;&#123;c&#125;</span>a_1x+b_1y+c_1z=d_1<span class="hljs-string">\\</span>a_2x+b_2y+c_2z=d_2<span class="hljs-string">\\</span>a_3x+b_3y+c_3z=d_3<span class="hljs-string">\end&#123;array&#125;</span><span class="hljs-string">\right.</span> <span class="hljs-string">\tag&#123;1-1&#125;</span></code></pre></div><p><span class="math display">\[\left\{    \begin{array}{c}        a_1x+b_1y+c_1z=d_1\\        a_2x+b_2y+c_2z=d_2\\        a_3x+b_3y+c_3z=d_3    \end{array}\right. \tag{1-1}\]</span> 其它复杂的数学公式可直接在线编辑。</p><h4 id="在线编辑器">在线编辑器</h4><p><a href="https://www.latexlive.com/home">LaTeX公式编辑器</a></p><p><a href="http://www.hostmath.com/">The Equation Editor</a></p><h4 id="参考链接">参考链接</h4><p><a href="https://blog.csdn.net/alwaysrun/article/details/115830269">Typora使用简介与插入数学公式</a></p><p><a href="https://zhuanlan.zhihu.com/p/261750408">Typora数学公式汇总（Markdown）</a></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PID理论及程序实现</title>
    <link href="/2023/04/24/PID%E7%90%86%E8%AE%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/04/24/PID%E7%90%86%E8%AE%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="pid控制的概念">PID控制的概念</h3><hr /><p>PID 控制的整体框图：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230424111806125.png" alt="image-20230424111806125" style="zoom:80%;" /></p><p>PID是 <strong>P</strong>roportion <strong>I</strong>ntegration <strong>D</strong>ifferentiation 的缩写，由<strong>比例项（Proportion ）</strong>，<strong>积分项（Integration ）</strong>，<strong>微分项（Differentiation）</strong> 三个部分组成，具体形式就是下面的公式： <span class="math display">\[U(t) = Kp \{ err(t) + \frac{1}{Ti}*\int_0^t err(t)dt + Td*\frac{derr(t)}{dt} \}\]</span> 其中： <strong>U(t)</strong> 是调节器的输出信号，<strong>err(t)</strong> 是当前值和目标值的偏差， <strong>Kp</strong> 是比例增益， <strong>Ti</strong> 是积分时间， <strong>Td</strong> 是微分时间。</p><p>PID控制其实就是对偏差的控制过程；如果偏差为 0, 则比例环节不起作用，只有存在偏差时，比例环节才起作用；积分环节主要是用来消除静差，所谓静差，就是系统稳定后输出值和设定值之间的差值，积分环节实际上就是偏差累计的过程，把累计的误差加到原有系统上以抵消系统造成的静差；而微分信号则反应了偏差信号的变化规律，也可以说是变化趋势，根据偏差信号的变化趋势来进行超前调节，从而增加了系统的预知性。</p><p><strong>比例项</strong>：某时刻误差值,代表着现在,表明现在预设值与实际的偏差。 <strong>积分项</strong>：所有时刻误差和,代表着过去，是过去Ti时间内的偏差积累，可以减少震荡。 <strong>微分项</strong>：某时刻误差变化率,代表着未来，可以超前预测并提出控制。</p><h3 id="pid的离散化公式">PID的离散化公式</h3><hr /><p>在数字系统中进行PID算法控制，需要对上述公式进行离散化，然后才好进行程序设计，从而得到： <span class="math display">\[U(k) = Kp*e(k) + \frac{Kp*T}{Ti}\sum_{n=0}^k e(n)+ \frac{Kp*Td}{T}(e(k)-e(k-1))\]</span> 其中：<strong>e(k)</strong> 是当前值和目标值的偏差， <strong>Kp</strong> 是比例增益， <strong>T</strong> 是控制周期，<strong>Ti</strong> 是积分时间， <strong>Td</strong> 是微分时间。</p><p>为了方便起见，将这些系数进行统一: <span class="math display">\[比例系数Kp= Kp;\ 积分系数Ki = \frac{Kp*T}{Ti};\ 微分系数Kd = \frac{Kp*Td}{T}\]</span> 则得到 <strong>位置式PID</strong> 公式： <span class="math display">\[U(k) = Kp*e(k) + Ki\sum_{n=0}^k e(n)+ Kd*(e(k)-e(k-1))\]</span> 因为 <code>△U(k) = U(k) - U(k-1)</code>，这样得到 <strong>增量式PID</strong> 公式： <span class="math display">\[△U(k) = Kp*(e(k)-e(k-1)) + Ki*e(k) + Kd*(e(k)-2*e(k-1)+e(k-2))\]</span></p><p><span class="math display">\[U(k) = △U(k)+U(k-1)\]</span></p><h3 id="pid算法的c语言实现">PID算法的C语言实现</h3><hr /><p>经过pid算法后得到的输出值，进行处理加工送到执行结构进行系统控制。在温度控制场景中，对于制冷控制，只需要将pid的输出值进行反向处理即可。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 位置式pid和增量式pid的选择 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> POSITION_PID</span><span class="hljs-comment">//#define INCREMENT_PID</span><span class="hljs-comment">/* pid 参数结构体定义 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">float</span> target;  <span class="hljs-comment">//target value 目标值</span><span class="hljs-type">float</span> curr;    <span class="hljs-comment">//current value 当前值</span><span class="hljs-type">float</span> err;     <span class="hljs-comment">//err=tag-cur 偏差值</span><span class="hljs-type">float</span> sum_err; <span class="hljs-comment">//偏差积分和</span><span class="hljs-type">float</span> last_err; <span class="hljs-comment">//上一个偏差值</span><span class="hljs-type">float</span> prev_last_err; <span class="hljs-comment">//上上个偏差值</span><span class="hljs-type">float</span> kp; <span class="hljs-comment">//proportion</span><span class="hljs-type">float</span> ki; <span class="hljs-comment">//integral</span><span class="hljs-type">float</span> kd; <span class="hljs-comment">//differential</span><span class="hljs-type">float</span> limit_integral; <span class="hljs-comment">//积分限幅</span><span class="hljs-type">float</span> limit_output; <span class="hljs-comment">//输出限幅</span><span class="hljs-type">float</span> output;<span class="hljs-comment">//控制输出值</span>&#125;<span class="hljs-type">pid_t</span>;<span class="hljs-comment">/* 限幅处理的宏定义 */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIMIT_MAX(value, max) \</span><span class="hljs-meta">    &#123;                        \</span><span class="hljs-meta"><span class="hljs-keyword">if</span> (value &gt; max)       \</span><span class="hljs-meta">value = max;       \</span><span class="hljs-meta"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; -max) \</span><span class="hljs-meta">value = -max;      \</span><span class="hljs-meta">    &#125;</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  pid初始化</span><span class="hljs-comment">  * @param  pid：pid结构体指针</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">pid_init</span><span class="hljs-params">(<span class="hljs-type">pid_t</span>* pid)</span>&#123;pid-&gt;target = <span class="hljs-number">0</span>;pid-&gt;curr = <span class="hljs-number">0</span>;pid-&gt;kp = <span class="hljs-number">2.3</span>;pid-&gt;ki = <span class="hljs-number">0.5</span>;pid-&gt;kd = <span class="hljs-number">5.6</span>;pid-&gt;err = <span class="hljs-number">0</span>;pid-&gt;last_err = <span class="hljs-number">0</span>;pid-&gt;prev_last_err = <span class="hljs-number">0</span>;pid-&gt;sum_err = <span class="hljs-number">0</span>;pid-&gt;output = <span class="hljs-number">0</span>;pid-&gt;limit_integral = <span class="hljs-number">255</span>;<span class="hljs-comment">//根据pwm输出范围进行设置</span>pid-&gt;limit_output = <span class="hljs-number">255</span>; <span class="hljs-comment">//根据pwm输出范围进行设置</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  pid的运算</span><span class="hljs-comment">  * @param  pid：pid指针</span><span class="hljs-comment">  * @paramcurrent_value：当前值</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">pid_calc</span><span class="hljs-params">(<span class="hljs-type">pid_t</span>* pid, <span class="hljs-type">float</span> current_value)</span>&#123;<span class="hljs-type">float</span> increment = <span class="hljs-number">0</span>;pid-&gt;curr = current_value;pid-&gt;err = pid-&gt;target - pid-&gt;curr;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> POSITION_PID</span><span class="hljs-comment">/* 位置式公式：u(t)=Kp*E(t)+Ki*[E(1)+...+E(t)]+Kd*[E(t)-E(t-1)] */</span>pid-&gt;sum_err += pid-&gt;err;LIMIT_MAX(pid-&gt;sum_err, pid-&gt;limit_integral);<span class="hljs-comment">//积分限幅</span>pid-&gt;output = pid-&gt;kp * pid-&gt;err + pid-&gt;ki * pid-&gt;sum_err + \pid-&gt;kd * (pid-&gt;err - pid-&gt;last_err);<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> INCREMENT_PID</span><span class="hljs-comment">/* 增量式公式：△u(t)=Kp*[E(t)-E(t-1)]+Ki*E(t)+Kd*[E(t)-2*E(t-1)+E(t-2)] */</span>increment = pid-&gt;kp * (pid-&gt;err - pid-&gt;last_err) + pid-&gt;ki * pid-&gt;err + \pid-&gt;kd * (pid-&gt;err - <span class="hljs-number">2</span> * pid-&gt;last_err + pid-&gt;prev_last_err);pid-&gt;output += increment;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>LIMIT_MAX(pid-&gt;output, pid-&gt;limit_output);<span class="hljs-comment">//输出限幅</span>pid-&gt;last_err = pid-&gt;err;pid-&gt;prev_last_err = pid-&gt;last_err;<span class="hljs-keyword">return</span> pid-&gt;output;&#125;</code></pre></div><h3 id="pid调试">PID调试</h3><hr /><p>借助<a href="https://serialplot.ozderya.net/downloads/serialplot-0.12.0-win32.exe">SerialPlot工具</a>使用printf函数将目标值和实时值图形显示处理，调节不同的Kp，Ki和Kd，可以很方便的进行调试。</p><h4 id="位置式pid调节">位置式PID调节</h4><p>位置型PID的参数整定过程一般是，先整定KP，然后整定KI，最后整定KD；</p><p>参数整定找最佳，从小到大顺序查 先是比例后积分，最后再把微分加 曲线振荡很频繁，比例度盘要放大(Kp减小) 曲线漂浮绕大湾，比例度盘往小扳(Kp增大) 曲线偏离回复慢，积分时间往下降(Ki增大) 曲线波动周期长，积分时间再加长(Ki减小) 曲线振荡频率快，先把微分降下来(Kd增大) 动差大来波动慢。微分时间应加长(Kd减小) 理想曲线两个波，前高后低4比1 一看二调多分析，调节质量不会低</p><h4 id="增量式pid调节">增量式pid调节</h4><p>增量型PID应该先整定Ki，然后整定Kd，最后整定Kp。这一点需要特别注意，弄错顺序的话会发现整定规律完全不适用的。<strong>网上大多数资料把增量式跟位置式混为一谈</strong></p><h3 id="参考链接">参考链接</h3><p><a href="https://blog.csdn.net/qq_25352981/article/details/81007075?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168231970816800192213769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168231970816800192213769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-81007075-null-null.142%5Ev86%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=pid&amp;spm=1018.2226.3001.4187">一文读懂PID控制算法（抛弃公式，从原理上真正理解PID控制）</a></p><p><a href="https://blog.csdn.net/skythinker616/article/details/123019829?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168231970816800192213769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168231970816800192213769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123019829-null-null.142%5Ev86%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=pid&amp;spm=1018.2226.3001.4187">PID超详细教程——PID原理+串级PID+C代码+在线仿真调参</a></p><p><a href="https://blog.csdn.net/qq_45396672/article/details/118057838?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168231970816800192213769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168231970816800192213769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-8-118057838-null-null.142%5Ev86%5Ekoosearch_v1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=pid&amp;spm=1018.2226.3001.4187">图文详解PID调参</a></p><p><a href="https://blog.csdn.net/u010312937/article/details/53363831">PID控制算法的C语言实现</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PID参数的自整定</title>
    <link href="/2023/04/24/PID%E5%8F%82%E6%95%B0%E7%9A%84%E8%87%AA%E6%95%B4%E5%AE%9A/"/>
    <url>/2023/04/24/PID%E5%8F%82%E6%95%B0%E7%9A%84%E8%87%AA%E6%95%B4%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>在某些PID应用场合，不同的对象就得采用不同的参数值，所以需要进行参数自整定。实质就是在首次使用时，通过N次测量得到一套PID参数。具体的整定方法有三种：临界比例度法、衰减曲线法、经验法。三种方法共同点都是通过试验，然后按照工程经验公式对控制器参数进行整定。现在一般采用比较多的是临界比例度法。</p><h4 id="临界比例度法ziegler-nichols">1、临界比例度法（Ziegler-Nichols）</h4><h5 id="操作方法">1.1 操作方法</h5><p>（1）将纯比例控制器接入到闭环控制系统中（设置控制器参数积分时间常数Ti=∞，实际微分时间常数Td=0）。</p><p>（2）由小到大改变比例增益K，直到闭环系统出现持续等幅振荡。此时的增益为临界增益（Ku），振荡周期（波峰间的时间）为临界周期（Tu）。然后根据下表得出PID控制器参数。</p><table><thead><tr class="header"><th>调节规律</th><th>K</th><th>Ti</th><th>Td</th></tr></thead><tbody><tr class="odd"><td><strong>P</strong></td><td>0.5Ku</td><td>-</td><td>-</td></tr><tr class="even"><td><strong>PI</strong></td><td>0.45Ku</td><td>0.85Tu</td><td>-</td></tr><tr class="odd"><td><strong>PD</strong></td><td>0.65Ku</td><td>-</td><td>0.15Tu</td></tr><tr class="even"><td><strong>PID</strong></td><td>0.6Ku</td><td>0.5Tu</td><td>0.125Tu</td></tr></tbody></table><h5 id="计算pid的三个参数值">1.2 计算PID的三个参数值：</h5><p><strong>Kp = K；</strong></p><p>**Ki = Kp*(T/Ti)；**</p><p>**Kd = Kp*(Td/T)；**</p><p>其中： <strong>T</strong> 是采样周期，也叫控制周期，每隔T时间段进行一次PID计算。</p><h5 id="注意事项">1.3 注意事项：</h5><p>（1）应使控制系统工作在线性区，不要使控制阀出现开、关的极端状态，否则得到的持续振荡曲线可能是“极限循环”，从线性系统概念上说系统早已处于发散振荡了。</p><p>（2）由于被控对象特性的不同，应针对具体系统在实际运行过程中对上述求得的控制器参数进行在线校正。</p><p>（3）适用于临界振幅不大、振荡周期较长的过程控制系统，但有些系统用纯比例控制时始终是稳定的，是无法用临界比例度法来进行参数整定的。</p><p>（4）只适用于二阶以上的高阶对象，或一阶加纯滞后的对象，否则，在纯比例控制情况下，系统不会出现等幅振荡。</p><h4 id="衰减曲线法">2、衰减曲线法</h4><h5 id="整定步骤">2.1 整定步骤</h5><p>（1）在纯比例控制器下，置比例增益K为较小值。系统稳定后，作设定值阶跃扰动，观察系统的响应。若系统响应衰减太快，则减小比例增益K；反之，应增大比例增益K。</p><p>（2）直到系统出现如下图（a）所示的4:1衰减振荡过程，记下此时的比例增益Ks及和振荡周期Ts数值。同理，10：1衰减曲线如下图（b）所示。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/v2-68670d44361ce32e7d24f695bd61c62c_720w.webp" alt="" /><figcaption>img</figcaption></figure><p>（3）利用Ks和Ts值，Tr值，按下表给出的经验公式，计算出控制器的参数整定值。</p><table><thead><tr class="header"><th>衰减率</th><th>调节规律</th><th>K</th><th>Ti</th><th>Td</th></tr></thead><tbody><tr class="odd"><td><strong>0.75（0.9）</strong></td><td><strong>P</strong></td><td>Ks</td><td>-</td><td>-</td></tr><tr class="even"><td><strong>0.75（0.9）</strong></td><td><strong>PI</strong></td><td>0.83Ks</td><td>0.5Ts（2Tr）</td><td>-</td></tr><tr class="odd"><td><strong>0.75（0.9）</strong></td><td><strong>PID</strong></td><td>1.25Ks</td><td>0.3TS（1.2Tr）</td><td>0.1Ts（0.4Tr</td></tr></tbody></table><h5 id="注意事项-1">2.2 注意事项</h5><p>（1）加给定干扰不能太大，要根据生产操作要求来定，一般在5%左右，也有例外的情况。</p><p>（2）必须在工艺参数稳定的情况下才能加给定干扰，否则得不到正确的整定参数。</p><p>（3）对于反应快的系统，如流量、管道压力和小容量的液位调节等，要得到严格的4：1衰减曲线较困难，一般以被调参数来回波动两次达到稳定，就近似地认为达到4：1衰减过程了。</p><p>（4）投运时，先将K放在较小的数值，把Ti减少到整定值，把Td逐步放大到整定值，然后把K拉到整定值（如果在K=整定值的条件下很快地把Td放到整定值，控制器的输出会剧烈变化）。</p><h4 id="经验整定法">3、经验整定法</h4><h5 id="方法一">3.1方法一</h5><p>（1）确定比例增益</p><p>使PID为纯比例调节,输入设定为系统允许最大值的60%~70%，由0逐渐加大比例增益至系统出现振荡；再逐渐减小比例增益至系统振荡消失，记录此时的比例增益，则设定PID的比例增益P为当前值的60%~70%。</p><p>（2）确定积分时间常数Ti</p><p>比例增益P确定后，设定一个较大的积分时间常数Ti的初值，逐渐减小Ti至系统出现振荡，之后逐渐加大Ti至振荡消失。记录此时的Ti，则设定PID的积分时间常数Ti为当前值的150%~180%。</p><p>（3）确定积分时间常数Td</p><p>积分时间常数Td一般不用设定，为0即可。若要设定，与确定 P和Ti的方法相同，取不振荡时的30%。</p><p>（4）系统带载联调，再对PID参数进行微调，直至满足要求。</p><h5 id="方法二">3.2 方法二</h5><p>（1）在实际调试中，也可以先大致设定一个经验值，然后根据调节效果修改。</p><p>　　流量系统：P（%）40~100，Ti（分）0.1~1</p><p>　　压力系统：P（%）30~70， Ti（分）0.4~3</p><p>　　液位系统：P（%）20~80， Ti（分）1~5</p><p>　　温度系统：P（%）20~60， Ti（分）3~10，Td（分）0.5~3</p><p>（2）以下整定的口诀：</p><p>阶跃扰动投闭环，参数整定看曲线；先投比例后积分，最后再把微分加；</p><p>理想曲线两个波，振幅衰减4比1；曲线震荡动作繁，微分时间要加长；</p><p>曲线震荡很频繁，比例刻度要放大；曲线漂浮波动大，比例刻度要拉小；</p><p>曲线波动周期长，积分时间要加长；偏离定值回复慢，积分时间往小降。</p><h3 id="参考链接">参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/82344845">详细讲解PID控制</a></p><p><a href="https://www.cnblogs.com/luckytimor/p/6881569.html">PID公式参数</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stc单片机存储器</title>
    <link href="/2023/04/23/stc%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2023/04/23/stc%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>stc单片机存储器结构的主要特点是 <strong>程序存储器</strong> 和 <strong>数据存储器</strong> 是各自独立编址的。单片机内部在物理和逻辑上有三个独立的地址空间：flash ROM(内部集成EEPROM)，片内基本RAM(256字节)和片内扩展RAM(1024字节)。</p><h3 id="程序存储器flash-rom">程序存储器flash ROM：</h3><p>程序存储器用于存放用户程序、数据和表格等信息。内部集成了的EEPROM是与程序空间是分开的，利用ISP/IAP技术可将内部Data Flash当EEPROM。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423212147712.png" alt="image-20230423212147712" style="zoom:67%;" /></p><h3 id="片内基本ram">片内基本RAM：</h3><p>片内基本RAM分低128字节和高128字节。</p><p>低128字节分为三个区：工作寄存器组区、可位寻址区、通用RAM区。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423212429407.png" alt="image-20230423212429407" style="zoom:80%;" /></p><p>高128字节RAM与特殊功能寄存器区貌似共用相同的地址范围，都使用80H~FFH,地址空间虽然貌似重叠，但物理上是独立的，使用时通过不同的寻址方式加以区分。高128字节RAM只能间接寻址，特殊功能寄存器区只可直接寻址。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423212649092.png" alt="image-20230423212649092" style="zoom: 80%;" /></p><h3 id="片内扩展ram">片内扩展RAM：</h3><p>在C语言中，可使用 <strong>xdata</strong> 声明扩展RAM变量存储类型，如 <code>unsigned  char  xdata  i=0;</code>。默认情况下，选择的是片内扩展RAM，当需要访问片外RAM时，EXTRAM必须为1.</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423213425262.png" alt="image-20230423213425262" style="zoom:67%;" /></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423213920633.png" alt="image-20230423213920633" style="zoom: 80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stc</tag>
      
      <tag>存储器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STC12C5A60S2单片机注意事项</title>
    <link href="/2023/04/23/STC12C5A60S2%E5%8D%95%E7%89%87%E6%9C%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/04/23/STC12C5A60S2%E5%8D%95%E7%89%87%E6%9C%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>STC12C5A60S2单片机是stc12系列一款比较经典的MCU，下面对照它的参考手册，摘录其使用时注意事项：</p><ol type="1"><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423184155244.png" alt="image-20230423184155244" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423184511042.png" alt="image-20230423184511042" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423185326975.png" alt="image-20230423185326975" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423190016475.png" alt="image-20230423190016475" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423190316983.png" alt="image-20230423190316983" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423222004968.png" alt="image-20230423222004968" style="zoom: 80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423193706324.png" alt="image-20230423193706324" style="zoom:80%;" /></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423194010351.png" alt="image-20230423194010351" style="zoom:80%;" /></p><ol start="7" type="1"><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423194201742.png" alt="image-20230423194201742" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423194225873.png" alt="image-20230423194225873" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423222448627.png" alt="image-20230423222448627" style="zoom:80%;" /></li><li><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423223648757.png" alt="image-20230423223648757" style="zoom:80%;" /></li></ol><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230423224016123.png" alt="image-20230423224016123" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用命令汇总</title>
    <link href="/2023/04/21/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <url>/2023/04/21/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>Linux开发过程中会经常接触到各种命令，常用的命令它们大致分为：</p><p><strong>文件管理、文档编辑、磁盘管理、系统设备管理、网络通讯、权限管理、其它</strong></p><hr /><p>在详细介绍各种常用命令之前，先了解一下Linux命令行默认显示的部分<code>[root@localhost ~]#</code>：</p><ul><li><p><strong>root</strong>是当前登录的用户</p></li><li><p><strong>localhost</strong>是主机名字</p></li><li><p><strong>~</strong> 表示当前所在的目录(家目录)， <strong>/</strong> 表示根目录</p></li><li><p><strong>#</strong> 是用户标识，表示管理员， <strong>$</strong> 表示普通用户</p></li></ul><hr /><h3 id="文件管理命令">文件管理命令：</h3><div class="code-wrapper"><pre><code class="hljs shell">ls       #查看目录ls -a　　 #列出全部的文件,包括以.开头的隐藏文件ls -l 　 #显示文件和目录的详细资料cd     #切换工作目录cd ~   #切换到家目录cd /   #切换到根目录cd ..  #切换到上一级mkdir abc                 # 在当前目录下新建一个名为abc的文件夹mkdir /usr/abc            #在指定目录下创建一个名为abc的文件夹mkdir -p /usr/file/abc    #在指定目录下创建文件夹abc，并创建父文件夹filetouch abc.txt              #在当前目录创建一个文件abc.txttouch /usr/abc.txt         #在指定目录下创建一个文件abc.txtmv 文件  文件夹          # 移动文件到目标文件夹中mv 文件A 文件B          # 修改文件A的名字为文件B，同样适用于目录名修改mv /usr/tmp /opt       #将/usr目录下的tmp目录剪切到 /opt目录下面cp file1 file2         #在当前目录下把file1复制粘贴为file2 cp /usr/tmp /opt       #将/usr目录下的tmp目录复制到 /opt目录下面cp -r /usr/tmp /opt    #递归剪复制目录中所有文件和文件夹rm rm -f file1　　 #强制删除file1文件rm -rf dir　　     #强制删除dir目录及其子目录下所有文件 rmdir dir　     　 #删除dir空目录（只能删除空目录）find / -name file1          #从根目录下查找file1文件find /bin -name &#x27;a*&#x27;        #查找/bin目录下的所有以a开头的文件或者目录find / -user user1          #搜索属于用户 &#x27;user1&#x27; 的文件和目录 ln log2013.log ln2013       #为log2013.log创建硬链接ln2013，log2013.log与ln2013的各项属性相同ln -s log2013.log link2013  #为log2013.log文件创建软链接link2013</code></pre></div><h3 id="文档编辑命令">文档编辑命令</h3><div class="code-wrapper"><pre><code class="hljs shell">vi 文件名        #打开需要编辑的文件，大多数Linux默认安装了vim编辑工具命令模式（command mode）：-按&quot;i&quot;在光标所在字符前开始插入-按&quot;a&quot;在光标所在字符后开始插入-按&quot;o&quot;在光标所在行的下面另起一新行插入-控制光标移动：↑，↓，j-跳到指定行 &quot;:n&quot; -跳到行首 &quot;gg&quot;-使用命令&quot;dd&quot;删除当前整行-使用命令&quot;/字段&quot;进行查找-按&quot;：&quot;进入底行模式插入模式（Insert mode）：-按&quot;ESC&quot;进入底行模式底行模式（last line mode）：-退出编辑：             :q-强制退出并取消本次修改：  :q!-保存并退出：            :wq或:xcat a.txt          #查看文件最后一屏内容less a.txt         #从第一页开始查看文件内容，PgUp向上翻页，PgDn向下翻页，&quot;q&quot;退出查看more a.txt         #显示百分比，回车查看下一行，空格查看下一页，&quot;q&quot;退出查看tail -10 a.txt    #查看文件的后10行，&quot;Ctrl+C&quot;退出查看head -10 a.txt     #查看文件的前10行，&quot;Ctrl+C&quot;退出查看grep abc test.txt #在test.txt文件中搜索abc字符串，大小写敏感且显示行；grep -n abc test.txt #在test.txt文件中搜索abc字符串，大小写敏感且显示行及行号；grep ^abc /var/test.txt  #在文件中查找以&quot;abc&quot;开始的词汇 grep [0-9] /var/test.txt # 在文件中选择所有包含数字的行 grep abc -R /var/log/*   #在目录 &#x27;/var/log&#x27; 及随后的目录中搜索字符串&quot;abc&quot;</code></pre></div><h3 id="磁盘管理命令">磁盘管理命令</h3><div class="code-wrapper"><pre><code class="hljs shell">du   #显示目录或者文件所占空间du -h test   #以K，M，G为单位显示test目录所占空间情况df -h         #显示文件系统的磁盘使用情况pwd   #查看当前所在目录tree dir           #树形显示dir目录下的所有文件mount /dev/hda1 /mnt  #将 /dev/hda1 挂在 /mnt 之下mount -o ro /dev/hda1 /mnt   #将 /dev/hda1 用唯读模式挂在 /mnt 之下 ， -o rw：用可读写模式挂上umount -v /dev/sda1    #通过设备名卸载sda1umount -v /mnt/mymount/  #通过挂载点卸载dd #命令用于读取、转换并输出数据，uboot应用中会使用到，详情查看手册man ddfdisk -l  #显示当前分区情况fdisk -lu #显示SCSI硬盘的每个分区情况</code></pre></div><h3 id="系统设备管理命令">系统设备管理命令</h3><div class="code-wrapper"><pre><code class="hljs shell">clear         #清屏export -p //列出当前的环境变量值date  #显示当前时间history       #查看历史的输入命令hostname               # 查看主机名uname -a      #显示一些重要的系统信息，例如内核名称、主机名、内核版本号、处理器类型之类的信息 kill id      #杀死该id的进程su 用户名            #切换用户sudo 命令      #以系统管理者的身份执行指令ps -ef        #查看所有正在运行的进程shutdown -h now        #立刻关机shutdown -h 15:30      #到15:30关机shutdown -h 5          #5分钟后关机shutdown -r now        #立刻重启shutdown -r 5          #5分钟后重启reboot                 #立刻重启sleep 5m               #休眠5分钟，时间长度，后面可接 s、m、h 或 dlogout                 #退出系统login                  #使用新的身份登录系统halt   #关闭系统exit                   #退出终端groupadd 组名    #创建组groupdel 组名    #删除组useradd -g 组名 用户名    #创建用户passwd runoob   #设置runoob用户的密码passwd -d lx138   #删除用户密码userdel -r 用户名    #删除用户</code></pre></div><h3 id="权限管理命令">权限管理命令</h3><div class="code-wrapper"><pre><code class="hljs shell">chmod u+x 文件名    # 给文件的所有者添加执行权限chmod o-rwx 文件名  # 给文件的其他人删除所有权限chmod g=wx 文件名   # 给文件的所属组设置读写权限chmod 764 file     #对file的所有者设置读写及可执行权限，对用户组设置读写权限, 为其他用户设置读权限<span class="hljs-meta prompt_">#</span><span class="language-bash">参数说明：u：文件所有者；g:文件所有者所在组；o:其他用户；</span><span class="hljs-meta prompt_">#</span><span class="language-bash">参数说明：+：增加权限；-:去除权限； =:设置权限；</span><span class="hljs-meta prompt_">#</span><span class="language-bash">参数说明：r(4):读权限；w(2):写权限；x(1)：可执行权限；</span></code></pre></div><h3 id="网络通讯">网络通讯</h3><div class="code-wrapper"><pre><code class="hljs shell">systemctl status 服务名       # 服务器管理命令systemctl start 服务名        # 启动服务systemctl restart 服务名      # 重启服务systemctl stop 服务名         # 停止服务systemctl disable 服务名      # 禁止服务随linux启动。systemctl enable 服务名       # 设置服务随linux启动。ifconfig    #显示网络设备信息ifconfig eth0 down   #关闭指定网卡ifconfig eth0 up     #启动指定网卡ifconfig eth0 192.168.1.56   #给eth0网卡配置IP地址netstat -a     #显示详细的网络状况netstat -i     #显示网卡列表netstat -l     #显示监听的套接口ping www.runoob.com    #检测是否与主机连通tty    #显示当前终端ftp 主机名称或IP地址   #匿名登录tftp 218.28.188.288 #连接远程服务器 telnet 192.168.0.5  #登录IP为 192.168.0.5 的远程主机</code></pre></div><h3 id="其它命令">其它命令</h3><div class="code-wrapper"><pre><code class="hljs shell">tar -zcvf a.tar file1 file2,...     #将多个文件压缩打包成a.tartar -zxvf a.tar                      #解包至当前目录tar -zxvf a.tar -C /usr              #指定解压的位置<span class="hljs-meta prompt_"># </span><span class="language-bash">参数说明：z：调用gzip压缩命令进行压缩; x:解压文件; c：打包文件; v：显示运行过程; f：指定文件名</span>whereis ls    #将和ls文件相关的文件都查找出来which bash    #在环境变量$PATH设置的目录里查找指令&quot;bash&quot;的绝对路径ifconfig  --help：     #命令帮助文档，查看网卡信息man shutdown           #man手册，打开命令说明书之后，使用按键q退出</code></pre></div><p><strong>参考链接：</strong></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32 SRAM调试设置</title>
    <link href="/2023/04/20/stm32-SRAM%E8%B0%83%E8%AF%95%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/04/20/stm32-SRAM%E8%B0%83%E8%AF%95%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>我们知道，当程序下载到芯片中，是直接下载到内部的flash区域，在我们写程序的初期阶段，会频繁的进行程序的下载烧录，而flash的擦除和写入是有寿命限制的，当然，我们平时这些几千上万次是无关紧要的，但为了进一步提高它的寿命，其实在调试阶段可以将程序写入SRAM中，这和写入flash中是一样的效果。</p><p>下面简单介绍一下：</p><p>在keil软件中，按下图步骤建立一个调试工程，其下会自动复制工程的所有文件：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230420192151263.png" alt="" /><figcaption>image-20230420192151263</figcaption></figure><p>此时，我们会看到当前的工程名字变成我们刚才设置的名字了。下面进行参数设置：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230420192729247.png" alt="" /><figcaption>image-20230420192729247</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230420193056604.png" alt="" /><figcaption>image-20230420193056604</figcaption></figure><p>然后创建一个SRAM.ini文件，放到工程中，并进行加载设置，文件内容如下：</p><div class="code-wrapper"><pre><code class="hljs bash">/*---------------------------------------------------------------------------- * Name:    Debug_RAM.ini * Purpose: RAM Debug Initialization File * Note(s): *---------------------------------------------------------------------------- * This file is part of the uVision/ARM development tools. * This software may only be used under the terms of a valid, current, * end user licence from KEIL <span class="hljs-keyword">for</span> a compatible version of KEIL software * development tools. Nothing <span class="hljs-keyword">else</span> gives you the right to use this software. * * This software is supplied <span class="hljs-string">&quot;AS IS&quot;</span> without warranties of any kind. * * Copyright (c) 2008-2011 Keil - An ARM Company. All rights reserved. *----------------------------------------------------------------------------*//*----------------------------------------------------------------------------  Setup()  configure PC &amp; SP <span class="hljs-keyword">for</span> RAM Debug *----------------------------------------------------------------------------*/FUNC void Setup (void) &#123;  SP = _RDWORD(0x20000000);          // Setup Stack Pointer  PC = _RDWORD(0x20000004);          // Setup Program Counter  _WDWORD(0xE000ED08, 0x20000000);   // Setup Vector Table Offset Register&#125;FUNC void OnResetExec (void)  &#123;      // executes upon software RESET  Setup();                           // Setup <span class="hljs-keyword">for</span> Running&#125;load %L incrementalSetup();                             // Setup <span class="hljs-keyword">for</span> Runningg, main</code></pre></div><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230420193627116.png" alt="" /><figcaption>image-20230420193627116</figcaption></figure><p>最后，手动设置一下板子上的<strong>BOOT0</strong>和<strong>BOOT1</strong>引脚到高电平，从<strong>SRAM</strong>启动即可。</p><p>参考链接</p><hr /><p><a href="https://www.cnblogs.com/TrueElement/archive/2012/09/11/2680863.html">STM32的SRAM调试</a></p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32 memory的转换计算</title>
    <link href="/2023/04/20/stm32-memory%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/04/20/stm32-memory%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>在stm32开发过程中，会经常考虑到各个外设部分在内存中分配情况，其中就牵扯到内存的计算问题，下面简单了解一下，以下是stm32 f1系列的memory分配情况。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/memory%20map.png" alt="" /><figcaption>memory map</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/memory%20address%E8%AE%A1%E7%AE%97.jpg" alt="" /><figcaption>memory address计算</figcaption></figure><p>可以看出，芯片厂商在分配外设内存区域时，起止地址都是有规律可循的，图上已经标识，所以，通过它的内存起止地址，就可以很方便快速知道某个外设部分的内存分配大小。</p>]]></content>
    
    
    <categories>
      
      <category>stm32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git的使用教程</title>
    <link href="/2023/04/19/git%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2023/04/19/git%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>git 是世界上最先进的开源分布式版本管理工具，相比于svn集中式版本管理工具，git可以让开发人员更加方便的查看和操作项目。</p><h3 id="git安装">1. git安装</h3><p>软件下载：<a href="https://git-scm.com/">git官网</a> 或 <a href="https://npm.taobao.org/mirrors/git-for-windows/">国内镜像</a></p><h3 id="配置本地git标识用户名和邮箱">2. 配置本地git标识(用户名和邮箱)</h3><p>打开 <code>git bash</code>,输入：</p><div class="code-wrapper"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;John Doe&quot;</span>git config --global user.email johndoe@example.com</code></pre></div><p><code>John Doe</code> 替换成你的用户名，<code>johndoe@example.com</code> 替换成你的邮箱。设置这两个信息的原因是在于远程库进行关联时需要一个key，配置这两个信息以确保你的唯一性。</p><p>使用--global参数表明你这台机器上所有的仓库都进行相同的配置。</p><h3 id="git的基本操作">3. git的基本操作</h3><div class="code-wrapper"><pre><code class="hljs bash">git init  <span class="hljs-comment"># 初始化git仓库，会在当前目录生成一个.git隐藏文件夹，不要去修改这个文件夹下的任意东西。</span>git add [file] <span class="hljs-comment">#添加文件到暂存区</span>git commit -m <span class="hljs-string">&quot;填写提交说明信息&quot;</span>   <span class="hljs-comment">#提交暂存区中的内容到本地仓库</span>git <span class="hljs-built_in">log</span>   <span class="hljs-comment"># 查看提交日志，可查看到版本commit ID</span>git status <span class="hljs-comment"># 查看所有文件的状态</span>git reset --hard HEAD^   <span class="hljs-comment">#上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写成HEAD~100</span>git reset --hard commit <span class="hljs-built_in">id</span> <span class="hljs-comment">#通过commit ID回退到那个版本，ID只需要前几位即可</span></code></pre></div><h3 id="git忽视文件">4. git忽视文件</h3><p>有些文件是不想被git管理可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。在仓库的根目录创建一个<code>.gitignore</code>的文件,然后将不需要被管理的文件添加到此文件中即可。如：</p><div class="code-wrapper"><pre><code class="hljs bash">log.txt  <span class="hljs-comment"># 忽视log.txt文件</span>.gitignore  <span class="hljs-comment"># 忽视.gitignore文件</span>css/*.js  <span class="hljs-comment"># 忽视css下的所有的js文件</span>css/*.*  <span class="hljs-comment"># 忽视css下的所有文件</span></code></pre></div><h3 id="git分支与合并">5. Git分支与合并</h3><div class="code-wrapper"><pre><code class="hljs bash">git branch                      <span class="hljs-comment">#查看本地分支</span>git branch [branch-name]        <span class="hljs-comment">#新建一个分支，但依然停留在当前分支</span>git checkout -b [branch]        <span class="hljs-comment">#新建一个分支，并切换到该branch分支</span>git checkout [branch-name]      <span class="hljs-comment">#切换到指定分支，并更新工作区</span>git branch -d [branch-name]     <span class="hljs-comment">#删除本地分支</span>git merge [branch]              <span class="hljs-comment">#合并指定branch分支到当前分支</span></code></pre></div><h3 id="关联远程仓库">6. 关联远程仓库</h3><p>远程仓库主要有：<a href="https://github.com/">github</a>和<a href="https://gitee.com/">gitee</a>。</p><p><strong>gitee</strong>服务器在国内，网速比较快，<strong>github</strong>服务器在国外，访问速度比较慢，但用户数比较多。</p><ul><li><p>进入他们的官网，按照要求自行注册一个账户。</p></li><li><p>远程仓库绑定本地仓库，就可以SSH免密登陆，在<code>git bash</code>命令行窗口输入<strong>ssh-keygen-t rsa</strong> ,一直默认按回车即可，在本地目录：<code>C:\Users\Administrator\.ssh</code> 文件中会生产两个秘钥文件，用记事本打开公钥文件 <strong>id_rsa.pub</strong>，复制里面的内容。</p></li><li><p>在 <strong>github</strong> 网页上，依次打开 <strong>settings</strong> -&gt; <strong>SSH and GPG keys</strong>页面，新创建SSH key，填上任意Title，在Key文本框里粘贴刚才复制的内容，添加即可。（gitee类似操作）</p></li><li><p>在 <strong>github</strong> 网页上新建一个远程仓库，然后实现云端仓库和本地仓库同步。（gitee类似操作）</p></li></ul><div class="code-wrapper"><pre><code class="hljs bash">git remote add origin [远端仓库地址]   <span class="hljs-comment">#把本地仓库与远程仓库进行关联</span>git push -u origin [本地分支名字]  <span class="hljs-comment">#推送分支的所有内容到远程仓库</span></code></pre></div><h3 id="将远程仓库内容复制到本地">7. 将远程仓库内容复制到本地</h3><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [url]  　<span class="hljs-comment">#获取github上的远程仓库</span>git pull [url]     <span class="hljs-comment">#拉取github上远程仓库变化的内容</span></code></pre></div><h3 id="git的一些常用命令">8. git的一些常用命令</h3><ul><li>新建代码库</li></ul><div class="code-wrapper"><pre><code class="hljs bash">git init         <span class="hljs-comment"># 在当前目录新建一个Git代码库</span>git <span class="hljs-built_in">clone</span> [url]  <span class="hljs-comment">#clone 远程仓库到本地</span></code></pre></div><ul><li>本地仓库更改</li></ul><div class="code-wrapper"><pre><code class="hljs bash">git add [file1] [file2] ...    <span class="hljs-comment"># 添加指定文件到暂存区</span>git add .     <span class="hljs-comment"># 添加当前目录的所有文件到暂存区</span>git diff       <span class="hljs-comment"># 显示暂存区和工作区的差异</span>git <span class="hljs-built_in">rm</span> [file1] [file2] ...     <span class="hljs-comment"># 删除工作区文件，并且将这次删除放入暂存区</span>git commit -m [message]        <span class="hljs-comment"># 提交暂存区到仓库区</span>git status                  <span class="hljs-comment"># 显示有变更的文件</span>git <span class="hljs-built_in">log</span>                      <span class="hljs-comment"># 显示当前分支的版本历史</span></code></pre></div><ul><li><p>分支与标签 <div class="code-wrapper"><pre><code class="hljs bash">git branch       <span class="hljs-comment"># 列出所有本地分支</span>git branch -r    <span class="hljs-comment"># 列出所有远程分支</span>git branch [branch-name]    <span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span>git checkout -b [branch]   <span class="hljs-comment"># 新建一个分支，并切换到该分支</span>git checkout [branch-name]  <span class="hljs-comment"># 切换到指定分支，并更新工作区</span>git branch -d [branch-name]  <span class="hljs-comment"># 删除分支</span>git merge [branch]  <span class="hljs-comment"># 合并指定分支到当前分支</span>git tag [tag-name] <span class="hljs-comment"># Mark the current commit with a tag</span>git tag -d [tag]   <span class="hljs-comment"># 删除本地tag</span>git show [tag]  <span class="hljs-comment"># 查看tag信息</span></code></pre></div></p></li><li><p>更新与发行</p></li></ul><div class="code-wrapper"><pre><code class="hljs bash">git fetch [remote]  <span class="hljs-comment"># 下载远程仓库的所有变动</span>git remote -v   <span class="hljs-comment"># 显示所有远程仓库</span>git remote show [remote]   <span class="hljs-comment"># 显示某个远程仓库的信息</span>git remote add [shortname] [url]  <span class="hljs-comment"># 增加一个新的远程仓库，并命名</span>git pull [remote] [branch]   <span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span>git push [remote] [branch]   <span class="hljs-comment"># 上传本地指定分支到远程仓库</span>git push [remote] --force  <span class="hljs-comment"># 强行推送当前分支到远程仓库，即使有冲突</span>git merge &lt;branch&gt;   <span class="hljs-comment">#Merge &lt;branch&gt; into your current HEAD</span>git rebase &lt;branch&gt;  <span class="hljs-comment">#Rebase your current HEAD onto &lt;branch&gt; </span></code></pre></div><ul><li>撤销</li></ul><div class="code-wrapper"><pre><code class="hljs bash">git checkout [file]  <span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span>git reset [file]   <span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span>git reset --hard   <span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span>git reset [commit]   <span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span>git reset --hard [commit]   <span class="hljs-comment"># 重置当前分支的HEAD为指定commit</span>git reset --keep [commit]  <span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span>$ git revert [commit]  <span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span></code></pre></div><h3 id="参考链接">参考链接</h3><p><a href="https://mp.weixin.qq.com/s/fU5lAC9_zjx6t5-ABfHRaQ">快速掌握Git分布式系统操作</a></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于删除keil或Altium Designer工程下无用文件</title>
    <link href="/2023/04/18/%E5%85%B3%E4%BA%8E%E5%88%A0%E9%99%A4keil%E6%88%96Altium-Designer%E5%B7%A5%E7%A8%8B%E4%B8%8B%E6%97%A0%E7%94%A8%E6%96%87%E4%BB%B6/"/>
    <url>/2023/04/18/%E5%85%B3%E4%BA%8E%E5%88%A0%E9%99%A4keil%E6%88%96Altium-Designer%E5%B7%A5%E7%A8%8B%E4%B8%8B%E6%97%A0%E7%94%A8%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>当使用keil软件或Altium Designer创建工程，完成工程后，需要进行打包传输，这时候会发现工程体积很大，其实里面有些文件是在编译时生成的，可以进行删除，只需保留必要的工程文件即可。如果手动删除，一个工程还好，如果是上百个工程，那就会很麻烦，其实，得益于<strong>bash</strong>指令，通过几句命令就可以自动批量删除这些工程中的无用文件。命令如下：</p><div class="code-wrapper"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> on:: keil trash<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.ddk&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.edk&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.lst&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.lnp&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.mpf&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.mpj&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.bak&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.obj&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.omf&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.rpt&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.tmp&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.__i&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.crf&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.o&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.d&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.axf&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.tra&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.iex&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.htm&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.sct&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.map&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.Administrator&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.dep&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;Jlink*&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;uvgui.*&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f:: Altium Designer trash<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.LOG&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.Dat&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.html&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.txtPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.PcbDocPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.PrjPcbStructure&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.SchDocPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.PcbPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.SchPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.pcbdoc_viewstate&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.$$<span class="hljs-variable">$Preview</span>&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.AnnotationPreview&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.OutJob&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.ERC&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;*.drc&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;Status Report.Txt&quot;</span>) <span class="hljs-keyword">do</span> del <span class="hljs-string">&quot;%%f&quot;</span> /f<span class="hljs-keyword">for</span> /r %%f <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;History&quot;</span>) <span class="hljs-keyword">do</span> rd <span class="hljs-string">&quot;%%f&quot;</span> /s /q<span class="hljs-keyword">for</span> /D %%a <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;Project Logs for*&quot;</span>) <span class="hljs-keyword">do</span> rd <span class="hljs-string">&quot;%%a&quot;</span> /s /q<span class="hljs-keyword">for</span> /D %%a <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;Project Outputs for*&quot;</span>) <span class="hljs-keyword">do</span> rd <span class="hljs-string">&quot;%%a&quot;</span> /s /qpause</code></pre></div><p>新建一个文本文档，将以上命令复制粘贴到文档中，命名为 <code>trash clear.bat</code> ,然后将此文件放到工程目录下，运行即可。它会删除你所有工程下需要删除的文件。</p><p>如果需要删除的某一个工程，只需将此文件放到当前工程目录中运行。如果你需要删除的文件不在以上内容中，可以自行按照其格式添加进去即可。</p><p><strong><u>注意： 这些命令是在当前目录中依次打开各个文件夹查找需要删除的内容。切记不要将不需要清除的文件夹放到当前目录中。</u></strong></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>添加U盘图标的方法</title>
    <link href="/2023/04/18/%E6%B7%BB%E5%8A%A0U%E7%9B%98%E5%9B%BE%E6%A0%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/18/%E6%B7%BB%E5%8A%A0U%E7%9B%98%E5%9B%BE%E6%A0%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>有时候我们想让U盘插到电脑上显示一个漂亮的图标，这样看起来就比较美观，其实，它的实现方式很简单，只需要进行几步设置，就可以打造出一个个性化的U盘出场方式，以下简单说明一下：</p><ol type="1"><li>准备一个漂亮的U盘 <strong>ico</strong> 格式的图标，借助图片处理工具将像素大小设置为 <strong>256像素x256像素</strong>，同时将图标命名为 <code>u_disk.ico</code></li><li>使用记事本创建一个文件，重命名为 <strong>autorun.inf</strong>,进入文件，写入以下内容：</li></ol><div class="code-wrapper"><pre><code class="hljs bash">[autorun]  icon=u_disk.ico,0label=Kayoung</code></pre></div><p><code>label</code> 显示的是U盘的名字。</p><ol start="3" type="1"><li>将这两个文件同时拷贝到U盘中，并各自右键打开文件的属性，设置为隐藏模式。</li><li>依次打开 <strong>工具</strong> -&gt; <strong>文件夹选项</strong> -&gt; <strong>查看</strong> -&gt; <strong>隐藏文件和文件夹</strong> -&gt; <code>勾选</code> <strong>不显示隐藏的文件、文件夹或驱动器</strong>, 然后点击 <strong>确定</strong>，这样，U盘中的两个文件就被隐藏了。</li></ol><p>效果图：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230418080723296.png" alt="" /><figcaption>image-20230418080723296</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>U盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BAM-1020 连续颗粒物监测仪器手册</title>
    <link href="/2023/04/17/BAM1020%E8%BF%9E%E7%BB%AD%E9%A2%97%E7%B2%92%E7%89%A9%E7%9B%91%E6%B5%8B%E4%BB%AA%E5%99%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2023/04/17/BAM1020%E8%BF%9E%E7%BB%AD%E9%A2%97%E7%B2%92%E7%89%A9%E7%9B%91%E6%B5%8B%E4%BB%AA%E5%99%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p>前两年部门采购了几套美国 <strong>MetOne</strong> 公司的颗粒物采样设备 <code>BAM-1020</code>，查看了它的使用说明手册，都是英文的，且没有电子版，后来为了好好研究一下它的操作规程，便于后期翻阅查看，我就把纸质版说明书拍照下来，借助 <strong>OCR工具</strong> （<a href="http://ocr.tianruo.net/">天若OCR文字识别</a>），整理成电子版，然后借助翻译软件（<a href="https://copytranslator.github.io/">CopyTranslator</a>）将其翻译下来。当然这两款软件并不是很智能，也会存在识别不出来，翻译不正确的地方，这就需要自己细心认真的进行处理，但借助它可以缩短我整理和翻译的速度，提高了效率，现在记录一下。</p><p>英文目录：</p><div class="code-wrapper"><pre><code class="hljs tex">Table of Contents1  INTRODUCTION11.1  About This Manual11.2  Technical Service11.3  BAM: Beta Attenuation Monitor21.4  Beta Radiation Safety Statement31.5  BAM 1020 US-EPA Configurations31.6  BAM 1020 Other Configurations31.7  BAM 1020 Specifications32  SITE SELECTION AND INSTALLATION42.1  Unpacking, Inspection, and Evaluation Testing42.2  Enclosure Selection and Temperature Control52.3  Site Selection and Inlet Positioning Criteria62.4  Mounting Options in a Walk-In Shelter62.5  BAM 1020 Installation Instructions72.6  BAM 1020 Power and Electrical Service133  INITIAL SETUP OF THE BAM 1020143.1  Power up153.2  Warm-up Period153.3  The Main Menu and Using the Keypad and Display153.4  Filter Tape Loading163.5  Self-Test173.6  Initial SETUP Settings Considerations183.7  Initial Leak Check and Flow Check193.8  Starting a Measurement Cycle193.9  Accessing the Flow Statistics Screen193.10  The OPERATE Menus193.11  The NORMAL Operation Screen203.12  The INSTANTANEOUS and AVERAGE Operation Screens204  THE MEASUREMENT CYCLE214.1  The One-Hour Cycle Timeline214.2  Automatic Span Checks During The Cycle224.3  Filter Tape Use235  FLOW SYSTEM and FLOW CALIBRATIONS235.1  Flow System Diagram235.2  Flow Control and Flow Reporting Types - Standard or Actual Flow245.2.1  ACTUAL Flow Control:245.2.2  STANDARD Flow Control:245.3  Total Flow(QTOT) and Flow Rate(LPM) Conversions255.4  About Leak Checks, Nozzle Cleaning, and Flow Checks255.5  Leak Check Procedure255.5.1  Basic Leak Check265.5.2  Advanced Leak Checks275.6  Nozzle and Vane Cleaning Procedure295.7  Field Calibration of the Flow System - Actual Flow Mode315.8  Field Calibration of the Flow System - Standard Flow Mode326  SETUP MENU DESCRIPTIONS336.1  CLOCK Setup Screen346.2  SAMPLE Setup Screen -Range, Sample, and Timing Settings346.3  CALIBRATE Setup Screen-Flow and Calibration Settings366.4  EXTRA1 Setup Screen386.5  ERRORS Setup Screen for the Analog Output386.6  PASSWORD Setup Screen396.7  INTERFACE Setup Screen406.8  SENSOR Setup Screen for External Met Sensors406.9  HEATER Setup Screen - RH Control Settings416.10  QUERY Setup Screen -Custom Data Array Setup436.11  REPORTS Setup Screen - Daily Data and Dynamic Ranges446.11.1  Daily Data Range446.11.2  Dynamic Range446.11.3  Log BP456.11.4  Log Membrane456.12  HJ 653 Setup Screen -Chinese Data Formatting457 MAINTENANCE, DIAGNOSTICS and TROUBLESHOOTING457.1  Met One Recommended Periodic Maintenance Table467.2  BAM 1020 Error and Alarm Descriptions467.3  Comparison of BAM 1020 Data to Integrated Filter Sampler Data507.4  Power Up Problems and Electrical Safety Considerations517.5  Basic Problem and Cause/Solution Table537.6  Nozzle Component Service and O-ring Replacement567.7  Performing the 72-Hour Zero Filter Background Test587.8  The TEST Menu System - Overview597.9  COUNT Test Menu -Beta Detector Count Tests607.10  PUMP Test Menu - Manual Pump and Nozzle Tests607.11  TAPE Test Menu -Manual Filter Forward/Backward Tests617.12  DAC Test Menu - Analog Output Test617.13  CALIBRATE Test Menu - Span Membrane Mass Tests617.14  INTERFACE Test Menu -Relay IO Channel Tests627.15  FLOW Test Menu627.16  ALIGN Test Menu -Tape Transport Motor and Photosensor Tests627.17  HEATER Test Menu637.18  FILTER-T Test Menu -Filter Temperature Sensor Tests647.19  FILTER-RH Test Menu - Filter Humidity Sensor Test and Calibration648  EXTERNAL DATA LOGGER INTERFACE SYSTEM658.1  Analog Concentration Output Signal658.2  Early Cycle Mode Option For Analog Data Collection668.3  Telemetry and Error Relays678.4  Interfacing a Digital Data logger with the BAM 1020699  DIGITAL COMMUNICATIONS AND DATA RETRIEVAL709.1  Direct Serial Port Connections and Settings719.2  Using Met One Comet Communications Software719.3  Downloading Data Using Simple Terminal Programs729.4  System Menu and File Descriptions Using a Terminal Program739.5  Printer Output Port Functions809.6  Modem Option819.7  BAM 1020 Firmware Upgrades819.8  Resetting the Data Pointer for New Data Collection849.9  Data Collection Using the Query Output or Bayern-Hessen Protocol8410  ACCESSORIES and PARTS8610.1  Consumables, Replacement Parts, and Accessories8610.2  BX-500 Series Meteorological Sensor Configurations9111  THEORY OF OPERATION9311.1  Converting Data Between EPA Standard and Actual Conditions95</code></pre></div><p>中文目录：</p><div class="code-wrapper"><pre><code class="hljs tex">目录1  概况11.1 关于本手册11.2 技术服务11.3 BAM: β衰减监测仪21.4 β辐射安全声明21.5 BAM 1020 US-EPA 配置21.6 BAM 1020 其他配置31.7 BAM 1020 规格32  采样点选择与安装42.1  拆箱，检视和评估测试42.2  外罩选择和温度控制42.3  选址和入口定位标准52.4  移动式方舱中的安装选项52.5  BAM 1020 安装指南52.6  BAM 1020 电力和电气服务113   BAM 1020的初始设置123.1  开机123.2  预热阶段133.3  主菜单和使用键盘和显示器133.4  过滤带加载143.5  自测143.6  初始设置注意事项153.7  初始泄漏检查和流量检查153.8  开始一个测量周期163.9  访问流量统计信息界面163.10  操作菜单163.11  NORMAL操作界面173.12  瞬时和平均操作界面174  测量周期174.1  一小时周期时间线184.2  循环期间自动量程（Span）检查194.3  滤带使用195  流量系统和流量校准195.1 流程系统图195.2  流量控制和流量报告类型-标况或工况流量205.2.1  工况流量控制:205.2.2  标况流量控制:205.3  总体积流量(QTOT) 和流量(LPM) 转换215.4  关于泄漏检查、喷嘴清洁和流量检查215.5  泄漏检查过程215.5.1 基本泄漏检查215.5.2  高级泄漏检查225.6  喷嘴和卡环清洁程序245.7  流量系统的现场校准-工况流量模式255.8  流量系统的现场校准-标况流量模式276  设置菜单说明276.1  时钟设置界面286.2  采样设置界面-范围、采样和时间设置286.3  校准设置界面-流量和校准设置306.4  EXTRA1设置界面316.5 模拟输出错误设置界面316.6  密码设置界面336.7  接口设置界面336.8  外部气象传感器的传感器设置界面336.9  加热器设置界面-相对湿度控制设置346.10  查询设置界面-自定义数据项设置356.11 报告设置界面-每日数据和动态范围366.11.1  每日数据范围376.11.2  动态范围376.11.3  BP日志376.11.4  膜日志376.12  HJ 653设置界面-中文数据格式377 维护、诊断和故障排除387.1 Met One建议的定期维护表387.2 BAM 1020错误和报警描述397.3 BAM 1020数据与集成过滤采样器数据的比较417.4 开机问题和电气安全注意事项427.5 基本问题及原因/解决方案表437.6 喷嘴部件维修和O形圈更换467.7 执行72小时零过滤器背景测试477.8 测试菜单系统-概述487.9 计数测试菜单-β探测器计数测试487.10 泵测试菜单-手动泵和喷嘴测试497.11 滤带测试菜单-过滤器向前/向后手动测试497.12 DAC测试菜单-模拟输出测试497.13 校准测试菜单-量程膜质量测试507.14 接口测试菜单-继电器IO通道测试507.15 流量测试菜单507.16 校准测试菜单-滤带传输电机和光电传感器测试507.17 加热器测试菜单517.18 FILTER-T 测试菜单-滤带温度传感器测试517.19 FILTER-RH 测试菜单 - 滤带湿度传感器测试和校准528  外部数据记录器接口系统528.1  模拟浓度输出信号538.2  模拟数据采集的早期循环模式选项538.3  遥测和错误继电器548.4 数字数据记录器与BAM 1020的接口569  数字通信与数据检索579.1  直接串行端口连接和设置579.2  使用Met One Comet通信软件589.3  使用简单的终端程序下载数据599.4  使用终端程序的系统菜单和文件说明609.5  打印机输出端口功能669.6  调制解调器选项669.7  BAM 1020固件升级669.8  重置新数据收集的数据指针699.9  使用查询输出或拜仁-黑森协议进行数据收集6910  附件和零件7010.1  消耗品、可替换的零件和附件7010.2  BX-500系列气象传感器配置7511  操作理论7811.1  在EPA标况（Standard）和工况（Actual）条件之间转换数据79</code></pre></div><p>因为能力有限，好多专业词汇翻译不够详尽，肯定还有很多翻译不正确的地方，但相比于长篇英语文章，后期翻阅就比较容易上手了，手册详细内容已上传：</p><p><a href="https://gitee.com/kayoungzhang/my_codehub.git">码云Gitee</a></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语</tag>
      
      <tag>环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stc单片机免断电自动下载程序方法</title>
    <link href="/2023/04/16/stc%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%8D%E6%96%AD%E7%94%B5%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/16/stc%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%8D%E6%96%AD%E7%94%B5%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>学过stc单片机的人，应该都知道，下载程序时，需要先加载程序，然后断电再上电，方可将程序下载到单片机中运行。有的开发板做了硬件电路处理，结合下载软件的设置，就不用断电也可以进行程序下载，下面介绍一下另外一种方式，硬件电路不需要如何修改，只通过软件设置就可以进行免断电下载程序。</p><p>在 <strong>STC</strong> 官方下载软件（<strong>STC-ISP</strong>）中，点击下载按钮后， 其实从电脑端串口是一直在发送数据的，一般是 <strong>0x7F</strong>，也可以是用户自定义， 根据STC12C5A60S2芯片手册软件复位一章中，设置 <strong>IAP_CONTR寄存器</strong>（STC89是<strong>ISP_CONTR寄存器</strong>） 就可以实现不断电复位，从而进入ISP下载区进行程序的下载。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/014.png" alt="" /><figcaption>014</figcaption></figure><p>第一种方式：利用串口下载程序瞬间一直发送 <strong>0x7f</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 方案一：串行口中断,用于stc单片机不断电自动下载程序 */</span><span class="hljs-type">uint8_t</span> uCount = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数</span><span class="hljs-type">void</span> <span class="hljs-title function_">UART1_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> interrupt 4&#123;ES = <span class="hljs-number">0</span>; <span class="hljs-comment">//关闭串口中断</span><span class="hljs-keyword">if</span>(RI)&#123;RI = <span class="hljs-number">0</span>; <span class="hljs-comment">//Clear receive interrupt flag</span><span class="hljs-keyword">if</span>(SBUF == <span class="hljs-number">0x7F</span>)&#123;            uCount++;            <span class="hljs-keyword">if</span>(uCount &gt; <span class="hljs-number">9</span>)   <span class="hljs-comment">//isp软件用户自定义命令连续发送10个0x7F，即可实现自动热复位下载</span>            &#123;                uCount = <span class="hljs-number">0</span>;                IAP_CONTR |= <span class="hljs-number">0x60</span>;    <span class="hljs-comment">//软复位到系统ISP监控区</span>            &#125;&#125;<span class="hljs-keyword">else</span>&#123;uCount = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数清零</span>&#125;&#125;ES = <span class="hljs-number">1</span>; <span class="hljs-comment">//重新打开串口中断。</span>&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230416190006307-16816443491601.png" alt="image-20230416190006307" style="zoom:80%;" /></p><p>第二种方式：利用<strong>stc-isp</strong>下载工具默认内部自定义命令”<strong><span class="citation" data-cites="STCISP">@STCISP</span>#</strong>“</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">UART1_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> interrupt 4&#123;<span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;@STCISP#&quot;</span>;<span class="hljs-comment">//stc internal definition command</span>ES = <span class="hljs-number">0</span>; <span class="hljs-comment">//关闭串口中断</span><span class="hljs-keyword">if</span>(RI)&#123;RI = <span class="hljs-number">0</span>; <span class="hljs-comment">//Clear receive interrupt flag</span><span class="hljs-keyword">while</span>(*str != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(*str++ == SBUF)<span class="hljs-keyword">continue</span>;IAP_CONTR |= <span class="hljs-number">0x60</span>;&#125;&#125;<span class="hljs-keyword">else</span>TI = <span class="hljs-number">0</span>;ES = <span class="hljs-number">1</span>; <span class="hljs-comment">//重新打开串口中断。</span>&#125;</code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230416190418784.png" alt="image-20230416190418784" style="zoom:80%;" /></p><p>选择以上任何一种方式，保证 <strong>USB-CDC/串口模式</strong> 中波特率跟自己程序中串口1的波特率一致，在main函数的开头初始化一下串口1，就可以实现不断电下载程序了。</p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的多任务管理程序架构</title>
    <link href="/2023/04/16/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/04/16/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>对于裸机开发过程中，任务多了就会出现一堆全局变量，管理上就会出现很混乱的状况，这在开发中是不允许的。看了B站上<strong>无极单片机</strong> up主讲的程序架构设计的教程中，发觉有些功能还可以删减，所以，自己再结合其他一些教程，写了一个的轮询任务管理架构，简单实用，下面详细介绍一下这套多任务管理架构。</p><p>多任务实现方式，我直接封装成 <code>scheduler.h</code> 和 <code>scheduler.c</code> ,首先看头文件：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SCHEDULER_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCHEDULER_H</span><span class="hljs-meta">#<span class="hljs-keyword">undef</span> NULL</span><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined (_cplusplus)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void*)0)</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-comment">/* exact-width signed integer types */</span><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">char</span> <span class="hljs-type">int8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">int16_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">int</span> <span class="hljs-type">int32_t</span>;<span class="hljs-comment">/* exact-width unsigned integer types */</span><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-type">uint8_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">uint16_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">uint32_t</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*p_task_func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-comment">//任务函数指针，方便传参</span><span class="hljs-comment">/* 任务ID枚举,将需要在main函数中执行的任务放到此处 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><span class="hljs-class">&#123;</span>LED0_TASK,LED1_TASK,LED2_TASK,OS_TASK_SUM <span class="hljs-comment">//任务总数,不需要修改</span>&#125;task_id_e;<span class="hljs-comment">/* 任务运行状态 */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><span class="hljs-class">&#123;</span>TASK_IDLE,TASK_RUN = !TASK_IDLE&#125;task_status_e;<span class="hljs-comment">/* 任务的结构体 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span><span class="hljs-type">void</span> (*p_task)(<span class="hljs-type">void</span>);   <span class="hljs-comment">// Pointer to the task</span>task_status_e run_flag; <span class="hljs-comment">//task status</span>  <span class="hljs-type">uint32_t</span> time_slice;   <span class="hljs-comment">// Delay (ticks) until the task will (next) be run(period/10ms)</span>  <span class="hljs-type">uint32_t</span> period;   <span class="hljs-comment">// Interval (ticks) between subsequent runs.(time_slice * 10ms)</span>&#125;<span class="hljs-type">os_task_t</span>; <span class="hljs-comment">/* task declarition */</span><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">os_task_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">os_task_create</span><span class="hljs-params">(task_id_e task_id, p_task_func proc, <span class="hljs-type">uint32_t</span> period)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">os_task_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">os_task_dispatch</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">//放到定时器10ms中断处理函数中</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>头文件中，主要定义了任务的结构体和两个枚举类型的变量，都写有注释，简单明了。下面介绍几个函数的定义：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment">  ***************************************************************</span><span class="hljs-comment">  * @file       scheduler.c</span><span class="hljs-comment">  * @author     Kayoung</span><span class="hljs-comment">  * @version    V1.0.0</span><span class="hljs-comment">  * @date       2023.04.01</span><span class="hljs-comment">  * @brief      一种轻量级的多任务实现方法</span><span class="hljs-comment">  * @attention  必须将任务调度函数放到定时器10ms中断处理函数中</span><span class="hljs-comment">  ***************************************************************</span><span class="hljs-comment">  */</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;scheduler.h&quot;</span></span><span class="hljs-comment">/* 定义任务数组 */</span><span class="hljs-keyword">volatile</span> <span class="hljs-type">os_task_t</span> os_task[OS_TASK_SUM];<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  系统任务初始化</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">os_task_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; OS_TASK_SUM; i++)&#123;os_task[i].p_task = <span class="hljs-literal">NULL</span>;os_task[i].run_flag = TASK_IDLE;os_task[i].time_slice = <span class="hljs-number">0</span>;os_task[i].period = <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  创建任务</span><span class="hljs-comment">  * @param  task_id:任务的id</span><span class="hljs-comment">  * @param  proc:具体任务处理函数指针</span><span class="hljs-comment">  * @param  period:任务周期(ms)</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">os_task_create</span><span class="hljs-params">(task_id_e task_id, p_task_func proc, <span class="hljs-type">uint32_t</span> period)</span>&#123;<span class="hljs-keyword">if</span>(!os_task[task_id].p_task)<span class="hljs-comment">//不存在任务</span>&#123;os_task[task_id].p_task = proc;os_task[task_id].run_flag = TASK_IDLE;os_task[task_id].period = period;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  任务调度器,必须放到10ms的定时器或系统时钟中断函数中</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">os_task_dispatch</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; OS_TASK_SUM; i++)&#123;<span class="hljs-keyword">if</span>(os_task[i].p_task) <span class="hljs-comment">//存在任务功能函数</span>&#123;os_task[i].time_slice++;<span class="hljs-keyword">if</span>(os_task[i].time_slice == os_task[i].period / <span class="hljs-number">10</span>)<span class="hljs-comment">//判断计时器值是否达到任务运行周期</span>&#123;os_task[i].time_slice = <span class="hljs-number">0</span>;os_task[i].run_flag = TASK_RUN;&#125;&#125;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  任务开始运行</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">os_task_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">uint8_t</span> i;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; OS_TASK_SUM; i++)&#123;<span class="hljs-keyword">if</span>(os_task[i].run_flag == TASK_RUN)&#123;os_task[i].run_flag = TASK_IDLE;os_task[i].p_task();<span class="hljs-comment">//执行任务</span>&#125;&#125;&#125;</code></pre></div><p>具体应用过程中，首先定义一个 <strong>10ms</strong> 的定时器，然后将任务调度器函数直接放到这个定时器中断中，接着定义不同的任务，<strong>这个任务函数形式必须跟任务函数指针定义的形式一致</strong>，同时将相应的任务放到任务ID枚举中，最后，在 <strong>main</strong> 函数中进行初始化调用，<strong>while</strong> 循环中启动任务即可。下面结合 <strong>main.c</strong> 函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC90C5xAD.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;scheduler.h&quot;</span></span>sbit led0 = P0^<span class="hljs-number">0</span>;sbit led1 = P0^<span class="hljs-number">1</span>;sbit led2 = P0^<span class="hljs-number">2</span>;<span class="hljs-comment">/* 10ms定时器初始化 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">Timer0_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//10毫秒@11.0592MHz</span>&#123;AUXR &amp;= <span class="hljs-number">0x7F</span>;<span class="hljs-comment">//定时器时钟12T模式</span>TMOD &amp;= <span class="hljs-number">0xF0</span>;<span class="hljs-comment">//设置定时器模式</span>TMOD |= <span class="hljs-number">0x01</span>;<span class="hljs-comment">//设置定时器模式</span>TL0 = <span class="hljs-number">0x00</span>;<span class="hljs-comment">//设置定时初始值</span>TH0 = <span class="hljs-number">0xDC</span>;<span class="hljs-comment">//设置定时初始值</span>TF0 = <span class="hljs-number">0</span>;<span class="hljs-comment">//清除TF0标志</span>TR0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//定时器0开始计时</span>ET0 = <span class="hljs-number">1</span>;EA = <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/* 定义三个led 翻转任务 */</span><span class="hljs-comment">/**</span><span class="hljs-comment">  * @brief  led翻转</span><span class="hljs-comment">  * @param  None</span><span class="hljs-comment">  * @retval None</span><span class="hljs-comment">  */</span><span class="hljs-type">void</span> <span class="hljs-title function_">led0_tongle</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;led0 = ~led0;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">led1_tongle</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;led1 = ~led1;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">led2_tongle</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;led2 = ~led2;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;Timer0_Init();os_task_init();<span class="hljs-comment">/* 创建三个不同周期闪烁的任务 */</span>os_task_create(LED0_TASK, led0_tongle, <span class="hljs-number">500</span>);<span class="hljs-comment">//500ms</span>os_task_create(LED1_TASK, led1_tongle, <span class="hljs-number">1000</span>);<span class="hljs-comment">//1000ms</span>os_task_create(LED2_TASK, led2_tongle, <span class="hljs-number">2000</span>);<span class="hljs-comment">//2000ms</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;os_task_start();<span class="hljs-comment">//执行启动任务</span>&#125;&#125;<span class="hljs-comment">/* 定时器0中断函数 */</span><span class="hljs-type">void</span> <span class="hljs-title function_">timer0_isr</span><span class="hljs-params">()</span> interrupt 1&#123;<span class="hljs-comment">/* reload counter */</span>TL0 = <span class="hljs-number">0x00</span>;TH0 = <span class="hljs-number">0xDC</span>;os_task_dispatch();&#125;</code></pre></div><p>烧录程序，会看到三个led不同频率的闪烁。</p><p>以上代码，已放到码云：<a href="https://gitee.com/kayoungzhang/my_codehub.git">multitask os</a></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客更换主题详细方法</title>
    <link href="/2023/04/16/hexo%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E8%AF%A6%E7%BB%86%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/16/hexo%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E8%AF%A6%E7%BB%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在创建hexo个人博客时，已经简单介绍了更换主题的方法，下面主要是介绍我在更换 <strong>fluid</strong> 主题后，进行的一些自定义设置及碰到的问题和解决方法。</p><h3 id="下载-fluid-主题及修改配置文件">1. 下载 fluid 主题及修改配置文件</h3><p>在本地 <strong>Hexo</strong> 博客目录中打开 <strong>git bash</strong>，然后下载 <strong>fluid</strong> 主题。</p><div class="code-wrapper"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/fluid-dev/</span>hexo-theme-fluid.git themes/fluid</code></pre></div><p>修改 <strong>Hexo</strong> 博客目录中的配置文件 **_config.yml** :</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span> <span class="hljs-comment">#根据主题目录下language文件夹选择相应语言</span></code></pre></div><h3 id="创建关于页">2. 创建「关于页」</h3><p><strong>fluid</strong>主题默认已经创建了首页，分类，归档，标签等项，但主题的「关于页」需要手动创建:</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">page</span> <span class="hljs-string">about</span></code></pre></div><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。修改后的文件示例如下：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><span class="hljs-attr">date:</span> <span class="hljs-number">2023-04-16 10:16:49</span><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><span class="hljs-meta">---</span><span class="hljs-meta"></span><span class="hljs-comment">#这里写关于页的正文，添加你需要在关于页展示的内容，支持 Markdown, HTML</span></code></pre></div><p>此时，运行以下命令，打开 <code>http://localhost:4000/</code>,即可查看到你的本地网页博客。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><span class="hljs-string">hexo</span> <span class="hljs-string">g</span><span class="hljs-string">hexo</span> <span class="hljs-string">s</span></code></pre></div><h3 id="自定义设置">3. 自定义设置</h3><p>打开 <strong>fluid</strong> 主题目录下配置文件 **_config.yml** ，里面详细介绍了各种设置的方法，并进行了中文翻译。</p><h4 id="更换-页面光标闪烁">3.1 更换 页面光标闪烁</h4><div class="code-wrapper"><pre><code class="hljs javascript"># <span class="hljs-title class_">Cursor</span> character<span class="hljs-attr">cursorChar</span>: <span class="hljs-string">&quot;✍&quot;</span></code></pre></div><h4 id="修改导航栏博客名">3.2 修改导航栏博客名</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">blog_title</span>: <span class="hljs-string">&quot;My Tech Blog&quot;</span></code></pre></div><h4 id="添加页脚-个人版权信息">3.3 添加页脚 个人版权信息</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;</span><span class="hljs-string">    &lt;p &lt;i class=&quot;iconfont icon-copyright&quot;&gt;&lt;/i&gt; &lt;span&gt;2023 | KayougZhang&lt;/span&gt; &lt;/p&gt;</span><span class="hljs-string">    &lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Hexo&lt;/span&gt;&lt;/a&gt;</span><span class="hljs-string">    &lt;i class=&quot;iconfont icon-love&quot;&gt;&lt;/i&gt;</span><span class="hljs-string">    &lt;a href=&quot;https://github.com/fluid-dev/hexo-theme-fluid&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Fluid&lt;/span&gt;&lt;/a&gt;</span><span class="hljs-string">  &#x27;</span></code></pre></div><h4 id="修改首页显示的图像">3.4 修改首页显示的图像</h4><p>找到自己喜欢的 <strong>png</strong> 格式图片，命名为 <strong>default.png</strong> ，然后复制到主题目录 <code>source/img</code> 下，进行替换原图片。</p><h4 id="修改post页面显示的图像">3.5 修改post页面显示的图像</h4><p>找到自己喜欢的 <strong>png</strong> 格式图片，命名为 <strong>article.png</strong> ，然后复制到主题目录 <code>source/img</code> 下。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">post</span>:  <span class="hljs-attr">banner_img</span>: <span class="hljs-regexp">/img/</span>article.<span class="hljs-property">png</span>  <span class="hljs-attr">banner_img_height</span>: <span class="hljs-number">70</span>  <span class="hljs-attr">banner_mask_alpha</span>: <span class="hljs-number">0.3</span></code></pre></div><h4 id="修改首页宣传语">3.6 修改首页宣传语</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">slogan</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>  # 为空则按 hexo config.<span class="hljs-property">subtitle</span> 显示  # <span class="hljs-title class_">If</span> empty, text based on <span class="hljs-string">`subtitle`</span> <span class="hljs-keyword">in</span> hexo config  <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;积跬步以至千里，积小流而成江海&quot;</span></code></pre></div><h4 id="文章开头显示更新时间">3.7 文章开头显示更新时间</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">updated</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span></code></pre></div><h4 id="关闭文章目录显示和版权声明">3.8 关闭文章目录显示和版权声明</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">toc</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">false</span><span class="hljs-attr">copyright</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">false</span></code></pre></div><h4 id="设置评论插件">3.9 设置评论插件</h4><p>打开评论插件需要第三方服务，所以需要进行第三方设置，根据<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">fluid评论配置指南</a>，选择 <a href="https://twikoo.js.org/">Twikoo</a>，进行 <a href="https://twikoo.js.org/quick-start.html#zeabur-部署">Zeabur 部署</a>，进行它的提示进行设置，最后会得到一个 <strong>envId</strong>, 此处我设置的是 https://ENV, 在配置文件进行如下设置：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">comments</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>    # 指定的插件，需要同时设置对应插件的必要参数    # <span class="hljs-title class_">The</span> specified plugin needs to set the necessary parameters at the same time    # <span class="hljs-title class_">Options</span>: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus    <span class="hljs-attr">type</span>: twikoo     # <span class="hljs-title class_">Twikoo</span># 基于腾讯云开发 , <span class="hljs-title class_">Zeabur</span> 部署# <span class="hljs-title class_">Based</span> on <span class="hljs-title class_">Tencent</span> <span class="hljs-title class_">CloudBase</span># <span class="hljs-title class_">See</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//twikoo.js.org</span><span class="hljs-attr">twikoo</span>:  <span class="hljs-attr">envId</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//ENV</span>  <span class="hljs-attr">region</span>: ap-shanghai  <span class="hljs-attr">path</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span></code></pre></div><p>如果选用<a href="https://valine.js.org/">valine</a>，需要进入<a href="https://leancloud.cn/dashboard/login.html#/signup">LeanCloud</a>，申请APP ID 和 APP Key，然后同上面一样在配置文件中进行如下设置：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">comments</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>    # 指定的插件，需要同时设置对应插件的必要参数    # <span class="hljs-title class_">The</span> specified plugin needs to set the necessary parameters at the same time    # <span class="hljs-title class_">Options</span>: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus    <span class="hljs-attr">type</span>: valine    # <span class="hljs-title class_">Valine</span># 基于 <span class="hljs-title class_">LeanCloud</span># <span class="hljs-title class_">Based</span> on <span class="hljs-title class_">LeanCloud</span># <span class="hljs-title class_">See</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//valine.js.org/</span><span class="hljs-attr">valine</span>:  <span class="hljs-attr">appId</span>: <span class="hljs-string">&#x27;填入申请的appID&#x27;</span>  <span class="hljs-attr">appKey</span>: <span class="hljs-string">&#x27;填入申请的appKey&#x27;</span>  <span class="hljs-attr">path</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>  <span class="hljs-attr">placeholder</span>: <span class="hljs-string">&quot;欢迎留言交流&quot;</span>  <span class="hljs-attr">avatar</span>: <span class="hljs-string">&#x27;robohash&#x27;</span>  <span class="hljs-attr">meta</span>: [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]  <span class="hljs-attr">requiredFields</span>: []  <span class="hljs-attr">pageSize</span>: <span class="hljs-number">10</span>  <span class="hljs-attr">lang</span>: <span class="hljs-string">&#x27;zh-CN&#x27;</span>  <span class="hljs-attr">highlight</span>: <span class="hljs-literal">false</span>  <span class="hljs-attr">recordIP</span>: <span class="hljs-literal">true</span>  <span class="hljs-attr">serverURLs</span>: <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-attr">emojiCDN</span>:  <span class="hljs-attr">emojiMaps</span>:  <span class="hljs-attr">enableQQ</span>: <span class="hljs-literal">false</span></code></pre></div><h4 id="更改about页图标">3.10 更改「about」页图标</h4><p>在 <strong>about</strong> 配置栏中，删除名字和介绍的部分，在 <a href="https://hexo.fluid-dev.com/docs/icon/">图标用法</a>中，选择需要添加的图标，然后进行设置，我添加了 <strong>github，mail</strong> 和 <strong>微信</strong>，所以，需要准备我的微信图片，命名为 <strong>wechat.png</strong> ,复制到主题目录 <code>source/img</code> 下。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">about</span>:  <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>  <span class="hljs-attr">banner_img</span>: <span class="hljs-regexp">/img/</span><span class="hljs-keyword">default</span>.<span class="hljs-property">png</span>  <span class="hljs-attr">banner_img_height</span>: <span class="hljs-number">60</span>  <span class="hljs-attr">banner_mask_alpha</span>: <span class="hljs-number">0.3</span>  <span class="hljs-attr">avatar</span>: <span class="hljs-regexp">/img/</span>avatar.<span class="hljs-property">png</span>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-attr">intro</span>: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">icons</span>:  - &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;iconfont icon-github-fill&quot;</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">&quot;https://github.com/KayoungZhang&quot;</span>, <span class="hljs-attr">tip</span>: <span class="hljs-string">&quot;GitHub&quot;</span> &#125;  - &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;iconfont icon-mail&quot;</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">&quot;mailto:zky0830@163.com&quot;</span>, <span class="hljs-attr">tip</span>: <span class="hljs-string">&quot;Email me&quot;</span> &#125;  - &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;iconfont icon-wechat-fill&quot;</span>, <span class="hljs-attr">qrcode</span>: <span class="hljs-string">&quot;/img/wechat.png&quot;</span> &#125;</code></pre></div><h4 id="更改about页avatar图像">3.11 更改「about」页avatar图像</h4><p>avatar图像可进行修改，也可以进行删除，修改方式是，找到自己喜欢的图片，命名为 <strong>avatar.png</strong> , 粘贴到 <strong>img</strong> 文件夹中进行替换，此处我直接删除，操作方式如下：</p><p>打开主题目录下 <code>layout/layout.ejs</code> 文件, 删除以下代码：</p><div class="code-wrapper"><pre><code class="hljs javascript">&lt;% <span class="hljs-keyword">if</span>(page.<span class="hljs-property">layout</span> === <span class="hljs-string">&#x27;about&#x27;</span>) &#123; %&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;about-avatar&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&lt;%= url_for(theme.about.avatar) %&gt;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-fluid&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;avatar&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">&lt;% &#125; %&gt;</span></code></pre></div><h4 id="调整-post-页面的大小">3.12 调整 post 页面的大小</h4><p>在post页中，文章内容部分页面很窄，有的文章排版成挤缩状，看起不舒服，进行如下设置：</p><p>打开主题目录下 <code>layout/post.ejs</code> 文件, 将 <strong>col-lg-8</strong> 修改为 <strong>12</strong>：</p><div class="code-wrapper"><pre><code class="hljs javascript">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;col-lg-12 nopadding-x-md&quot;</span>&gt;</code></pre></div><p>以上是我采用 <strong>fluid</strong> 主题的一些详细设置，因为不会 <strong>javascript</strong>，所以，后面几项设置折腾了两天，现在记录一下。</p><h4 id="更改代码显示的样式">3.13 更改代码显示的样式</h4><p>打开 <strong>fluid</strong> 主题目录下配置文件 **_config.yml** ，修改：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">highlightjs:</span>    <span class="hljs-comment"># 在链接中挑选 style 填入</span>    <span class="hljs-comment"># Select a style in the link</span>    <span class="hljs-comment"># See: https://highlightjs.org/static/demo/</span>    <span class="hljs-comment"># style: &quot;github gist&quot;</span>    <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;Vs&quot;</span>    <span class="hljs-attr">style_dark:</span> <span class="hljs-string">&quot;dark&quot;</span></code></pre></div><h3 id="添加数学公式支持">4. 添加数学公式支持</h3><p>打开主题目录下的配置文件 <code>_config.yml</code>,将markdown公式支持打开。</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">math:</span>  <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span>  <span class="hljs-comment"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span>  <span class="hljs-comment"># If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math</span>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># Options: mathjax | katex</span>  <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span></code></pre></div><p>下载安装： <a href="https://github.com/jgm/pandoc/releases">pandoc</a>，然后进入本地博客目录下，右键打开<code>git bash</code>,安装 <strong>hexo-renderer-pandoc</strong></p><div class="code-wrapper"><pre><code class="hljs ada">npm uninstall hexo-renderer-marked <span class="hljs-comment">--save  </span>npm install hexo-renderer-pandoc <span class="hljs-comment">--save</span></code></pre></div><p>根据 <code>\node_modules\hexo-renderer-pandoc</code>目录下的 <strong>README.md</strong> 文档，打开本地博客主目录下的配置文件： <code>_config.yml</code>，添加pandoc软件的路径。</p><div class="code-wrapper"><pre><code class="hljs arcade">pandoc:  pandoc_path: C:<span class="hljs-regexp">/Program Files/</span>Pandoc/pandoc.exe</code></pre></div><p><strong>注意：</strong> 有时部署博客文章会出现关于pandoc的错误，可根据提示，进行相应的修改。</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230706225516667.png" alt="image-20230706225516667" style="zoom:80%;" /></p><p>在需要显示数学公式的文档前面添加 <code>math: true</code>,之后页面就会显示公式。为了方便，可以打开 <code>\scaffolds\post.md</code>文件，添加<code>math:</code>,这样，在以后需要显示公式的文档中将math后面添加true即可。</p><h3 id="参考链接">参考链接</h3><hr /><p><a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a></p><p><a href="https://zhuanlan.zhihu.com/p/35988761">Hexo构建blog时渲染LaTeX数学公式的问题</a></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>printf输出函数总结</title>
    <link href="/2023/04/15/printf%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/15/printf%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>在调试程序时，会经常需要将某些信息输出到电脑，便于查找问题原因，快速解决问题。printf函数作为已经封装好的信息输出函数，会被经常使用到，下面介绍一些它的使用方式：</p><ul><li><h4 id="头文件-stdio.h-函数原型">头文件 <strong>&lt;stdio.h&gt;</strong> 函数原型：</h4></li></ul><p><code>int printf ( const char * format, … );</code> 返回值：正确返回输出的字符总数，错误返回负值。</p><ul><li><h4 id="调用格式">调用格式：</h4></li></ul><p><code>printf(“格式化字符串”, 输出表列);</code> 格式化字符串包含：（1）字符串常量；（2）格式控制字符串；（3）转义字符。</p><ul><li>格式控制字符串形式:</li></ul><p><code>%[flags][width][.prec][length]type  //%[标志][最小宽度][.精度][类型长度]类型</code></p><div class="code-wrapper"><pre><code class="hljs c">标志:-左对齐, 默认右对齐<span class="hljs-number">0</span>右对齐时, 用<span class="hljs-number">0</span>填充宽度.(默认用空格填充)空格   输出值为正数时,在输出值前面加上空格, 为负数时加上负号#对x类型,在输出时加前缀<span class="hljs-number">0</span>x如：<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d\n&quot;</span>,<span class="hljs-number">1000</span>);     <span class="hljs-comment">//输出:( 1000)默认右对齐,左边补空格</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-5d\n&quot;</span>,<span class="hljs-number">1000</span>);     <span class="hljs-comment">//输出:(1000 )左对齐,右边补空格</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>,<span class="hljs-number">1000</span>);    <span class="hljs-comment">//输出:(01000)前面补0</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x\n&quot;</span>,<span class="hljs-number">1000</span>);  <span class="hljs-comment">//输出:0x3e8</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.0f %#.0f\n&quot;</span>,<span class="hljs-number">1000.0</span>,<span class="hljs-number">1000.0</span>);<span class="hljs-comment">//输出:(1000 1000.)当小数点后不输出值时依然输出小数点</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c">类型长度:长度         修饰类型 含义hhd、i、o、u、x输出 <span class="hljs-type">char</span>hd、i、o、u、x输出 <span class="hljs-type">short</span> <span class="hljs-type">int</span>ld、i、o、u、x输出 <span class="hljs-type">long</span> <span class="hljs-type">int</span>lld、i、o、u、x输出 <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span>如：<span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-type">short</span> <span class="hljs-type">int</span> b = <span class="hljs-number">123</span>;<span class="hljs-type">int</span>  c = <span class="hljs-number">123</span>;<span class="hljs-type">long</span> <span class="hljs-type">int</span> d = <span class="hljs-number">123</span>;<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> e = <span class="hljs-number">123</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%hhd\n&quot;</span>, a); <span class="hljs-comment">// 97</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%hd\n&quot;</span>, b); <span class="hljs-comment">// 123</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c); <span class="hljs-comment">// 123</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>, d); <span class="hljs-comment">// 123</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, e); <span class="hljs-comment">// 123</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c">类型:d有符号<span class="hljs-number">10</span>进制整型i有符号<span class="hljs-number">10</span>进制整型u无符号<span class="hljs-number">10</span>进制整型o无符号<span class="hljs-number">8</span>进制整型x无符号<span class="hljs-number">16</span>进制整型X无符号<span class="hljs-number">16</span>进制整型f单、双精度浮点数(默认保留<span class="hljs-number">6</span>位小数)e / E以指数形式输出单、双精度浮点数g / G以最短输出宽度,输出单、双精度浮点数c字符s字符串p地址如：有符号十进制:  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-number">123</span>);<span class="hljs-comment">//输出123</span>无符号十进制:   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u&quot;</span>,<span class="hljs-number">-10</span>);<span class="hljs-comment">//不可以输出负数,输出429496786</span>无符号八进制:    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%o&quot;</span>,<span class="hljs-number">123</span>);<span class="hljs-comment">//输出123</span>无符号十六进制： <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x 0x%X&quot;</span>,<span class="hljs-number">123</span>,<span class="hljs-number">123</span>);  <span class="hljs-comment">//输出0x7b 0x7B</span>无符号十六进制： <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x %#X&quot;</span>,<span class="hljs-number">123</span>,<span class="hljs-number">123</span>);  <span class="hljs-comment">//输出0x7b 0X7B</span>字符型数据：  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,<span class="hljs-number">64</span>);<span class="hljs-comment">//输出A</span>字符串型数据： <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,<span class="hljs-string">&quot;测试test&quot;</span>);<span class="hljs-comment">//输出：测试test</span>单精度浮点数： <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.9f&quot;</span>,<span class="hljs-number">0.000000123</span>);<span class="hljs-comment">//输出0.000000123</span>科学计数法：  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%e %E&quot;</span>,<span class="hljs-number">0.000000123</span>,<span class="hljs-number">0.000000123</span>);<span class="hljs-comment">//输出1.230000e-07 1.230000E-07</span></code></pre></div><ul><li><h4 id="ansi-c标准中有几个标准预定义宏也是常用的">ANSI C标准中有几个标准预定义宏（也是常用的）:</h4></li></ul><div class="code-wrapper"><pre><code class="hljs c">__LINE__：当前的函数行 (<span class="hljs-type">int</span>)__FILE__：当前程序源文件 (<span class="hljs-type">char</span>*)__DATE__：在源文件中插入当前的编译日期__TIME__：在源文件中插入当前编译时间__STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为<span class="hljs-number">1</span>__FUNCTION__:  当前运行的函数 (<span class="hljs-type">char</span>*)__cplusplus：当编写C++程序时该标识符被定义。如：<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file: %s\n&quot;</span>, __FILE__);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;function: %s\n&quot;</span>, __FUNCTION__);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;line: %d\n&quot;</span>, __LINE__);</code></pre></div><ul><li><h4 id="字符串化操作符"><strong>#</strong> 字符串化操作符</h4></li></ul><p>可以使用 <strong>#</strong> 将当前的内容转换成字符串。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DPRINT(expr) printf(<span class="hljs-string">&quot;%s = %d\n&quot;</span>, #expr, expr);</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;    <span class="hljs-type">int</span> x = <span class="hljs-number">3</span>;    <span class="hljs-type">int</span> y = <span class="hljs-number">5</span>;    DPRINT(x / y);    DPRINT(x + y);    DPRINT(x * y);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>执行结果：</p><div class="code-wrapper"><pre><code class="hljs c">x / y = <span class="hljs-number">0</span>x + y = <span class="hljs-number">8</span>x * y = <span class="hljs-number">15</span></code></pre></div><ul><li><h4 id="连接操作符"><strong>##</strong> 连接操作符</h4></li></ul><p><strong>##</strong> 是C语言中的连接操作符，可以在编译的预处理阶段实现字符串连接的操作。 在程序的调试语句中，<strong>##</strong> 常用的方式如下</p><p><code>#define DEBUG(fmt, args…) printf(fmt, ##args)</code></p><p>调试宏第一种形式:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(fmt, args...)\</span><span class="hljs-meta">do&#123;  \</span><span class="hljs-meta">    printf(<span class="hljs-string">&quot;file:%s function: %s line: %d &quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span>    <span class="hljs-built_in">printf</span>(fmt, #<span class="hljs-meta">#args); \</span><span class="hljs-meta">&#125;while(0)</span></code></pre></div><p>调试宏的第二种定义方式:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(fmt, args...)    printf(<span class="hljs-string">&quot;file:%s function: %s line: %d &quot;</span> \</span><span class="hljs-meta">fmt, __FILE__, __FUNCTION__, __LINE__, ##args)</span></code></pre></div><p>实例：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_DEBUG  <span class="hljs-comment">//开启DEBUG宏 #undef DEBUG （不开启宏）</span></span><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_DEBUG</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(fmt, args...) printf(<span class="hljs-string">&quot;file:%s function: %s line: %d &quot;</span> \</span><span class="hljs-meta">    fmt, __FILE__, __FUNCTION__, __LINE__, ##args)</span><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(fmt, args...)</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;        <span class="hljs-type">char</span> str[]=<span class="hljs-string">&quot;Hello World&quot;</span>;        debug(<span class="hljs-string">&quot;%s&quot;</span>,str);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><ul><li><h4 id="printf-函数重定向方法"><strong>printf()</strong> 函数重定向方法</h4></li></ul><p>在C语言中 <strong>printf </strong>函数已经定义为默认输出到显示器的，在单片机中若要想在串口上显示，那就需要重定向 <strong>printf</strong>。例如将 <strong>printf</strong> 函数重定向到 <strong>USART1</strong> ，这样就可以利用printf函数将单片机的数据通过串口调试助手打印到PC上。</p><p>printf函数底层实际是调用 <strong>fputc</strong> 函数，所以重定向 <strong>printf</strong> 函数，就是重新写 <strong>fputc</strong> 函数。</p><p>在 <strong>51单片机</strong> 中:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">uart1_send_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> value)</span>&#123;SBUF = value;<span class="hljs-keyword">while</span> (!TI); <span class="hljs-comment">//等待发送完成</span>TI = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 重定向printf函数 */</span><span class="hljs-type">char</span> <span class="hljs-title function_">putchar</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span>&#123;uart1_send_byte(ch);<span class="hljs-keyword">return</span> ch;&#125;</code></pre></div><p>在 <strong>STM32</strong> 中, 注意要勾选keil软件中 <strong>TARGET</strong> 中的 <strong>USE Micro LIB</strong> 选项, 然后进行重定义：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;    <span class="hljs-keyword">while</span> ((USART1 -&gt; SR &amp; <span class="hljs-number">0X40</span>)== <span class="hljs-number">0</span> );    USART1 -&gt; DR  = (<span class="hljs-type">uint8_t</span>)ch;    <span class="hljs-keyword">return</span>  ch;&#125;或者<span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;  USART_SendData(USARTx, (<span class="hljs-type">uint8_t</span>)ch); <span class="hljs-comment">/* 发送一个字节数据到串口 */</span>  <span class="hljs-keyword">while</span> (USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET);<span class="hljs-comment">/* 等待发送完毕 */</span>  <span class="hljs-keyword">return</span> (ch);&#125;或者<span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span> &#123;  HAL_UART_Transmit(&amp;huartx, (<span class="hljs-type">uint8_t</span> *)&amp;ch, <span class="hljs-number">1</span>, <span class="hljs-number">0xffff</span>);  <span class="hljs-keyword">return</span> ch;&#125;</code></pre></div><p>此外，<strong>正点原子</strong> 有另外一种半主机模式，也可以实现printf输出，只做了解：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span>   import (__use_no_semihosting)</span><span class="hljs-class"><span class="hljs-keyword">struct</span>  __<span class="hljs-title">FILE</span></span><span class="hljs-class">&#123;</span>   <span class="hljs-type">int</span>  handle ;&#125;;FILE  __stdout ;_sys_exit (<span class="hljs-type">int</span>  x)&#123;   x  =  x ;&#125;<span class="hljs-type">int</span>  <span class="hljs-title function_">fputc</span> <span class="hljs-params">(<span class="hljs-type">int</span>  ch , FILE   * f)</span>&#123;   <span class="hljs-keyword">while</span> ((USART1 -&gt; SR &amp; <span class="hljs-number">0X40</span> )== <span class="hljs-number">0</span>);    USART1 -&gt; DR  = (<span class="hljs-type">uint8_t</span>) ch ;    <span class="hljs-keyword">return</span>  ch ;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>printf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程常用英文单词及缩写汇总</title>
    <link href="/2023/04/15/%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%8F%8A%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB/"/>
    <url>/2023/04/15/%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%8F%8A%E7%BC%A9%E5%86%99%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>在写程序过程中，会经常定义变量、函数等，比较规范的做法是采用英文定义，这样，别人读到你的代码时，就会立刻了解它的意思，同时，在应用过程中，有些单词较复杂，为了代码的简洁，一般会采用它的缩写，下面介绍一些编程中常用的英文单词：</p><h3 id="正反属性词">正反属性词</h3><hr /><table><thead><tr class="header"><th style="text-align: left;">正义词</th><th>意思</th><th>反义词</th><th>意思</th><th>正义词</th><th>意思</th><th>反义词</th><th>意思</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">add</td><td>添加</td><td>remove</td><td>删除</td><td>begin</td><td>开启</td><td>end</td><td>结束</td></tr><tr class="even"><td style="text-align: left;">create</td><td>创建</td><td>destroy</td><td>销毁</td><td>insert</td><td>插入</td><td>delete</td><td>删除</td></tr><tr class="odd"><td style="text-align: left;">first</td><td>首先</td><td>last</td><td>最后</td><td>get</td><td>获取</td><td>release</td><td>发行</td></tr><tr class="even"><td style="text-align: left;">increment</td><td>增长</td><td>decrement</td><td>减少</td><td>put</td><td>放</td><td>get</td><td>获得</td></tr><tr class="odd"><td style="text-align: left;">add</td><td>添加</td><td>delete</td><td>删除</td><td>lock</td><td>锁住</td><td>unlock</td><td>解锁</td></tr><tr class="even"><td style="text-align: left;">open</td><td>打开</td><td>close</td><td>关闭</td><td>min</td><td>最小</td><td>max</td><td>最大</td></tr><tr class="odd"><td style="text-align: left;">old</td><td>旧的</td><td>new</td><td>新的</td><td>start</td><td>开始</td><td>stop</td><td>停止</td></tr><tr class="even"><td style="text-align: left;">next</td><td>下一个</td><td>previous</td><td>前一个</td><td>source</td><td>源头</td><td>target</td><td>目标</td></tr><tr class="odd"><td style="text-align: left;">show</td><td>展示</td><td>hide</td><td>隐藏</td><td>send</td><td>发送</td><td>receive</td><td>接收</td></tr><tr class="even"><td style="text-align: left;">source</td><td>来源</td><td>destination</td><td>目的地</td><td>copy</td><td>复制</td><td>paste</td><td>粘贴</td></tr><tr class="odd"><td style="text-align: left;">up</td><td>上</td><td>down</td><td>下</td><td>big</td><td>大</td><td>small</td><td>小</td></tr></tbody></table><h3 id="常用词及缩写">常用词及缩写</h3><hr /><table><thead><tr class="header"><th style="text-align: left;">英文单词(缩写)</th><th>意思</th><th>英文单词(缩写)</th><th>意思</th><th style="text-align: center;">英文单词(缩写)</th><th>意思</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">compare(cmp)</td><td>比较</td><td>utility (util)</td><td>实用程序</td><td style="text-align: center;">configuration(cfg)</td><td>配置</td></tr><tr class="even"><td style="text-align: left;">device(dev)</td><td>设备</td><td>information(info)</td><td>信息</td><td style="text-align: center;">error(err)</td><td>错误</td></tr><tr class="odd"><td style="text-align: left;">hexadecimal(hex)</td><td>十六进制</td><td>image (img)</td><td>图像</td><td style="text-align: center;">increment(inc)</td><td>增加</td></tr><tr class="even"><td style="text-align: left;">initialize(init)</td><td>初始化</td><td>function (func)</td><td>函数</td><td style="text-align: center;">maximum(max)</td><td>最大</td></tr><tr class="odd"><td style="text-align: left;">message(msg)</td><td>信息</td><td>array (arr)</td><td>数组</td><td style="text-align: center;">minimum(min)</td><td>最小</td></tr><tr class="even"><td style="text-align: left;">parameter(param)</td><td>参数</td><td>read(rd)</td><td>读</td><td style="text-align: center;">previous(prev)</td><td>前一个</td></tr><tr class="odd"><td style="text-align: left;">register(reg)</td><td>注册</td><td>hour (hr)</td><td>小时</td><td style="text-align: center;">semaphore(sem)</td><td>信号量</td></tr><tr class="even"><td style="text-align: left;">statistic(stat)</td><td>统计</td><td>value(val)</td><td>值</td><td style="text-align: center;">synchronize(syn)</td><td>同步</td></tr><tr class="odd"><td style="text-align: left;">temp(tmp)</td><td>临时变量</td><td>version(ver)</td><td>版本</td><td style="text-align: center;">buffer(buf)</td><td>缓存</td></tr><tr class="even"><td style="text-align: left;">argument(arg)</td><td>参数</td><td>user (usr)</td><td>用户</td><td style="text-align: center;">command(cmd)</td><td>命令</td></tr><tr class="odd"><td style="text-align: left;">clock(clk)</td><td>时钟</td><td>time (tm)</td><td>时间</td><td style="text-align: center;">reference (ref)</td><td>参考</td></tr><tr class="even"><td style="text-align: left;">power (pwr)</td><td>电源</td><td>system (sys)</td><td>系统</td><td style="text-align: center;">password (pw)</td><td>密码</td></tr><tr class="odd"><td style="text-align: left;">control (ctrl)</td><td>控制</td><td>standard (std)</td><td>标准</td><td style="text-align: center;">package (pkg)</td><td>安装包</td></tr><tr class="even"><td style="text-align: left;">number (num)</td><td>数目</td><td>signal (sig)</td><td>信号</td><td style="text-align: center;">negative(neg)</td><td>负极</td></tr><tr class="odd"><td style="text-align: left;">copy (cpy)</td><td>复制</td><td>return (ret)</td><td>返回</td><td style="text-align: center;">constant (const)</td><td>常量</td></tr><tr class="even"><td style="text-align: left;">check (chk)</td><td>检查</td><td>request (req)</td><td>请求</td><td style="text-align: center;">calculate (calc)</td><td>计算</td></tr><tr class="odd"><td style="text-align: left;">asynchronous(asyn)</td><td>异步</td><td>receive (recv)</td><td>接收</td><td style="text-align: center;">assembly (asm)</td><td>装配</td></tr><tr class="even"><td style="text-align: left;">application(app)</td><td>应用</td><td>alternate (alt)</td><td>交替</td><td style="text-align: center;">administrator(admin)</td><td>管理员</td></tr><tr class="odd"><td style="text-align: left;">technology(tech)</td><td>技术</td><td>pointer (ptr)</td><td>指针</td><td style="text-align: center;">adjust (adj)</td><td>调整</td></tr><tr class="even"><td style="text-align: left;">address (addr)</td><td>地址</td><td>picture (pic)</td><td>图片</td><td style="text-align: center;">position (pos)</td><td>位置</td></tr><tr class="odd"><td style="text-align: left;">acknowledge(ack)</td><td>承认</td><td>multiplication(mul)</td><td>乘</td><td style="text-align: center;">positive(pos)</td><td>正极</td></tr><tr class="even"><td style="text-align: left;">write(wr)</td><td>写</td><td>middle (mid)</td><td>中间</td><td style="text-align: center;">memory (mem)</td><td>内存</td></tr><tr class="odd"><td style="text-align: left;">variable (var)</td><td>变量</td><td>link (lnk)</td><td>链接</td><td style="text-align: center;">library (lib)</td><td>库</td></tr><tr class="even"><td style="text-align: left;">button (btn)</td><td>按钮</td><td>average (avg)</td><td>平均</td><td style="text-align: center;">attribute (attr)</td><td>属性</td></tr><tr class="odd"><td style="text-align: left;">column (col)</td><td>列</td><td>count (cnt)</td><td>计数</td><td style="text-align: center;">clear (clr)</td><td>清除</td></tr><tr class="even"><td style="text-align: left;">make (mk)</td><td>做</td><td>database(db)</td><td>数据库</td><td style="text-align: center;">current (cur)</td><td>当前</td></tr><tr class="odd"><td style="text-align: left;">object (obj)</td><td>对象</td><td>decrease (dec)</td><td>减少</td><td style="text-align: center;">debug (dbg)</td><td>调试</td></tr><tr class="even"><td style="text-align: left;">process (proc)</td><td>处理</td><td>delete (del)</td><td>删除</td><td style="text-align: center;">definition(def)</td><td>定义</td></tr><tr class="odd"><td style="text-align: left;">record (rec)</td><td>记录</td><td>difference (diff)</td><td>不同</td><td style="text-align: center;">destination(dest)</td><td>目的地</td></tr><tr class="even"><td style="text-align: left;">volume (vol)</td><td>音量，体积</td><td>length (leng)</td><td>长度</td><td style="text-align: center;">language(lang)</td><td>语言</td></tr><tr class="odd"><td style="text-align: left;">rename (ren)</td><td>重命名</td><td>display(disp)</td><td>显示</td><td style="text-align: center;">directory (dir)</td><td>目录</td></tr><tr class="even"><td style="text-align: left;">result (res)</td><td>结果</td><td>division(div)</td><td>除</td><td style="text-align: center;">distance (dist)</td><td>距离</td></tr><tr class="odd"><td style="text-align: left;">connection (conn)</td><td>连接</td><td>icon (ico)</td><td>图标</td><td style="text-align: center;">background (bg)</td><td>背景</td></tr><tr class="even"><td style="text-align: left;">structure(struct)</td><td>结构体</td><td>extension(ext)</td><td>拓展</td><td style="text-align: center;">experience(exp)</td><td>经验</td></tr><tr class="odd"><td style="text-align: left;">remove (rm)</td><td>移除</td><td>document (doc)</td><td>文档</td><td style="text-align: center;">dialog(dlg)</td><td>对话框</td></tr><tr class="even"><td style="text-align: left;">source (src)</td><td>源头</td><td>environment(env)</td><td>环境</td><td style="text-align: center;">driver (drv)</td><td>驱动</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言中位操作</title>
    <link href="/2023/04/14/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/04/14/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>嵌入式开发过程中，C语言的位操作在寄存器的设置中会经常用到，需要熟练掌握，从而在实际应用中灵活应用位操作，其中主要会用到它的三种基本操作方式，具体如下：</p><p><strong>清零操作</strong></p><p>如将 char型变量a的第七位(bit6)清零，其它位不变：</p><div class="code-wrapper"><pre><code class="hljs c">a &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);   <span class="hljs-comment">/* 1&lt;&lt;6 -&gt; 0100 0000 取反 -&gt; 1011 1111  位与 -&gt; bit6为0，其它位不变 */</span></code></pre></div><p><strong>置位操作</strong></p><p>如将 char型变量a的第七位(bit6)置1，其它位不变：</p><div class="code-wrapper"><pre><code class="hljs c">a |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<span class="hljs-comment">/* 1&lt;&lt;6 -&gt; 0100 0000 位或 -&gt; bit6为1，其它位不变 */</span></code></pre></div><p><strong>取反操作</strong></p><p>如将 char型变量a的第七位(bit6)取反，其它位不变：</p><div class="code-wrapper"><pre><code class="hljs c">a ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<span class="hljs-comment">/* 1&lt;&lt;6 -&gt; 0100 0000 异或 -&gt; bit6取反了，其它位不变 */</span></code></pre></div><p>下面介绍通过位操作，在实际应用中的使用。</p><p><strong>1. 获取32bit数据单字节:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BYTE0(x)    ((x &gt;&gt; 0) &amp; 0x000000FF)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BYTE1(x)    ((x &gt;&gt; 8) &amp; 0x000000FF)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BYTE2(x)    ((x &gt;&gt; 16) &amp; 0x000000FF)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BYTE3(x)    ((x &gt;&gt; 24) &amp; 0x000000FF)</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n = <span class="hljs-number">0x12345678</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, GET_BYTE0(n)); <span class="hljs-comment">//0x78</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, GET_BYTE1(n)); <span class="hljs-comment">//0x56</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, GET_BYTE2(n)); <span class="hljs-comment">//0x34</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, GET_BYTE3(n)); <span class="hljs-comment">//0x12        </span>&#125;</code></pre></div><p><strong>2. 获取32bit数据某一位:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BIT(x, n) ((x &amp; (1<span class="hljs-string">&lt;&lt;n)) &gt;</span>&gt; n)</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-comment">//0001_0010_0011_0100_0101_0110_0111_1000</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit0 is %d\r\n&quot;</span>, GET_BIT(a, <span class="hljs-number">0</span>));<span class="hljs-comment">//0</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit3 is %d\r\n&quot;</span>, GET_BIT(a, <span class="hljs-number">3</span>));<span class="hljs-comment">//1</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit28 is %d\r\n&quot;</span>, GET_BIT(a, <span class="hljs-number">28</span>));<span class="hljs-comment">//1</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit31 is %d\r\n&quot;</span>, GET_BIT(a, <span class="hljs-number">31</span>));<span class="hljs-comment">//0</span>&#125;</code></pre></div><p><strong>3. 获取32bit数据某连续几位的值:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* 获取第[n:m]位的值(m&gt;n) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BITS(x, n, m)  ((x <span class="hljs-string">&lt;&lt; (31-m)) &gt;</span>&gt; (31-(m-n)))</span><span class="hljs-comment">/* 获取第[n:m]位的值(m&lt;n) */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_BITS(x, n, m)  ((x <span class="hljs-string">&lt;&lt; (31-n)) &gt;</span>&gt; (31-(n-m)))</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-comment">//0001_0010_0011_0100_0101_0110_0111_1000</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit[3, 1] is %x\r\n&quot;</span>, GET_BITS(a, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>));<span class="hljs-comment">//0100b</span>&#125;</code></pre></div><p><strong>4. 32bit数据清零某一字节:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BYTE0(x)  (x &amp; 0xFFFFFF00)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BYTE1(x)  (x &amp; 0xFFFF00FF)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BYTE2(x)  (x &amp; 0xFF00FFFF)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BYTE3(x)  (x &amp; 0x00FFFFFF)</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, CLEAR_BYTE0(a));<span class="hljs-comment">//0x12345600</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, CLEAR_BYTE1(a));<span class="hljs-comment">//0x12340078</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\r\n&quot;</span>, CLEAR_BYTE2(a));<span class="hljs-comment">//0x12005678</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#.8x\r\n&quot;</span>, CLEAR_BYTE3(a));<span class="hljs-comment">//0x00345678</span>&#125;</code></pre></div><p><strong>5. 32bit数据清零某一位:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_BIT(x, n)    (x &amp; ~(1&lt;&lt;n))</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-comment">//0001_0010_0011_0100_0101_0110_0111_1000</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit3 change to 0. 0x%x\r\n&quot;</span>, CLEAR_BIT(a, <span class="hljs-number">3</span>));<span class="hljs-comment">//0x12345670</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit6 change to 0. 0x%x\r\n&quot;</span>, CLEAR_BIT(a, <span class="hljs-number">6</span>));<span class="hljs-comment">//0x12345638</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit28 change to 0. 0x%x\r\n&quot;</span>, CLEAR_BIT(a, <span class="hljs-number">28</span>));<span class="hljs-comment">//0x2345678</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bit31 change to 0. 0x%x\r\n&quot;</span>, CLEAR_BIT(a, <span class="hljs-number">31</span>));<span class="hljs-comment">//0x12345678</span>&#125;</code></pre></div><p><strong>6. 32bit数据某一字节置位:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BYTE0(x)    x | 0x000000FF</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BYTE1(x)    x | 0x0000FF00</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BYTE2(x)    x | 0x00FF0000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BYTE3(x)    x | 0xFF000000</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set byte0: 0x%x\r\n&quot;</span>, SET_BYTE0(a));<span class="hljs-comment">//0x123456ff</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set byte1: 0x%x\r\n&quot;</span>, SET_BYTE1(a));<span class="hljs-comment">//0x1234ff78</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set byte2: 0x%x\r\n&quot;</span>, SET_BYTE2(a));<span class="hljs-comment">//0x12ff5678</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set byte3: 0x%x\r\n&quot;</span>, SET_BYTE3(a));<span class="hljs-comment">//0xff345678</span>&#125;</code></pre></div><p><strong>7. 32bit数据某一位置位:</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET_BIT(x, n)     x | (1&lt;&lt;n)</span><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0x12345678</span>;<span class="hljs-comment">//0001_0010_0011_0100_0101_0110_0111_1000</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set bit0 to 1: 0x%x\r\n&quot;</span>, SET_BIT(a, <span class="hljs-number">0</span>));<span class="hljs-comment">//0x12345679</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set bit3 to 1: 0x%x\r\n&quot;</span>, SET_BIT(a, <span class="hljs-number">3</span>));<span class="hljs-comment">//0x12345678</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set bit7 to 1: 0x%x\r\n&quot;</span>, SET_BIT(a, <span class="hljs-number">7</span>));<span class="hljs-comment">//0x123456f8</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set bit31 to 1: 0x%x\r\n&quot;</span>, SET_BIT(a, <span class="hljs-number">31</span>));<span class="hljs-comment">//0x92345678</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ASCII编码对照表</title>
    <link href="/2023/04/14/ASCII%E7%BC%96%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <url>/2023/04/14/ASCII%E7%BC%96%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/ascii.png" alt="" /><figcaption>ascii</figcaption></figure><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/02.jpg" alt="" /><figcaption>../_images/02.jpg</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ASCII</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows局域网共享文件</title>
    <link href="/2023/04/14/Windows%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"/>
    <url>/2023/04/14/Windows%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>有的时候，我们需要在两台电脑上进行局域网连接，通过一根网线，进行相应的简单设置，就可以实现这个目的，具体有以下4个步骤：</p><ul><li><strong>1.配置IP地址</strong></li><li><strong>2.关闭防火墙</strong></li><li><strong>3.更改“本地策略”</strong></li><li><strong>4.共享需要访问的文件夹</strong></li></ul><p>具体步骤如下：</p><p><strong>1.</strong> 将两台电脑中的其中一台的IPV4地址配置为：</p><div class="code-wrapper"><pre><code class="hljs dns">IP地址：<span class="hljs-number">192.168.1.101</span>子网掩码：<span class="hljs-number">255.255.255.0</span>默认网关：<span class="hljs-number">192.168.1.1</span></code></pre></div><p>另一台设置：</p><div class="code-wrapper"><pre><code class="hljs dns">IP地址：<span class="hljs-number">192.168.1.102</span> （此地址只要设置在同一网段即可）子网掩码：<span class="hljs-number">255.255.255.0</span>默认网关：<span class="hljs-number">192.168.1.1</span></code></pre></div><p><strong>2.</strong> 打开控制面板中的防火墙，关闭防火墙</p><p><strong>3.</strong> <strong>Win+R</strong>，输入<strong>gpedit.msc</strong> 打开本地策略，依次展开 <strong>计算机配置</strong> -&gt; <strong>Windows设置</strong> -&gt; <strong>本地策略</strong> -&gt; <strong>安全选项</strong>，双击 其中的一个账户：<strong>账户：使用空白密码的本地账户只允许进行控制台登陆</strong> ，改为 <strong>已禁用</strong> 点击确定。</p><p><strong>4.</strong> 右键需要共享的文件夹，选择共享即可。</p><p><strong>5.</strong> 访问操作，在一台电脑上 <strong>Win+R</strong>，输入对方IP地址，如：\192.168.102即可看到共享的文件，同理在另一台电脑上 <strong>Win+R</strong> 输入\192.168.101即可看到另一台电脑上共享的文件夹或者进入电脑桌面的网络，选择相应的共享电脑，就可看到共享的文件夹（或者网络邻居进行访问）。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows变量路径与通配符</title>
    <link href="/2023/04/14/Windows%E5%8F%98%E9%87%8F%E8%B7%AF%E5%BE%84%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <url>/2023/04/14/Windows%E5%8F%98%E9%87%8F%E8%B7%AF%E5%BE%84%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p><code>%SystemDrive%</code> 操作系统所在的分区号。如 C:</p><p><code>%SystemRoot%</code> 操作系统根目录。如 C:</p><p><code>%windir%</code> 操作系统根目录。如 C:</p><p><code>%ALLUSERSPROFILE%</code> 相当于 C:and SettingsUsers</p><p><code>%APPDATA%</code> 相当于 C:and SettingsData</p><p><code>%ProgramFiles%</code> 相当于 C:Files</p><p><code>%CommonProgramFiles%</code> 相当于 C:FilesFiles</p><p><code>%HOMEDRIVE%</code>操作系统所在的分区号。如：C:</p><p><code>%HOMEPATH%</code> 相当于 and Settings</p><p><code>%USERPROFILE%</code> 相当于 C:and Settings</p><p><code>%ALLUSERSPROFILE%</code> 列出所有用户Profile文件位置。</p><p><code>%system%</code> 即C:</p><p><code>%APPDATA%</code> 列出应用程序数据的默认存放位置。</p><p><code>%CD%</code>列出当前目录。</p><p><code>%CLIENTNAME%</code>列出联接到终端服务会话时客户端的NETBIOS名。</p><p><code>%CMDCMDLINE%</code> 列出启动当前cmd.exe所使用的命令行。</p><p><code>%CMDEXTVERSION%</code> 命令出当前命令处理程序扩展版本号。</p><p><code>%CommonProgramFiles%</code> 列出了常用文件的文件夹路径。</p><p><code>%COMPUTERNAME%</code> 列出了计算机名。</p><p><code>%COMSPEC%</code>列出了可执行命令外壳（命令处理程序）的路径。</p><p><code>%DATE%</code> 列出当前日期。</p><p><code>%ERRORLEVEL%</code> 列出了最近使用的命令的错误代码。</p><p><code>%HOMEDRIVE%</code> 列出与用户主目录所在的驱动器盘符。</p><p><code>%HOMEPATH%</code> 列出用户主目录的完整路径。</p><p><code>%HOMESHARE%</code> 列出用户共享主目录的网络路径。</p><p><code>%LOGONSEVER%</code> 列出有效的当前登录会话的域名控制器名。</p><p><code>%NUMBER_OF_PROCESSORS%</code> 列出了计算机安装的处理器数。</p><p><code>%OS%</code> 列出操作系统的名字。(Windows XP 和 Windows 2000 列为 Windows_NT.)</p><p><code>%Path%</code> 列出了可执行文件的搜索路径。</p><p><code>%PATHEXT%</code> 列出操作系统认为可被执行的文件扩展名。</p><p><code>%PROCESSOR_ARCHITECTURE%</code> 列出了处理器的芯片架构。</p><p><code>%PROCESSOR_IDENTFIER%</code> 列出了处理器的描述。</p><p><code>%PROCESSOR_LEVEL%</code> 列出了计算机的处理器的型号。</p><p><code>%PROCESSOR_REVISION%</code> 列出了处理器的修订号。</p><p><code>%ProgramFiles%</code> 列出了Program Files文件夹的路径。</p><p><code>%PROMPT%</code> 列出了当前命令解释器的命令提示设置。</p><p><code>%RANDOM%</code> 列出界于0 和 32767之间的随机十进制数。</p><p><code>%SESSIONNAME%</code>列出连接到终端服务会话时的连接和会话名。</p><p><code>%SYSTEMDRIVE%</code> 列出了Windows启动目录所在驱动器。</p><p><code>%SYSTEMROOT%</code> 列出了Windows启动目录的位置。</p><p><code>%TEMP%</code> 和 <code>%TMP%</code> 列出了当前登录的用户可用应用程序的默认临时目录。</p><p><code>%TIME%</code> 列出当前时间。</p><p><code>%USERDOMAIN%</code> 列出了包含用户帐号的域的名字。</p><p><code>%USERNAME%</code> 列出当前登录的用户的名字。</p><p><code>%USERPROFILE%</code> 列出当前用户Profile文件位置。</p><p><code>%WINDIR%</code> 列出操作系统目录的位置。</p>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>产品文档体系</title>
    <link href="/2023/04/14/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E4%BD%93%E7%B3%BB/"/>
    <url>/2023/04/14/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>产品在整个开发过程及售后都会涉及到文档的编写，具体文档如下：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/07.png" alt="" /><figcaption>../_images/07.png</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>调试九法：软硬件错误的排除之道</title>
    <link href="/2023/04/14/%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%EF%BC%9A%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E9%99%A4%E4%B9%8B%E9%81%93/"/>
    <url>/2023/04/14/%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%EF%BC%9A%E8%BD%AF%E7%A1%AC%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%92%E9%99%A4%E4%B9%8B%E9%81%93/</url>
    
    <content type="html"><![CDATA[<p>在嵌入式技术过程中，会经常进行debug调试，最近看了<strong>《调试九法：软硬件错误的排除之道》</strong>一书，里面详细介绍了九种不同的调试方式，针对不同的问题不同的状态进行不同的思考方式来进行解决，觉得很是受用。现记录如下：</p><h4 id="理解系统">1. 理解系统</h4><p>仔细查阅手册每个细节。</p><h4 id="制造失败">2. 制造失败</h4><p>从头开始复制现象，查找不受控制的条件，记录每件事情，不要过于相信统计数据。</p><h4 id="不要想而要看">3. 不要想，而要看</h4><p>查看细节，并使用外部调试工具</p><h4 id="分而治之">4. 分而治之</h4><p>主次逼近缩小搜索范围，使用易于查看的测试模式。</p><h4 id="一次只改一个地方">5. 一次只改一个地方</h4><p>隔离关键因素，一次只改动一个测试，与正常情况进行对比，确定自从上一次正常工作以来改动的地方。</p><h4 id="保持审计跟踪">6. 保持审计跟踪</h4><p>记下你的每步操作、顺序和结果，记录任何细节，最好用计算机记录下来附加到bug报告中，可以之道修订版本信息。</p><h4 id="检查插头">7. 检查插头</h4><p>质疑你的假设，尤其是一些显而易见的假设，从头开始检查，对工具进行测试。</p><h4 id="获得全新观点">8. 获得全新观点</h4><p>征求别人的意见，获取专业知识，听取别人的经验，报告症状而不要讲你的理论。</p><h4 id="如果你不修复bug它将依然存在">9. 如果你不修复bug，它将依然存在</h4><p>bug从来不会自己消失，从根本上解决问题。</p>]]></content>
    
    
    <categories>
      
      <category>硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora基本用法</title>
    <link href="/2023/04/14/Typora%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2023/04/14/Typora%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。typora软件大部分语法都可以通过快捷键和鼠标右键来完成，具体如下：</p><h4 id="标题级别">标题级别</h4><p>使用简单的 <code>ctrl+数字键</code> 就可以快速完成各种级别的标题</p><h4 id="高亮显示">高亮显示</h4><p><code>==文字==</code> 文字两字就会高亮</p><h4 id="下划线">下划线</h4><p>ctrl + u</p><p><u>下划线</u></p><h4 id="斜体">斜体</h4><p>使用 <code>*单个星号*</code> 或者 <code>_单下划线_</code> 可以字体倾斜。快捷键 <code>Ctrl + I</code></p><p><em>斜体</em></p><h4 id="加粗">加粗</h4><p>使用 <code>**两个星号**</code> 或者 <code>__两个下划线__</code> 可以字体加粗。快捷键 <code>Ctrl + B</code></p><p><strong>加粗</strong></p><h4 id="删除线">删除线</h4><p>使用<code>~~删除线~~</code></p><p><del>删除线</del></p><h4 id="引用文字">引用文字</h4><p>&gt; + 空格 + 引用文字</p><blockquote><p>这是一段引用文字</p><blockquote><p>换行</p></blockquote></blockquote><h4 id="无序列表">无序列表</h4><p>-或+或* + space + enter</p><ul><li><p>AAA</p></li><li><p>BBB</p></li><li><p>CCC</p></li></ul><h4 id="嵌套无序列表">嵌套无序列表</h4><p>在删除第一级后，自动跳到下一级，返回上一级，连续按次enter</p><h4 id="有序列表">有序列表</h4><p>数字键 + space + enter</p><ol type="1"><li><p>AAA</p></li><li><p>BBB</p></li><li><p>CCC</p></li></ol><h4 id="任务列表">任务列表</h4><p>鼠标右键选择对勾即可。</p><h4 id="代码块">代码块</h4><ul><li><p>插入单句或单词，使用反引号（`） 把其包围</p><p><code>prinf();</code></p></li><li><p>插入代码段，输入3个反引号（`） + enter，并在后面选择一个语言名称即可实现语法高亮。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">helloworld</span>():    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello,world!&quot;</span>)</code></pre></div></li></ul><h4 id="表格">表格</h4><p>使用鼠标右键插入表格或快捷键Ctrl + T。</p><h4 id="分割线">分割线</h4><p>输入 <code>***</code> 或者 <code>---</code> 再按回车即可绘制一条水平线，如下：</p><hr /><h4 id="脚注">脚注</h4><p><code>文字[^脚注]</code></p><p>这是一个脚注[^1]</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414224318716.png"/></p><h4 id="目录toc">目录（TOC）</h4><p>输入 <code>[toc]</code> 然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。</p><h4 id="插入图片">插入图片</h4><p>直接拖进来或鼠标右键插入图像</p><h4 id="链接">链接</h4><p><code>[链接名](http://example.com/)</code></p><p><a href="http://example.com/">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reST基础语法</title>
    <link href="/2023/04/14/reST%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/04/14/reST%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>RestructureText(ReST)是Docutils和Sphinx都使用的默认明文标记语言。Docutils提供了基本的重构文本语法，而Sphinx对此进行了扩展，以支持额外的功能。可以使用在线的rst编辑器了解相关语法：<a href="http://rst.ninjs.org/">rst在线编辑器</a>，下面介绍它的一些常用语法：</p><h2 id="章节标题">1. 章节标题</h2><p>在文本下一行（或上一行）添加至少与文本长度同宽的符号，即可以使文本成为标题, <code>= - ` : ' " ~ ^ _ * + # &lt; &gt;</code> 这些符号都可以</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">===============    一级标题~~~~~~~~~~~~~~~    二级标题---------------    三级标题^^^^^^^^^^^^^^^    四级标题&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;    五级标题***************    六级标题</code></pre></div><p>效果如下： <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/section.png" alt="章节级数" /></p><h2 id="字体样式">2. 字体样式</h2><p>符号外侧必须留有空格, 英文标点符号::</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">**强调***斜体*``红色字体块``:guilabel:`背景块`.. centered:: 黑体中心字体</code></pre></div><p>效果如下： <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414210438330.png" alt="image-20230414210438330" /></p><div class="code-wrapper"><pre><code class="hljs reStructuredText">无序列表:- hhhhhhhh- hhhhhhhh- hhhhhhhh* 列表第一级   + 第二级       - 第三级   + 第二级的另一个项目有序列表:支持数字、大小写字母和罗马数字1. hhhhhhhh#. hhhhhhhh#. hhhhhhhha. hhhhhhhh#. hhhhhhhh#. hhhhhhhh</code></pre></div><p>效果如下： <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414210520680.png" alt="image-20230414210520680" /></p><h2 id="提示框">3. 提示框</h2><p>特殊提示支持警告、重要、提示、注意等标签，适合做显眼的用途。</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. note:: This is note.(注解).. attention:: Directives at large.(注意).. warning:: This is warning.(警告).. caution:: Don&#x27;t take any wooden nickels.(警告).. seealso:: This is seealso.(参见).. danger:: Mad scientist at work!(危险).. error:: Does not compute.(错误).. hint:: It&#x27;s bigger than a bread box.(提示).. important::   - Wash behind your ears.  - Clean up your room.  - Call your mother.  - Back up your data.(重要).. tip:: 15% if the service is good.(小技巧).. admonition:: by the way  You can make up your own admonition too.</code></pre></div><p>效果如下： <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414210957097.png" alt="image-20230414210957097" style="zoom: 50%;" /></p><h2 id="超链接">4. 超链接</h2><div class="code-wrapper"><pre><code class="hljs reStructuredText">1.直接嵌入： `野火公司官网 &lt;http://www.embedfire.com&gt;`_2.使用引用的方式把具体网址定义在其它地方： - 单个词汇：External hyperlinks, like Python_.- 多个词汇时，使用``, `fire website`_.. _Python: http://www.python.org/     .. _fire website: http://www.embedfire.com</code></pre></div><p>效果： <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414211213549.png" alt="image-20230414211213549" style="zoom:80%;" /></p><h2 id="图片">5. 图片</h2><p>显示图片直接使用image或figure指令，还需要添加“alt”选项指定图片的描述（类似doc中的题注），以便图片加载失败时显示文字, <strong>不要使用bmp图片</strong> ，bmp图片在生成pdf的时候会丢失，所以不要使用bmp格式的图片。</p><p>figure命令</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. figure: pic/fire.png    :alt: 野火logo    :align: center    :caption: 野火logo   align-&gt;&quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;center&quot;, or &quot;right&quot;</code></pre></div><p>image命令</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. image:: pic/fire.png    :align: center    :alt: 野火logo</code></pre></div><p>效果一样： <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/fire.png" alt="野火logo" /></p><p>图片还可以使用 width、heigh、scale等参数，但不推荐使用。</p><h2 id="代码高亮">6. 代码高亮</h2><p>在reST文档中列出代码有三种方式：</p><ul><li><ol type="1"><li>单行代码 用 `code`，如：</li></ol><p>`#define LED P23`</p><p>效果： <code>#define LED P23</code></p></li><li><ol start="2" type="1"><li>简单代码块 在代码块的上一个段落后面加2个冒号，空一行后开始代码块，代码块要缩进, 如：</li></ol><div class="code-wrapper"><pre><code class="hljs reStructuredText">::     #此命令在主机执行     sudo apt install python     echo &quot;helloworld,this is a script test!&quot;</code></pre></div><p>效果：</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">#此命令在主机执行sudo apt install pythonecho &quot;helloworld,this is a script test!&quot;</code></pre></div></li><li><ol start="3" type="1"><li>复杂代码块 使用code-block指导语句，还可以选择列出行号和高亮重点行等，如：</li></ol><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. code-block:: c:caption: test:name: test333:emphasize-lines: 2,4-9:linenos:int main()&#123;    printf(&quot;hello, world! This is a C program.\n&quot;);    for(int i=0;i&lt;10;i++ )&#123;    printf(&quot;output i=%d\n&quot;,i);&#125;return 0;&#125;注意：code-block 后面可以是不同的编程语言，sh、c、v(verilog)、python、makefile等caption -&gt; 代码前面显示的名字name -&gt; 自定义名字，方便其他地方使用此名字加下划线来引用emphasize-lines -&gt; 高亮的行linenos -&gt; 显示行数</code></pre></div></li></ul><h2 id="表格">7. 表格</h2><p>表格语法说明：http://docutils.sourceforge.net/docs/ref/rst/directives.html#csv-table ,推荐使用列表式表格，修改比较方便,</p><h4 id="列表式表格">7.1 列表式表格</h4><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. list-table:: Frozen Delights!    :widths: 15 10 30    :header-rows: 1    * - Treat    - Quantity    - Description    * - Albatross    - 2.99    - On a stick!    * - Crunchy Frog    - 1.49    - If we took the bones out, it wouldn&#x27;t be    crunchy, now would it?    * - Gannet Ripple    - 1.99    - On a stick!</code></pre></div><p>效果：<img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414214027390.png" alt="image-20230414214027390" /></p><h4 id="普通表格">7.2 普通表格</h4><div class="code-wrapper"><pre><code class="hljs reStructuredText">=====  =====  =======A      B      A and B=====  =====  =======False  False  FalseTrue   False  FalseFalse  True   FalseTrue   True   True=====  =====  =======</code></pre></div><p>效果：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414214149304.png" alt="" /><figcaption>image-20230414214149304</figcaption></figure><h4 id="csv表格">7.3 CSV表格</h4><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. csv-table:: Frozen Delights!    :header: &quot;Treat&quot;, &quot;Quantity&quot;, &quot;Description&quot;    :widths: 15, 10, 30    &quot;Albatross&quot;, 2.99, &quot;On a stick!&quot;    &quot;Crunchy Frog&quot;, 1.49, &quot;If we took the bones out, it wouldn&#x27;t be    crunchy, now would it?&quot;    &quot;Gannet Ripple&quot;, 1.99, &quot;On a stick!&quot;</code></pre></div><p>效果： <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414214306558.png" alt="image-20230414214306558" /></p><h2 id="引用">8. 引用</h2><h4 id="引用图片表格">8.1 引用图片、表格</h4><p>在图片、表格上面加一个下划线的引用标签，然后在下面通过 ref指令引用。 示例1：</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. _my-reference-label:.. figure: pic/fire.png   :alt: 野火logo   :align: center   name   :ref:`my-reference-label`</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414214640426.png" alt="image-20230414214640426" style="zoom:67%;" /></p><p>示例2：</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. _Table1:.. table:: 拨码开关启动配置表    ==== ====== ========== ==== == ===    编号 名称   NAND FLASH eMMC SD USB    ==== ====== ========== ==== == ===    1    MODE0  0          0    0  1    2    MODE1  1          1    1  0    3    CFG1-4 1          0    0  X    4    CFG1-5 0          1    0  X    5    CFG1-6 0          1    1  X    6    CFG1-7 1          0    0  X    7    CFG2-3 0          1    0  X    8    CFG2-5 0          0    1  X    ==== ====== ========== ==== == ===:ref:`Table1` :ref:`自定义引用名称 &lt;Table1&gt;`</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414214843366.png" alt="image-20230414214843366" style="zoom: 67%;" /></p><h4 id="引用文档">8.2 引用文档</h4><div class="code-wrapper"><pre><code class="hljs reStructuredText">:doc:`base-syntax`链接到当前目录的base-syntax.rst文档，且显示为其标题:doc:`our two different sites &lt;base-syntax&gt;`链接到当前目录的base-syntax.rst文档</code></pre></div><p>效果：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414215033089.png" alt="" /><figcaption>image-20230414215033089</figcaption></figure><h4 id="引用非rst文档">8.3 引用非rst文档</h4><p>会呈现出点击后下载文件的效果。注意这种引用方式在生成pdf文件时链接会无效。</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">:download:`引用非rst的本地文档 &lt;base-syntax.rst&gt;`.</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414215143223.png" alt="image-20230414215143223" style="zoom:80%;" /></p><h2 id="脚注">9. 脚注</h2><p>与引用语法类似，只是它在正文中显示的不是文本，而是编号。</p><div class="code-wrapper"><pre><code class="hljs reStructuredText">Footnote references, like [5]_.using [#]_ and [#]_.instant[#fourth]_ and [#third]_.reference[DOC]_.                                                                             Footnotes                                                       .. [5] A numerical footnote... [#] This is the first one. .. [#] This is the second one. .. [#third] a.k.a. third.. [#fourth] a.k.a. fourth .. [DOC] A citation</code></pre></div><p>效果：</p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414215340170.png" alt="image-20230414215340170" style="zoom:67%;" /></p><h2 id="rst格式">10. rst格式</h2><div class="code-wrapper"><pre><code class="hljs reStructuredText">.. include:: ../README.rst在index.rst中添加其他rst文件.. contents:: 目录        生成目录.. section-numbering::生成的目录自动编号.. contents::    :local:  当前主题之下生成目录   :depth: 3  目录深度为3级</code></pre></div><h2 id="参考链接">参考链接</h2><ul><li><a href="https://docutils.sourceforge.io/docs/user/rst/">restruct语法官网</a></li><li><a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html">reST参考网站</a></li><li><a href="https://www.jianshu.com/p/1885d5570b37">其他参考网站</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sphinx + reST + github + ReadtheDocs编写在线文档</title>
    <link href="/2023/04/14/Sphinx-reST-github-ReadtheDocs%E7%BC%96%E5%86%99%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3/"/>
    <url>/2023/04/14/Sphinx-reST-github-ReadtheDocs%E7%BC%96%E5%86%99%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>使用标记语言(Markup Language)写文档是当前比较流行的文档编写方式，目前标记语言主要有两种，Markdown和reStructuredText（简称reST)。很多开源项目的文档就是用Sphinx+reST做的，上传到github和ReadtheDocs，通过浏览器就可以直接查看带有格式的文档了。结合网上多个教程，总结了以下创建教程。</p><h3 id="安装软件包">1. 安装软件包</h3><hr /><ul><li>安装 <a href="https://www.python.org/">python3</a>,并添加bin目录到环境变量中。</li><li>安装 <a href="https://git-scm.com/download">git 软件</a>，并添加bin目录到环境变量中。</li><li>通过pip工具安装 <a href="https://www.sphinx-doc.org/en/master/index.html">sphinx工具</a>, <code>pip install -U Sphinx</code> 或 <code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple sphinx</code></li><li>安装 <a href="https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes">Sphinx Themes</a>, 这里选择 <a href="https://sphinx-themes.org/">第三方主题</a> “Read the Docs”, <code>pip install sphinx sphinx-autobuild sphinx_rtd_theme</code> 或 <code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple sphinx sphinx-autobuild sphinx_rtd_theme</code></li></ul><h3 id="建立项目">2. 建立项目</h3><hr /><p>新建文件夹，这里命名为 <strong>doc_demo</strong> ,进入文件夹，按住 <strong>shift键</strong> ，点击鼠标右键，选择 <strong>在此处打开命令窗口</strong> ，弹出cmd命令行，运行 sphinx-quickstart，根据需要命令行中的提示输入创建信息。这里我建立了一个 <strong>doc</strong>的Project，版本是 <strong>1.0</strong>， 作者名为 <strong>kayoungzhang</strong>，语言为 <strong>zh_CN</strong> ,将source与build目录分开。</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">Microsoft Windows [版本 <span class="hljs-number">6.1</span><span class="hljs-number">.7601</span>]版权所有 (c) <span class="hljs-number">2009</span> Microsoft Corporation。保留所有权利。C:\Users\Administrator&gt;cd doc_demoC:\Users\Administrator\doc_demo&gt;sphinx-quickstartWelcome <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> Sphinx <span class="hljs-number">3.5</span><span class="hljs-number">.4</span> quickstart utility.Please enter values <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> following settings (just press Enter <span class="hljs-built_in">to</span>accept <span class="hljs-keyword">a</span> default <span class="hljs-built_in">value</span>, <span class="hljs-keyword">if</span> <span class="hljs-literal">one</span> is given <span class="hljs-keyword">in</span> brackets).Selected root path: .You have <span class="hljs-literal">two</span> options <span class="hljs-keyword">for</span> placing <span class="hljs-keyword">the</span> build <span class="hljs-built_in">directory</span> <span class="hljs-keyword">for</span> Sphinx output.Either, you use <span class="hljs-keyword">a</span> <span class="hljs-built_in">directory</span> <span class="hljs-string">&quot;_build&quot;</span> <span class="hljs-keyword">within</span> <span class="hljs-keyword">the</span> root path, <span class="hljs-keyword">or</span> you separate<span class="hljs-string">&quot;source&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;build&quot;</span> <span class="hljs-built_in">directories</span> <span class="hljs-keyword">within</span> <span class="hljs-keyword">the</span> root path.&gt; Separate source <span class="hljs-keyword">and</span> build <span class="hljs-built_in">directories</span> (y/n) [n]: yThe project name will occur <span class="hljs-keyword">in</span> several places <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> built documentation.&gt; Project name: doc&gt; Author name(s): kayoungzhang&gt; Project release []: <span class="hljs-number">1.0</span>If <span class="hljs-keyword">the</span> documents are <span class="hljs-built_in">to</span> be written <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> language other than English,you can select <span class="hljs-keyword">a</span> language here <span class="hljs-keyword">by</span> its language code. Sphinx will <span class="hljs-keyword">then</span>translate <span class="hljs-keyword">text</span> that <span class="hljs-keyword">it</span> generates <span class="hljs-keyword">into</span> that language.For <span class="hljs-keyword">a</span> list <span class="hljs-keyword">of</span> supported codes, see<span class="hljs-keyword">https</span>://www.sphinx-doc.org/en/master/usage/configuration.html<span class="hljs-comment">#confval-language.</span>&gt; Project language [en]: zh_CNCreating <span class="hljs-built_in">file</span> C:\Users\Administrator\doc_demo\source\conf.py.Creating <span class="hljs-built_in">file</span> C:\Users\Administrator\doc_demo\source\index.rst.Creating <span class="hljs-built_in">file</span> C:\Users\Administrator\doc_demo\Makefile.Creating <span class="hljs-built_in">file</span> C:\Users\Administrator\doc_demo\make.bat.Finished: An initial <span class="hljs-built_in">directory</span> structure has been created.You should now populate your master <span class="hljs-built_in">file</span> C:\Users\Administrator\doc_demo\source\index.rst <span class="hljs-keyword">and</span> <span class="hljs-built_in">create</span> other documentationsource <span class="hljs-built_in">files</span>. Use <span class="hljs-keyword">the</span> Makefile <span class="hljs-built_in">to</span> build <span class="hljs-keyword">the</span> docs, like so:make builderwhere <span class="hljs-string">&quot;builder&quot;</span> is <span class="hljs-literal">one</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> supported builders, e.g. html, latex <span class="hljs-keyword">or</span> linkcheck.C:\Users\Administrator\doc_demo&gt;</code></pre></div><p><strong>doc_demo</strong> 文件夹中出现一些文件：</p><ul><li>source和build分别是源文件目录和编译生成文件的存放目录</li><li>Makefile和make.bat分别是Linux和Windows下的makefile</li><li>conf.py是配置文件，index.rst是配置文档显示结构，_static是静态文件存放目录_templates是模板存放目录</li></ul><h3 id="conf.py配置">3. conf.py配置</h3><hr /><h4 id="更换主题">3.1 更换主题</h4><p>使用记事本打开文件 <strong>conf.py</strong>，找到 <strong>theme</strong> 主题，屏蔽旧主题，更换新的主题。</p><div class="code-wrapper"><pre><code class="hljs clean"># html_theme = <span class="hljs-string">&#x27;alabaster&#x27;</span><span class="hljs-keyword">import</span> sphinx_rtd_themehtml_theme = <span class="hljs-string">&quot;sphinx_rtd_theme&quot;</span></code></pre></div><h4 id="添加主页logo">3.2 添加主页logo</h4><p>准备好logo文件</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">html_logo</span> = <span class="hljs-string">&#x27;./logo.png&#x27;</span></code></pre></div><h4 id="不显示源文件链接">3.3 不显示源文件链接</h4><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">html_show_sourcelink</span> = <span class="hljs-literal">False</span></code></pre></div><h4 id="支持markdown编辑及表格">3.4 支持markdown编辑及表格</h4><p>首先需要安装插件 <strong>myst-parser，recommonmark，sphinx-markdown_tables</strong>:</p><div class="code-wrapper"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> myst-parserpip <span class="hljs-keyword">install</span> recommonmarkpip <span class="hljs-keyword">install</span> sphinx-markdown_tables</code></pre></div><p>然后在 <strong>conf.py</strong> 添加：</p><div class="code-wrapper"><pre><code class="hljs pgsql">extensions = [‘myst_parser’, ‘sphinx_markdown_tables’]<span class="hljs-keyword">from</span> recommonmark.<span class="hljs-keyword">parser</span> <span class="hljs-keyword">import</span> CommonMarkParsersource_parsers = &#123;                <span class="hljs-string">&#x27;.md&#x27;</span>: CommonMarkParser,&#125;source_suffix = [<span class="hljs-string">&#x27;.rst&#x27;</span>, <span class="hljs-string">&#x27;.md&#x27;</span>]</code></pre></div><h3 id="创建rst文件">4. 创建rst文件</h3><hr /><p>当需要创建自己的文档时，就在 <strong>source</strong> 文件夹中创建，这里创建 <strong>sphinx.rst</strong> 和 <strong>vscode.rst</strong> 文档，同时新建文件夹 <strong>docxtorst</strong> ，并在其中创建 <strong>docxtorst.rst</strong> 文档。在这三个文档中添加标题和内容。</p><h3 id="设置toctree">5. 设置toctree</h3><hr /><p>使用记事本打开 <strong>source</strong> 目录下的 <strong>index.rst</strong> 文件，根据刚才创建的文档和位置，填写以下内容：</p><div class="code-wrapper"><pre><code class="hljs elixir">.. toctree::   <span class="hljs-symbol">:maxdepth</span>: <span class="hljs-number">2</span>   <span class="hljs-symbol">:caption</span>: <span class="hljs-title class_">Table</span> of <span class="hljs-title class_">Contents</span>   <span class="hljs-symbol">:titlesonly</span>:   <span class="hljs-symbol">:numbered</span>:   sphinx   vscode   docxtorst/docxtorst</code></pre></div><p>说明：</p><div class="code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">maxdepth</span> -&gt;</span> 目录中可显示标题的最多级数，不添加则会显示文档中所有标题<span class="hljs-function"><span class="hljs-title">caption</span> -&gt;</span> toctree显示标题<span class="hljs-function"><span class="hljs-title">titleonly</span> -&gt;</span>只想显示toctree文档标题，而不显示同一级别的其他标题<span class="hljs-function"><span class="hljs-title">numbered</span> -&gt;</span> 给罗列的文档标题进行显示标号，子目录也会自动编号<span class="hljs-function"><span class="hljs-title">sphinx</span>、vscode -&gt;</span>当前index.rst文档所在目录下的sphinx.rst和vscode.rst文档<span class="hljs-function"><span class="hljs-title">docxtorst</span>/docxtorst -&gt;</span> docxtorst文件夹下的docxtorst.rst文档</code></pre></div><h3 id="编译输出">6. 编译输出</h3><hr /><p>在命令行中，运行 <code>make html</code> 编译生成html文件：</p><div class="code-wrapper"><pre><code class="hljs gams">C:\Users\Administrator\doc_demo&gt;make htmlRunning Sphinx v3<span class="hljs-number">.5</span><span class="hljs-number">.4</span>loading translations [zh_CN]... done<span class="hljs-function"><span class="hljs-title">loading</span></span> pickled environment... donemyst v0<span class="hljs-number">.14</span><span class="hljs-number">.0</span>: MdParserConfig(renderer=<span class="hljs-string">&#x27;sphinx&#x27;</span>, commonmark_only=False, dmath_allow_labels=True, dmath_allow_space=True, dmath_allow_digits=True, dmath_double_inline=False, update_mathjax=True, enable_extensions=[<span class="hljs-string">&#x27;dollarmath&#x27;</span>], disable_syntax=[], url_schemes=None, heading_anchors=None, html_meta=[], footnote_transition=True, substitutions=[], sub_delimiters=[<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>], words_per_minute=<span class="hljs-number">200</span>)building [mo]: targets <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> po <span class="hljs-keyword">files</span> that are out of datebuilding [html]: targets <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> source <span class="hljs-keyword">files</span> that are out of dateupdating environment: [config changed (<span class="hljs-string">&#x27;source_parsers&#x27;</span>)] <span class="hljs-number">4</span> added, <span class="hljs-number">0</span> changed, <span class="hljs-number">0</span>removed<span class="hljs-function"><span class="hljs-title">reading</span></span> sources... [<span class="hljs-number">100</span>%] vscode<span class="hljs-function"><span class="hljs-title">looking</span></span> <span class="hljs-keyword">for</span> now-outdated <span class="hljs-keyword">files</span>... none found<span class="hljs-function"><span class="hljs-title">pickling</span></span> environment... done<span class="hljs-function"><span class="hljs-title">checking</span></span> consistency... done<span class="hljs-function"><span class="hljs-title">preparing</span></span> documents... done<span class="hljs-function"><span class="hljs-title">Building</span></span> prefix dict from the default dictionary ...Loading <span class="hljs-keyword">model</span> from cache C:\Users\ADMINI~<span class="hljs-number">1</span>\AppData\Local\Temp\jieba.cacheLoading <span class="hljs-keyword">model</span> cost <span class="hljs-number">1.264</span> seconds.Prefix dict has been built succesfully.<span class="hljs-function"><span class="hljs-title">writing</span></span> output... [<span class="hljs-number">100</span>%] vscode<span class="hljs-function"><span class="hljs-title">generating</span></span> indices... genindex done<span class="hljs-function"><span class="hljs-title">writing</span></span> additional pages... search done<span class="hljs-function"><span class="hljs-title">copying</span></span> images... [<span class="hljs-number">100</span>%] docxtorst/media/docxto015.png<span class="hljs-function"><span class="hljs-title">copying</span></span> static <span class="hljs-keyword">files</span>... done<span class="hljs-function"><span class="hljs-title">copying</span></span> extra <span class="hljs-keyword">files</span>... donedumping search index in Chinese (code: zh)... done<span class="hljs-function"><span class="hljs-title">dumping</span></span> object inventory... donebuild succeeded.The HTML pages are in build\html.</code></pre></div><p>在build文件夹的html文件夹下, 打开html文件即可看到具体的网页实现：</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230414133802554.png" alt="" /><figcaption>image-20230414133802554</figcaption></figure><h3 id="github或gitee托管">7. github或gitee托管</h3><hr /><p>以上的操作，只能在本地的浏览器查看文档，若想让所有人都能看到，需要部署到 <strong>ReadtheDocs</strong> ，在部署之前，要把代码托管到代码托管平台，这里选用github，也可以选gitee，国内访问使用速度快。</p><p>先到 <strong>github</strong> 上建立一个公开的仓库，如我建立一个名为 <strong>doc</strong> 的仓库,然后在本地仓库中创建一个 <strong>.gitignore</strong> 文件，它的作用是将本地一些文件不上传到远程仓库，这里将 <code>build/</code>填入此其中，最后打开 <strong>git bash</strong>，将本地仓库上传到远端：</p><div class="code-wrapper"><pre><code class="hljs mipsasm">git initgit <span class="hljs-keyword">add </span>-Agit commit -m <span class="hljs-string">&quot;first commit&quot;</span>git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>github上远程库地址git push -u <span class="hljs-keyword">origin </span>master</code></pre></div><h3 id="readthedocs托管">8. ReadtheDocs托管</h3><hr /><p>在 <a href="https://readthedocs.org/">ReadtheDocs</a> 上注册一个账号, 登陆后点击 “<strong>Import</strong>”，给该文档项目填写一个名字比如：<strong>doc</strong>, 添加你在GitHub上面的工程 <strong>HTTPS链接</strong>, 选择仓库类型为 <strong>Git</strong>, 其他项目根据自己的需要填写,点击 <strong>Create</strong>，创建完后会自动激活Webhooks，不用再去GitHub设置，从此只要你往这个仓库push内容，readthedoc上面的文档就会自动更新。可参考 <a href="https://github.com/rtfd/readthedocs.org">ReadtheDocs官方文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bat(批处理)指令与应用</title>
    <link href="/2023/04/13/Bat-%E6%89%B9%E5%A4%84%E7%90%86-%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/13/Bat-%E6%89%B9%E5%A4%84%E7%90%86-%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Windows下批处理指令在工作生活中有很大的应用，可实现自动化处理某些任务。打开window中的命令行窗口，输入相应命令加上/? 可以查看各命令的详细使用方法（如 <strong>dir /?</strong> ），下面介绍一些常用的指令：</p><hr /><h4 id="基本指令">基本指令</h4><p><code>rem 这是一条注释语句</code> ---&gt;命令行注释，可以回显</p><p><code>:: 这是一条注释语句</code> ---&gt;命令行注释，不可回显</p><p><code>pause</code> ---&gt;暂停批处理文件的执行，命令行提示 <strong>请按任意键继续</strong></p><p><code>@echo off</code> ---&gt;关闭回显，一般批处理文件第一行都是这句</p><p><code>echo off</code> ---&gt;从下一行开始关闭回显</p><p><code>echo on</code> ---&gt;从下一行开始打开回显</p><p><code>ehco.</code> ---&gt;换行</p><p><code>echo Y | rd /s E:\mybat</code> ---&gt;删除文件提示 <strong>Y</strong></p><p><code>echo hello word &gt; E:\newfile.txt</code> ---&gt;创建文件并向文件写内容</p><p><code>echo hello word &gt;&gt; E:\newfile.txt</code> ---&gt;向文件追加内容</p><p><code>cls</code> ---&gt;清屏</p><p><code>title 这是一个标题</code> ---&gt;设置窗口标题</p><p><code>color 0A</code> ---&gt;设置窗口颜色，颜色的设置具体用法查看 <strong>color /?</strong></p><p><code>dir</code> ---&gt;显示当前目录下文件</p><p><code>cd 路径</code> ---&gt;切换路径</p><p><code>call test1.bat</code> ---&gt;在同一个命令窗口调用另一个批处理文件</p><p><code>start e:\test.txt</code> ---&gt;打开命令行并执行一个新的程序</p><p><code>del /q/a/f d:\temp\*.*</code> ---&gt;删除指定文件，参数的具体用法查看 <strong>del /?</strong></p><p><code>rd /s/q d:\temp</code> ---&gt;删除文件夹及子文件夹</p><p><code>md mybat</code> ---&gt;创建文件夹</p><p><code>copy C:\mybat.txt D:\</code> ---&gt;复制文件，不能复制文件夹</p><p><code>ren d:\temp tmp</code> ---&gt;重命名文件</p><p><code>move mybat\1.txt myfile\</code> ---&gt;移动文件</p><p><code>find "abc" mybat\4.txt</code> ---&gt;在文件中查找字符，参数的具体用法查看 <strong>find /?</strong></p><p><code>type c:\boot.ini</code> ---&gt;显示文件内容</p><p><code>date</code> ---&gt;显示系统日期</p><p><code>time</code> ---&gt;显示系统时间</p><p><code>:label</code> ---&gt;行标签</p><p><code>goto label</code> ---&gt;跳转到指定标签</p><p><code>tree d:\</code> ---&gt;显示目录结构</p><p><code>ping www.baidu.com</code> ---&gt;测试网络连接量</p><p><code>del a.txt &amp;&amp; echo OK</code> ---&gt;顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令</p><p><code>del a.txt || echo error</code> ---&gt;顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令</p><p><code>dir *.* /s/a | find /c ".exe"</code> --&gt;管道命令表示先执行 dir 命令，对其输出的结果执行后面的 find 命令</p><hr /><h4 id="高级指令">高级指令</h4><p><strong><code>if</code> 判断命令</strong>,具体查看 <strong>if /?</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> not exist d:\test.bat (    <span class="hljs-built_in">echo</span> @<span class="hljs-built_in">echo</span> off&gt;d:\test.bat) <span class="hljs-keyword">else</span> (    del d:\test.bat) ::如果d盘不存在test.bat文件，则在d盘创建test.bat文件，并写入 @<span class="hljs-built_in">echo</span> off，如果存在则删除此文件</code></pre></div><p><strong><code>for</code> 循环命令</strong>，具体查看 <strong>for /?</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> %%i <span class="hljs-keyword">in</span> (d:\*.*) <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;%%i&quot;</span>  ::找出D盘下所有文件<span class="hljs-keyword">for</span> %%i <span class="hljs-keyword">in</span> (*.txt) <span class="hljs-keyword">do</span> find <span class="hljs-string">&quot;abc&quot;</span> %%i   ::对当前目录里所有的txt文件执行 find 命令<span class="hljs-keyword">for</span> /r d:\mp3 %%i <span class="hljs-keyword">in</span> (*.mp3) <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> %%i&gt;&gt;d:\mp3.txt   ::把 d:\mp3 及其子目录里的mp3文件的文件名都存到 d:\mp3.txt 里去<span class="hljs-keyword">for</span> /l %%i <span class="hljs-keyword">in</span> (2,1,8) <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> %%i   ::生成2345678序列，2是数字序列的开头，8是结尾，1表示每次加1<span class="hljs-keyword">for</span> /f <span class="hljs-string">&quot;skip=5 tokens=4&quot;</span> %%a <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;dir&#x27;</span>) <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> %%a   ::对<span class="hljs-built_in">dir</span>命令的结果，跳过前5行，余下每行取第4列</code></pre></div><p><strong><code>start</code></strong></p><div class="code-wrapper"><pre><code class="hljs bash">start <span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">&quot;D:\Program Files\Git\git-bash.exe&quot;</span> -c <span class="hljs-string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d;bash&quot;</span> ::通过命令窗口打开git-bash，并在git-bash中运行hexo命令，完成后bash窗口不关闭::参数说明： <span class="hljs-string">&quot;&quot;</span> ---&gt;用于执行计算机空白符::参数说明： -c ---&gt;设置启动命令参数，各个参数间用&amp;&amp;分隔::参数说明： ;bash结尾符 ---&gt;防止git-bash窗口关闭</code></pre></div><p><strong><code>set</code> 设置变量</strong>，具体查看 <strong>set /?</strong></p><ol type="1"><li>set接收用户输入数据</li></ol><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> /p param=请输入密码：<span class="hljs-built_in">echo</span> %param%</code></pre></div><ol start="2" type="1"><li>set定义变量</li></ol><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> p=aa1bb1aa2bb2           ::设置变量p并赋值，即aa1bb1aa2bb2, <span class="hljs-string">&quot;变量名=值&quot;</span> 中间不要有空格<span class="hljs-built_in">echo</span> %p%                     ::显示变量p代表的字符串，即aa1bb1aa2bb2<span class="hljs-built_in">echo</span> %p:~6%                  ::显示变量p中第6个字符以后的所有字符，即aa2bb2<span class="hljs-built_in">echo</span> %p:~6,3%                ::显示第6个字符以后的3个字符，即aa2<span class="hljs-built_in">echo</span> %p:~0,3%                ::显示前3个字符，即aa1<span class="hljs-built_in">echo</span> %p:~-2%                 ::显示最后面的2个字符，即b2<span class="hljs-built_in">echo</span> %p:~0,-2%               ::显示除了最后2个字符以外的其它字符，即aa1bb1aa2b<span class="hljs-built_in">echo</span> %p:aa=c%                ::用c替换变量p中所有的aa，即显示c1bb1c2bb2<span class="hljs-built_in">echo</span> %p:aa=%                 ::将变量p中的所有aa字符串置换为空，即显示1bb12bb2<span class="hljs-built_in">echo</span> %p:*bb=c%               ::第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2<span class="hljs-built_in">set</span> p=%p:*bb=c%              ::设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2<span class="hljs-built_in">set</span> /a p=39                  ::设置p为数值型变量，值为39<span class="hljs-built_in">set</span> /a p=39/10               ::支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3<span class="hljs-built_in">set</span> /a p=p/10                ::用 /a 参数时，在 = 后面的变量可以不加%直接引用<span class="hljs-built_in">set</span> /a p=”1&amp;0″               ::”与”运算，要加引号。<span class="hljs-built_in">set</span> p=                       ::取消p变量</code></pre></div><ol start="3" type="1"><li>set用于数字表达式</li></ol><div class="code-wrapper"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<span class="hljs-built_in">set</span> a=1&amp;<span class="hljs-built_in">set</span> b=6<span class="hljs-built_in">set</span> c=%a%+%b% <span class="hljs-built_in">echo</span> %c% ::输出1+6<span class="hljs-built_in">set</span> d=a+b<span class="hljs-built_in">echo</span> %d% ::输出a+b<span class="hljs-built_in">set</span> /a e=a+b<span class="hljs-built_in">echo</span> %e% ::输出7pause</code></pre></div><p><strong><code>变量%0--%9</code></strong> 命令行传递给批处理的参数</p><div class="code-wrapper"><pre><code class="hljs bash">%0 ::批处理文件本身%1 ::第一个参数%9 ::第九个参数%* ::从第一个参数开始的所有参数%~1     :: 删除引号(<span class="hljs-string">&quot;)，扩充 %1</span><span class="hljs-string">%~f1    :: 将 %1 扩充到一个完全合格的路径名</span><span class="hljs-string">%~d1    :: 仅将 %1 扩充到一个驱动器号</span><span class="hljs-string">%~p1    :: 仅将 %1 扩充到一个路径</span><span class="hljs-string">%~n1    :: 仅将 %1 扩充到一个文件名</span><span class="hljs-string">%~x1    :: 仅将 %1 扩充到一个文件扩展名</span><span class="hljs-string">%~s1    :: 扩充的路径指含有短名</span><span class="hljs-string">%~a1    :: 将 %1 扩充到文件属性</span><span class="hljs-string">%~t1    :: 将 %1 扩充到文件的日期/时间</span><span class="hljs-string">%~z1    :: 将 %1 扩充到文件的大小</span><span class="hljs-string">%~dp1   ::只将 %1 扩展到驱动器号和路径</span><span class="hljs-string">%~nx1   ::只将 %1 扩展到文件名和扩展名</span></code></pre></div><p><strong><code>net</code> 网络命令</strong></p><div class="code-wrapper"><pre><code class="hljs bash">::关闭/启动MySQL服务,等待停止/启动的过程,完成后执行之后的代码net start MySQLnet stop MySQLnet start   ::查看所有运行的服务</code></pre></div><p><strong><code>mshta</code></strong></p><div class="code-wrapper"><pre><code class="hljs bash">::可以调用vb脚本和js脚本mshta vbscript:window.execScript(<span class="hljs-string">&quot;alert(&#x27;hello world!&#x27;);&quot;</span>,<span class="hljs-string">&quot;javascript&quot;</span>)(window.close)mshta javascript:window.execScript(<span class="hljs-string">&quot;msgBox(&#x27;hello world!&#x27;)(window.close)&quot;</span>,<span class="hljs-string">&quot;vbs&quot;</span>)mshta vbscript:msgbox(<span class="hljs-string">&quot;弹窗单行显示内容&quot;</span>,65,<span class="hljs-string">&quot;弹窗的标题&quot;</span>)(window.close)mshta vbscript:CreateObject(<span class="hljs-string">&quot;Wscript.Shell&quot;</span>).popup(<span class="hljs-string">&quot;弹窗内容&quot;</span>,7,<span class="hljs-string">&quot;标题&quot;</span>,64)(window.close)::连续弹二个信息框mshta vbscript:execute(<span class="hljs-string">&quot;msgbox &quot;</span><span class="hljs-string">&quot;one BOX&quot;</span><span class="hljs-string">&quot;:msgbox &quot;</span><span class="hljs-string">&quot;two BOX&quot;</span><span class="hljs-string">&quot;:window.close&quot;</span>)</code></pre></div><p><strong><code>延时</code></strong></p><div class="code-wrapper"><pre><code class="hljs bash">ping 127.0.0.1 -n 3 &gt;nul ---&gt;延时3s<span class="hljs-built_in">timeout</span> /t 10   ---&gt;延迟10s，具体查看 <span class="hljs-built_in">timeout</span> /?</code></pre></div><p><strong><code>弹框</code></strong></p><ol type="1"><li>MSG命令方式</li></ol><div class="code-wrapper"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off::/time:5设置时间弹框的显示时间为5S,5S后自动关闭msg * /time:5 这里是弹窗显示的文本pause::设置弹窗的多行文本(<span class="hljs-built_in">echo</span> 这是弹窗的第一行文本<span class="hljs-built_in">echo</span> 这是第二行文本)|msg * /time:5pause</code></pre></div><ol start="2" type="1"><li>调用VBScript的MsgBox实现弹窗</li></ol><div class="code-wrapper"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> offmshta vbscript:msgbox(<span class="hljs-string">&quot;弹窗单行显示内容&quot;</span>,65,<span class="hljs-string">&quot;弹窗的标题&quot;</span>)(window.close)::多行显示文本可在文本中使用vbCrLf或vbNewLine<span class="hljs-built_in">set</span> msg=<span class="hljs-string">&quot;多行显示vbCrLf这是第二行vbNewLine这是第三行&quot;</span>mshta vbscript:msgbox(Replace(Replace(%msg%,<span class="hljs-string">&quot;vbCrLf&quot;</span>,vbCrLf),<span class="hljs-string">&quot;vbNewLine&quot;</span>,vbNewLine),6,<span class="hljs-string">&quot;自定义标题&quot;</span>)(window.close)MsgBox的button参数取值如下：0 = vbOKOnly - 只显示确定按钮。1 = vbOKCancel - 显示确定和取消按钮。2 = vbAbortRetryIgnore - 显示放弃、重试和忽略按钮。3 = vbYesNoCancel - 显示是、否和取消按钮。4 = vbYesNo - 显示是和否按钮。5 = vbRetryCancel - 显示重试和取消按钮。16 = vbCritical - 显示临界信息图标。32 = vbQuestion - 显示警告查询图标。48 = vbExclamation - 显示警告消息图标。64 = vbInformation - 显示信息消息图标。0 = vbDefaultButton1 - 第一个按钮为默认按钮。256 = vbDefaultButton2 - 第二个按钮为默认按钮。512 = vbDefaultButton3 - 第三个按钮为默认按钮。768 = vbDefaultButton4 - 第四个按钮为默认按钮。0 = vbApplicationModal - 应用程序模式：用户必须响应消息框才能继续在当前应用程序中工作。4096 = vbSystemModal - 系统模式：在用户响应消息框前，所有应用程序都被挂起。注意：第一组值 (0 - 5) 用于描述对话框中显示的按钮类型与数目；第二组值 (16, 32, 48, 64) 用于描述图标的样式；第三组值 (0, 256, 512) 用于确定默认按钮；第四组值 (0, 4096) 则决定消息框的样式。在将这些数字相加以生成 buttons 参数值时，只能从每组值中取用一个数字。</code></pre></div><h4 id="参考链接">参考链接</h4><p><a href="https://www.jb51.net/article/245233.htm">bat脚本常用命令及亲测示例代码超详细讲解</a> <a href="https://blog.csdn.net/qq_43331089/article/details/124222342">Bat文件的创建及其命令大全</a></p>]]></content>
    
    
    <categories>
      
      <category>编程基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo和Github Pages搭建个人博客</title>
    <link href="/2023/04/12/Hexo%E5%92%8CGithub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/04/12/Hexo%E5%92%8CGithub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="前言">1. 前言</h3><hr /><p>目前网上有很多第三方博客类型，像博客园，CSDN，简书，知乎等。也可以自己搭建个人技术博客，这里以Hexo+Github Pages为例搭建个人博客。Hexo是一个简单、快速、强大的基于 Node.js的静态博客发布工具，支持Markdown格式，有众多优秀插件和主题。Github Pages 是 Github 提供的一种免费的静态网页托管服务，可以用来托管博客、项目官网等静态网页。搭建步骤如下：</p><h3 id="开发环境">2. 开发环境</h3><hr /><p>需要安装开发环境<a href="https://nodejs.org/zh-cn">Node.js</a>和<a href="https://git-scm.com/downloads">git</a></p><h4 id="section"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412203324937.png" alt="image-20230412203324937" style="zoom: 67%;" /></h4><h4 id="section-1"><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412203447726.png" alt="image-20230412203447726" style="zoom: 67%;" /></h4><p>安装完成后，在桌面右键选择 <code>Git Bash Here</code> ，命令窗口打开后，分别输入<code>git --version</code>, <code>node -v</code>, <code>npm -v</code>, 如果弹出对应的版本号，则说明安装正确，否则，需要查找原因。 <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412203622210.png" alt="image-20230412203622210" style="zoom:67%;" /></p><h3 id="安装-hexo">3. 安装 Hexo</h3><hr /><p>在你的电脑上创建一个博客文件夹，如：<code>F:\Blog</code>, 进入此文件夹，右键打开<code>Git Bash Here</code>,依次输入</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-cli</span> <span class="hljs-string">-g</span>  <span class="hljs-comment"># 安装hexo</span><span class="hljs-string">hexo</span> <span class="hljs-string">init</span>                <span class="hljs-comment"># 初始化，安装所需包</span><span class="hljs-string">npm</span> <span class="hljs-string">install</span>              <span class="hljs-comment"># 新版本的Hexo在初始化时就安装好了依赖包</span><span class="hljs-string">hexo</span> <span class="hljs-string">g</span>                   <span class="hljs-comment"># 生成</span><span class="hljs-string">hexo</span> <span class="hljs-string">s</span>                   <span class="hljs-comment"># 启动本地服务</span></code></pre></div><p>打开浏览器访问 <code>http://localhost:4000</code> 即可看到博客网页内容。第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章。</p><h3 id="配置ssh-key">4. 配置SSH key</h3><hr /><p>ssh key用来解决本地和服务器的连接访问github权限问题。</p><h4 id="本地生成密钥对">4.1 本地生成密钥对</h4><p>在git bash命令行中执行 <code>cd ~/.ssh</code>, 如果弹出 <code>No such file or directory</code>,说明你是第一次使用git。需要生成ssh key,否则说明你已经配置了SSH key，不需要再次操作。 在命令行中执行 ：</p><div class="code-wrapper"><pre><code class="hljs c">git config --global user.name <span class="hljs-string">&quot;填入你的github用户名&quot;</span>git config --global user.email <span class="hljs-string">&quot;填入你的email地址&quot;</span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;填入你的email地址&quot;</span></code></pre></div><p>连续三次回车，最终会在用户目录下生成文件，在用户目录下（C:）找到<code>.ssh\id_rsa.pub</code>文件，用记事本打开并复制里面的所有内容。</p><h4 id="添加公钥到github">4.2 添加公钥到Github</h4><p>打开你的github主页，进入Settings -&gt; SSH and GPG keys -&gt; New SSH key： <img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412203930192.png" alt="image-20230412203930192" style="zoom:67%;" /></p><p>添加完成后，还需要确认并添加主机到本机SSH可信列表，在 git bash中输入 <code>ssh -T git@github.com</code> ,若返回 <code>Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.</code>则证明添加成功。</p><h3 id="创建github远程仓库并与本地blog仓库关联">5. 创建github远程仓库，并与本地blog仓库关联</h3><hr /><p>进入你的github主页，创建一个新的仓库，因为Github 仅能使用一个同名仓库的代码托管一个静态站点，所以Repository名字必须是<strong>你的Github名.github.io</strong>，比如我的是<code>KayoungZhang.github.io</code></p><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412204212914.png" alt="image-20230412204212914" style="zoom: 67%;" /></p><p>打开本地blog仓库中配置文件 **_config.yml**，在末尾添加：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><span class="hljs-attr">type:</span> <span class="hljs-string">git</span><span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:你的用户名/你的用户名.github.io.git</span><span class="hljs-comment">#上一步的Github仓库地址，项目主页点SSH再复制url，不要采用http形式的url</span><span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><span class="hljs-comment">#填写远程仓库的分支名，新版本默认是main分支，老版本是master分支</span></code></pre></div><p>在blog文件夹中打开git bash命令行，安装hexo 部署插件，然后进行部署。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-deployer-git</span> <span class="hljs-string">--save</span><span class="hljs-string">hexo</span> <span class="hljs-string">d</span></code></pre></div><p>在浏览器中输入网址： <strong>你的用户名.github.io</strong> ，即可查看到网页。一般来说如果出现莫名的问题，按照以下步骤来解决。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">删除本地blog仓库中.deploy_git文件夹</span><span class="hljs-string">git</span> <span class="hljs-string">bash中执行命令</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><span class="hljs-string">hexo</span> <span class="hljs-string">g</span><span class="hljs-string">hexo</span> <span class="hljs-string">d</span></code></pre></div><p><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230412204326064.png" alt="image-20230412204326064" style="zoom: 50%;" /></p><h3 id="写博客">6. 写博客</h3><hr /><p>在本地blog仓库中，打开<code>git bash</code>，执行命令 <code>hexo new 'my-first-blog'</code>(my-first-blog是文件名)，hexo会帮我们在<code>source/_posts</code>下生成<strong>my-first-blog.md</strong>文件，打开文件，hexo自动添加了一些说明的文件头，后面只需要自己添加文章内容即可。写完后，执行以下命令完成网页上传部署，一般情况下编辑文章中的图片在网页上会无法正常显示，需要图床，将图片上传到网上，同时在主题目录下<strong>head.jade</strong>文件中添加<code>&lt;meta name="referrer" content="no-referrer" /&gt;</code>，具体操作和原因，参看博客 <a href="https://zhuanlan.zhihu.com/p/102594554">PicGo + Gitee(码云)实现markdown图床</a>，<a href="https://www.cnblogs.com/selier/archive/2018/09/01/9570650.html">Hexo使用细节及各种问题</a></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><span class="hljs-string">hexo</span> <span class="hljs-string">g</span> <span class="hljs-string">-d</span></code></pre></div><h3 id="个性化你的博客">7. 个性化你的博客</h3><hr /><h4 id="更换主题">7.1 更换主题</h4><p>默认主题不好看，可以进入 <a href="https://hexo.io/themes/">hexo主题官网</a> 选择自己喜欢的主题，进行更改。这里以 <strong>beautiful-hexo</strong> 主题为例。进入本地blog文件夹中，右键打开 <code>Git Bash Here</code>, 根据选择主题的 <strong>README.md</strong>文件执行相应命令:</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">--save</span> <span class="hljs-string">hexo-generator-archive</span> <span class="hljs-string">hexo-renderer-jade</span> <span class="hljs-string">hexo-generator-tag</span> <span class="hljs-string">hexo-generator-feed</span> <span class="hljs-string">hexo-generator-sitemap</span> <span class="hljs-string">hexo-browsersync</span> <span class="hljs-string">git</span> <span class="hljs-string">clone</span> <span class="hljs-string">--depth</span> <span class="hljs-number">1</span> <span class="hljs-string">https://github.com/twoyao/beautiful-hexo.git</span> <span class="hljs-string">themes/beautiful-hexo</span></code></pre></div><p>在blog文件夹中找到配置文件 **_config.yml** ,使用记事本打开，找到 <strong>theme: landscape</strong> , 将 <strong>landscape</strong>改为 <strong>beautiful-hexo</strong>,保存后，执行命令 <code>hexo clean</code>, 清理一下public的内容，然后执行 <code>hexo g</code>来重新生成, 最后打开本地服务器，执行 <code>hexo s</code> ,打开浏览器就会看到新的主题界面。</p><figure><img src="https://gitee.com/kayoungzhang/picgo_res/raw/master/img/image-20230413074402552.png" alt="" /><figcaption>image-20230413074402552</figcaption></figure><h4 id="主题配置">7.2 主题配置</h4><p>打开<strong>主题目录</strong>下的配置文件 **_config.yml**，可以进行自修改，不使用的功能进行注释（语句前添加#）</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">header:</span>   <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;Beautiful Hexo&quot;</span>   <span class="hljs-attr">motto:</span> <span class="hljs-string">不积跬步无以至千里，不积小流无以成江海</span>   <span class="hljs-attr">bigimgs:</span>       <span class="hljs-bullet">-</span> <span class="hljs-attr">src:</span> <span class="hljs-string">/bigimgs/01.jpg</span>         <span class="hljs-attr">desc:</span> <span class="hljs-string">beautiful</span> <span class="hljs-string">island</span>       <span class="hljs-bullet">-</span> <span class="hljs-attr">src:</span> <span class="hljs-string">/bigimgs/02.jpg</span>         <span class="hljs-attr">desc:</span> <span class="hljs-string">Tropical</span> <span class="hljs-string">Fish</span>       <span class="hljs-bullet">-</span> <span class="hljs-attr">src:</span> <span class="hljs-string">/bigimgs/03.jpg</span>         <span class="hljs-attr">desc:</span> <span class="hljs-string">ocean</span><span class="hljs-attr">mail:</span>  <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;mailto:zky0830@163.com&#x27;</span>  <span class="hljs-attr">title:</span> <span class="hljs-string">Email</span> <span class="hljs-string">me</span>  <span class="hljs-attr">icon:</span> <span class="hljs-string">fa-envelope</span>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><span class="hljs-attr">wechat:</span>  <span class="hljs-attr">link:</span> <span class="hljs-string">&#x27;/wechat.png&#x27;</span> <span class="hljs-comment">#将图片放到source目录下</span>  <span class="hljs-attr">title:</span> <span class="hljs-string">Wechat</span>  <span class="hljs-attr">icon:</span> <span class="hljs-string">fa-wechat</span>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span></code></pre></div><h4 id="全局配置">7.3 全局配置</h4><p>打开配置文件 <code>_config.yml</code>，修改相应内容：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><span class="hljs-attr">title:</span> <span class="hljs-string">My</span> <span class="hljs-string">Tech</span> <span class="hljs-string">Blog</span> <span class="hljs-comment">#主页标题</span><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">#副标题</span><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">#网站描述</span><span class="hljs-attr">keywords:</span><span class="hljs-attr">author:</span> <span class="hljs-string">KayoungZhang</span> <span class="hljs-comment">#作者</span><span class="hljs-attr">language:</span> <span class="hljs-string">zh-cn</span> <span class="hljs-comment">#可根据themes主题中language选择相应语言</span><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment"># URL</span><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><span class="hljs-attr">url:</span> <span class="hljs-string">https://KayoungZhang.github.io</span> <span class="hljs-comment">#项目的 GitHub Pages网址</span><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><span class="hljs-attr">permalink_defaults:</span><span class="hljs-attr">pretty_urls:</span>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><span class="hljs-comment">#自定义站点内容搜索，需要安装插件：</span><span class="hljs-comment"># npm install hexo-generator-search --save</span><span class="hljs-attr">search:</span>  <span class="hljs-attr">path:</span> <span class="hljs-string">search.xml</span>  <span class="hljs-attr">field:</span> <span class="hljs-string">all</span> <span class="hljs-comment"># 如果只索引文章，可设置为post</span></code></pre></div><h4 id="创建文档标签和分类">7.4 创建文档、标签和分类</h4><p>创建标签和分类是为了便于管理和查找，为了给文章自动添加标识，比较方便的做法是，打开<strong>scaffolds</strong>目录下的<strong>post.md</strong>文档，添加<code>tags: 和 categories:</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> &#123;&#123; <span class="hljs-string">title</span> &#125;&#125;<span class="hljs-attr">date:</span> &#123;&#123; <span class="hljs-string">date</span> &#125;&#125;<span class="hljs-attr">tags:</span><span class="hljs-attr">categories:</span><span class="hljs-meta">---</span></code></pre></div><p>这样以后创建文档，它就会自动在文档开头添加标识，你只需要在相应标识下添加分类和标签（以<code>-</code>+空格开头）即可，注意：hexo 一篇文章只能属于一个分类，不会产生两个分类，而是把分类嵌套。如下：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">Hexo和Github</span> <span class="hljs-string">Pages搭建个人博客</span><span class="hljs-attr">date:</span> <span class="hljs-number">2023-04-12 18:57:46</span><span class="hljs-attr">tags:</span> <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-bullet">-</span> <span class="hljs-string">入门</span><span class="hljs-attr">categories:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Blog</span></code></pre></div><p>进入本地blog仓库，打开<code>git bash</code>，通过不同的命令，创建相应的内容。</p><h5 id="创建文章">7.4.1 创建文章</h5><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">&quot;填入你的文章名&quot;</span></code></pre></div><p>在<code>source/_posts</code> 目录下就会生成创建的文档，打开进行写作即可。</p><h5 id="创建标签">7.4.2 创建标签</h5><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">page</span> <span class="hljs-string">tags</span></code></pre></div><p>在<strong>source/tags/</strong>目录下会生成<strong>index.md</strong>文档，打开此文档，添加 <code>layout: "tags"</code>到文档中保存退出，如：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">tags</span><span class="hljs-attr">date:</span> <span class="hljs-number">2023-04-12 11:12:33</span><span class="hljs-attr">layout:</span> <span class="hljs-string">&quot;tags&quot;</span><span class="hljs-meta">---</span></code></pre></div><p>要想在主页显示标签栏，需要进入主题配置文件 <code>_config.yml</code>，添加标签栏</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">navbar-links:</span><span class="hljs-string">...</span><span class="hljs-attr">Tags:</span> <span class="hljs-string">/tags</span></code></pre></div><p>点击首页的 “tags” 可以看到该标签页下的所有文章。当然，只有文章中添加了tag属性的才会被收录到首页的 “标签” 中。</p><h5 id="创建分类">7.4.3 创建分类</h5><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">page</span> <span class="hljs-string">categories</span></code></pre></div><p>在<strong>source/categories</strong>目录下生成的<strong>index.md</strong>文档，打开文档，添加 <code>layout: "categories"</code>到内容中,保存退出，如：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">categories</span><span class="hljs-attr">date:</span> <span class="hljs-number">2023-04-12 19:05:47</span><span class="hljs-attr">layout:</span> <span class="hljs-string">&quot;categories&quot;</span><span class="hljs-meta">---</span></code></pre></div><p>同理，要想在主页显示分类栏，需要进入主题配置文件 <code>_config.yml</code>，添加分类栏：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">navbar-links:</span>  <span class="hljs-string">...</span>  <span class="hljs-attr">Categories:</span> <span class="hljs-string">/categories</span></code></pre></div><p>对于<strong>beautiful-hexo</strong>主题，还需要在主题的<strong>layout</strong>目录下创建<strong>categories.jade</strong>文件，内容如下（<em>因为不会前端知识，所以根据tags.jade编写</em>）：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">extends</span> <span class="hljs-string">partial/base</span><span class="hljs-string">block</span> <span class="hljs-string">header</span>    <span class="hljs-string">header.header-section</span>        <span class="hljs-string">.intro-header.no-img</span><span class="hljs-string">block</span> <span class="hljs-string">content</span>    <span class="hljs-string">.container</span>        <span class="hljs-string">.row</span>            <span class="hljs-string">.col-lg-6.col-lg-offset-3.col-md-10.col-md-offset-1</span>                <span class="hljs-bullet">-</span> <span class="hljs-string">site.categories.map(function(category)</span> &#123;                      <span class="hljs-string">if</span> <span class="hljs-string">category.posts.length</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">0</span>                        <span class="hljs-string">ul.archive-list</span>                            <span class="hljs-string">span.fa.fa-category.listing-seperator(id=category.name</span>, <span class="hljs-string">style=&quot;font-size:</span> <span class="hljs-number">1.</span><span class="hljs-string">17em;&quot;)</span>                            <span class="hljs-string">span(style=&quot;font-size:</span> <span class="hljs-number">1.</span><span class="hljs-string">5em;</span> <span class="hljs-attr">font-weight:</span> <span class="hljs-string">bold;</span> <span class="hljs-attr">margin-left:</span> <span class="hljs-string">5px;&quot;)=</span> <span class="hljs-string">category.name</span>                            <span class="hljs-bullet">-</span> <span class="hljs-string">category.posts.map(function(post)</span> &#123;                                <span class="hljs-string">li.col-lg-offset-1.col-md-offset-1</span>                                    <span class="hljs-string">span.post-meta=</span> <span class="hljs-string">full_date(post.date</span>, <span class="hljs-string">&#x27;MMM D&#x27;</span><span class="hljs-string">)</span>                                    <span class="hljs-string">a.post-title(href=url_for(post.path))=</span> <span class="hljs-string">post.title</span>                            <span class="hljs-bullet">-</span> &#125;<span class="hljs-string">)</span>                <span class="hljs-bullet">-</span> &#125;<span class="hljs-string">)</span></code></pre></div><p>点击首页的 “categories” 可以看到该分类下的所有文章。 参考博客：<a href="https://www.baidu.com/link?url=jNXzClJm8Ve2gFpOPz9vyfQiMfkrP7icKAOSfJyszHlh2vGqYoCZ9YDXU5T1aZj86pjyFXrf4lrjp6Mwj80qSa&amp;wd=&amp;eqid=f4337b38000dc2e90000000664376496">使用Hexo创建文章、标签和分类</a></p><h3 id="hexo博客同时发布到github和gitee">8. Hexo博客同时发布到github和gitee</h3><hr /><p>因为github服务器在国外，所以打开网页比较慢，国内的gitee pages具有同样的部署功能，打开网页就会更快一些，所以可以将hexo博客同步到gitee上，它的部署发布与github差不多，就是每次更新完博客后，gitee部署时需要进入Pages页面进行手动更新，不再过多赘述，具体参照这篇博客：<a href="https://blog.csdn.net/qq_23858785/article/details/123104823">hexo博客同时发布到github和gitee</a></p><p>本地博客文件同时上传到github和gitee：<a href="https://blog.csdn.net/yilovexing/article/details/107226141">如何将一个项目同时提交到GitHub和Gitee(码云)两个仓库</a></p><h3 id="多台设备同步更新hexo博客">9. 多台设备同步更新Hexo博客</h3><hr /><p>真正的原始Hexo博客内容在我们的电脑本地，上传到网页上的内容是public文件夹里面的静态内容，有的时候写文章需要在不同的电脑上操作，这样就需要博客项目在不同设备间的迁移与同步，具体操作参照博客： <a href="https://blog.csdn.net/K1052176873/article/details/122879462">Hexo在多台电脑上提交和更新</a> <a href="https://blog.csdn.net/qq_30105599/article/details/118302086">多台电脑同步更新Hexo博客</a></p><p>以上是备份本地博客内容到云端仓库，所以所有人都能看到你的源文件，如果不想让人看到你的源文件，只需在云端仓库新建一个仓库，再与本地博客仓库关联起来即可。之后在不同的设备上，git clone这个云端新仓库，然后按照正常方式操作即可。</p><h3 id="参考链接">参考链接</h3><hr /><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a> <a href="https://segmentfault.com/a/1190000017986794">超详细Hexo+Github Page搭建技术博客教程</a> <a href="https://lovenight.github.io/2015/11/10/Hexo-3-1-1-静态博客搭建指南/?">Hexo 3.1.1静态博客搭建指南</a></p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
